/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 67);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__foundation__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component__ = __webpack_require__(12);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__foundation__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_1__component__["a"]; });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */







/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaginationModel; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__options__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modeleventadapter__ = __webpack_require__(39);






/**
 * The data model used for Pagination components.
 * The optional properties are @exported only for backward compatibility with
 * the legacy AngularJS pagination directives and any apps using them, that may
 * for example access model properties directly from an AngularJS template,
 * instead of wrapping them in accessors defined in the controller. Also needed
 * for pagination-state that looks up model properties by unobfuscated name.
 * @unrestricted
 */
class PaginationModel {

  /**
   * @param {Object=} options
   */
  constructor(options = {}) {
    /**
     * Total number of pages.
     * @private {number}
     */
    this.totalPages_ = options['totalPages'] != undefined ?
        options['totalPages'] : PaginationModel.defaults.totalPages;

    /**
     * Total number of items. A page can contain multiple items if
     * {@code itemsPerPage} is bigger than 1.
     * @private {number}
     */
    this.totalItems_ = options['totalItems'] != undefined ?
        options['totalItems'] : PaginationModel.defaults.totalItems;

    /**
     * The index of the current page. Starts at 1.
     * @private {number}
     */
    this.currentPage_ = options['currentPage'] != undefined ?
        options['currentPage'] : PaginationModel.defaults.currentPage;

    /**
     * List of titles assigned to each page.
     * @private {!Array<string>}
     */
    this.titles_ = options['titles'] != undefined ?
        options['titles'] : PaginationModel.defaults.titles;

    /**
     * Whether the pagination can loop from the last to the first page.
     * @export {boolean}
     */
    this.cyclical = options['cyclical'] != undefined ?
        options['cyclical'] : PaginationModel.defaults.cyclical;

    /**
     * Number of items per page.
     * @export {number}
     */
    this.itemsPerPage = options['itemsPerPage'] != undefined ?
        options['itemsPerPage'] : PaginationModel.defaults.itemsPerPage;

    if (this.totalPages_ == 0) {
      this.totalPages_ = this.countTotalPages_();
    }

    if (this.totalPages_ > 0 && this.totalItems_ == 0) {
      this.totalItems_ = this.totalPages_;
    }

    /**
     * Maximum number of buttons to display in the page list directive.
     * @export {number}
     */
    this.maxLength = options['maxLength'] != undefined ?
        options['maxLength'] : PaginationModel.defaults.maxLength;

    /**
     * Time in milliseconds until transitioning to next page.
     * @export {number}
     */
    this.timer = options['timer'] != undefined ?
        options['timer'] : PaginationModel.defaults.timer;

    /**
     * The id of the current active element.
     * @export {string}
     */
    this.activeEl = options['activeEl'] != undefined ?
        options['activeEl'] : PaginationModel.defaults.activeEl;

    /**
     * Key value pairs of page id to element ids. This is needed for generating
     * aria roles necessary to tie together tab buttons and tab panels.
     * Index begins with 1.
     * @type {!Object<string>}
     */
    this.elementIds = {};

    /**
     * The object the model delegates to to emit and listen to events. In a
     * typical MDC manner, each platform will implement these methods by
     * leveraging their own framework-specific way.
     * @private {ModelEventAdapter}
     */
    this.eventAdapter_ = null;

    /**
     * Whether the timer is currently running. A paused timer is considered as
     * running.
     * @private {boolean}
     */
    this.isTimerRunning_ = false;

    /**
     * @private {?number}
     */
    this.timerIntervalId_ = null;

    /**
     * Whether the timer is currently paused.
     * @private {boolean}
     */
    this.isTimerPaused_ = false;

    /**
     * Original {@code timer} value preserved while the timer is paused and its
     * value is zero.
     * @private {number}
     */
    this.pausedTimerDuration_ = 0;

    /**
     * A function that other pagination components can override if they want to
     * implement how the main content element should get keyboard focus from
     * other components like {@code pagination-page-list} or
     * {@code pagination-teleport}.
     * @private {Function}
     */
    this.focusMainElement_ = null;

    this.startTimer();
  }

  /**
   * Default model options.
   * @return {!Options}
   */
  static get defaults() {
    return {
      currentPage: 1,
      totalItems: 0,
      itemsPerPage: 1,
      totalPages: 0,
      maxLength: 0,
      timer: 0,
      cyclical: false,
      titles: [],
      activeEl: '',
    };
  }

  /**
   * @return {number}
   */
  get currentPage() {
    return this.currentPage_;
  }

  /**
   * @param {number} index
   * @export
   */
  set currentPage(index) {
    if (index < 1) return;
    // If a page number limit is defined but the specified index value exceeds
    // it, we don't assign it
    if (this.totalPages > 0 && index > this.totalPages) return;
    this.currentPage_ = index;
    this.emit_(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* strings */].CURRENT_PAGE_EVENT);
  }

  /**
   * @return {number}
   */
  get totalItems() {
    return this.totalItems_;
  }

  /**
   * @param {number} count
   * @export
   */
  set totalItems(count) {
    this.totalItems_ = count;
    this.totalPages = this.countTotalPages_();
  }

  /**
   * @return {number}
   */
  get totalPages() {
    return this.totalPages_;
  }

  /**
   * @param {number} count
   * @export
   */
  set totalPages(count) {
    this.totalPages_ = count;
    this.emit_(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* strings */].TOTAL_PAGES_EVENT);
  }

  /**
   * Paginates to the previous page.
   * @param {boolean=} updateModel Whether the model should be updated. If not,
   *     only the pagination event is fired, and its the listener's job to
   *     update the model or not
   * @export
   */
  previous(updateModel = true) {
    if (updateModel) {
      this.currentPage = this.getPreviousPage_();
    };
    this.emit_(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* strings */].PREVIOUS_EVENT);
  }

  /**
   * Paginates to the next page.
   * @param {boolean=} updateModel Whether the model should be updated. If not,
   *     only the pagination event is fired, and its the listener's job to
   *     update the model or not
   * @export
   */
  next(updateModel = true) {
    if (updateModel) {
      this.currentPage = this.getNextPage_();
    };
    this.emit_(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* strings */].NEXT_EVENT);
  }

  /**
   * Set the focus on the main content element.
   */
  focusMainElement() {
    this.focusMainElement_ && this.focusMainElement_();
  }

  /**
   * Lets a pagination component tell the model it wants to move keyboard focus
   * on one of its DOM element when another pagination component relinquishes
   * focus, for example {@code pagination-page-list} or
   * {@code pagination-teleport}.
   * Typically the handler will:
   * 1. pick which DOM element will receive focus,
   * 2. delegate to the adapter how to set focus on this element.
   * For a given pagination model, only one pagination component can set this
   * handler and declare itself as able to receive keyboard focus.
   * @param {!Function} handler
   */
  setFocusMainElementHandler(handler) {
    if (this.focusMainElement_) return;
    this.focusMainElement_ = handler;
  }

  /**
   * Releases the handler that set the focus to the main content element.
   * A component calling {@code setFocusMainElementHandler} should always
   * release this handler when it's disposed to ensure it's properly garbage
   * collected.
   */
  clearFocusMainElementHandler() {
    this.focusMainElement_ = null;
  }

  /**
   * Whether the current page is the first one. Always false for cyclical
   * paginations.
   * @return {boolean}
   */
  isFirst() {
    return !this.cyclical && (this.currentPage_ == 1);
  }

  /**
   * Whether the current page is the last one. Always false for cyclical
   * paginations.
   * @return {boolean}
   */
  isLast() {
    return !this.cyclical && (this.currentPage_ == this.totalPages_);
  }

  /**
   * Registers a title for a page.
   * @param {string} title
   */
  registerPageTitle(title) {
    this.titles_.push(title);
  }

  /**
   * Registers several titles for pages.
   * @param {!Array<string>} titles
   */
  registerPageTitles(titles) {
    this.titles_.push(...titles);
  }

  /**
   * @return {string} The title of the previous page.
   */
  getPreviousPageTitle() {
    return this.titles_[this.getPreviousPage_() - 1];
  }

  /**
   * @return {string} The title of the next page.
   */
  getNextPageTitle() {
    return this.titles_[this.getNextPage_() - 1];
  }

  /**
   * Sets the adapter that contains methods used to delegate event broadcasting
   * and listening.
   * @param {!ModelEventAdapter} adapter
   */
  setEventAdapter(adapter) {
    this.eventAdapter_ = adapter;
  }

  /**
   * Listens to a pagination event, and executes a handler function when it
   * fires.
   * @param {string} type
   * @param {!Function} listener
   */
  listen(type, listener) {
    this.eventAdapter_ && this.eventAdapter_.listen(type, listener);
  }

  /**
   * Stops listening to an event.
   * @param {string} type
   * @param {!Function} listener
   */
  unlisten(type, listener) {
    this.eventAdapter_ && this.eventAdapter_.unlisten(type, listener);
  }

  /**
   * Starts the timer.
   * @param {boolean=} updateModel Whether to update the model, or only fire
   *     pagination events.
   */
  startTimer(updateModel = true) {
    if (!this.timer || this.isTimerRunning_) return;
    this.isTimerRunning_ = true;
    this.timerIntervalId_ =
        setInterval(() => this.next(updateModel), this.timer);
  }

  /**
   * Stops the timer.
   */
  stopTimer() {
    this.isTimerRunning_ = false;
    clearInterval(this.timerIntervalId_);
  }

  /**
   * Pauses or resumes the timer.
   * @param {boolean=} pause Whether to pause or resume the timer.
   */
  pauseTimer(pause = true) {
    if (pause && !this.isTimerPaused_) {
      this.isTimerPaused_ = true;
      this.pausedTimerDuration_ = this.timer;
      this.timer = 0;
      this.stopTimer();

    } else if (!pause && this.isTimerPaused_) {
      this.isTimerPaused_ = false;
      this.timer = this.pausedTimerDuration_;
      this.startTimer();
    }
  }

  /**
   * If the current page has a "previous" page. If {@code cyclical} is
   * {@code true} this method will always return {@code true}.
   * @return {boolean}
   */
  hasPrevious() {
    return !this.isFirst();
  }

  /**
   * If the current page has a "next" page. If {@code cyclical} is {@code true}
   * this method will always return {@code true}.
   * @return {boolean}
   */
  hasNext() {
    return !this.isLast();
  }

  /**
   * @return {number} The previous page index.
   * @private
   */
  getPreviousPage_() {
    if (this.currentPage_ > 1) {
      return this.currentPage_ - 1;
    }
    if (this.cyclical) {
      return this.totalPages_;
    }
    return this.currentPage_ - 1;
  }

  /**
   * @return {number} The next page index.
   * @private
   */
  getNextPage_() {
    if (this.currentPage_ < this.totalPages_) {
      return this.currentPage_ + 1;
    }
    if (this.cyclical) {
      return 1;
    }
    return this.currentPage_ + 1;
  }

  /**
   * Emits a pagination event.
   * @param {string} evtType
   * @private
   */
  emit_(evtType) {
    this.eventAdapter_ && this.eventAdapter_.emit(evtType);
  }

  /**
   * Counts how many pages are needed to accomodate the number of items and
   * the number of items per page.
   * @private
   */
  countTotalPages_() {
    return Math.ceil(this.totalItems_ / this.itemsPerPage);
  }

}




/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export runNextPaint */
/* unused harmony export coerceStringValue */
/* unused harmony export clamp */
/* unused harmony export emit */
/* harmony export (immutable) */ __webpack_exports__["a"] = delegate;
/* harmony export (immutable) */ __webpack_exports__["e"] = undelegate;
/* unused harmony export matches */
/* unused harmony export debounce */
/* harmony export (immutable) */ __webpack_exports__["d"] = throttle;
/* unused harmony export isElementInView */
/* unused harmony export intersectsContainer */
/* unused harmony export loadAsyncScript */
/* unused harmony export getCorrectTargetEl */
/* unused harmony export openNewWindow */
/* unused harmony export getNextIndex */
/* harmony export (immutable) */ __webpack_exports__["b"] = emptyContainer;
/* harmony export (immutable) */ __webpack_exports__["c"] = getThresholdArray;
/**
 * Runs a callback the next time a page paint is requested.
 * Note: any rAFs queued in a rAF will be executed in the next frame.
 * @param {!Function} callback
 * @return {number}
 */
function runNextPaint(callback) {
  return requestAnimationFrame(() => requestAnimationFrame(() => callback()));
};

/**
 * Converts a value (number or boolean) masquerading as a string back into
 * its intended type.
 * @param {string} value
 * @return {*}
 */
function coerceStringValue(value) {
  let coercedValue = value;

  if (typeof value !== 'string') {
    return value;
  }

  coercedValue =
      ['True', 'False'].includes(value) ? value.toLowerCase() : value;

  try {
    coercedValue = JSON.parse(coercedValue);
  } catch (e) {
    // Not a Boolean or Number
  }
  return coercedValue;
};

/**
 * Clamps a value between `min` and `max` bounds.
 * @param {number} min
 * @param {number} max
 * @return {!Function}
 */
function clamp(min, max) {
  return (val) => Math.min(Math.max(val, min), max);
};

/**
 * Fires a cross-browser-compatible custom event from element of
 * the given type, with the given data.
 * @param {!Element} element
 * @param {string} evtType
 * @param {!Object} evtData
 * @param {boolean=} shouldBubble
 */
function emit(element, evtType, evtData, shouldBubble = false) {
  let evt;
  if (typeof CustomEvent === 'function') {
    evt = new CustomEvent(evtType, {
      detail: evtData,
      bubbles: shouldBubble,
    });
  } else {
    evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(evtType, shouldBubble, false, evtData);
  }

  element.dispatchEvent(evt);
};

/**
 * Adds an event listener.
 * @param {!Element|!HTMLDocument} element Parent element or document to add
 *     the event listener to.
 * @param {string} selector Query selector for children.
 * @param {string} eventName Name of event to listen for (first argument of
 *     addEventListener).
 * @param {!Function} handler Function to call. Receives the event as an
 *     argument.
 */
function delegate(element, selector, eventName, handler) {
  element.addEventListener(eventName, (e) => {
    delegateHelper_(e, element, selector, eventName, handler);
  }, false);
};

/**
 * Removes an event listener.
 * @param {!Element|!HTMLDocument} element Parent element or document to add
 *     the event listener to.
 * @param {string} selector Query selector for children.
 * @param {string} eventName Name of event to listen for (first argument of
 *     addEventListener).
 * @param {!Function} handler Function to call. Receives the event as an
 *     argument.
 */
function undelegate(element, selector, eventName, handler) {
  element.removeEventListener(eventName, (e) => {
    delegateHelper_(e, element, selector, eventName, handler);
  }, false);
};

/**
 * Determines whether the given element matches the given query selector.
 * Delegates to the native Element.prototype.matches or older native
 * <prefix>MatchesSelector.
 * @param {!Element} element
 * @param {string} selector
 */
function matches(element, selector) {
  if (Element.prototype.matches) {
    return element.matches(selector);
  } else {
    const matches = Element.prototype.matchesSelector ||
        Element.prototype.mozMatchesSelector ||
        Element.prototype.msMatchesSelector ||
        Element.prototype.oMatchesSelector ||
        Element.prototype.webkitMatchesSelector;
    return matches.call(element, selector);
  }
};

/**
 * Waits the given amount of time before applying the given function.
 * @param {!Function<?>} callback Function to apply after the given time has
 *     been reached.
 * @param {number} threshold The amount of time in milliseconds to wait before
 *     applying the callback.
 * @param {boolean} execAsap Whether to apply the callback immediately or not.
 * @return {!Function}
 */
function debounce(callback, threshold, execAsap, ...theArgs) {
  let timeout;
  return () => {
    const obj = this;
    const args = theArgs;
    const delayed = () => {
      if (!execAsap) {
        callback.apply(obj, args);
      }
      timeout = null;
    };
    if (timeout) {
      clearTimeout(timeout);
    } else if (execAsap) {
      callback.apply(obj, args);
    }
    timeout = setTimeout(delayed, threshold || 100);
  };
};

/**
 * Returns a function, that, when invoked, will only be triggered at most
 * once during a given window of time. Useful for window scroll or
 * resize handlers that want to run callbacks very frequently, which can
 * harm page performance. Source inspiration comes from underscore.
 * @param {!Function<?>} callback Function to apply after the given time has
 *     been reached.
 * @param {number} threshold The amount of time in milliseconds to wait before
 *     applying the callback.
 * @param {Object} options Options to disable the execution on the leading
 *   edge, {leading: false}. To disable execution on the trailing edge, use
 *   {trailing: false}.
 * @return {!Function}
 */
function throttle(callback, threshold = 100, options = {}) {
  let timeout;
  let context;
  let args;
  let result;
  let previous = 0;

  const later = () => {
    previous = options.leading === false ? 0 : +new Date();
    timeout = null;
    result = callback.apply(context, args);
    if (!timeout) {
      context = args = null;
    }
  };

  const throttled = () => {
    const now = +new Date();
    if (!previous && options.leading === false) {
      previous = now;
    }
    const remaining = threshold - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > threshold) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = callback.apply(context, args);
      if (!timeout) {
        context = args = null;
      }
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = () => {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
};

/**
 * Applies a callback function if the given element is in view or above the
 * scrollable area.
 * @param {!Element} element The element to check if it is in view or not.
 * @param {!Function} callback The callback fucntion.
 * @param {!Element=} opt_root The scrollable element. If no element, is
 *     given, the window is used.
 * @param {number=} opt_threshold The fraction of the element you want to be
 *     visible before returning true. By default, the whole element must be in
 *     view. Examples:
 *       1 == the whole element
 *       2 == half of the element
 *       4 == a quarter of the element
 * @return {!Function}
 */
function isElementInView(
    element, callback, opt_root, opt_threshold, ...theArgs) {
  const root = opt_root || window;
  const rootHeight = root.offsetHeight || root.innerHeight;
  const scrollPostition = root.scrollTop || root.pageYOffset;
  const threshold = opt_threshold ?
      element.offsetHeight / opt_threshold : element.offsetHeight;
  return () => {
    const obj = this;
    const args = theArgs;
    if (rootHeight + scrollPostition >= element.offsetTop + threshold) {
      callback.apply(obj, args);
    }
  };
};

/**
 * Check if the element is visible inside parent container.
 * @param {!Element} element
 * @param {number} bounds
 * @return {number} - The percentage of image visible in viewport.
 */
function intersectsContainer(element, bounds) {
  const clientRect = element.getBoundingClientRect();
  const ratioVisible = (bounds - clientRect.top) / clientRect.height;
  return ratioVisible <= 0 ? 0 : ratioVisible  >= 1.0 ? 1.0 : ratioVisible;
};

/**
 * Returns a Promise that resolves after the given script has loaded.
 * @param {string} src Script source URL.
 * @param {boolean=} autoAppend If false, the developer can determine where to
 *     place the script in the DOM.
 * @return {!Promise}
 */
function loadAsyncScript(src, autoAppend = true) {
  return new Promise((resolve, reject) => {
    const firstScriptTag = document.getElementsByTagName('script')[0];
    const tag = document.createElement('script');

    tag.src = src;
    tag.onload = () => resolve(tag);

    if (autoAppend) {
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }
  });
};

/**
 * Gets the correct target element based on the element provided. Used when
 * the 'wrong' (child element) receives a click event.
 * @param {Element} element The element from the click event.
 * @param {string} selector The selector for the correct element.
 * @return {Element} The correct target element.
 */
function getCorrectTargetEl(element, selector) {
  return element.matches(selector) ? element : element.closest(selector);
};

/**
 * Opens new window with a given dimensions. Good for showing a component at
 * different viewport sizes.
 * Ex. To open a 320x640 window at /docs/:
 *     <button path="/docs/"
 *             size="320:640"
 *             class="js-open-new-window">
 *     </button>
 * @param {Element} target The element from the click event.
 * @param {Event} e The click event.
 */
function openNewWindow(target, e) {
  const path = target.getAttribute('path');
  const size = target.getAttribute('size').split(':');
  const width = size[0];
  const height = size[1];

  window.open(path, '',
      `height=${height},width=${width},left=${e.screenX},top=${e.screenY}`);
};

/**
 * Determines the next valid index of a given array. Either increments the
 * current index or resets to zero.
 * @param {!Array|NodeList} list The list to cycle through.
 * @param {number} currentIndex The current index to increment from.
 * @returns {number} The next valid index.
 */
function getNextIndex(list, currentIndex) {
 const incrementedNext = ++currentIndex;
 return incrementedNext < list.length ? incrementedNext : 0;
};

/**
 * Removes all child elements of a container.
 * @param {!Element} container The element to empty of its children.
 */
function emptyContainer(container) {
 while (container.firstChild) {
   container.removeChild(container.firstChild);
 }
};

/**
 * Creates an array of numbers used in the 'threshold' argument for an
 *   Intersection Observer.
 * @param {number} fidelity The number of elements in the array.
 *   This can be used to tell an intersection observer how often to run a
 *   callback. For instance a fidelity of 10 will create an array that tells
 *   an intersection observer to run the callback every time the visible area
 *   of the element being observed changes by at least 10%. A higher fidelity
 *   will run the callback more often.
 * @returns {Array<number>} An array of numbers.
 */
function getThresholdArray(fidelity = 1001) {
 const step = 1 / fidelity;
 return new Array(fidelity).fill(0).map((zero, index) => {
    return index * step;
  });
};

// Private functions that are used by utils, not exported.

/**
 * Listens for events on a parent that are bubbled up from children that match
 * the given query selector.
 * @param {!Event} e Event object.
 * @param {!Element|!HTMLDocument} element Parent element or document to add
 *     the event listener to.
 * @param {string} selector Query selector for children.
 * @param {string} eventName Name of event to listen for (first argument of
 *     addEventListener).
 * @param {!Function} handler Function to call. Receives the event as an
 *     argument.
 * @private
 */
function delegateHelper_(e, element, selector, eventName, handler) {
  let target = e.target;
  while (target) {
    if (matches(target, selector)) {
      handler(target, e);
      break;
    }
    target = target.parentElement;
  }
};


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Visibility; });



/**
 * The view status of a tile in a display map.
 * @enum {number}
 */
const Visibility = {
  HIDDEN: 0,
  PARTIALLY: 1,
  VISIBLE: 2,
};




/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
const utils = {
  /** @const {string} */
  IS_DEV: document.documentElement.getAttribute('env') === 'dev',

  /** @const {string} */
  LANG: document.documentElement.lang,

  /**
   * Localizes given date.
   * @param {string} date Date to be localized.
   * @param {string} format
   *     `short`: Month and year
   *     `medium`: Month year and day
   *     `long`: Month, year, day and abbreviated weekday
   * @param {?string} tz Optional timezone.
   * @return {string}
   */
  localizeDate: (date, format='short', tz=undefined) => {
    const options = {
      month: 'long',
      year: 'numeric',
    };

    if (format === 'medium' || format === 'long') options.day = 'numeric';
    if (format === 'long') options.weekday = 'short';
    if (tz) options.timeZone = tz;

    return new Date(date).toLocaleDateString(utils.LANG, options);
  },

  /**
   * Localizes given number.
   * @param {number} number NUmber to be localized.
   * @return {string}
   */
  localizeNumber: (number) => {
    return number.toLocaleString(utils.LANG);
  },
};


/* harmony default export */ __webpack_exports__["default"] = (utils);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/* harmony default export */ __webpack_exports__["a"] = (MDCFoundation);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @fileoverview Constants used throughout the pagination components.
 */



/**
 * TODO: Move boolean class definitions to common (SHOW_PAGE, PAGES_READY).
 * @enum {string}
 */
const cssClasses = {
  BUTTON: 'glue-o-pagination__button',
  BUTTON_CONTAINER: 'glue-o-pagination__button-container',
  PAGINATION: 'glue-o-pagination',
};
/* unused harmony export cssClasses */


/**
 * @enum {string}
 */
const strings = {
  CURRENT_PAGE_EVENT: 'gluepaginationcurrentpage',
  TOTAL_PAGES_EVENT: 'gluepaginationtotalpages',
  PREVIOUS_EVENT: 'gluepaginationprevious',
  NEXT_EVENT: 'gluepaginationnext',
  // FOCUS_EVENT is deprecated, use {@code PaginationModel.focusMainElement()}
  // instead.
  FOCUS_EVENT: 'gluepaginationfocus',
};
/* harmony export (immutable) */ __webpack_exports__["a"] = strings;



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MDCFoundation; });
/**
 * @fileoverview Parent class for Foundation classes of components built with the MDC-Web architecture.
 * Forked from https://github.com/material-components/material-components-web/blob/master/packages/mdc-base/foundation.js
 * MDC-Web architecture:
 * https://github.com/material-components/material-components-web/blob/master/docs/architecture.md
 * Authoring components:
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 */



/**
 * @abstract
 * @template T
 */
class MDCFoundation {

  /**
   * Classes extending MDCFoundation should implement this method to return an
   * object which exports every CSS class the foundation class needs as a
   * property.
   * e.g. {ACTIVE: 'mdc-component--active'}
   * @return {!Object<string>}
   */
  static get cssClasses() {
    return {};
  }

  /**
   * Classes extending MDCFoundation should implement this method to return an
   * object which exports all semantic strings as constants.
   * e.g. {ARIA_ROLE: 'tablist'}
   * @return {!Object<string>}
   */
  static get strings() {
    return {};
  }

  /**
   * Classes extending MDCFoundation should implement this method to return an
   * object which exports all of its semantic numbers as constants.
   * e.g. {ANIMATION_DELAY_MS: 350}
   * @return {!Object<number>}
   */
  static get numbers() {
    return {};
  }

  /**
   * @param {T=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!T} */
    this.adapter = /** @type {!T} */ (adapter);
  }

  /**
   * Subclasses should override this method to perform initialization routines
   * (registering events, etc.)
   * @abstract
   */
  init() {}

  /**
   * Subclasses should override this method to perform de-initialization
   * routines (de-registering events, etc.)
   * @abstract
   */
  destroy() {}

}




/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export IterableTileMap */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__visibility__ = __webpack_require__(3);


/**
 * @record
 */
function IterableTileMap() {}

/** @return {boolean} */
IterableTileMap.prototype.isValid = function() {};

/** @return {boolean} */
IterableTileMap.prototype.isCyclical = function() {};

/** @return {number} */
IterableTileMap.prototype.getFrameX = function() {};

/** @return {number} */
IterableTileMap.prototype.getTilesCount = function() {};

/** @return {number} */
IterableTileMap.prototype.getAllTilesWidth = function() {};

/**
 * @param {number} tileIndex
 * @param {number} tileX
 * @param {number=} opt_frameX
 * @param {boolean=} opt_applyExpand
 * @return {!Visibility}
 */
IterableTileMap.prototype.getTileVisibility =
    function(tileIndex, tileX, opt_frameX, opt_applyExpand) {};

/** @type {number} */
IterableTileMap.prototype.frameWidth;

/** @type {number} */
IterableTileMap.prototype.frameExpand;




/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ModelFactory; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__events_eventtarget__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modeleventadapter__ = __webpack_require__(39);







/**
 * Pagination model factory. Used only in Vanilla JS applications since it also
 * setup delegate methods to broadcast pagination events. Other platforms
 * should instead delegate to their framework-specific way of broadcasting
 * events. See {@code glue.ng.ui.pagination.PaginationCtrl} for
 * the AngularJS implementation.
 */
class ModelFactory {

  /**
   * Returns a new or existing pagination model instance based on an identifier.
   * Falls back on a default instance if no id is provided.
   * @param {string=} id
   * @return {!PaginationModel}
   */
  static get(id = ModelFactory.DEFAULT_INSTANCE_ID) {
    let instance = ModelFactory.instances_[id];
    if (!instance) {
      instance = ModelFactory.createInstance_();
      ModelFactory.instances_[id] = instance;
    }
    return instance;
  }

  /**
   * Clears all existing pagination model instances.
   */
  static clearAll() {
    ModelFactory.instances_ = {};
  }

  /**
   * Creates a new pagination model instance.
   * @return {!PaginationModel}
   * @private
   */
  static createInstance_() {
    const instance = new __WEBPACK_IMPORTED_MODULE_1__model__["a" /* PaginationModel */]();
    const eventTarget = new __WEBPACK_IMPORTED_MODULE_0__events_eventtarget__["a" /* EventTarget */]();

    const /** !ModelEventAdapter */ adapter = {
      emit: (evtType) => eventTarget.dispatchEvent(evtType),
      listen: (evtType, handler) => eventTarget.listen(evtType, handler),
      unlisten: (evtType, handler) => eventTarget.unlisten(evtType, handler),
    };

    instance.setEventAdapter(adapter);
    return instance;
  }

}

/**
 * Internal list of all registered pagination model instances.
 * @private {!Object<!PaginationModel>}
 */
ModelFactory.instances_ = {};

/**
 * Pagination model key for the default pagination model.
 * @const {string}
 */
ModelFactory.DEFAULT_INSTANCE_ID = '__default';




/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/** @private @enum {string}*/
const Selectors_ = {
  ACTIVE_ITEM: '.yt-js-active-page-nav',
  HEADER: '.lb-header',
  HEADER_NAV_ITEMS: '.lb-nav__item, .lb-nav__subitem, '+
                    '.lb-mobile-nav__item, .lb-mobile-nav__subitem',
};

/** @private @enum {string}*/
const Classes_ = {
  HAS_ACTIVE_PAGE_NAV: 'has-active-page-nav',
};
/* harmony export (immutable) */ __webpack_exports__["Classes_"] = Classes_;



/**
 * Sets the correct active states on all nav items when a user is on a page
 * that's not part of the main header nav.
 * @final
 */
class PageNav {
  constructor() {
    /**
     * The active page nav, if one exists.
     * @private {?Element}
     */
    this.activeItem_ = document.querySelector(Selectors_.ACTIVE_ITEM);

    // No need to go further. There is no page nav or the user is on an
    // `Overview` page and the header component correctly sets the active states
    // of all nav items.
    if (!this.activeItem_ || !this.activeItem_.dataset.parentLinks) return;

    /**
     * The links of the parent nav(s) of the active page nav set into a `data`
     * attribute as a string separated by a comma.
     * @private {!Array<string>}
     */
    this.parentLinks_ = this.activeItem_.dataset.parentLinks.split(',');

    /**
     * All nav items that are part of the main header nav. This excludes the
     * page nav items.
     * @private {!Array<!Element>}
     */
    this.mainNavItems_ = [...document.querySelector(Selectors_.HEADER)
        .querySelectorAll(Selectors_.HEADER_NAV_ITEMS)];

    this.setActiveStatesOnParentNavs_();
  }

  /**
   * @return {!Array<!Element>}
   * @private
   */
  getActiveParentNavs_() {
    const activeParentNavs = [];

    this.parentLinks_.forEach((parentLink) => {
      this.mainNavItems_.forEach((item) => {
        const itemHref = item.getAttribute('href');

        if (itemHref === parentLink) {
          activeParentNavs.push(item);
        }
      });
    });

    return activeParentNavs;
  }

  /** @private */
  setActiveStatesOnParentNavs_() {
    this.getActiveParentNavs_().forEach((item) => {
      item.classList.add(Classes_.HAS_ACTIVE_PAGE_NAV);
    });
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = PageNav;



/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MDCRipple; });
/* unused harmony export RippleCapableSurface */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_component__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util__ = __webpack_require__(22);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_2__foundation__["a"]; });
/* unused harmony reexport util */
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */






/**
 * @extends MDCComponent<!MDCRippleFoundation>
 */
class MDCRipple extends __WEBPACK_IMPORTED_MODULE_0__material_base_component__["a" /* default */] {
  /** @param {...?} args */
  constructor(...args) {
    super(...args);

    /** @type {boolean} */
    this.disabled = false;

    /** @private {boolean} */
    this.unbounded_;
  }

  /**
   * @param {!Element} root
   * @param {{isUnbounded: (boolean|undefined)}=} options
   * @return {!MDCRipple}
   */
  static attachTo(root, {isUnbounded = undefined} = {}) {
    const ripple = new MDCRipple(root);
    // Only override unbounded behavior if option is explicitly specified
    if (isUnbounded !== undefined) {
      ripple.unbounded = /** @type {boolean} */ (isUnbounded);
    }
    return ripple;
  }

  /**
   * @param {!RippleCapableSurface} instance
   * @return {!MDCRippleAdapter}
   */
  static createAdapter(instance) {
    const MATCHES = __WEBPACK_IMPORTED_MODULE_3__util__["b" /* getMatchesProperty */](HTMLElement.prototype);

    return {
      browserSupportsCssVars: () => __WEBPACK_IMPORTED_MODULE_3__util__["d" /* supportsCssVariables */](window),
      isUnbounded: () => instance.unbounded,
      isSurfaceActive: () => instance.root_[MATCHES](':active'),
      isSurfaceDisabled: () => instance.disabled,
      addClass: (className) => instance.root_.classList.add(className),
      removeClass: (className) => instance.root_.classList.remove(className),
      containsEventTarget: (target) => instance.root_.contains(target),
      registerInteractionHandler: (evtType, handler) =>
        instance.root_.addEventListener(evtType, handler, __WEBPACK_IMPORTED_MODULE_3__util__["a" /* applyPassive */]()),
      deregisterInteractionHandler: (evtType, handler) =>
        instance.root_.removeEventListener(evtType, handler, __WEBPACK_IMPORTED_MODULE_3__util__["a" /* applyPassive */]()),
      registerDocumentInteractionHandler: (evtType, handler) =>
        document.documentElement.addEventListener(evtType, handler, __WEBPACK_IMPORTED_MODULE_3__util__["a" /* applyPassive */]()),
      deregisterDocumentInteractionHandler: (evtType, handler) =>
        document.documentElement.removeEventListener(evtType, handler, __WEBPACK_IMPORTED_MODULE_3__util__["a" /* applyPassive */]()),
      registerResizeHandler: (handler) => window.addEventListener('resize', handler),
      deregisterResizeHandler: (handler) => window.removeEventListener('resize', handler),
      updateCssVariable: (varName, value) => instance.root_.style.setProperty(varName, value),
      computeBoundingRect: () => instance.root_.getBoundingClientRect(),
      getWindowPageOffset: () => ({x: window.pageXOffset, y: window.pageYOffset}),
    };
  }

  /** @return {boolean} */
  get unbounded() {
    return this.unbounded_;
  }

  /** @param {boolean} unbounded */
  set unbounded(unbounded) {
    this.unbounded_ = Boolean(unbounded);
    this.setUnbounded_();
  }

  /**
   * Closure Compiler throws an access control error when directly accessing a
   * protected or private property inside a getter/setter, like unbounded above.
   * By accessing the protected property inside a method, we solve that problem.
   * That's why this function exists.
   * @private
   */
  setUnbounded_() {
    this.foundation_.setUnbounded(this.unbounded_);
  }

  activate() {
    this.foundation_.activate();
  }

  deactivate() {
    this.foundation_.deactivate();
  }

  layout() {
    this.foundation_.layout();
  }

  /**
   * @return {!MDCRippleFoundation}
   * @override
   */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* default */](MDCRipple.createAdapter(this));
  }

  /** @override */
  initialSyncWithDOM() {
    this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
  }
}

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */
class RippleCapableSurface {}

/** @protected {!Element} */
RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;




/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__foundation__ = __webpack_require__(5);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/**
 * @template F
 */
class MDCComponent {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  static attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent(root, new __WEBPACK_IMPORTED_MODULE_0__foundation__["a" /* default */]());
  }

  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */
  constructor(root, foundation = undefined, ...args) {
    /** @protected {!Element} */
    this.root_ = root;
    this.initialize(...args);
    // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.
    /** @protected {!F} */
    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  initialize(/* ...args */) {
    // Subclasses can override this to do any additional setup work that would be considered part of a
    // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
    // initialized. Any additional arguments besides root and foundation will be passed in here.
  }

  /**
   * @return {!F} foundation
   */
  getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' +
      'foundation class');
  }

  initialSyncWithDOM() {
    // Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  }

  destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  }

  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */
  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }

  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */
  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }

  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */
  emit(evtType, evtData, shouldBubble = false) {
    let evt;
    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble,
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }
}

/* harmony default export */ __webpack_exports__["a"] = (MDCComponent);


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_index__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__google_glue_lib_ui_carousel_carousel_component__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__google_glue_lib_ui_pagination_next_component__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__google_glue_lib_ui_pagination_modelfactory__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__google_glue_lib_ui_pagination_pagelist_component__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__google_glue_lib_ui_pagination_previous_component__ = __webpack_require__(107);









/** @private @const {string} */
const {GLUE_PAGINATION_PAGE_LIST_SELECTOR,
       GLUE_PAGINATION_PREVIOUS_SELECTOR,
       GLUE_PAGINATION_NEXT_SELECTOR,
       GLUE_CAROUSEL_SELECTOR,
       GLUE_PAGINATION_DATA,
       OPTIONS_KEY,
       MODEL_PREFIX,
     } = __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */];

/**
 * @fileoverview Wrapper for Glue Carousel that initializes the carousel and
 * its related next/previous/list nav components.
 */


/** @private {number} */
let carouselNumber = 1;

/**
 * Class that defines LBGlueCarousel.
 */
class LBGlueCarousel extends __WEBPACK_IMPORTED_MODULE_0__base_index__["a" /* default */] {
  // Invoked by `mdc.autoInit()`
  static attachTo(root) {
    return new LBGlueCarousel(root);
  }

  /**
   * `paginationModel` getter.
   */
  get model() {
    return this.paginationModel_;
  }

  /**
   * Instantiate component foundation and pass it the adapter dict.
   * @return {LBGlueCarouselFoundation}
   */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBGlueCarouselFoundation */]({
      getOptions: () => {
        return this.options_;
      },
    });
  }

  /**
   * Initialize Glue sub components.
   * @private
   */
  initGlueComponents_() {
    Object.keys(this.glueModules).forEach((key) => {
      const module = this.glueModules[key];
      const componentRoot = this.queryComponentSelector(module.selector);

      if (componentRoot) {
        componentRoot.setAttribute(
            GLUE_PAGINATION_DATA, this.carouselModelInstance_);

        module.instance =
            module.componentCtor.attachTo(componentRoot, module.options);
      }
    });
  }

  /**
   * Initializes component. Setup elements and child components.
   */
  initialize() {
    this.parseOptionsString(OPTIONS_KEY);

    const {cyclical, startPage} = this.options_;

    /** @private @const {!Object<string, *>} Seperate Glue specific options. */
    const glueOptions = Object.keys(this.options_)
        .filter((opt) => (__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* lists */].IGNORE_OPTIONS.indexOf(opt) === -1))
        .reduce((opts, opt) => {
          opts[opt] = this.options_[opt];
          return opts;
        }, {});

    /** @private @const {string} */
    this.carouselModelInstance_ = `${MODEL_PREFIX}${carouselNumber}`;

    /** @private @const {!PaginationModel} */
    this.paginationModel_ = __WEBPACK_IMPORTED_MODULE_5__google_glue_lib_ui_pagination_modelfactory__["a" /* ModelFactory */].get(this.carouselModelInstance_);

    /** @const {!Object<string, *>} */
    this.glueModules = {
      PaginationPageList: {
        'selector': GLUE_PAGINATION_PAGE_LIST_SELECTOR,
        'componentCtor': __WEBPACK_IMPORTED_MODULE_6__google_glue_lib_ui_pagination_pagelist_component__["a" /* PaginationPageList */],
      },
      PaginationNext: {
        'selector': GLUE_PAGINATION_NEXT_SELECTOR,
        'componentCtor': __WEBPACK_IMPORTED_MODULE_4__google_glue_lib_ui_pagination_next_component__["a" /* PaginationNext */],
      },
      PaginationPrevious: {
        'selector': GLUE_PAGINATION_PREVIOUS_SELECTOR,
        'componentCtor': __WEBPACK_IMPORTED_MODULE_7__google_glue_lib_ui_pagination_previous_component__["a" /* PaginationPrevious */],
      },
      Carousel: {
        'selector': GLUE_CAROUSEL_SELECTOR,
        'componentCtor': __WEBPACK_IMPORTED_MODULE_3__google_glue_lib_ui_carousel_carousel_component__["a" /* Carousel */],
        'options': glueOptions,
      },
    };


    if (cyclical) {
      this.paginationModel_.cyclical = true;
    }

    if (startPage) {
     // Start on a specific page.
      this.paginationModel_.currentPage = startPage;
    }

    // To ensure our Glue components and model are properly synced wait an extra
    // tick to ensure `ModelFactory` has generated a new instance before
    // initialization.
    setTimeout(this.initGlueComponents_.bind(this));

    // Increment carousel number to enable multiple carousels/pagination
    // models on the same page.
    carouselNumber += 1;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBGlueCarousel;



/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixin__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_base__ = __webpack_require__(0);



/**
 * @fileoverview LBComponent:
 * Common base component that includes LB specific utility methods and
 * properties and is compatible with MDC CAF architecture.
 */

class LBComponent extends Object(__WEBPACK_IMPORTED_MODULE_0__mixin__["a" /* lbClassMixin */])(__WEBPACK_IMPORTED_MODULE_1__material_base__["a" /* MDCComponent */]) {
  /**
   * @param {!Element} root
   * @param {!Object|undefined} foundation
   * @param  {...any} args
   */
  constructor(root, foundation = undefined, ...args) {
    super(root, foundation, ...args);

    /** @private @const {!Object<string, boolean|number|string>} */
    this.options_ = {};
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBComponent;



/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CarouselAdapter */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tilemap_visibility__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pagination_model__ = __webpack_require__(1);





/** @record */
class CarouselAdapter {

  /**
   * How many items has the carousel. Used to update the pagination model.
   * @return {number}
   */
  countItems() {}

  /** @return {!PaginationModel} */
  getPaginationModel() {}

  /**
   * Toggles tile elements visibility based on a display map, then calls a
   * function once the DOM has been updated.
   * @param {!Array<Visibility>} displayMap
   * @param {!Function} callback
   */
  toggleElements(displayMap, callback) {}

  /**
   * Makes all tile elements visible, then calls a function once the DOM has
   * been updated.
   * @param {!Function} callback
   */
  resetElements(callback) {}

  /** @return {boolean} */
  isRtl() {}

  /** @param {string} className */
  addClass(className) {}

  /** @param {string} className */
  removeClass(className) {}

  /**
   * Set focus on a tile DOM element.
   * @param {!Element} el
   */
  focusTile(el) {}

  /**
   * Set a CSS style on the container DOM element.
   * @param {string} prop
   * @param {string} value
   */
  setStyle(prop, value) {}

  /**
   * The width in pixels of the parent element of the container DOM element.
   * @return {number}
   */
  getParentElementWidth() {}

  /**
   * The container's child DOM elements.
   * @return {!Array<!Element>}
   */
  getChildElements() {}

  /**
   * The width and height dimensions in pixels of a tile DOM element.
   * @param {!Element} el
   * @return {!Object<number>}
   */
  getTileDimensions(el) {}

  /**
   * Set a CSS style on a tile DOM element.
   * @param {!Element} el
   * @param {string} prop
   * @param {string} value
   */
  setTileStyle(el, prop, value) {}

  /**
   * Set an attribute on a tile DOM element.
   * @param {!Element} el
   * @param {string} attr
   * @param {string|number|boolean} value
   */
  setTileAttr(el, attr, value) {}

  /**
   * Removes an attribute from a tile DOM element.
   * @param {!Element} el
   * @param {string} attr
   */
  rmTileAttr(el, attr) {}

  /** @param {!Function} handler */
  registerResizeHandler(handler) {}

  /** @param {!Function} handler */
  deregisterResizeHandler(handler) {}

  /** @param {!Function} handler */
  registerSwipeStart(handler) {}

  /** @param {!Function} handler */
  deregisterSwipeStart(handler) {}

  /** @param {!Function} handler */
  registerSwipeMove(handler) {}

  /** @param {!Function} handler */
  deregisterSwipeMove(handler) {}

  /** @param {!Function} handler */
  registerSwipeEnd(handler) {}

  /** @param {!Function} handler */
  deregisterSwipeEnd(handler) {}

  /** @param {!Function} handler */
  registerSwipeCancel(handler) {}

  /** @param {!Function} handler */
  deregisterSwipeCancel(handler) {}

  /** @param {!Function} handler */
  registerMouseLeave(handler) {}

  /** @param {!Function} handler */
  deregisterMouseLeave(handler) {}

}




/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Options */



/** @record */
function Options() {}

/** @type {boolean} */
Options.prototype.elasticEdge;

/** @type {number} */
Options.prototype.edgeFriction;

/** @type {function(number): number} */
Options.prototype.easing;

/** @type {number} */
Options.prototype.transitionDuration;

/** @type {number} */
Options.prototype.expand;

/** @type {boolean} */
Options.prototype.jump;

/** @type {boolean} */
Options.prototype.center;

/** @type {boolean} */
Options.prototype.group;




/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TileMap; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__containedtileiterator__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iterabletilemap__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tile__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tileiterator__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__visibility__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__visibilityiterator__ = __webpack_require__(90);










/**
 * A one-dimension tile map.
 *
 * It defines the X position of a frame which deliminates the view area,
 * the frame's width, each tile's width, and a display map that lists which
 * tiles are currently visible inside the frame, given its position on the
 * tile container's coordinate system.
 *
 * It is only defined at a mathematic level. The concrete display on the DOM
 * is delegated to a renderer.
 *
 * In the case of a cyclical carousel, all available tiles cycle infinitely
 * in both directions, like the example below with 4 available tiles.
 *
 * - ... [ 1 ][ 2 ][ 3 ][ 4 ]|[ 1 ][ 2 ][ 3 ][ 4 ][ 1 ][ 2 ][ 3 ][ 4 ] ... +
 *
 * `|` marks the origin (x = 0) of the tile container's coordinate system.
 *
 * @implements {IterableTileMap}
 */
class TileMap {

  /**
   * @param {boolean} cyclical Whether the carousel is cyclical. In a cyclical
   *     carousel, going from the first item to the last will move backward,
   *     instead of jumping forward.
   * @param {boolean=} opt_canExceedEdges Whether the frame can move beyond the
   *     edges when the carousel is non-cyclical.
   * @param {boolean=} opt_snapToCenter Whether to snap to center.
   */
  constructor(cyclical, opt_canExceedEdges, opt_snapToCenter) {
    /** @private {boolean} */
    this.cyclical_ = cyclical;

    /** @private {boolean|undefined} */
    this.canExceedEdges_ = (opt_canExceedEdges == undefined) ||
        (opt_canExceedEdges == true);

    /** @private {boolean} */
    this.snapToCenter_ = (opt_snapToCenter != false);

    /**
     * The position of the left boundary of the frame in the tile container's
     * coordinate system.
     * @private {number}
     */
    this.x_ = 0;

    /**
     * The cumulative width of all available tiles combined.
     * @private {number}
     */
    this.allTilesWidth_ = 0;

    /** @private {!Array<number>} The list of all available tiles' width. */
    this.tileWidths_ = [];

    /** @private {!Array<number>} The list of disabled tile indexes. */
    this.disabledTiles_ = [];

    /**
     * Whether there's at least one tile with a size above 0.
     * @private {boolean}
     */
    this.areTilesValid_ = false;

    /** @type {number} The width of the frame. */
    this.frameWidth = 0;

    /**
     * A pixel value expanding the frame on both sides. Used when tiles outside
     * the frame area need to be displayed.
     * @type {number}
     */
    this.frameExpand = 0;

    /**
     * The display map for the current position.
     * The structure of the array is based on the number of available items.
     * If the position of the frame can reveal the first and last tiles of two
     * different cycles, or is large enough to show all tiles several times,
     * the array will be larger to represent them all.
     *
     * Given a tile map of 4 tiles, here are some examples of scenarios of
     * visible tiles and their equivalent display map.
     *
     * [ 1 ][ 2 ]                          : [1, 1, 0, 0]
     * [ 1 ][ 2 ][ 3 ]                     : [1, 1, 1, 0]
     * [ 2 ][ 3 ][ 4 ]                     : [0, 1, 1, 1]
     * [ 4 ][ 1 ][ 2 ]                     : [0, 0, 0, 1, 1, 1]
     * [ 3 ][ 4 ][ 1 ][ 2 ][ 3 ][ 4 ][ 1 ] : [0, 0, 1, 1, 1, 1, 1, 1, 1]
     *
     * @private {!Array<Visibility>}
     */
    this.displayMap_ = [];

    /**
     * The tile currently snapped.
     * @private {?Tile|undefined}
     */
    this.currentSnappedTile_;
  }


  /**
   * Returns the list of all available tiles' width.
   * @return {!Array<number>}
   */
  getTiles() {
    return this.tileWidths_;
  }


  /**
   * Set all tiles width at once, and as a result the number of available tiles.
   * @param {!Array<number>} widths The list of all tiles' width.
   */
  setTiles(widths) {
    this.tileWidths_ = Array.prototype.slice.apply(widths);
    this.allTilesWidth_ = this.getAllTilesWidth();

    var isBelowZero = function(width) {
      return width <= 0;
    };
    // Needs to have at least one tile with a width greater than zero to be
    // considered as valid.
    this.areTilesValid_ = !this.getTiles().every(isBelowZero);

    this.updateDisplayMap_();
  }


  /**
   * Returns the number of available tiles.
   * @return {number}
   */
  getTilesCount() {
    return this.tileWidths_.length;
  }


  /**
   * The cumulative width of all available tiles combined.
   * @return {number}
   */
  getAllTilesWidth() {
    var width = 0;
    for (var i = 0, len = this.getTilesCount(); i < len; i++) {
      width += this.getTileWidth(i);
    }
    return width;
  }


  /**
   * Whether the carousel is properly sized to be computed.
   * @return {boolean}
   */
  isValid() {
    return this.frameWidth > 0 && this.areTilesValid_;
  }


  /**
   * Returns the width of a defined tile, or zero if the tile has been disabled.
   * @param {number} index The index of the tile. It can safely exceed the
   *    number of available tiles, eg. if there are 4 tiles available,
   *    index = 6 will get the width of the tile #2.
   * @return {number} The width of the tile.
   */
  getTileWidth(index) {
    index = index % this.getTilesCount();
    if (this.getDisabledTiles_().indexOf(index) == -1) {
      return this.tileWidths_[index];
    } else {
      return 0;
    }
  }


  /**
   * Computes a width large enough to contain all visible tiles.
   * @return {number}
   */
  getMaxWidth() {
    // Computes how large the container should be if it was fill with multiple
    // occurences of the largest available tile.
    var largestTileWidth = Math.max.apply(null, this.tileWidths_);

    // Apply expand value on both sides of the frame area.
    var frameWidth = this.frameWidth + 2 * this.frameExpand;
    return (2 + Math.ceil(frameWidth / largestTileWidth)) * largestTileWidth;
  }


  /**
   * Returns the frame position.
   * @return {number} The frame position.
   */
  getFrameX() {
    return this.x_;
  }


  /**
   * Sets the frame position.
   * @param {?number} x The frame position.
   */
  setFrameX(x) {
    if (x == null) {
      x = 0;
    }
    if (!isFinite(x)) {
      return;
    }
    this.x_ = x;

    if (!this.cyclical_ && !this.canExceedEdges_) {
      this.x_ =
          Math.min(Math.max(this.x_, this.getMinFrameX()), this.getMaxFrameX());
    }

    this.updateDisplayMap_();
    this.currentSnappedTile_ = this.getSnappedTile();
  }


  /**
   * Gets the tile currently snapped.
   * @return {?Tile|undefined}
   */
  getCurrentSnappedTile() {
    return this.currentSnappedTile_;
  }


  /**
   * The frame's minimum position if the tile map is non-cyclical.
   * @return {number}
   */
  getMinFrameX() {
    if (this.snapToCenter_) {
      return this.getTileWidth(0) / 2 - this.frameWidth / 2;
    } else {
      return 0;
    }
  }


  /**
   * The frame's maximum position if the tile map is non-cyclical.
   * @return {number}
   */
  getMaxFrameX() {
    var lastTileWidth = this.getTileWidth(this.getTilesCount() - 1);
    var frameX = this.allTilesWidth_ - lastTileWidth;
    if (this.snapToCenter_) {
      frameX += lastTileWidth / 2 - this.frameWidth / 2;
    }
    return frameX;
  }


  /**
   * Gets the frame position snapped on the previous tile.
   * @param {number=} opt_frameX A frame position to use instead of the current
   *     one.
   * @return {?number}
   */
  getPreviousFrameX(opt_frameX) {
    var snappedTile = this.getSnappedTile(false, opt_frameX);
    if (!snappedTile) {
      return null;
    }

    var iterator = new __WEBPACK_IMPORTED_MODULE_3__tileiterator__["a" /* TileIterator */](this, snappedTile, null, false);
    iterator.next();
    var tile = iterator.next().value || snappedTile;
    var frameX = tile ? tile.x : snappedTile.x;
    if (this.snapToCenter_) {
      frameX += tile.width / 2 - this.frameWidth / 2;
    }
    return frameX;
  }


  /**
   * Gets the frame position snapped on the next tile.
   * @param {number=} opt_frameX A frame position to use instead of the current
   *     one.
   * @return {?number}
   */
  getNextFrameX(opt_frameX) {
    var snappedTile = this.getSnappedTile(false, opt_frameX);
    if (!snappedTile) {
      return null;
    }

    var iterator = new __WEBPACK_IMPORTED_MODULE_3__tileiterator__["a" /* TileIterator */](this, snappedTile, null, true);
    iterator.next();
    var tile = iterator.next().value || snappedTile;
    var frameX = tile ? tile.x : snappedTile.x;
    if (this.snapToCenter_) {
      frameX += tile.width / 2 - this.frameWidth / 2;
    }
    return frameX;
  }


  /**
   * Gets the frame position snapped on the previous group of tiles.
   * @param {number=} opt_frameX A frame position to use instead of the current
   *     one.
   * @return {number}
   */
  getPreviousGroupFrameX(opt_frameX) {
    var frameX = (opt_frameX != undefined) ? opt_frameX : this.getFrameX();

    var getFirstTile = (function() {
      var iterator = new __WEBPACK_IMPORTED_MODULE_0__containedtileiterator__["a" /* ContainedTileIterator */](this, frameX);
      return iterator.next().value;
    }).bind(this);

    var getFirstVisibleTile = (function(frameX) {
      var iterator = new __WEBPACK_IMPORTED_MODULE_0__containedtileiterator__["a" /* ContainedTileIterator */](this, frameX);
      var tile;
      while (tile = iterator.next().value) {
        var vsb = this.getTileVisibility(tile.index, tile.x, frameX, false);
        if (vsb == __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].VISIBLE) {
          return tile;
        }
      }
      return null;
    }).bind(this);

    // Get the first tile inside the current frame
    var firstTile = getFirstTile();

    // Get the target frame position
    var targetFrameX;
    var vsb =
        this.getTileVisibility(firstTile.index, firstTile.x, frameX, false);

    if (vsb == __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].VISIBLE) {
      targetFrameX = frameX;
    } else {
      targetFrameX = firstTile.x + firstTile.width;
    }
    targetFrameX -= this.frameWidth;

    // Get the first fully visible tile in the target frame
    var firstVisibleTile = getFirstVisibleTile(targetFrameX);

    // Return its position
    return firstVisibleTile ? firstVisibleTile.x : 0;
  }


  /**
   * Gets the frame position snapped on the next group of tiles.
   * @param {number=} opt_frameX A frame position to use instead of the current
   *     one.
   * @return {number}
   */
  getNextGroupFrameX(opt_frameX) {
    var frameX = this.frameWidth;
    frameX += (opt_frameX != undefined) ? opt_frameX : this.getFrameX();
    var iterator = new __WEBPACK_IMPORTED_MODULE_0__containedtileiterator__["a" /* ContainedTileIterator */](this, frameX);
    var tile = iterator.next().value;

    // Even if the current tile is also contained in the next frame, still move
    // to the next tile.
    if (tile && this.currentSnappedTile_ &&
        tile.x == this.currentSnappedTile_.x) {
      tile = iterator.next().value;
    }

    if (tile) {
      return tile.x;
    } else {
      var lastTileIndex = this.getTilesCount() - 1;
      var lastTileX = this.allTilesWidth_ - this.getTileWidth(lastTileIndex);
      return lastTileX;
    }
  }


  /**
   * Returns the display map for the current frame position.
   * @return {!Array<Visibility>}
   */
  getDisplayMap() {
    return this.displayMap_;
  }


  /**
   * Whether the carousel is cyclical.
   * @return {boolean}
   */
  isCyclical() {
    return this.cyclical_;
  }


  /**
   * Returns the position of the first visible tile in the frame's coordinate
   * system. This can be used by the renderer to set the translate property of
   * the visible tiles container in the DOM.
   * @return {number}
   */
  getContainerX() {
    // Convert to the frame's coordinate system.
    var x = -this.getFrameX();

    if (this.cyclical_ && this.isValid()) {
      while (x > 0) {
        x -= this.allTilesWidth_;
      }
    }

    for (var i = 0, len = this.displayMap_.length; i < len; i++) {
      var visible = this.displayMap_[i];
      if (visible) {
        return x;
      } else {
        x += this.getTileWidth(i);
      }
    }

    return 0;
  }


  /**
   * Returns the position of the frame where the horizontal center of the
   * specified tile is aligned with the center of the frame. The position is
   * computated based on the current frame position, so the relative distance
   * should be short.
   * @param {number} index The tile index.
   * @param {?boolean=} opt_moveForward Whether to move forward from the current
   *     frame position. Only used for cyclical carousels. (Default: true)
   * @param {?boolean=} opt_forceSnapToCenter Whether to always get the tile
   *     snapped to the center of the frame, overriding the carousel options.
   * @return {?number} The frame position.
   */
  getFrameXSnappedOnTile(index, opt_moveForward, opt_forceSnapToCenter) {
    // Keep tile index within bounds.
    index = Math.min(Math.max(index, 0), this.getTilesCount() - 1);

    var iterator;

    if (this.cyclical_) {
      var snappedTile = this.getSnappedTile();
      if (!snappedTile) {
        return null;
      }
      iterator = new __WEBPACK_IMPORTED_MODULE_3__tileiterator__["a" /* TileIterator */](this, snappedTile, index, opt_moveForward);
    } else {
      iterator = new __WEBPACK_IMPORTED_MODULE_3__tileiterator__["a" /* TileIterator */](this, 0, index);
    }

    var frameX = 0;
    var tile;
    while (tile = iterator.next().value) {
      frameX = tile.x;
    }

    // Centering within frame.
    if (this.snapToCenter_ || opt_forceSnapToCenter) {
      frameX += this.getTileWidth(index) / 2 - this.frameWidth / 2;
    }

    return frameX;
  }


  /**
   * Get the tile currently snapped.
   * @param {boolean=} opt_forceSnapToCenter Whether to always get the tile
   *     snapped to the center of the frame, overriding the carousel options.
   * @param {number=} opt_frameX A frame position to use instead of the current
   *     one.
   * @return {?Tile|undefined}
   */
  getSnappedTile(opt_forceSnapToCenter, opt_frameX) {
    if (!this.isValid()) {
      return null;
    }

    var frameX = (opt_frameX != undefined) ? opt_frameX : this.getFrameX();

    var tile;
    var iterator = new __WEBPACK_IMPORTED_MODULE_0__containedtileiterator__["a" /* ContainedTileIterator */](this, 0, frameX);

    // If the frame is out of bounds of a non-cyclical carousel, return either
    // the first of the last tile.
    if (!this.cyclical_) {
      if (frameX < this.getMinFrameX() || frameX > this.getMaxFrameX()) {
        var index = frameX < this.getMinFrameX() ? 0 : this.getTilesCount() - 1;
        iterator = new __WEBPACK_IMPORTED_MODULE_3__tileiterator__["a" /* TileIterator */](this, index);
        tile = iterator.next().value;
        tile.offset = 0;
        return tile;
      }
    }

    while (tile = iterator.next().value) {
      var isSnappedTile;
      var offset;
      var leftBound;
      var rightBound;
      var snapX = frameX;

      if (this.snapToCenter_ || opt_forceSnapToCenter) {
        leftBound = tile.x;
        rightBound = tile.x + tile.width - 1;
        snapX += this.frameWidth / 2;
        isSnappedTile = (snapX >= leftBound && snapX < rightBound);
        offset = snapX - leftBound - ((rightBound - leftBound + 1) / 2);

      } else {
        rightBound = tile.x + tile.width / 2;
        if (frameX >= 0) {
          isSnappedTile = snapX <= rightBound;
        } else {
          leftBound = tile.x - tile.nextWidth / 2;
          isSnappedTile = (snapX >= leftBound && snapX < rightBound);
        }
        offset = snapX - tile.x;
      }

      if (isSnappedTile) {
        tile.offset = offset;
        return tile;
      }
    }
  }


  /**
   * Moves the frame position back between 0 and the cumulative width of all
   * available tiles. This is only to make sure the frame position stays within
   * reasonable boundaries, even though the visible position and tiles will
   * stay identical.
   * That method should be called only when the carousel is not animating, to
   * prevent any unwanted animations where the carousel would jump to the same
   * visible position but one cycle ahead.
   */
  adjustFrameX() {
    var correctedX = this.getFrameX() % this.allTilesWidth_;
    this.setFrameX(correctedX);
  }


  /**
   * Whether a frame position would exceed the bounds of a non-cyclical
   * carousel.
   * @param {number} x A frame position to test against.
   * @return {boolean}
   */
  isFrameXExceedingBounds(x) {
    if (this.cyclical_) {
      return false;
    }

    var min = this.getMinFrameX();
    var max = this.getMaxFrameX();
    return x < min || x > max;
  }


  /**
   * Returns the index of the specified tile among the visible ones.
   * @param {number} index The tile index.
   * @return {?number} The visible index, or null if the tile is not visible.
   */
  getVisibleIndex(index) {
    if (!this.isValid()) {
      return null;
    }

    var firstVisibleTile = null;

    // Get the index of the first visible tile in the current display map
    for (var i = 0, len = this.displayMap_.length; i < len; i++) {
      if (this.displayMap_[i] == __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].HIDDEN) {
        continue;
      }

      firstVisibleTile = i;
      break;
    }

    while (index < firstVisibleTile) {
      index += this.tileWidths_.length;
    }

    var visibility = this.displayMap_[index];
    if (visibility != __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].HIDDEN && visibility != undefined) {
      return index - firstVisibleTile;
    }

    return null;
  }


  /**
   * Gets a tile's visibility status.
   * @param {number} tileIndex The tile index.
   * @param {number} tileX The tile position.
   * @param {number=} opt_frameX A frame position to use instead of the current
   *     one.
   * @param {boolean=} opt_applyExpand Whether to check visibility inside the
   *     expanded frame area.
   * @return {!Visibility}
   */
  getTileVisibility(tileIndex, tileX, opt_frameX, opt_applyExpand) {
    var frameX = (opt_frameX != undefined) ? opt_frameX : this.getFrameX();
    var tileWidth = this.getTileWidth(tileIndex);
    if (tileWidth == 0) {
      return __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].HIDDEN;
    }

    var tileLeftX = tileX;
    var tileRightX = tileLeftX + tileWidth - 1;
    var frameExpand = (opt_applyExpand != false) ? this.frameExpand : 0;
    var frameLeftX = frameX - frameExpand;
    var frameRightX = frameX + this.frameWidth + frameExpand;

    var fullyVisible = (tileLeftX >= frameLeftX) && (tileRightX < frameRightX);
    if (fullyVisible) {
      return __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].VISIBLE;
    }

    var partiallyVisible =
        (tileLeftX >= frameLeftX && tileLeftX < frameRightX) ||
        (tileRightX >= frameLeftX && tileRightX < frameRightX) ||
        (tileLeftX <= frameLeftX && tileRightX >= frameRightX);

    return partiallyVisible ? __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].PARTIALLY : __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].HIDDEN;
  }


  /**
   * Re-enables previously disabled tiles.
   */
  enableHiddenTiles() {
    if (!this.getDisabledTiles_().length) {
      return;
    }

    var snappedTile = this.getSnappedTile(true);
    if (!snappedTile) {
      return;
    }

    this.setDisabledTiles_([]);

    // Replace carousel at the new position of the same focused tile;
    var frameX = this.getFrameXSnappedOnTile(snappedTile.index, null, true) +
        snappedTile.offset;
    this.setFrameX(frameX);
  }


  /**
   * Disables all tiles placed contained between the bounds of the current
   * frame and another one.
   * @param {number} frameX The position of the other frame.
   */
  disableHiddenTiles(frameX) {
    if (frameX == this.getFrameX()) {
      return;
    }

    var snappedTile = this.getSnappedTile();
    if (!snappedTile) {
      return;
    }

    var hiddenTiles = this.getHiddenTiles_(this.getFrameX(), frameX);
    if (!hiddenTiles.length) {
      return;
    }

    this.setDisabledTiles_(hiddenTiles);

    // Replace carousel at the new position of the same focused tile
    frameX = this.getFrameXSnappedOnTile(snappedTile.index) +
        snappedTile.offset;
    this.setFrameX(frameX);
  }


  /**
   * Gets all tiles contained between two frame bounds.
   * @param {number} fromFrameX The position of the first frame.
   * @param {number} toFrameX The position of the second frame.
   * @return {!Array<number>} A list of tile indexes.
   * @private
   */
  getHiddenTiles_(fromFrameX, toFrameX) {
    var tiles = [];
    var iterator = new __WEBPACK_IMPORTED_MODULE_0__containedtileiterator__["a" /* ContainedTileIterator */](this, fromFrameX, toFrameX);
    var tile;
    while (tile = iterator.next().value) {
      var vsb1 = this.getTileVisibility(tile.index, tile.x, fromFrameX);
      var vsb2 = this.getTileVisibility(tile.index, tile.x, toFrameX);
      if (vsb1 == __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].HIDDEN && vsb2 == __WEBPACK_IMPORTED_MODULE_4__visibility__["a" /* Visibility */].HIDDEN) {
        tiles.push(tile.index);
      }
    }
    return tiles;
  }


  /**
   * Computes which tiles are visible in the frame and creates the equivalent
   * display map.
   * @private
   */
  updateDisplayMap_() {
    this.displayMap_.length = 0;
    var iterator = new __WEBPACK_IMPORTED_MODULE_5__visibilityiterator__["a" /* VisibilityIterator */](this);
    var tile;
    while (tile = iterator.next().value) {
      this.displayMap_.push(tile.vsb);
    }
  }


  /**
   * Gets the list of disabled tiles.
   * @return {!Array<number>} A list of tile indexes.
   * @private
   */
  getDisabledTiles_() {
    return this.disabledTiles_;
  }


  /**
   * Disables a set of tiles.
   * @param {!Array<number>} tiles A list of tile indexes.
   * @private
   */
  setDisabledTiles_(tiles) {
    this.disabledTiles_ = tiles;
    this.allTilesWidth_ = this.getAllTilesWidth();
  }

}




/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Tile */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__visibility__ = __webpack_require__(3);




/** @record */
function Tile() {}

/** @type {number} */
Tile.prototype.index;

/** @type {number} */
Tile.prototype.x;

/** @type {number|undefined} */
Tile.prototype.width;

/** @type {number|undefined} */
Tile.prototype.nextWidth;

/** @type {number|undefined} */
Tile.prototype.offset;

/** @type {Visibility|undefined} */
Tile.prototype.vsb;




/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MDCComponent; });
/**
 * @fileoverview Parent class for Vanilla components built with the MDC-Web architecture.
 * Forked from https://github.com/material-components/material-components-web/blob/master/packages/mdc-base/component.js
 * MDC-Web architecture:
 * https://github.com/material-components/material-components-web/blob/master/docs/architecture.md
 * Authoring components:
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 */



/**
 * @abstract
 * @template T
 */
class MDCComponent {

  /**
   * @param {!Element} root
   * @param {T=} foundation
   * @param {...?} args
   */
  constructor(root, foundation = undefined, ...args) {
    /** @protected @const {!Element} */
    this.root_ = root;
    this.initialize(...args);

    // Note that we initialize foundation here and not within the constructor's
    // default param so that
    // this.root_ is defined and can be used within the foundation class.
    this.foundation_ = foundation === undefined ?
        this.getDefaultFoundation() : foundation;

    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  /**
   * Subclasses can override this to do any additional setup work that would be
   * considered part of a "constructor". Essentially, it is a hook into the
   * parent constructor before the foundation is initialized. Any additional
   * arguments besides root and foundation will be passed in here.
   * @param {...?} args
   */
  initialize(...args) {}

  /**
   * Subclasses must override this method to return a properly configured
   * foundation class for the component.
   * @abstract
   * @return {T}
   */
  getDefaultFoundation() {}

  /**
   * Subclasses should override this method if they need to perform work to
   * synchronize with a host DOM object. An example of this would be a form
   * control wrapper that needs to synchronize its internal state to some
   * property or attribute of the host DOM. Please note: this is *not* the
   * place to perform DOM reads/writes that would cause layout / paint, as this
   * is called synchronously from within the constructor.
   */
  initialSyncWithDOM() {}

  /**
   * Subclasses may implement this method to release any resources / deregister
   * any listeners they have attached. An example of this might be
   * deregistering a resize event from the window object.
   */
  destroy() {
    this.foundation_.destroy();
  }

  /**
   * Wrapper method to add an event listener to the component's root element.
   * This is most useful when listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */
  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }

  /**
   * Wrapper method to remove an event listener to the component's root element.
   * This is most useful when unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */
  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }

  /**
   * Fires a cross-browser-compatible custom event from the component root of
   * the given type, with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */
  emit(evtType, evtData, shouldBubble = false) {
    let evt;
    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble,
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }

}




/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__global_constants__ = __webpack_require__(60);



/** @enum {string} */
const Selectors = {
  ACTIVE_MOBILE_SUBNAV_ITEM: '.lb-mobile-nav__subitem--active',
  ACTIVE_SUBNAV_ITEM: '.lb-nav__subitem--active',
  HASH_LINKS: '.lb-js-hash-link',
  MENU_BTN: '.lb-js-menu-btn',
  MOBILE_NAV: '.lb-js-mobile-nav',
  MOBILE_NAV_TOGGLE: '.lb-js-mobile-nav-toggle',
  NAV_ITEM_WRAPPER: '.lb-js-desktop-nav-item-wrapper',
  NAV_ITEMS: '.lb-js-nav-item',
  SUBNAV: '.lb-js-subnav',
  TABABLE_ELS: 'a, button',
};
/* harmony export (immutable) */ __webpack_exports__["f"] = Selectors;


/** @enum {string} */
const Classes = {
  ACTIVE_MOBILE_NAV_ITEM: 'lb-mobile-nav__item--active',
  ACTIVE_NAV_ITEM: 'lb-nav__item--active',
  ACTIVE_MOBILE_SUBNAV_ITEM: 'lb-mobile-nav__subitem--active',
  ACTIVE_SUBNAV_ITEM: 'lb-nav__subitem--active',
  HAS_ACTIVE_MOBILE_SUBNAV: 'lb-mobile-nav__item--subnav-active',
  HAS_ACTIVE_SUBNAV: 'lb-nav__item--subnav-active',
  MOBILE_NAV_ITEM: 'lb-mobile-nav__item',
  MOBILE_SUBNAV_ITEM: 'lb-mobile-nav__subitem',
  NAV_ITEM: 'lb-nav__item',
  NAV_ITEM_WRAPPER: 'lb-nav__item-wrapper',
  NAV_ITEM_WRAPPER_FOCUSED: 'lb-nav__item-wrapper--focused',
  NO_SCROLL: 'no-scroll',
  OPENED_MOBILE_NAV: 'lb-mobile-nav--opened',
  SUBNAV_ITEM: 'lb-nav__subitem',
  SUBNAV_OVERFLOWING_LEFT: 'lb-nav__subnav--overflowing-left',
  SUBNAV_OVERFLOWING_RIGHT: 'lb-nav__subnav--overflowing-right',
  STICKY: 'lb-header--sticky',
  SLIDE_AWAY: 'lb-header--slide-away',
};
/* harmony export (immutable) */ __webpack_exports__["b"] = Classes;


/** @enum {string} */
const Attrs = {
  ARIA_HIDDEN: 'aria-hidden',
};
/* harmony export (immutable) */ __webpack_exports__["a"] = Attrs;


/** @enum {string} */
const Events = {
  // Events.
  KEYUP: 'keyup',
  MOUSEENTER: 'mouseenter',
  MOUSELEAVE: 'mouseleave',
  RESIZE: 'resize',
};
/* harmony export (immutable) */ __webpack_exports__["c"] = Events;


/** @enum {number} */
const Keys = __WEBPACK_IMPORTED_MODULE_0__global_constants__["a" /* KeyCodes */];
/* harmony export (immutable) */ __webpack_exports__["d"] = Keys;


/** @enum {number} */
const Numbers = {
  // The amount of pixels a user needs to scroll to make the header show/hide.
  SLIDE_AWAY_SCROLL_THRESHOLD: 10,
  // The amount of pixels a user needs to mousemove to make the header show.
  SLIDE_AWAY_MOUSEMOVE_THRESHOLD: 100,
  // The amount of time to measure if a user's mousemove reaches the distance
  // defined in SLIDE_AWAY_MOUSEMOVE_THRESHOLD before resetting.
  SLIDE_AWAY_MOUSEMOVE_RESET_TIME: 750,
};
/* harmony export (immutable) */ __webpack_exports__["e"] = Numbers;



/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export MDCSelectionControlState */
/* unused harmony export MDCSelectionControl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_ripple_index__ = __webpack_require__(11);
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint-disable no-unused-vars */

/* eslint-enable no-unused-vars */

/**
 * @typedef {{
 *   checked: boolean,
 *   indeterminate: boolean,
 *   disabled: boolean,
 *   value: ?string
 * }}
 */
let MDCSelectionControlState;

/**
 * @record
 */
class MDCSelectionControl {
  /** @return {?MDCRipple} */
  get ripple() {}
}




/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return supportsCssVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return applyPassive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getMatchesProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getNormalizedEventCoords; });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
 * @private {boolean|undefined}
 */
let supportsCssVariables_;

/**
 * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
 * @private {boolean|undefined}
 */
let supportsPassive_;

/**
 * @param {!Window} windowObj
 * @return {boolean}
 */
function detectEdgePseudoVarBug(windowObj) {
  // Detect versions of Edge with buggy var() support
  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
  const document = windowObj.document;
  const node = document.createElement('div');
  node.className = 'mdc-ripple-surface--test-edge-var-bug';
  document.body.appendChild(node);

  // The bug exists if ::before style ends up propagating to the parent element.
  // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
  // but Firefox is known to support CSS custom properties correctly.
  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
  const computedStyle = windowObj.getComputedStyle(node);
  const hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
  node.remove();
  return hasPseudoVarBug;
}

/**
 * @param {!Window} windowObj
 * @param {boolean=} forceRefresh
 * @return {boolean|undefined}
 */

function supportsCssVariables(windowObj, forceRefresh = false) {
  let supportsCssVariables = supportsCssVariables_;
  if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
    return supportsCssVariables;
  }

  const supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
  if (!supportsFunctionPresent) {
    return;
  }

  const explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
  // See: https://bugs.webkit.org/show_bug.cgi?id=154669
  // See: README section on Safari
  const weAreFeatureDetectingSafari10plus = (
    windowObj.CSS.supports('(--css-vars: yes)') &&
    windowObj.CSS.supports('color', '#00000000')
  );

  if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
    supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
  } else {
    supportsCssVariables = false;
  }

  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVariables;
  }
  return supportsCssVariables;
}

//
/**
 * Determine whether the current browser supports passive event listeners, and if so, use them.
 * @param {!Window=} globalObj
 * @param {boolean=} forceRefresh
 * @return {boolean|{passive: boolean}}
 */
function applyPassive(globalObj = window, forceRefresh = false) {
  if (supportsPassive_ === undefined || forceRefresh) {
    let isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, {get passive() {
        isSupported = true;
      }});
    } catch (e) { }

    supportsPassive_ = isSupported;
  }

  return supportsPassive_ ? {passive: true} : false;
}

/**
 * @param {!Object} HTMLElementPrototype
 * @return {!Array<string>}
 */
function getMatchesProperty(HTMLElementPrototype) {
  return [
    'webkitMatchesSelector', 'msMatchesSelector', 'matches',
  ].filter((p) => p in HTMLElementPrototype).pop();
}

/**
 * @param {!Event} ev
 * @param {{x: number, y: number}} pageOffset
 * @param {!ClientRect} clientRect
 * @return {{x: number, y: number}}
 */
function getNormalizedEventCoords(ev, pageOffset, clientRect) {
  const {x, y} = pageOffset;
  const documentX = x + clientRect.left;
  const documentY = y + clientRect.top;

  let normalizedX;
  let normalizedY;
  // Determine touch point relative to the ripple container.
  if (ev.type === 'touchstart') {
    normalizedX = ev.changedTouches[0].pageX - documentX;
    normalizedY = ev.changedTouches[0].pageY - documentY;
  } else {
    normalizedX = ev.pageX - documentX;
    normalizedY = ev.pageY - documentY;
  }

  return {x: normalizedX, y: normalizedY};
}




/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_dialog__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__google_youtube_src_providers_utils_utils__ = __webpack_require__(2);




/**
 * Reveals an MDCDialog.
 * @final
 */
class Modal {
  constructor() {
    /** @private {!Array<!Element>} */
    this.modalEls_ = [...document.querySelectorAll('[data-modal]')];

    /** @private {!Object<string, !MDCDialog>} */
    this.modals_ = {};

    // Makes a new instance of MDCDialog for each designated element and sets
    // them into an object.
    this.modalEls_.forEach((el) => {
      this.modals_[el.getAttribute('data-modal')] = new __WEBPACK_IMPORTED_MODULE_0__material_dialog__["a" /* MDCDialog */](el);
    });

    // Shows the video dialog on click.
    Object(__WEBPACK_IMPORTED_MODULE_1__google_youtube_src_providers_utils_utils__["a" /* delegate */])(document,
        '[data-modal-trigger]', 'click', this.showModal_.bind(this));
  }

  /**
   * @param {!Element} target The dialog trigger.
   * @private
   */
  showModal_(target) {
    const modal = this.modals_[target.getAttribute('data-modal-trigger')];

    modal.lastFocusedTarget = target;
    modal.show();
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Modal;



/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__yt_player_constants__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__yt_player_index__ = __webpack_require__(78);






/**
 * Parent class that loads the YT Iframe API for YTPlayer components.
 */
class LBIframeApi extends __WEBPACK_IMPORTED_MODULE_0__material_base__["a" /* MDCComponent */] {
  /**
   * Creates a new instance of the YTIframeApi.
   * @param {string=} root The selector of the parent element. The root will be
   *    the document's body if no selector is given.
   * @return {!LBIframeApi}
   */
  static attachTo(root='body') {
    return new LBIframeApi(root);
  }

  /**
   * @return {!LBIframeApiFoundation}
   */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* LBIframeApiFoundation */]({});
  }

  /**
   * Registers a callback on onYouTubeIframeAPIReady to initialize a video
   * player for each component player element. Optionally loads the YT Iframe
   * API if it's not already loaded.
   */
  initialize() {
    if (!window.onYouTubeIframeAPIReady) {
      window.onYouTubeIframeAPIReady = () => {
        let playerEls = document.querySelectorAll(__WEBPACK_IMPORTED_MODULE_1__yt_player_constants__["e" /* Selectors */].PLAYER);
        playerEls = Array.prototype.slice.call(playerEls);

        playerEls.forEach((el) => {
          __WEBPACK_IMPORTED_MODULE_3__yt_player_index__["a" /* YTPlayer */].attachTo(el);
        });
      };
    }

    if (!window.YT) {
      const tag = document.createElement('script');
      const firstScriptTag = document.getElementsByTagName('script')[0];

      tag.src = __WEBPACK_IMPORTED_MODULE_1__yt_player_constants__["c" /* IFRAME_API_SRC */];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBIframeApi;



/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @const {string} */
const IFRAME_API_SRC = 'https://www.youtube.com/iframe_api';
/* harmony export (immutable) */ __webpack_exports__["c"] = IFRAME_API_SRC;


/** @enum {string} */
const Attrs = {
  EVENT: 'lb-player-event',
  SETTINGS: 'lb-player-settings',
  VIDEO_ID: 'lb-video-id',
};
/* harmony export (immutable) */ __webpack_exports__["a"] = Attrs;


/** @enum {string} */
const Selectors = {
  EVENT: `[${Attrs.EVENT}]`,
  PLAYER: '.lb-js-video-iframe',
};
/* harmony export (immutable) */ __webpack_exports__["e"] = Selectors;


/** @enum {string} */
const JsonKeys = {
  CUE_ID: 'cue_id',
  EVENT_TYPE: 'event',
  PLAYER_ID: 'player_id',
};
/* harmony export (immutable) */ __webpack_exports__["d"] = JsonKeys;


/** @enum {!YT.Player} */
const YTPlayers = {};
/* harmony export (immutable) */ __webpack_exports__["f"] = YTPlayers;


/** @enum {number} */
const DEFAULT_SETTINGS = {
  enablejsapi: 1,
  modestbranding: 1,
  rel: 0,
};
/* harmony export (immutable) */ __webpack_exports__["b"] = DEFAULT_SETTINGS;



/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TileIterator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__indexiterator__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iterabletilemap__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tile__ = __webpack_require__(18);







/**
 * Iterates tiles from a starting tile, from either a tile index or position,
 * up to a specified tile index or forever, in a given direction.
 */
class TileIterator {

  /**
   * @param {!IterableTileMap} tileMap A tile map.
   * @param {number|!Tile} fromTile A tile index or a
   *     tile properties.
   * @param {?number=} opt_toTileIndex The tile index to iterate to.
   * @param {?boolean=} opt_moveForward Whether to iterate forward.
   *     (Default: true)
   */
  constructor(tileMap, fromTile, opt_toTileIndex, opt_moveForward) {
    /** @private {!IterableTileMap} */
    this.tileMap_ = tileMap;

    /** @private {boolean} Whether to iterate tiles forward. */
    this.moveForward_ = (opt_moveForward != false);

    /** @private {number} The position of the current tile. */
    this.x_ = 0;

    var fromTileIndex;
    if (fromTile.x != undefined) {
      fromTileIndex = /** @type {number} */(fromTile.index);
      this.x_ = fromTile.x;
    } else {
      fromTileIndex = /** @type {number} */(fromTile);
      this.x_ = this.getStartTileX_(fromTileIndex);
    }

    /**
     * Tile index iterator.
     * @private {!IndexIterator}
     */
    this.indexIterator_ = new __WEBPACK_IMPORTED_MODULE_0__indexiterator__["a" /* IndexIterator */](
        this.tileMap_, fromTileIndex, opt_toTileIndex, opt_moveForward);

    /**
     * Another index iterator one step ahead of {@code indexIterator_}, used to
     * also provide the width of the next tile.
     * @private {!IndexIterator}
     */
    this.nextIndexIterator_ = new __WEBPACK_IMPORTED_MODULE_0__indexiterator__["a" /* IndexIterator */](
        this.tileMap_, fromTileIndex, opt_toTileIndex, opt_moveForward);

    this.nextIndexIterator_.next();
  }


  /**
   * Moves the iterator to the next tile.
   * @return {!IteratorObject}
   */
  next() {
    var index = this.indexIterator_.next().value;
    var nextIndex = this.nextIndexIterator_.next().value;
    if (index != undefined) {
      var width = this.tileMap_.getTileWidth(index);
      var nextWidth = (nextIndex != undefined) ?
          this.tileMap_.getTileWidth(nextIndex) : undefined;
      var x = this.x_;
      this.x_ += this.moveForward_ ? width : -nextWidth;

      const /** !Tile */ value = {
        index: index,
        width: width,
        nextWidth: nextWidth,
        x: x,
      };

      return {
        value: value,
        done: false,
      };

    } else {
      return {value: undefined, done: true};
    }
  }


  /**
   * Gets the first tile position to iterate from.
   * @param {number} index The tile index to start from.
   * @return {number}
   * @private
   */
  getStartTileX_(index) {
    var x;
    var tileMap = this.tileMap_;
    if (tileMap.isCyclical()) {
      var cycles = Math.floor(tileMap.getFrameX() / tileMap.getAllTilesWidth());
      x = cycles * tileMap.getAllTilesWidth();
    } else {
      x = 0;
    }

    for (var i = 0; i < index; i++) {
      x += tileMap.getTileWidth(i);
    }
    return x;
  }

}


/**
 * Iterator object.
 * @typedef {!{
 *   value: (Tile|undefined),
 *   done: boolean
 * }}
 */
let IteratorObject;




/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return numbers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return swipeDirection; });


/** @enum {string} */
const cssClasses = {
  MEASURING: 'glue-is-measuring',
  READY: 'glue-is-ready',
  SWIPING: 'glue-is-swiping',
};

/** @enum {number} */
const numbers = {
  RESIZE_DELAY: 250,
};

/**
 * @enum {string}
 */
const swipeDirection = {
  SWIPE_RIGHT: 'RIGHT',
  SWIPE_LEFT: 'LEFT',
};




/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/** @enum {string} */
const strings = {
  BANNER: '.lb-banner',
  CLOSE_BTN: '.lb-banner__close',
  SHOW_ELEMENT: 'lb-banner--show',
};
/* harmony export (immutable) */ __webpack_exports__["strings"] = strings;


/**
 * Local storage key required for banner on the site.
 * @Type {string}
 */
const localStorageBannerKey = 'creators-banner';
/* harmony export (immutable) */ __webpack_exports__["localStorageBannerKey"] = localStorageBannerKey;



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_base_plain__ = __webpack_require__(62);


/** @enum {string} */
const strings = {
  DATA_PREFIX: 'data-',
  STORE_REGISTER_ATTR: 'lb-auto-init',
};

const lbAttr = `${strings.STORE_REGISTER_ATTR}`;
const lbDataAttr = `${strings.DATA_PREFIX}${strings.STORE_REGISTER_ATTR}`;

/** @private @const {!Object<string, Function>} */
const registry = Object.create(null);

/** @private @const {!WeakMap} */
const componentInstances = new WeakMap();

/**
 * Performs a component name look up in the registry and instantiates the
 * corresponding class.
 * @param {!Element} node
 */
function instantiateComponent(node) {
  // Guard against duplicate component Ctor instantiations.
  // TODO(claytonmisura@) Find a cleaner way to do this.
  if (componentInstances.has(node)) {
    return;
  }
  let ctorNames = node.getAttribute(lbAttr) || node.getAttribute(lbDataAttr);
  if (!ctorNames) {
    throw new Error(`(lb-auto-init) Node doesn't have a valid attribute key.`);
  }
  ctorNames = ctorNames.split(',');
  if (!ctorNames.length) {
    throw new Error(
        `(lb-auto-init) Node doesn't have a valid attribute value.`);
  }
  // The "lb-auto-init" attribute value can included N number of comma
  // seperated component names- initialize each one.
  for (let ctorName of ctorNames) {
    ctorName = ctorName.trim();
    if (!registry[ctorName]) {
      throw new Error(
          `(lb-auto-init) Could not find constructor in registry ` +
          `for ${ctorName}`);
    }

    let component;
    let {Ctor, deps} = registry[ctorName];
    // Safeguard against components that don't have a static `attachTo`
    // method by instantiating the constructor and calling `new`.
    if ('attachTo' in Ctor) {
      component = Ctor.attachTo(node, ...deps);
    } else {
      component = new Ctor(node, undefined, ...deps);
    }

    // To ensure class properties assigned in sub classes aren't undefined,
    // we'll call `initialize` after the component class has been instantiated.
    if (component instanceof __WEBPACK_IMPORTED_MODULE_0__components_base_plain__["a" /* default */]) {
      component.initialize && component.initialize();
    }

    let instanceObj = componentInstances.get(node) || {};
    instanceObj[ctorName] = component;
    componentInstances.set(node, instanceObj);
  }
}

/**
 * Initializes component constructors found in registry.
 * @param {Element} parentNode The parent node to search within.
 * @return {!Object<string, !Function>}
 */
const lbAutoInit = (parentNode = document) => {
  if (!parentNode) {
    throw new Error(`(lb-auto-init) The specified parentNode does not exist.`);
  };

  const nodes =
      [...parentNode.querySelectorAll(`[${lbAttr}]`),
      ...parentNode.querySelectorAll(`[${lbDataAttr}]`)];

  for (const node of nodes) {
    instantiateComponent(node);
  }

  return {
    getComponent: lbAutoInit.getComponent,
    deleteInstance: lbAutoInit.deleteInstance,
    unregisterComponent: lbAutoInit.deleteInstance,
  };
};
/* harmony export (immutable) */ __webpack_exports__["a"] = lbAutoInit;


/**
 * Adds new component with dependencies to the registry.
 * @param {string} name
 * @param {!Function} Ctor
 * @param {...*} deps
 */
lbAutoInit.register = (name, Ctor, ...deps) => {
  if (typeof name !== 'string') {
    throw new Error(
        `(lb-auto-init) Components must have a name to be registered.`);
  }
  registry[name] = {Ctor, deps};
};

/**
 * Returns the registry.
 * @return {!Object<string, Function>}
 */
lbAutoInit.getRegistry = () => {
  return registry;
};

/**
 * Uses a DOM element to retrieve a corresponding component instance.
 * @param {!Element} element
 * @param {?string} componentName
 * @return {LBComponent|null}
 */
lbAutoInit.getComponent = (element, componentName) => {
  if (!componentInstances.has(element)) {
    try {
      instantiateComponent(element);
    } catch (error) {
      console.warn(error);
      return null;
    }
  }
  const elementEntry = componentInstances.get(element);
  // If a component name was provided, return that instance.
  // If no component name was provided, return the first instance.
  const componentEntry =
      componentName ?
      elementEntry[componentName] :
      elementEntry[Object.keys(elementEntry)[0]];

  return componentEntry;
};

/**
 * Uses a DOM element to retrieve an object of corresponding component instances.
 * @param {!Element} element
 * @return {?LBComponent}
 */
lbAutoInit.getComponents = (element) => {
  if (componentInstances.has(element)) {
    return componentInstances.get(element);
  }
};

/**
 * Removes an instance from the component store and calls `destroy` method
 * on the deleted instance.
 * @param {!Element} element
 */
lbAutoInit.deleteInstance = (element) => {
  const instance = lbAutoInit.getComponent(element);
  componentInstances.delete(element);
  ('destroy' in instance) && instance.destroy();
};


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class PubSub {
  constructor() {
    /** @private @const {!Object<string, ?Array<?Function>>} */
    this.subscribers_ = Object.create(null);
  }

  /**
   * Broadcasts an event.
   * @param {string} topic The topic name to broadcast.
   * @param {*} detail The details of the broadcast.
   */
  broadcast(topic, detail) {
    if (!this.subscribers_[topic]) {
      return;
    }

    this.subscribers_[topic].forEach((subscriber) => subscriber(detail));
  }

  /**
   * Removes a subscriber from the registry.
   * @param {string} topic The topic name to broadcast.
   * @param {!Function} subscriber The callback to unregister.
   */
  unsubscribe(topic, subscriber) {
    subscriber = subscriber.toString();
    this.subscribers_[topic] =
        this.subscribers_[topic].filter((sub) => sub.toString() !== subscriber);
  }

  /**
   * Adds a subscriber to the registry.
   * @param {string} topic The topic name to broadcast.
   * @param {!Function} subscriber The callback to unregister.
   * @param {?Object} context The context to run the subscriber callback in.
   */
  subscribe(topic, subscriber, context) {
    if (typeof topic !== 'string') {
      throw new Error('`topic` must be a string.');
    }

    this.subscribers_[topic] = this.subscribers_[topic] || [];
    this.subscribers_[topic].push(subscriber.bind(context || subscriber));
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PubSub;



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/** @private @const {string} */
const YT_OAUTH_SCOPE_ = 'https://www.googleapis.com/auth/youtube.readonly';


/**
 * Google sign in with Firebase Authentication and YouTUbe Oauth provider. It
 * exposes callback methods for both signing in and signing out.
 */
class Auth {
  constructor() {
    // Sets up YT oauth with Firebase login.
    Auth.FB_PROVIDER.addScope(YT_OAUTH_SCOPE_);

    // Sets language of oauth screen.
    Auth.FB_AUTH.languageCode = document.documentElement.lang;

    this.checkLoginStatus_();
  }

  /**
   * Empty method that is called on sign in and should be replaced in all pages
   * that extend this class.
   * @param {!Object} user The user data tree given by Firebase when signed in.
   */
  onSignIn(user) {}

  /**
   * Empty method that is called on sign out and should be replaced in all pages
   * that extend this class.
   */
  onSignOut() {}

  /**
   * Checks if a user is signed in or not then fires the appropriate callback.
   * @private
   */
  checkLoginStatus_() {
    Auth.FB_AUTH.onAuthStateChanged((user) => {
      if (user) {
        this.onSignIn(user);
      } else {
        this.onSignOut();
      }
    });
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Auth;


if (window.firebase) {
  /** @const {!firebase.auth.AuthProvider} */
  Auth.FB_PROVIDER = new window.firebase.auth.GoogleAuthProvider();

  /** @const {!firebase.auth.Auth} */
  Auth.FB_AUTH = window.firebase.auth();

  /**
   * Signs the user in.
   */
  Auth.signIn = () => {
    Auth.FB_AUTH.signInWithRedirect(Auth.FB_PROVIDER);
  };

  /**
   * Signs the user out.
   */
  Auth.signOut = () => {
    Auth.FB_AUTH.signOut();
  };
}


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Ripple. Provides an interface for managing
 * - classes
 * - dom
 * - CSS variables
 * - position
 * - dimensions
 * - scroll position
 * - event handlers
 * - unbounded, active and disabled states
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
class MDCRippleAdapter {
  /** @return {boolean} */
  browserSupportsCssVars() {}

  /** @return {boolean} */
  isUnbounded() {}

  /** @return {boolean} */
  isSurfaceActive() {}

  /** @return {boolean} */
  isSurfaceDisabled() {}

  /** @param {string} className */
  addClass(className) {}

  /** @param {string} className */
  removeClass(className) {}

  /** @param {!EventTarget} target */
  containsEventTarget(target) {}

  /**
   * @param {string} evtType
   * @param {!Function} handler
   */
  registerInteractionHandler(evtType, handler) {}

  /**
   * @param {string} evtType
   * @param {!Function} handler
   */
  deregisterInteractionHandler(evtType, handler) {}

  /**
   * @param {string} evtType
   * @param {!Function} handler
   */
  registerDocumentInteractionHandler(evtType, handler) {}

  /**
   * @param {string} evtType
   * @param {!Function} handler
   */
  deregisterDocumentInteractionHandler(evtType, handler) {}

  /**
   * @param {!Function} handler
   */
  registerResizeHandler(handler) {}

  /**
   * @param {!Function} handler
   */
  deregisterResizeHandler(handler) {}

  /**
   * @param {string} varName
   * @param {?number|string} value
   */
  updateCssVariable(varName, value) {}

  /** @return {!ClientRect} */
  computeBoundingRect() {}

  /** @return {{x: number, y: number}} */
  getWindowPageOffset() {}
}

/* unused harmony default export */ var _unused_webpack_default_export = (MDCRippleAdapter);


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__globals_utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_blog_blog__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_modal_modal__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_hero_slideshow__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_twitter_feed_twitter_feed__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_yt_channel_spotlight_yt_channel_spotlight__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__google_youtube_src_components_video_iframe__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__google_youtube_src_components_glue_carousel__ = __webpack_require__(13);










/** @private @const {string}*/
const Selectors_ = {
  BLOG: '.yt-js-blog',
  TWITTER_FEED: '.yt-js-twitter-feed',
  YT_CHANNEL_CAROUSEL: '.lb-js-carousel',
  YT_CHANNEL_SPOTLIGHT: '.yt-js-channel-spotlight',
};


/**
 * Class for Index page.
 */
class IndexPage {
  constructor() {
    // Initialize page components.
    new __WEBPACK_IMPORTED_MODULE_2__components_modal_modal__["default"];
    new __WEBPACK_IMPORTED_MODULE_3__components_hero_slideshow__["default"];
    new __WEBPACK_IMPORTED_MODULE_6__google_youtube_src_components_video_iframe__["a" /* LBIframeApi */];

    /** @private @const {?Element}*/
    this.twitterFeedEl_ = document.querySelector(Selectors_.TWITTER_FEED);

    /** @private {!Array<string>} */
    this.noSocialLocales_ = [];

    if (this.twitterFeedEl_) {
      this.noSocialLocales_ =
          this.twitterFeedEl_.dataset.noSocialLocales.split(',');
    }

    /** @private @const {?Element}*/
    this.blogEl_ = document.querySelector(Selectors_.BLOG);

    /** @private @const {!Element}*/
    this.ytChannelCarousel_ =
        document.querySelector(Selectors_.YT_CHANNEL_CAROUSEL);

    this.ytChannelSpotlights_ =
        [...document.querySelectorAll(Selectors_.YT_CHANNEL_SPOTLIGHT)];

    // Twitter and blog feeds.
    if (this.twitterFeedEl_ &&
        this.noSocialLocales_.indexOf(__WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].LANG) < 0) {
      new __WEBPACK_IMPORTED_MODULE_7__google_youtube_src_components_glue_carousel__["a" /* LBGlueCarousel */](this.twitterFeedEl_);
      new __WEBPACK_IMPORTED_MODULE_4__components_twitter_feed_twitter_feed__["default"](this.twitterFeedEl_);
      new __WEBPACK_IMPORTED_MODULE_1__components_blog_blog__["default"](this.blogEl_);
    }

    // YT Channel sportlight.
    this.ytChannelSpotlights_.forEach((spotlight) => {
      new __WEBPACK_IMPORTED_MODULE_5__components_yt_channel_spotlight_yt_channel_spotlight__["default"](spotlight);
    });

    if (this.ytChannelSpotlights_.length > 1) {
      new __WEBPACK_IMPORTED_MODULE_7__google_youtube_src_components_glue_carousel__["a" /* LBGlueCarousel */](this.ytChannelCarousel_);
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = IndexPage;



/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__globals_utils__ = __webpack_require__(4);



/** @private @enum {string} */
const Selectors_ = {
  COPY_EL: '.yt-js-blog-copy',
  CTA: '.yt-js-blog-cta',
  DATE_EL: '.yt-js-blog-date',
  LINK_EL: '.yt-js-blog-link',
  MODAL_COPY_EL: '.yt-js-blog-modal-copy',
  TITLE_EL: '.yt-js-blog-title',
};

/** @private @enum {string} */
const Classes_ = {
  HIDE: 'yt-hide',
};


/**
 * Gets a blog post via Blogger API and populates DOM with a post.
 * @param {!Element} root
 * @final
 */
class Blog {
  constructor(root) {
    /** @private @const {string} */
    this.id_ = root.dataset.blogId;

    /** @private @const {string} */
    this.endpoint_ =
        'https://www.googleapis.com/blogger/v3/blogs/' + this.id_ +
        '/posts?key=AIzaSyAllLmILW-i3sTeTeiM0He6HgwbKJ4TXbY&maxResults=1';

    /** @private @const {!Element} */
    this.linkEl_ = root.querySelector(Selectors_.LINK_EL);

    /** @private @const {!Array<!Element>} */
    this.titleEls_ = [...root.querySelectorAll(Selectors_.TITLE_EL)];

    /** @private @const {!Element} */
    this.dateEl_ = root.querySelector(Selectors_.DATE_EL);

    /** @private @const {!Element} */
    this.copyEl_ = root.querySelector(Selectors_.COPY_EL);

    /** @private @const {!Element} */
    this.modalCopyEl_ = root.querySelector(Selectors_.MODAL_COPY_EL);

    /** @private @const {!Element} */
    this.cta_ = root.querySelector(Selectors_.CTA);

    this.getPost_();
  }

  /**
   * Makes an HTTP request to get blog posts.
   * @private
   */
  getPost_() {
    const http = new XMLHttpRequest();

    http.onreadystatechange = () => {
      if (http.readyState == 4 && http.status == 200) {
        const response = JSON.parse(http.responseText);

        // Set link to blog post on handle.
        this.linkEl_.href = response.items[0].url;

        // Show CTA.
        this.cta_.classList.remove(Classes_.HIDE);

        // Fill in DOM elements.
        this.date_(response);
        this.title_(response);
        this.copy_(response);
      }
    };

    http.open('GET', this.endpoint_, true);
    http.send();
  }

  /**
  * Returns a substring of the given string with and ellipsis appended to it.
  * @param {string} str
  * @param {number} charCount
  * @return {string}
  * @private
  */
  getSubstring_(str, charCount) {
   const substring = str.substring(0, charCount);

   if (substring[substring.length - 1] == ' ') {
     charCount = charCount - 1;
   }

   return `${str.substring(0, charCount)}...`;
  }

  /**
   * Fills in date element with localized date.
   * @param {!Object} response
   * @private
   */
  date_(response) {
    const date = new Date(response.items[0].published);

    [...this.dateEl_.children].forEach((child) => child.remove());
    this.dateEl_.innerText = __WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].localizeDate(date, 'long');
  }

  /**
   * Fills in title elements with blog post title.
   * @param {!Object} response
   * @private
   */
  title_(response) {
    const title = response.items[0].title;

    this.titleEls_.forEach((el) => {
      [...el.children].forEach((child) => child.remove());
      el.innerText = title;
    });
  }

  /**
   * Fills in copy elements with blog content.
   * @param {!Object} response
   * @private
   */
  copy_(response) {
    const copy = response.items[0].content;
    const fullPost = document.createRange().createContextualFragment(copy);
    const shortPost = document.createRange().createContextualFragment(
        this.getSubstring_(copy, 900));

    [...this.copyEl_.children].forEach((child) => child.remove());

    this.copyEl_.appendChild(shortPost);
    this.modalCopyEl_.appendChild(fullPost);
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Blog;



/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__google_youtube_src_providers_utils_utils__ = __webpack_require__(2);



/** @private @const {number} */
const Selectors_ = {
  RADIO: '.yt-js-slideshow-radio',
  SLIDE: '.yt-js-slideshow-slide',
  SLIDESHOW: '.yt-js-slideshow',
};

/** @private @const {number} */
const Classes_ = {
  ACTIVE_RADIO: 'slideshow__radio--active',
  ACTIVE_SLIDE: 'slideshow__slide--active',
};

/** @private @const {number} */
const TIMING_ = 6000;


/**
 * Utilizes setInterval() to add an `active` class to one element in a list at a
 * time. This allows developers to style these elements in a manner that
 * visually resembles a slideshow. The user can stop the setInterval() by
 * clicking anywhere in the root element. It resumes once the mouse leaves the
 * root.
 * @final
 */
class Slideshow {
  constructor(root) {
    /** @private @const {!Element} */
    this.root_ = document.querySelector(Selectors_.SLIDESHOW);

    /**
     * setInterval.
     * @private {number}
     */
    this.animation_ = 0;

    /**
     * Each slide contains a hero component.
     * @private @const {!Array<!Element>}
     */
    this.slides_ = [...this.root_.querySelectorAll(Selectors_.SLIDE)];

    /**
     * Pagination radio buttons.
     * @private @const {!Array<!Element>}
     */
    this.radios_ = [...this.root_.querySelectorAll(Selectors_.RADIO)];

    /**
     * The visible slide's index.
     * @private {!Array<!Element>}
     */
    this.activeSlideIndex_ = 0;

    /** @private {boolean} */
    this.animationInProgress_ = false;

    this.initAnimation_();
    this.registerEvents_();
  }

  /** @private */
  registerEvents_() {
    // Pauses animation on click.
    this.root_.addEventListener('click', this.destroy_.bind(this));

    // Resumes animation on mouseleave.
    this.root_.addEventListener('mouseleave', this.initAnimation_.bind(this));

    // Handles pagination.
    Object(__WEBPACK_IMPORTED_MODULE_0__google_youtube_src_providers_utils_utils__["a" /* delegate */])(this.root_,
        Selectors_.RADIO, 'click', this.handlePagination_.bind(this));
  }

  /**
   * Initiates setInterval() animation.
   * @private {number}
   */
  initAnimation_() {
    if (this.animationInProgress_) return;

    this.animation_ = setInterval(() => {
      if (this.activeSlideIndex_ + 1 === this.slides_.length) {
        // Last slide is active, start slideshow from beginning.
        this.activeSlideIndex_ = 0;
      } else {
        // Have not yet reached last slide, so go to next one.
        this.activeSlideIndex_++;
      }

      this.setActiveSlide_(this.activeSlideIndex_);
    }, TIMING_);

    this.animationInProgress_ = true;
  }

  /**
   * Stops setInterval().
   * @private
   */
  destroy_() {
    if (!this.animationInProgress_) return;
    clearInterval(this.animation_);
    this.animationInProgress_ = false;
  }

  /**
   * Removes the `active` class from all slides and pagination radio buttons.
   * @private
   */
  resetAllSlides_() {
    this.slides_.forEach((slide, i) => {
      slide.classList.remove(Classes_.ACTIVE_SLIDE);
      this.radios_[i].classList.remove(Classes_.ACTIVE_RADIO);
    });
  }

  /**
   * Removes the `active` class from the previus slide and radio and adds it to
   * the next ones.
   * @private
   */
  setActiveSlide_() {
    this.resetAllSlides_();

    this.radios_[this.activeSlideIndex_].classList.add(Classes_.ACTIVE_RADIO);
    this.slides_[this.activeSlideIndex_].classList.add(Classes_.ACTIVE_SLIDE);
  }

  /**
   * switchets the active slide index to the target's `data-index` before
   * setting the active slide.
   * @return {!Element} target The clicked radio button.
   * @private
   */
  handlePagination_(target) {
    this.activeSlideIndex_ = parseInt(target.dataset.index, 10);
    this.setActiveSlide_();
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Slideshow;



/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__globals_utils__ = __webpack_require__(4);



/** @private @enum {string} */
const Selectors_ = {
  COPY_ELS: '.yt-js-twitter-feed-copy',
  DATE_ELS: '.yt-js-twitter-feed-post-date',
  IMG_ELS: '.yt-js-twitter-feed-img',
};

/** @private @const {string} */
const TEST_FEED_ = '/creators/static/json/tests/twitter-feed-test.json';

/** @private @const {string} */
const PATH_TO_FEEDS_ =
    'https://www.gstatic.com/google_social_feeds/yt_creators/';

/** @private @enum {string} */
const LocaleSpecificMap_ = {
  'ar': 'ar_all.json',
  'de': 'de_all.json',
  'en': 'en_us.json',
  'es': 'es_all.json',
  'es-419': 'es_all.json',
  'fr': 'fr_all.json',
  'it': 'it_all.json',
  'ja': 'ja_all.json',
  'pt-BR': 'pt_all.json',
  'pt-PT': 'pt_all.json',
};

/**
 * Regexes used to parse the feed results.
 * @private @enum {RegExp}
 */
const Regex_ = {
  // HASHTAG regex has a match for '&' as a surrogate for negative lookbehind.
  // Fixes an issue where encoded characters got matched as hashtags eg. &#123;
  HASHTAG: /(&)?#(\w+)/g,
  LINK: /https:\/\/t.co\/?(\w+)/g,
  USER: /@(\w+)/g,
};

/** @private @enum {string} */
const Links_ = {
  HASHTAG: '<a href="https://twitter.com/hashtag/$2" target="_blank" ' +
           'rel="noreferrer noopener nofollow">#$2</a>',
  LINK: '<a href="https://t.co/$1" target="_blank" ' +
        'rel="noreferrer noopener nofollow">https://t.co/$1</a><br>',
  USER: '<a href="https://twitter.com/$1" target="_blank" ' +
        'rel="rel="noreferrer noopener nofollow">@$1</a>',
};


/**
 * Pulls YouTube Creators Twitter feeds from Brand Studio's social aggregator
 * and populates the DOM with the response.
 * @param {!Element} root
 * @final
 */
class TwitterFeed {
  constructor(root) {
    /** @private @const */
    this.carousel_ = root;

    /** @private @const {!IArrayLike<!Element>} */
    this.dateEls_ = [...this.carousel_.querySelectorAll(Selectors_.DATE_ELS)];

    /** @private @const {!IArrayLike<!Element>} */
    this.imgEls_ = [...this.carousel_.querySelectorAll(Selectors_.IMG_ELS)];

    /** @private @const {!IArrayLike<!Element>} */
    this.copyEls_ = [...this.carousel_.querySelectorAll(Selectors_.COPY_ELS)];

    this.getPosts_();
  }

  /**
   * Makes an HTTP request to the social-feed-aggregator-generated Twitter JSON
   * file hosted on gstatic.
   * @private
   */
  getPosts_() {
    const http = new XMLHttpRequest();
    let jsonText;
    let endpoint;

    http.onreadystatechange = () => {
      if (http.readyState == 4 && http.status == 200) {
        // Excludes JSONP callback charactes at beginning of responseText.
        jsonText = http.responseText.substring(6, http.responseText.length);

        JSON.parse(jsonText).feeds[0].posts.forEach((post, i) => {
          this.date_(post, i);
          this.copy_(post, i);
          this.img_(post, i);
        });
      }
    };

    endpoint = TEST_FEED_;

    if (!__WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].IS_DEV) {
      // Is production, so use real endpoint.
      endpoint = `${PATH_TO_FEEDS_}${LocaleSpecificMap_[__WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].LANG]}`;

      if (!LocaleSpecificMap_[__WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].LANG]) {
        endpoint = `${PATH_TO_FEEDS_}${LocaleSpecificMap_.en}`;
      }
    }

    http.open('GET', endpoint, true);
    http.send();
  }

  /**
   * Fills in date elements with localized date.
   * @param {!Object} post
   * @param {number} i
   * @private
   */
  date_(post, i) {
    const date = new Date(parseInt(post.created_at, 10)).toString();

    [...this.dateEls_[i].children].forEach((child) => child.remove());
    this.dateEls_[i].innerText = __WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].localizeDate(date, 'long');
  }

  /**
   * Fills in copy elements with parsed content.
   * @param {!Object} post
   * @param {number} i
   * @private
   */
  copy_(post, i) {
    const parsedCopy = this.parseCopy_(post.content);
    const textEl = document.createElement('p');
    const text = document.createRange().createContextualFragment(parsedCopy);

    textEl.appendChild(text);

    [...this.copyEls_[i].children].forEach((child) => child.remove());
    this.copyEls_[i].appendChild(textEl);
  }

  /**
   * Replaces characters in the given string with the appropriate anchor tag
   * based on the given regex before returning the new string.
   * @param {string} content Post copy.
   * @return {string}
   * @private
   */
  parseCopy_(copy) {
    const withUserLinks = copy.replace(Regex_.USER, Links_.USER);
    const withLinks = withUserLinks.replace(Regex_.LINK, Links_.LINK);
    const withHashtagsLinks = withLinks.replace(Regex_.HASHTAG, Links_.HASHTAG);
    return withHashtagsLinks;
  }

  /**
   * Sets background image of image elements with the posts' images.
   * @param {!Object} post
   * @param {number} i
   * @private
   */
  img_(post, i) {
    this.imgEls_[i].href = post.url;

    if (post.media && post.media.images) {
      const imagUrl = post.media.images[0].url;
      this.imgEls_[i].style.backgroundImage = 'url(' + imagUrl + ')';
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = TwitterFeed;



/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__globals_utils__ = __webpack_require__(4);



/** @private @enum {string} */
const Selectors_ = {
  CHANNEL_TITLE_EL: '.yt-js-channel-title',
  COPY_EL: '.yt-js-channel-copy',
  DATE_EL: '.yt-js-channel-date',
  VIDEO_IFRAME: '.yt-js-channel-video',
  VIDEO_TITLE_EL: '.yt-js-channel-headline',
};

/** @private @const {string} */
const YT_DATA_ENDPOINT_ =
    'https://www.googleapis.com/youtube/v3/activities' +
    '?key=AIzaSyAllLmILW-i3sTeTeiM0He6HgwbKJ4TXbY' +
    '&part=snippet,contentDetails' +
    '&maxResults=1' +
    '&channelId=';


/**
 * Gets the most recent YouTube video from a channel and displays it on the DOM.
 * @param {!Element} root
 * @final
 */
class YTChannelSpotlight {
  constructor(root) {
    /** @private @const {string} */
    this.channelID_ = root.dataset.channelId;

    /** @private @const {!Element} */
    this.channelTitleEl_ = root.querySelector(Selectors_.CHANNEL_TITLE_EL);

    /** @private @const {!Element} */
    this.copyEl_ = root.querySelector(Selectors_.COPY_EL);

    /** @private @const {!Element} */
    this.dateEl_ = root.querySelector(Selectors_.DATE_EL);

    /** @private @const {!Element} */
    this.videoIframe_ = root.querySelector(Selectors_.VIDEO_IFRAME);

    /** @private @const {!Element} */
    this.videoTitleEl_ = root.querySelector(Selectors_.VIDEO_TITLE_EL);

    this.getChannelData_();
  }

  /**
   * Gets channel data via YT Data API.
   * @private
   */
  getChannelData_() {
    const http = new XMLHttpRequest();
    http.onreadystatechange = () => {
      if (http.readyState == 4 && http.status == 200) {
        const response = JSON.parse(http.responseText);
        const snippet = response.items[0].snippet;
        const details = response.items[0].contentDetails;

        if (response.items.length) {
          const videoID = details.upload ? details.upload.videoId :
              details.playlistItem.resourceId.videoId;

          this.video_(videoID);
          this.channelTitle_(snippet.channelTitle);
          this.date_(snippet.publishedAt);
          this.videoTitle_(snippet.title);
          this.copy_(snippet.description);
        }
      }
    };
    http.open('GET', YT_DATA_ENDPOINT_ + this.channelID_, true);
    http.send();
  }

  /**
  * Returns a substring of the given string with and ellipsis appended to it.
  * @param {string} str
  * @param {number} charCount
  * @return {string}
  * @private
  */
  getSubstring_(str, charCount) {
   const substring = str.substring(0, charCount);

   if (substring[substring.length - 1] == ' ') {
     charCount = charCount - 1;
   }

   return `${str.substring(0, charCount)}...`;
  }

  /**
   * Creates an YouTube video iframe with the given ID and appends it to the
   * video element.
   * @param {string} videoID
   * @private
   */
  video_(videoID) {
    const iframe = document.createElement('iframe');

    iframe.classList.add('lb-player__video');
    iframe.setAttribute('frameborder', '0');
    iframe.setAttribute('allowfullscreen', true);
    iframe.setAttribute('title', 'YT Player Iframe');
    iframe.setAttribute('aria-hidden', 'true');
    iframe.src = `https://www.youtube.com/embed/${videoID}/`;

    this.videoIframe_.querySelector('iframe').remove();
    this.videoIframe_.appendChild(iframe);
  }

  /**
   * Fills in the channel title element with the given string.
   * @param {string} channelTitle
   * @private
   */
  channelTitle_(channelTitle) {
    [...this.channelTitleEl_.children].forEach((child) => child.remove());
    this.channelTitleEl_.innerText = channelTitle;
    this.channelTitleEl_.href =
        `https://www.youtube.com/channel/${this.channelID_}/`;
  }

  /**
   * Fills in date element with localized date.
   * @param {!Object} response
   * @private
   */
  date_(pubDate) {
    const date = new Date(pubDate);

    [...this.dateEl_.children].forEach((child) => child.remove());
    this.dateEl_.innerText = __WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].localizeDate(date, 'long');
  }

  /**
   * Fills in the video title element with the given string.
   * @param {string} videoTitle
   * @private
   */
  videoTitle_(videoTitle) {
    [...this.videoTitleEl_.children].forEach((child) => child.remove());
    this.videoTitleEl_.innerText = videoTitle;
  }

  /**
   * Fills in the copy element with a substring of the given string.
   * @param {string} copy
   * @private
   */
  copy_(copy) {
    [...this.copyEl_.children].forEach((child) => child.remove());
    this.copyEl_.innerText = this.getSubstring_(copy, 150);
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = YTChannelSpotlight;



/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(80);


/**
 * A function that accepts a superclass and creates a new subclass from it.
 * @param {!Object} superClass
 * @return {!Object}
 */
const lbClassMixin = (superClass) => {
  return class extends superClass {
    /**
     * Checks if the style value matches one of the transform style values.
     * @param {!Object<string, *>} style
     * @return {boolean}
     */
    cssStylesContainTransform_(style) {
      return (__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* lists */].TRANSFORMS.indexOf(style) !== -1);
    }

    /**
     * Combines transform value chunks into a valid CSS transform value
     * and appends them into an array.
     * @param {!Object<string, *>} styles
     * @param {!Array<string>} transforms
     * @param {string} style
     * @return {boolean}
     */
    combineTransformValues_(styles, transforms, style) {
      const transformString = `${style}(${styles[style]})`;
      transforms.push(transformString);
      return transforms;
    }

    /**
     * Collapses any transform values into a valid transform string.
     * e.g `scaleY: .5`, `translateX: 50px` into
     * `transform: scaleY(.5) translateX(50px)`
     * and appends them into an array.
     * @param {!Object<string, *>} styles
     * @return {!Object<string, *>}
     */
    flattenTransformStyles_(styles) {
      // Find all the transform values in our styles object.
      const transformStyles = Object.keys(styles)
          .filter(this.cssStylesContainTransform_.bind(this));

      const transformStyleString = transformStyles
          .reduce(this.combineTransformValues_.bind(this, styles), [])
          .join(' ');

      // Remove any transform values so they don't get written
      // to the DOM twice.
      Object.keys(styles).forEach((style) => {
        this.cssStylesContainTransform_(style) && (delete styles[style]);
      });

      const transform = transformStyleString;

      if (transform) {
        Object.assign(styles, {transform});
      }

      return styles;
    }

   /**
     * Parse root element's `data-lb-<component>-options` or
     *   `lb-<component>-options` attribute value.
     * @param {string} componentName
     * @param {Object=} defaultOptions
     * @return {!Object<string, *>}
     */
    parseOptionsString(componentName, defaultOptions = {}) {
      const namedOptionsKey = `data-lb-${componentName}-options`;
      const namedOptionsKeyLb = `lb-${componentName}-options`;
      let options = this.root_.getAttribute(namedOptionsKey) ||
          this.root_.getAttribute(namedOptionsKeyLb) ||
          this.root_.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["c" /* strings */].DEFAULT_OPTIONS_KEY) ||
          this.root_.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["c" /* strings */].DEFAULT_OPTIONS_KEY_LB);

      // To ensure we always return a valid options object, assign defaults
      // to `this.options_`.
      this.options_ = defaultOptions;

      if (!options) {
        return this.options_;
      }

      // Wrapping an HTML attribute value in double quotes is a more
      // common pattern. To avoid choking the JSON parser, we need to
      // swap single for double quotes.
      try {
        // Check for special characters, including HTML entities and
        // escaped characters.
        const handleReplace = (char) => {
          // When there's an escaped single quote.
          // e.g. 'Let\'s make it ourselves.'
          if (char.match(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* re */].SINGLE_QUOTE_SLASH)) {
            return __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* re */].SINGLE_QUOTE;
          }
          // When there's single quote surrounded by letters or numbers
          // e.g. "Let's make it ourselves."
          if (char.match(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* re */].SINGLE_QUOTE_WITH_ALPHA_NUM)) {
            return char.replace(
                new RegExp(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* re */].SINGLE_QUOTE, 'g'), __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* re */].SINGLE_QUOTE);
          }
          return '"';
        };

        const quoteRe = new RegExp(Object.values(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* re */]).join('|'), 'gi');
        options = options.replace(quoteRe, handleReplace);
        this.options_ = Object.assign({}, defaultOptions, JSON.parse(options));
      } catch (error) {
        if (error instanceof SyntaxError) {
          throw new Error(
            `(Lazy Bones Error) There's a problem parsing the options ` +
            `string: ${error}. \n` +
            `(Component Name) ${componentName}`);
        }
      }
      return this.options_;
    }


    /**
     * Updates or creates element styles.
     * E.g this.setStyle({translateX: 100});
     * @param {!Object<string, *>} style
     * @param {Element=} element
     */
    setStyle(style, element = this.root_) {
      if (!(element instanceof Element)) {
        return console.error('Ensure that `element` is a DOM Element');
      }

      this.flattenTransformStyles_(style);
      Object.assign(element.style, style);
    }

    /**
     * Gets a value of an element's attribute.
     * @param {string} attrKey
     * @param {Element=} element
     * @return {string}
     */
    getAttr(attrKey, element = this.root_) {
      return element.getAttribute(attrKey);
    }

    /**
     * Removes the given attribute from the given element.
     * @param {string} attrKey
     * @param {Element=} element
     * @return {string}
     */
    removeAttr(attrKey, element = this.root_) {
      return element.removeAttribute(attrKey);
    }

    /**
     * Sets or updates an element's attribute.
     * @param {string} attrKey
     * @param {*} attrVal
     * @param {Element=} element
     */
    setAttr(attrKey, attrVal, element = this.root_) {
      /** @type {string} Get the previous value. */
      const lastVal = this.getAttr(attrKey);

      // Set the key and value on the element.
      element.setAttribute(attrKey, attrVal);

      if (lastVal !== attrVal) {
        // Then run change callback.
        this.attrChangeCallback_(lastVal, attrVal, element);
      }
    }

    /**
     * Removes all children of component root or root child element.
     * @param {!Element=} element
     */
    emptyComponentElements(element = this.root_) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }

    /**
     * Queries component child selector
     * @param {string} selector
     * @return {?Element}
     */
    queryComponentSelector(selector) {
      return this.root_.querySelector(selector);
    }

    /**
     * Queries component child selector
     * and converts to native `Array`
     * @param {string} selector
     * @return {!Array<?Element>}
     */
    queryComponentSelectorAll(selector) {
      return [...this.root_.querySelectorAll(selector)];
    }

    /**
     * A method that gets overwritten in a component that extends `LBComponent`.
     * Runs after attribute values have been updated.
     * @param {string} lastVal
     * @param {string} currentVal
     * @param {!Element} element
     * @private
     */
    attrChangeCallback_(lastVal, currentVal, element) {}

    /**
     * Toggles the given class name on the given element.
     * @param {string} className
     * @param {bool} addClass
     * @param {!Element=} element
     */
    toggleClass(className, addClass, element = this.root_) {
      element.classList.toggle(className, addClass);
    }
  };
};
/* harmony export (immutable) */ __webpack_exports__["a"] = lbClassMixin;



/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ModelEventAdapter */



/** @record */
class ModelEventAdapter {

  /**
   * Emits an event.
   * @param {string} evtType
   */
  emit(evtType) {}

  /**
   * Listens to an event, and executes a handler function when it fires.
   * @param {string} evtType
   * @param {!Function} handler
   */
  listen(evtType, handler) {}

  /**
   * Stops listening to an event.
   * @param {string} evtType
   * @param {!Function} handler
   */
  unlisten(evtType, handler) {}

}




/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Navigator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__options__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__renderer__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tilemap_tilemap__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__fx_tween__ = __webpack_require__(91);








/**
 * Provides all possible ways to move the carousel to a tile, a group of
 * tiles, or a specific position, with or without animation.
 */
class Navigator {

  /**
   * @param {!TileMap} tileMap The tile map definition.
   * @param {!Renderer} renderer The renderer.
   * @param {!Options} options The carousel options.
   */
  constructor(tileMap, renderer, options) {
    /** @private {!TileMap} */
    this.tileMap_ = tileMap;

    /** @private {!Renderer} */
    this.renderer_ = renderer;

    /** @private {!Object} */
    this.options_ = options;

    /** @private {number?} The index of the currently snapped tile. */
    this.snappedTileIndex_ = null;

    /**
     * The target frame position. During previous/next paginations, used to
     * start the transition from the target position of any ongoing animation,
     * instead of the current position.
     * @private {number}
     */
    this.targetFrameX_ = 0;

    /**
     * A reference to a tween animation.
     * @private {Tween}
     */
    this.tween_ = null;
  }

  /**
   * @see targetFrameX_
   * @return {number}
   */
  get currentFrame() {
    return this.targetFrameX_;
  }

  /**
   * Moves the carousel to the specified tile index.
   * @param {number} index The tile index to move to.
   * @param {boolean=} opt_animate Whether to animate the transition.
   */
  selectTile(index, opt_animate) {
    this.tileMap_.enableHiddenTiles();

    var snappedTile = this.tileMap_.getSnappedTile();
    if (!snappedTile) {
      return;
    }

    // Don't cycle to the next set of tiles, stay within the current one.
    var moveForward = index > snappedTile.index;
    var frameX = this.tileMap_.getFrameXSnappedOnTile(index, moveForward);

    if (!isFinite(frameX) || frameX == null) {
      // Cannot move to that position.
      return;
    }

    if (!opt_animate) {
      this.setFramePosition(frameX);
      this.tileMap_.adjustFrameX();
      this.targetFrameX_ = this.tileMap_.getFrameX();

    } else if (this.options_.jump) {
      // Recalculate the target frame position after temporarily disabling
      // hidden tiles.
      this.tileMap_.disableHiddenTiles(frameX);

      var tempFrameX = this.tileMap_.getFrameXSnappedOnTile(index, moveForward);
      if (tempFrameX == null) {
        return;
      }

      /** @this {Navigator} */
      var animCompleteHandler = function() {
        // Re-enable hidden tiles and move to actual target frame position.
        this.tileMap_.enableHiddenTiles();
        this.setFramePosition(/** @type {!number} */ (frameX));
      };

      this.animateFramePosition(tempFrameX, null,
          animCompleteHandler.bind(this));

    } else {
      this.animateFramePosition(frameX);
    }
  }


  /**
   * Moves the carousel to the previous tile or group of tiles.
   * @param {Function=} opt_updateHandler A callback executed after each
   *     animation update.
   * @param {?number=} opt_frameX The frame position to start the transition
   *     from.
   */
  selectPrevious(opt_updateHandler, opt_frameX) {
    this.paginate_(false, opt_updateHandler, opt_frameX);
  }


  /**
   * Moves the carousel to the next tile or group of tiles.
   * @param {Function=} opt_updateHandler [description]
   * @param {?number=} opt_frameX The frame position to start the transition
   *     from.
   */
  selectNext(opt_updateHandler, opt_frameX) {
    this.paginate_(true, opt_updateHandler, opt_frameX);
  }


  /**
   * Moves the carousel frame to the specified position.
   * @param {number} x The target frame position.
   * @param {boolean=} opt_updateTarget Whether to register the specified frame
   *     position to be the start position of any next transition.
   */
  setFramePosition(x, opt_updateTarget) {
    this.tileMap_.setFrameX(x);
    this.renderer_.draw();

    var snappedTile = this.tileMap_.getCurrentSnappedTile();
    if (snappedTile) {
      this.snappedTileIndex_ = snappedTile.index;
    }

    if (opt_updateTarget) {
      this.targetFrameX_ = x;
    }
  }


  /**
   * Animates the carousel frame to the specified position.
   * @param {number} x The frame position.
   * @param {Function=} opt_updateHandler A callback executed after each
   *     animation update.
   * @param {Function=} opt_completeHandler A callback executed once the
   *     animation is completed.
   */
  animateFramePosition(x, opt_updateHandler, opt_completeHandler) {
    this.stopAnimation();

    if (x == this.tileMap_.getFrameX()) {
      return;
    }

    this.targetFrameX_ = x;

    var positionTween = {x: this.tileMap_.getFrameX()};
    /** @this {Navigator} */
    var updateHandler = function(params) {
      this.setFramePosition(params.x);
      opt_updateHandler && opt_updateHandler();
    };
    /** @this {Navigator} */
    var completeHandler = function() {
      opt_completeHandler && opt_completeHandler();
      this.tileMap_.adjustFrameX();
      this.targetFrameX_ = this.tileMap_.getFrameX();
    };

    var animOptions = {
      'x': x,
      'ease': this.options_.easing,
      'onUpdateParams': [positionTween],
      'onUpdate': updateHandler.bind(this),
      'onComplete': completeHandler.bind(this),
    };

    this.tween_ = __WEBPACK_IMPORTED_MODULE_3__fx_tween__["a" /* Tween */].to(
        positionTween, this.options_.transitionDuration, animOptions);
  }


  /**
   * Stops any ongoing animation.
   */
  stopAnimation() {
    this.tween_ && this.tween_.kill();
  }


  /**
   * Whether to paginate tiles by group instead of one by one.
   * @return {boolean}
   */
  isPaginatingGroups() {
    return !!this.options_.group;
  }


  /**
   * Animates the carousel to a tile or a group of tiles in the specified
   * direction.
   * @param {boolean} moveForward Whether to move the carousel forward.
   * @param {?Function=} opt_updateHandler A callback executed after each
   *     animation update.
   * @param {?number=} opt_frameX The frame position to start the transition
   *     from.
   * @private
   */
  paginate_(moveForward, opt_updateHandler, opt_frameX) {
    // Paginate from the current animation destination by default.
    var fromFrameX =
        (opt_frameX != undefined) ? opt_frameX : this.targetFrameX_;

    var toFrameX = 0;
    if (moveForward && this.options_.group) {
      toFrameX = this.tileMap_.getNextGroupFrameX(fromFrameX);

    } else if (moveForward) {
      toFrameX = this.tileMap_.getNextFrameX(fromFrameX);

    } else if (!moveForward && this.options_.group) {
      toFrameX = this.tileMap_.getPreviousGroupFrameX(fromFrameX);

    } else if (!moveForward) {
      toFrameX = this.tileMap_.getPreviousFrameX(fromFrameX);
    }

    if (toFrameX != null) {
      this.animateFramePosition(toFrameX, opt_updateHandler);
    }
  }

}




/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Renderer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dom_focus_util_focus_util__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tilemap_tilemap__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tilemap_visibility__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants__ = __webpack_require__(27);









/**
 * Renders a tile map on the DOM, where each child of a container element is
 * a tile item. Positions the container element, measures and updates element
 * sizes.
 */
class Renderer {

  /**
   * @param {!TileMap} tileMap The tile map definition.
   * @param {!CarouselAdapter} adapter The adapter interface.
   * @param {boolean=} multipleVisibleTiles Whether all tiles fully displayed
   *     within the frame should be visible to screen readers. By default, only
   *     the currently snapped tile is marked as visible.
   */
  constructor(tileMap, adapter, multipleVisibleTiles = false) {
    /** @private */
    this.tileMap_ = tileMap;

    /** @private */
    this.adapter_ = adapter;

    /** @private {boolean} */
    this.isRtl_ = this.adapter_.isRtl();

    /** @private */
    this.multipleVisibleTiles_ = multipleVisibleTiles;

    /** @private {number} The tallest element height. */
    this.maxHeight_ = 0;

    /** @private {!Array<Element>} The list of currently displayed elements. */
    this.elements_ = [];

    /**
     * The list of elements that were injected in the DOM during the last draw
     * cycle.
     * @private {!Array<Element>}
     */
    this.addedElements_ = [];

    /**
     * @private {Element}
     */
    this.snappedTileElement_ = null;
  }


  /**
   * Counts number of children elements, measures their width and their
   * container width and updates the tile map accordingly.
   * @param {!Function=} callback A function to call once the markup has been
   *     rendered.
   */
  init(callback = () => {}) {
    this.resetElements(() => {
      this.measureElements_();
      callback();
    });
  }


  /**
   * Updates the carousel view.
   */
  draw() {
    // Add/remove items to DOM
    const newMap = Array.prototype.slice.apply(this.tileMap_.getDisplayMap());
    this.adapter_.toggleElements(newMap, () => {
      this.updateAttributes_();
      this.setContainerTranslation_();
      this.indexVisibleElements_();
    });
  }


  /**
   * Restores the container and its children to their initial state.
   * @param {!Function=} callback A function to call once the markup has been
   *     rendered.
   */
  resetElements(callback = () => {}) {
    this.adapter_.setStyle('width', 'auto');
    this.adapter_.setStyle('transform', 'none');
    this.adapter_.resetElements(() => {
      this.resetAttributes_();
      callback();
    });
  }


  /**
   * The list of elements that were injected in the DOM during the last draw
   * cycle.
   * @return {!Array<Element>}
   */
  getAddedElements() {
    return this.addedElements_;
  }


  /**
   * @return {Element}
   */
  getSnappedTileElement() {
    return this.snappedTileElement_;
  }


  /**
   * Measures the container and the tile elements, update the tile map
   * properties accordingly and locks their size.
   * @private
   */
  measureElements_() {
    const {MEASURING} = __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */];
    this.adapter_.addClass(MEASURING);
    this.tileMap_.frameWidth = this.adapter_.getParentElementWidth();

    const widths = [];
    const els = this.adapter_.getChildElements();
    this.maxHeight_ = 0;

    for (let i = 0, el; el = els[i]; i++) {
      const {width, height} = this.adapter_.getTileDimensions(el);
      // Lock element's width
      // Needed when the width is a percentage of the viewport (fluid mode)
      this.adapter_.setTileStyle(el, 'width', `${width}px`);

      // Update cached page widths
      widths.push(width);

      this.maxHeight_ = Math.max(this.maxHeight_, height);
    }

    this.adapter_.removeClass(MEASURING);

    // Apply max height to all elements
    this.maxHeight_ = Math.round(this.maxHeight_);
    for (let i = 0, el; el = els[i]; i++) {
      this.adapter_.setTileStyle(el, 'minHeight', `${this.maxHeight_}px`);
    }

    this.tileMap_.setTiles(widths);
    this.adapter_.setStyle('width', `${this.tileMap_.getMaxWidth()}px`);
  }


  /**
   * Updates the elements' sizes and accessibility attributes.
   * @private
   */
  updateAttributes_() {
    const els = this.adapter_.getChildElements();
    const displayMap = this.tileMap_.getDisplayMap();
    const snappedTile = this.tileMap_.getCurrentSnappedTile();
    if (!snappedTile) {
      return;
    }

    const visibleIndex = this.tileMap_.getVisibleIndex(snappedTile.index);
    this.snappedTileElement_ =
        (visibleIndex != null) ? els[visibleIndex] : null;

    for (let i = 0, j = 0, len = displayMap.length; i < len; i++) {
      const visible = displayMap[i];
      if (visible) {
        const el = els[j++];
        if (!el) return;

        // Set tile element's width and height
        const width = this.tileMap_.getTileWidth(i);
        this.adapter_.setTileStyle(el, 'width', `${width}px`);
        this.adapter_.setTileStyle(el, 'minHeight', `${this.maxHeight_}px`);

        const markAsVisible =
            (this.multipleVisibleTiles_ && visible == __WEBPACK_IMPORTED_MODULE_3__tilemap_visibility__["a" /* Visibility */].VISIBLE) ||
            (!this.multipleVisibleTiles_ && el == this.snappedTileElement_);

        // Apply accessibility attributes on tile elements
        if (markAsVisible) {
          this.adapter_.rmTileAttr(el, 'aria-hidden');
          this.adapter_.setTileAttr(el, 'tabindex', -1);
        } else {
          this.adapter_.setTileAttr(el, 'aria-hidden', true);
          this.adapter_.rmTileAttr(el, 'tabindex');
        }

        // Apply accessibility attributes on tiles' child elements
        const selector = __WEBPACK_IMPORTED_MODULE_0__dom_focus_util_focus_util__["a" /* FOCUSABLE_ELEMENT_SELECTORS */].join(',');
        const focusables = el.querySelectorAll(selector);
        for (let i = 0, focusableEl; focusableEl = focusables[i]; i++) {
          if (markAsVisible) {
            this.adapter_.rmTileAttr(focusableEl, 'tabindex');
          } else {
            this.adapter_.setTileAttr(focusableEl, 'tabindex', -1);
          }
        }
      }
    }
  }


  /**
   * Updates the translate3d property of the carousel container element.
   * @private
   */
  setContainerTranslation_() {
    let translateX = Math.round(this.tileMap_.getContainerX());
    translateX *= this.isRtl_ ? -1 : 1;
    const translation = `translate3d(${translateX}px, 0, 0)`;
    this.adapter_.setStyle('transform', translation);
  }


  /**
   * Makes a diff of elements that were just added to the DOM.
   * @private
   */
  indexVisibleElements_() {
    this.addedElements_ = [];
    const els = this.adapter_.getChildElements();

    for (let i = 0, el; el = els[i]; i++) {
      if (this.elements_.indexOf(el) == -1) {
        this.addedElements_.push(el);
      }
    }

    this.elements_ = Array.prototype.slice.apply(els);
  }


  /**
   * Removes size attributes from tile elements.
   * @private
   */
  resetAttributes_() {
    const els = this.adapter_.getChildElements();
    for (let i = 0, len = els.length; i < len; i++) {
      const el = els[i];
      if (el) {
        this.adapter_.setTileStyle(el, 'width', '');
        this.adapter_.setTileStyle(el, 'minHeight', '');
      }
    }
  }

}





/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export easingFuncMap */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ease; });
/* unused harmony export easeInSine */
/* unused harmony export easeOutSine */
/* unused harmony export easeInOutSine */
/* unused harmony export easeInQuad */
/* unused harmony export easeOutQuad */
/* unused harmony export easeInOutQuad */
/* unused harmony export easeInCubic */
/* unused harmony export easeOutCubic */
/* unused harmony export easeInOutCubic */
/* unused harmony export easeInQuart */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return easeOutQuart; });
/* unused harmony export easeInOutQuart */
/* unused harmony export easeInQuint */
/* unused harmony export easeOutQuint */
/* unused harmony export easeInOutQuint */
/* unused harmony export easeInExpo */
/* unused harmony export easeOutExpo */
/* unused harmony export easeInOutExpo */
/* unused harmony export easeInCirc */
/* unused harmony export easeOutCirc */
/* unused harmony export easeInOutCirc */
/* unused harmony export easeInBack */
/* unused harmony export easeOutBack */
/* unused harmony export easeInOutBack */
/* unused harmony export easeInElastic */
/* unused harmony export easeOutElastic */
/* unused harmony export easeInOutElastic */
/* unused harmony export easeInBounce */
/* unused harmony export easeOutBounce */
/* unused harmony export easeInOutBounce */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return linear; });
/**
 * @fileoverview A series of utility functions for use in implementing easing in
 * javascript animations.
 *
 * Closure provides three easing functions (goog.fx.easing.easeIn,
 * goog.fx.easing.easeOut, goog.fx.easing.inAndOut), but as that is a woefully
 * inadequate library for broad animation use, this series of functions adds
 * many more options to be used in a similar way. Easing functions are useful
 * for adding a natural feel to what would otherwise be unrealistic, linear
 * animations.
 *
 * Example usage: Say you have a DOM element that you want to animate by moving
 * it between two arbitrary locations in a page, over 2 seconds. Normally you'd
 * determine its starting position, its ending position, set up an interval,
 * then with each iteration, determine the position you should move it to based
 * on its initial and ending position values and a percentage that represents
 * its progress from start to finish, based on the 2 second duration. Call that
 * percentage T. In order to implement an easing method using glue.fx.easing,
 * simply pass T through your desired easing method, and the returned value is
 * an "eased" value of T. Using that new T, you set the element's position,
 * and the resulting animation will have a smooth ease to it, instead of its
 * original, jarring linear movement. It's hard to understand this without
 * seeing it in action, so visit the example link below for some live animation
 * utilizing all of the easing functions provided in this library.
 *
 * If you are more familiar with jQuery's style of easing methods which expect
 * four arguments (t, b, c, d), you can use glue.fx.easing.ease(), passing in
 * those four arguments and a reference to the easing method you'd like to use.
 * Whether you should use this, or directly call one of the single-argument
 * methods, is up to the developer, and largely depends on circumstance.
 *
 * Note: Frequently, you will have the easing method by name in string form (as
 * when contained in some JSON configuration data), so you can also call it
 * like: glue.fx.easing[methodName](percentage);
 *
 * For examples, see:
 * https://glue-docs.appspot.com/docs/components/raw/fx-easing
 */



/**
 * A namespace for the easing functions. This is being created and exported
 * because we will often have the name of our desired easing method by string
 * only, so we'll need to test to see if glue.fx.easing contains a property
 * (function) with that name, and then call it like so:
 * glue.fx.easing[methodName](percentage);
 */


/**
 * Eases values based on the typical four-argument easing method structure used
 * by popular libraries like jQuery. This is an adapter to interface with the
 * single-argument easing methods in this class.
 * @param {number} t Current time of the animation.
 * @param {number} b Beginning value of the property to be eased.
 * @param {number} c Total change in the property value across this animation.
 * @param {number} d Total duration of the animation.
 * @param {!function(number): number} func The easing method to call.
 * @return {number} The final eased value.
 * @export
 */
function ease(t, b, c, d, func) {
  return b + c * func(t / d);
}

/**
 * Eases the value in with a Sine curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInSine(t) {
  return (t == 0 || t == 1) ? t : 1 - Math.cos(t * (Math.PI / 2));
}

/**
 * Eases the value out with a Sine curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutSine(t) {
  return (t == 0 || t == 1) ? t : Math.sin(t * (Math.PI / 2));
}

/**
 * Eases the value in and out with a Sine curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutSine(t) {
  return (t == 0 || t == 1) ? t : -0.5 * (Math.cos(Math.PI * t) - 1);
}

/**
 * Eases the value in with a quadratic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInQuad(t) {
  return (t == 0 || t == 1) ? t : t * t;
}

/**
 * Eases the value out with a quadratic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutQuad(t) {
  return (t == 0 || t == 1) ? t : t * (2 - t);
}

/**
 * Eases the value in and out with a quadratic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutQuad(t) {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return 2 * t * t;
  } else {
    return -1 + (4 - 2 * t) * t;
  }
}

/**
 * Eases the value in with a cubic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInCubic(t) {
  return (t == 0 || t == 1) ? t : t * t * t;
}

/**
 * Eases the value out with a cubic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutCubic(t) {
  return (t == 0 || t == 1) ? t : (--t) * t * t + 1;
}

/**
 * Eases the value in and out with a cubic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutCubic(t) {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return 4 * t * t * t;
  } else {
    return (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }
}

/**
 * Eases the value in with a quartic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInQuart(t) {
  return (t == 0 || t == 1) ? t : t * t * t * t;
}

/**
 * Eases the value out with a quartic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutQuart(t) {
  return (t == 0 || t == 1) ? t : 1 - (--t) * t * t * t;
}

/**
 * Eases the value in and out with a quartic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutQuart(t) {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return 8 * t * t * t * t;
  } else {
    return 1 - 8 * (--t) * t * t * t;
  }
}

/**
 * Eases the value in with a quintic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInQuint(t) {
  return (t == 0 || t == 1) ? t : t * t * t * t * t;
}

/**
 * Eases the value out with a quintic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutQuint(t) {
  return (t == 0 || t == 1) ? t : 1 + (--t) * t * t * t * t;
}

/**
 * Eases the value in and out with a quintic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutQuint(t) {
  return (t == 0 || t == 1) ? t : t < .5 ? 16 * t * t * t * t * t : 1 + 16 *
      (--t) * t * t * t * t;
}

/**
 * Eases the value in with an exponential curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInExpo(t) {
  return (t == 0 || t == 1) ? t : Math.pow(2, 10 * (t - 1));
}

/**
 * Eases the value out with an exponential curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutExpo(t) {
  return (t == 0 || t == 1) ? t : (1 - Math.pow(2, -10 * t));
}

/**
 * Eases the value in and out with an exponential curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutExpo(t) {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return .5 * Math.pow(2, 10 * (t * 2 - 1));
  } else {
    return .5 * (2 - Math.pow(2, -10 * (t * 2 - 1)));
  }
}

/**
 * Eases the value in with a circular curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInCirc(t) {
  return (t == 0 || t == 1) ? t : 1 - Math.sqrt(1 - (t * t));
}

/**
 * Eases the value out with a circular curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutCirc(t) {
  return (t == 0 || t == 1) ? t : Math.sqrt(1 - (t - 1) * (t - 1));
}

/**
 * Eases the value in and out with a circular curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutCirc(t) {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return -.5 * (Math.sqrt(1 - t * t * 4) - 1);
  } else {
    return .5 * (Math.sqrt(1 - 4 * (t - 1) * (t - 1)) + 1);
  }
}

/**
 * Eases the value in after bounding backwards at the beginning.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInBack(t) {
  return (t == 0 || t == 1) ? t : t * t * (2.70158 * t - 1.70158);
}

/**
 * Eases the value out after bounding past the end point and back.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutBack(t) {
  return (t == 0 || t == 1) ?
      t :
      (t - 1) * (t - 1) * (2.70158 * (t - 1) + 1.70158) + 1;
}

/**
 * Eases the value in and out with an initial and ending movement beyond the
 * full range.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutBack(t) {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return .5 * (t * 2) * (t * 2) * (3.5949095 * (t * 2) - 2.5949095);
  } else {
    return .5 * ((t * 2 - 2) * (t * 2 - 2) *
        (3.5949095 * (t * 2 - 2) + 2.5949095) + 2);
  }
}

/**
 * Eases the value in with an elastic springy motion.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInElastic(t) {
  if (t == 0 || t == 1) {
    return t;
  } else {
    return -1 * (
        Math.pow(2, 10 * (t - 1)) *
        Math.sin((t - 1.075) * (2 * Math.PI) / .3)
    );
  }
}

/**
 * Eases the value out with an elastic springy motion.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutElastic(t) {
  return (t == 0 || t == 1) ? t : Math.pow(2, -10 * t) *
      Math.sin((t - .075) * (2 * Math.PI) / .3) + 1;
}

/**
 * Eases the value in and out with an elastic springy motion.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutElastic(t) {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return -.5 * (Math.pow(2, 10 * ((t * 2) - 1)) *
        Math.sin((t * 2 - 1.1125) * 2 * Math.PI / .45));
  } else {
    return .5 * Math.pow(2, -10 * (t * 2 - 1)) *
        Math.sin((t * 2 - 1.1125) * 2 * Math.PI / .45) + 1;
  }
}

/**
 * Eases the value in with a simple physics bounce.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInBounce(t) {
  return (t == 0 || t == 1) ? t : 1 - easeOutBounce(1 - t);
}

/**
 * Eases the value out with a simple physics bounce.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeOutBounce(t) {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < 1 / 2.75) {
    return 7.5625 * t * t;
  } else if (t < 2 / 2.75) {
    return 7.5625 * (t - 1.5 / 2.75) * (t - 1.5 / 2.75) + .75;
  } else if (t < 2.5 / 2.75) {
    return 7.5625 * (t - 2.25 / 2.75) * (t - 2.25 / 2.75) + .9375;
  } else {
    return 7.5625 * (t - 2.625 / 2.75) * (t - 2.625 / 2.75) + .984375;
  }
}

/**
 * Eases the value in and out with starting and ending bounces.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function easeInOutBounce(t) {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return easeInBounce(t * 2) * .5;
  } else {
    return easeOutBounce(t * 2 - 1) * .5 + .5;
  }
}

/**
 * Returns the value without any easing. This is only useful if a script is
 * expecting an easing method, but one isn't needed in that instance.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @export
 */
function linear(t) {
  return t;
}

/**
 * A map for easing functions.
 * We need this map to reference easing function based on name.
 * It is useful when the easing function is defined in run-time.
 * @export
 */
const easingFuncMap = new Map([
  ['ease', ease],
  ['easeInSine', easeInSine],
  ['easeOutSine', easeOutSine],
  ['easeInOutSine', easeInOutSine],
  ['easeInQuad', easeInQuad],
  ['easeOutQuad', easeOutQuad],
  ['easeInOutQuad', easeInOutQuad],
  ['easeInCubic', easeInCubic],
  ['easeOutCubic', easeOutCubic],
  ['easeInOutCubic', easeInOutCubic],
  ['easeInQuart', easeInQuart],
  ['easeOutQuart', easeOutQuart],
  ['easeInOutQuart', easeInOutQuart],
  ['easeInQuint', easeInQuint],
  ['easeOutQuint', easeOutQuint],
  ['easeInOutQuint', easeInOutQuint],
  ['easeInExpo', easeInExpo],
  ['easeOutExpo', easeOutExpo],
  ['easeInOutExpo', easeInOutExpo],
  ['easeInCirc', easeInCirc],
  ['easeOutCirc', easeOutCirc],
  ['easeInOutCirc', easeInOutCirc],
  ['easeInBack', easeInBack],
  ['easeOutBack', easeOutBack],
  ['easeInOutBack', easeInOutBack],
  ['easeInElastic', easeInElastic],
  ['easeOutElastic', easeOutElastic],
  ['easeInOutElastic', easeInOutElastic],
  ['easeInBounce', easeInBounce],
  ['easeOutBounce', easeOutBounce],
  ['easeInOutBounce', easeInOutBounce],
  ['linear', linear],
]);




/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CarouselImageAdapter */



/** @record */
class CarouselImageAdapter {

  /**
   * @return {number}
   */
  getWidth() {}

  /**
   * @return {number}
   */
  getHeight() {}

  /**
   * @return {boolean}
   */
  isFetchingComplete() {}

  /** @param {!Function} handler */
  registerLoadHandler(handler) {}

  /** @param {!Function} handler */
  deregisterLoadHandler(handler) {}

  notifyLoad() {}

}




/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Options */



/** @record */
function Options() {}

/** @type {string} */
Options.prototype.skipLabel;




/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export PageListAdapter */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model__ = __webpack_require__(1);




/** @record */
class PageListAdapter {

  /**
   * @return {!PaginationModel}
   */
  getPaginationModel() {}

  /**
   * Sets the `aria-selected` attribute on all button elements such that the
   * active button is `true` while all others are `false`.
   * @param {number} index The currently active page (starting from 1).
   */
  setAriaSelected(index) {}

  /**
   * @param {number} index
   */
  setActiveButton(index) {}

  /**
   * Sets the `tabindex` attribute for all buttons in the component, setting
   * only the active button to be focusable (`tabindex="0"`) while other buttons
   * are set to not focusable (`tabindex="-1"`).
   * See b/68821405 for rationale on this feature.
   * @param {number} index The currently active page (starting from 1).
   */
  setTabIndex(index) {}

  /**
   * @param {number} index
   * @return {string}
   */
  getAriaLabel(index) {}

  /**
   * @param {number} index
   * @param {string} label
   */
  setAriaLabel(index, label) {}

  /**
   * @param {!Function} handler
   */
  registerClickHandler(handler) {}

  /**
   * @param {!Function} handler
   */
  deregisterClickHandler(handler) {}

  /**
   * Registers a handler to be used when the user presses keys on the keyboard
   * when focused on buttons within the component. This is used to navigate
   * the component to the next/previous page when right/left arrows are pressed.
   * @param {!Function} handler
   */
  registerKeyHandler(handler) {}

  /** @param {!Function} handler */
  deregisterKeyHandler(handler) {}

  /**
   * @param {!Function} handler
   */
  registerFocusHandler(handler) {}

  /**
   * @param {!Function} handler
   */
  deregisterFocusHandler(handler) {}

  /**
   * @param {!Function} handler
   */
  registerBlurHandler(handler) {}

  /**
   * @param {!Function} handler
   */
  deregisterBlurHandler(handler) {}

  /**
   * Sets whether the component currently has a child with focus or not.
   * @param {boolean} isFocused
   */
  setHasFocus(isFocused) {}

  /**
   * Sets keyboard focus to the button specified.
   * @param {number} index The page number (starting from 1).
   */
  focus(index) {}

  /**
   * @return {boolean} True if this is a right to left language block.
   */
  isRtl() {}
}




/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Key; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return KeyCode; });
/* unused harmony export KEY_CODE_MAP */
/**
 * @fileoverview Constants used when working with key events.
 */



/**
 * Possible values for `Event.key`. Spec is still in draft form.
 * @enum {string}
 */
const Key = {
  ENTER: 'Enter',
  SPACE: ' ',
  TAB: 'Tab',
  ESC: 'Escape',
  // These only trigger with `keydown` not `keypress` on Chrome.
  LEFT: 'ArrowLeft',
  UP: 'ArrowUp',
  RIGHT: 'ArrowRight',
  DOWN: 'ArrowDown',
};


/**
 * Keycodes sent with `Event.keyCode` and `Event.which`.
 * Note that `keyCode` and `which` are deprecated in browsers but `key` is
 * still in draft form and not fully supported yet.
 * @enum {number}
 */
const KeyCode = {
  ENTER: 13,
  SPACE: 32,
  TAB: 9,
  ESC: 27,
  LEFT: 37,       // also NUM_WEST
  UP: 38,         // also NUM_NORTH
  RIGHT: 39,      // also NUM_EAST
  DOWN: 40,       // also NUM_SOUTH
};


/**
 * Constructs a mapping of KeyCode to Key. This is useful for testing for
 * setting both `key` and `keyCode` consistently.
 * @return {!Map<number,string>}
 */
const createKeyCodeToKeyMap = function() {
  const keyCodeMap = new Map();
  Object.keys(KeyCode).forEach((keyName) => {
    keyCodeMap.set(KeyCode[keyName], Key[keyName]);
  });
  return keyCodeMap;
};

/** @const {!Map<number,string>} */
const KEY_CODE_MAP = createKeyCodeToKeyMap();




/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_page_nav_page_nav__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__google_youtube_src_components_glue_carousel__ = __webpack_require__(13);




/** @private @const {string}*/
const Selectors_ = {
  CAROUSEL: '.lb-js-carousel',
};

/**
 * Class for Bronze page.
 */
class Bronze {
  constructor() {
    new __WEBPACK_IMPORTED_MODULE_0__components_page_nav_page_nav__["default"];
    new __WEBPACK_IMPORTED_MODULE_1__google_youtube_src_components_glue_carousel__["a" /* LBGlueCarousel */](document.querySelector(Selectors_.CAROUSEL));
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Bronze;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_page_nav_page_nav__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__google_youtube_src_components_glue_carousel__ = __webpack_require__(13);




/** @private @const {string}*/
const Selectors_ = {
  CAROUSEL: '.lb-js-carousel',
};

/**
 * Class for Graphite page.
 */
class Graphite {
  constructor() {
    new __WEBPACK_IMPORTED_MODULE_0__components_page_nav_page_nav__["default"];
    new __WEBPACK_IMPORTED_MODULE_1__google_youtube_src_components_glue_carousel__["a" /* LBGlueCarousel */](document.querySelector(Selectors_.CAROUSEL));
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Graphite;



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_page_nav_page_nav__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__google_youtube_src_components_glue_carousel__ = __webpack_require__(13);




/** @private @const {string}*/
const Selectors_ = {
  CAROUSEL: '.lb-js-carousel',
};

/**
 * Class for Opal page.
 */
class Opal {
  constructor() {
    new __WEBPACK_IMPORTED_MODULE_0__components_page_nav_page_nav__["default"];
    new __WEBPACK_IMPORTED_MODULE_1__google_youtube_src_components_glue_carousel__["a" /* LBGlueCarousel */](document.querySelector(Selectors_.CAROUSEL));
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Opal;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_page_nav_page_nav__ = __webpack_require__(10);



/**
 * Class for Silver page.
 */
class Silver {
  constructor() {
    new __WEBPACK_IMPORTED_MODULE_0__components_page_nav_page_nav__["default"];
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Silver;



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_modal_modal__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__google_youtube_src_components_video_iframe__ = __webpack_require__(24);




/**
 * Class for Benefits page.
 */
class Benefits {
  constructor() {
    new __WEBPACK_IMPORTED_MODULE_0__components_modal_modal__["default"];
    new __WEBPACK_IMPORTED_MODULE_1__google_youtube_src_components_video_iframe__["a" /* LBIframeApi */];
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Benefits;



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__google_youtube_src_components_video_iframe__ = __webpack_require__(24);



/**
 * Class for Awards page.
 */
class Awards {
  constructor() {
    new __WEBPACK_IMPORTED_MODULE_0__google_youtube_src_components_video_iframe__["a" /* LBIframeApi */];
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Awards;



/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(28);



/**
 * Class for Creators Banner.
 * @param {LocalStore} A new LocalStore instance.
 * @constructor
 */
class CreatorsBanner {
  constructor(localStore) {
    this.bannerEl_ = document.querySelector(__WEBPACK_IMPORTED_MODULE_0__constants__["strings"].BANNER);

    this.closeBtn_ = document.querySelector(__WEBPACK_IMPORTED_MODULE_0__constants__["strings"].CLOSE_BTN);

    if (this.closeBtn_) {
      this.closeBtn_.addEventListener('click', () => this.handleClick_());
    }

    this.localStore = localStore;

    if (this.bannerEl_) {
      this.initialize_();
    }
  }

  /**
   * Initializes the banner.
   */
  initialize_() {
    const isBannerClosed = this.localStore.redeem('isBannerClosed');

    this.bannerEl_.classList.toggle(__WEBPACK_IMPORTED_MODULE_0__constants__["strings"].SHOW_ELEMENT, !isBannerClosed);
  }

  /**
   * Handles the click on close buttion. Closes the banner
   * and inserts value in localstore.
   */
  handleClick_() {
    this.bannerEl_.classList.remove(__WEBPACK_IMPORTED_MODULE_0__constants__["strings"].SHOW_ELEMENT);

    this.localStore.insert({
      'isBannerClosed': true,
    });
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = CreatorsBanner;



/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__accordion_drawer_index__ = __webpack_require__(56);





/** @const {string} - component classes */
const {
  DRAWERS_TOGGLE_BTN_CLASS,
  VISIBLE_CLASS} = __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBAccordionFoundation */].cssClasses;


/** @const {string} - component strings */
const {
    OPTIONS_KEY,
    DRAWER_INDEX_KEY,
    DRAWERS_SELECTOR,
    DRAWERS_TOGGLE_BTN_SELECTOR,
    DRAWER_HEAD_SELECTOR,
    DRAWER_SELECTOR,
    HIDDEN_ARIA,
    OPEN_ALL_FAQ_TEXT,
    SHUT_ALL_FAQ_TEXT} = __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBAccordionFoundation */].strings;


/** @const {string} - component events */
const {REFRESH} = __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBAccordionFoundation */].events;
/**
 * Class that defines LBAccordion.
 */
class LBAccordion extends __WEBPACK_IMPORTED_MODULE_0__material_base__["a" /* MDCComponent */] {
  // Invoked by `mdc.autoInit()`
  static attachTo(root) {
    return new LBAccordion(root);
  }

  /**
   * Instantiate component foundation and pass it the adapter dict.
   * @return {LBAccordionFoundation}
   */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBAccordionFoundation */]({
      getRoot: () => {
        return this.root_;
      },
      getOptions: () => {
        return this.options_;
      },
      getDrawers: () => {
        return this.drawers_;
      },
      getDrawerIndexFromEvent: (event) => {
        const drawerIndex =
            (event.target.getAttribute(DRAWER_INDEX_KEY) || '-1');
        return Number(drawerIndex);
      },
      setToggleButtonAttr: (attr, value) => {
        if (!this.toggleBtn_) {
          return;
        }

        this.toggleBtn_.setAttribute(attr, value);
      },
      eventStopPropagation: (event) => {
        event.stopPropagation();
      },
      eventPreventDefault: (event) => {
        event.preventDefault();
      },
      nodeEqualsToggleButton: (event) => {
       return event.target.classList.contains(DRAWERS_TOGGLE_BTN_CLASS);
      },
      setDrawerStyles: (styles) => {
        Object.assign(this.drawersParent_.style, styles);
      },
      enableDrawersTabState: () => {
        this.enableDrawersTabState_();
      },
      removeClassDrawers: (className) => {
        this.drawersParent_.classList.add(className);
      },
      appendClassDrawers: (className) => {
        this.drawersParent_.classList.add(className);
      },
      drawersHaveMaterialized: () => {
        return this.drawersParent_.classList.contains(VISIBLE_CLASS);
      },
      appendClassToggleButton: (className) => {
        if (!this.toggleBtn_) {
          return;
        }
        this.toggleBtn_.classList.add(className);
      },
      removeClassToggleButton: (className) => {
        if (!this.toggleBtn_) {
          return;
        }
        this.toggleBtn_.classList.remove(className);
      },
      attachInteractionHandler: (type, handler) => {
        this.root_.addEventListener(type, handler);
      },
      detachInteractionHandler: (type, handler) => {
        this.root_.removeEventListener(type, handler);
      },
      attachResizeHandler: (handler) => {
        // TODO(claytonmisura@): Replace with Raf resize.
        window.addEventListener('resize', handler);
      },
      detachResizeHandler: (handler) => {
        window.removeEventListener('resize', handler);
      },
    });
  }

  /**
   * Parses root element's `data-lb-options=` attribute value.
   * @return {?Object<string, *>}
   * @private
   */
  parseOptionsString_() {
    const defaults = {
      defaultHideAccordion: false,
      // Aria Strings
      openAllFaqText: OPEN_ALL_FAQ_TEXT,
      shutAllFaqText: SHUT_ALL_FAQ_TEXT,
    };

    const parsedJSON = JSON.parse(
        this.root_.getAttribute(OPTIONS_KEY)
      );

    const options = new Object(parsedJSON); // eslint-disable-line no-new-object

    return Object.assign({}, defaults, options);
  }

  /**
   * Recomputes the height of each accordion drawer.
   */
  computeDrawerHeightAll() {
    this.drawers_.forEach((drawer) => drawer.computeDrawerHeight());
  }

  /**
   * Ensures drawer/drawer content can be accessed by
   * screen readers
   * @private
   */
  enableDrawersTabState_() {
    this.drawersParent_.setAttribute(HIDDEN_ARIA, 'false');
    this.drawers_.forEach((drawer) => drawer.enableDrawerHeadTabState());
  }

  /**
   * Ensures hidden drawer/drawer content can't be accessed by
   * screen readers.
   * @private
   */
  disableDrawersTabState_() {
    this.drawersParent_.setAttribute(HIDDEN_ARIA, 'true');
    this.drawers_.forEach((drawer) => drawer.disableDrawerHeadTabState());
  }

  /**
   * Tears down component styles, removes attributes and unbinds
   * all event listeners.
   */
  destroy() {
    this.unlisten(REFRESH, this.refreshCallback_);
    this.drawersParent_.removeAttribute(HIDDEN_ARIA);
    this.drawers_.forEach((drawer) => drawer.destroy());
  }

  /**
   * Initializes component. Setup elements and child components.
   */
  initialize() {
    /** @private {?Object} */
    this.options_ = this.parseOptionsString_();

    /** @private @const {!Element} */
    this.toggleBtn_ = this.root_.querySelector(DRAWERS_TOGGLE_BTN_SELECTOR);

    /** @private @const {!Element} */
    this.drawersParent_ = this.root_.querySelector(DRAWERS_SELECTOR);

    /** @private @const {!Array<!LBAccordionDrawer>} */
    this.drawers_ = this.queryEncapsulated_(DRAWER_SELECTOR)
        .map(this.gatherDrawers_);

    /** @private @const {!Function} */
    this.refreshCallback_ = this.computeDrawerHeightAll.bind(this);

    this.drawersParent_.setAttribute(HIDDEN_ARIA, 'true');
    this.listen(REFRESH, this.refreshCallback_);
  }

  /**
   * Creates child drawer component from DOM node.
   * @param {!Element} drawer
   * @param {number} index
   * @private
   * @return {!Array<!LBAccordionDrawer>}
   */
  gatherDrawers_(drawer, index) {
    const drawerHead = drawer.querySelector(DRAWER_HEAD_SELECTOR);
    drawerHead.setAttribute(DRAWER_INDEX_KEY, index);
    return new __WEBPACK_IMPORTED_MODULE_2__accordion_drawer_index__["a" /* LBAccordionDrawer */](drawer);
  }

  /**
   * Queries child selector and coerce DOM list to native Array.
   * @param {string} selector
   * @private
   * @return {!Array<!Element>}
   */
  queryEncapsulated_(selector) {
    return Array.from(
        this.root_.querySelectorAll(selector)
      );
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBAccordion;



/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {string} */
const cssClasses = {
  OPEN_CLASS: 'is-open',
  ACTIVE_CLASS: 'is-active',
  DRAWERS_TOGGLE_BTN_CLASS: 'lb-js-accordion-toggle-drawers',
  ROOT_CLASS: 'lb-js-accordion',
  VISIBLE_CLASS: 'is-visible',
  HAS_TOGGLED_CLASS: 'has-toggled',
};
/* harmony export (immutable) */ __webpack_exports__["a"] = cssClasses;


/** @enum {string} */
const strings = {
  ROOT_SELECTOR: '.lb-js-accordion',
  DRAWERS_SELECTOR: '.lb-js-accordion-drawers',
  DRAWERS_TOGGLE_BTN_SELECTOR: '.lb-js-accordion-toggle-drawers',
  DRAWER_SELECTOR: '.lb-js-accordion-drawer',
  DRAWER_HEAD_SELECTOR: '.lb-js-accordion-drawer-head',
  DRAWER_BODY_SELECTOR: '.lb-js-accordion-drawer-body',
  DRAWER_INDEX_KEY: 'data-index',
  OPTIONS_KEY: 'data-lb-accordion-options',
  ID: 'id',
  ID_PREFIX: 'id-drawer-index-',
  HIDDEN_ARIA: 'aria-hidden',
  CONTROLS_ARIA: 'aria-controls',
  EXPANDED_ARIA: 'aria-expanded',
  LABEL_ARIA: 'aria-label',
  OPEN_TRANSITION: 'will-open',
  SHUT_TRANSITION: 'will-shut',
  SHOW_FAQ_TEXT: 'Click to show FAQs',
  OPEN_ALL_FAQ_TEXT: 'Click to open all FAQs',
  SHUT_ALL_FAQ_TEXT: 'Click to close all FAQs',
  FOCUSABLE_ELEMENTS: 'a[href], area[href], input:not([disabled]), ' +
      'select:not([disabled]), textarea:not([disabled]), ' +
      'button:not([disabled]), iframe, object, embed, [tabindex], ' +
      '[contenteditable]',
};
/* harmony export (immutable) */ __webpack_exports__["d"] = strings;


/** @enum {number} */
const numbers = {
  TAB_KEY: 9,
  ESCAPE_KEY: 27,
  ENTER_KEY: 13,
  WAIT_UNTIL_VISIBLE_TIME: 250,
};
/* harmony export (immutable) */ __webpack_exports__["c"] = numbers;


/** @enum {string} */
const events = {
  OPEN_DRAWER: 'lb-accordion-open-drawer',
  CLOSE_DRAWER: 'lb-accordion-close-drawer',
  TOGGLE_DRAWER: 'lb-accordion-toggle-drawer',
  REFRESH: 'lb-accordion-refresh',
};
/* harmony export (immutable) */ __webpack_exports__["b"] = events;



/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(112);




/** @const {string} - component classes */
const {ROOT_CLASS} = __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBAccordionDrawerFoundation */].cssClasses;

/** @const {string} - component strings */
const {
  FOCUSABLE_ELEMENTS,
  DRAWER_HEAD_SELECTOR,
  DRAWER_BODY_SELECTOR,
  DRAWER_INDEX_KEY} = __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBAccordionDrawerFoundation */].strings;

/**
 * Class that defines an Accordion drawer component.
 */
class LBAccordionDrawer extends __WEBPACK_IMPORTED_MODULE_0__material_base__["a" /* MDCComponent */] {

  static attachTo(root) {
    return new LBAccordionDrawer(root);
  }

  /**
   * Instantiate component foundation and pass it the adapter dict.
   * @return {LBAccordionDrawerFoundation}
   */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBAccordionDrawerFoundation */]({
      getDrawerRoot: () => {
        return this.root_;
      },
      getDrawerBody: () => {
        return this.drawerBody_;
      },
      getDrawerHead: () => {
        return this.drawerHead_;
      },
      getDrawerIndex: () => {
        return Number(
            this.drawerHead_.getAttribute(DRAWER_INDEX_KEY)
          );
      },
      setDrawerBodyAttr: (attrName, attrData) => {
        Object(__WEBPACK_IMPORTED_MODULE_2__util__["c" /* setAttr */])(this.drawerBody_, attrName, attrData);
      },
      setDrawerHeadAttr: (attrName, attrData) => {
        Object(__WEBPACK_IMPORTED_MODULE_2__util__["c" /* setAttr */])(this.drawerHead_, attrName, attrData);
      },
      removeDrawerBodyAttr: (attrName) => {
        this.drawerBody_.removeAttribute(attrName);
      },
      removeDrawerHeadAttr: (attrName) => {
        this.drawerHead_.removeAttribute(attrName);
      },
      getDrawerBodyAttr: (attrName) => {
        return this.getDrawerBody().getAttribute(attrName);
      },
      getDrawerHeadAttr: (attrName) => {
        return this.drawerHead_.getAttribute(attrName);
      },
      setDrawerBodyStyle: (propertyNames) => {
        Object.assign(this.drawerBody_.style, propertyNames);
      },
      getDrawerBodyHeight: () => {
        return this.drawerBody_.scrollHeight;
      },
      appendClassDrawerBody: (className) => {
        this.drawerBody_.classList.add(className);
      },
      removeClassDrawerBody: (className) => {
        this.drawerBody_.classList.remove(className);
      },
      removeClassDrawerRoot: (className) => {
        this.root_.classList.remove(className);
      },
      appendClassDrawerRoot: (className) => {
        this.root_.classList.add(className);
      },
      probeDOMForController: () => {
        return Object(__WEBPACK_IMPORTED_MODULE_2__util__["d" /* traverseDOMForParentElement */])(this.root_, (parentNode) => {
          return parentNode.classList.contains(ROOT_CLASS);
        });
      },
      nameEqualsEventProperty: (event, propertyName) => {
        return event.propertyName === propertyName;
      },
      getFocusableElements: () => {
        return Array.from(
            this.drawerBody_.querySelectorAll(FOCUSABLE_ELEMENTS)
          );
      },
      saveElementTabState: (element) => {
        Object(__WEBPACK_IMPORTED_MODULE_2__util__["b" /* saveElementTabState */])(element);
      },
      restoreElementTabState: (element) => {
        Object(__WEBPACK_IMPORTED_MODULE_2__util__["a" /* restoreElementTabState */])(element);
      },
      preventElementTab: (element) => {
        element.setAttribute('tabindex', '-1');
      },
      eventStopPropagation: (event) => {
        event.stopPropagation();
      },
      drawerHeadAttachInteractionHandler: (type, handler) => {
        this.drawerHead_.addEventListener(type, handler);
      },
      drawerHeadDetachInteractionHandler: (type, handler) => {
        this.drawerHead_.removeEventListener(type, handler);
      },
      attachInteractionHandler: (type, handler) => {
        this.root_.addEventListener(type, handler);
      },
      detachInteractionHandler: (type, handler) => {
        this.root_.removeEventListener(type, handler);
      },
    });
  }

  /**
   * Initializes component. Setup elements and child components.
   */
  initialize() {
    this.drawerBody_ = this.root_.querySelector(DRAWER_BODY_SELECTOR);
    this.drawerHead_ = this.root_.querySelector(DRAWER_HEAD_SELECTOR);
  }

  /**
   * Proxy foundation to destroy drawer.
   */
  destroy() {
    this.foundation_.destroy();
  }

  /**
   * Calls post DOM interactive.
   */
  initialSyncWithDOM() {
    this.computeDrawerHeight();
  }

  /**
   * Ensures drawer/drawer content tabbable.
   * @private
   */
  enableDrawerHeadTabState() {
    this.drawerHead_.setAttribute('tabindex', '0');
  }

  /**
   * Ensures hidden drawer/drawer content is untabbable.
   * @private
   */
  disableDrawerHeadTabState() {
    this.drawerHead_.setAttribute('tabindex', '-1');
  }

  /**
   * Proxy foundation to compute drawer height.
   * XXX(claytonmisura@): Is this necessary?
   */
  computeDrawerHeight() {
    this.foundation_.computeHeight();
  }

  /**
   * Proxy foundation to set drawer state to shut.
   */
  shutDrawer() {
    this.foundation_.shutDrawer();
  }

  /**
   * Proxy foundation to set drawer state to open.
   */
  openDrawer() {
    this.foundation_.openDrawer();
  }

  /**
   * Proxy foundation to toggle drawer state.
   */
  openShutDrawer() {
    this.foundation_.openShutDrawer();
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBAccordionDrawer;



/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer_timer__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_easing__ = __webpack_require__(59);



/**
 * @typedef {{
 *  'x': number,
 *  'y': number,
 * }}
 */
let ElementPosition;

/**
 * Default values for optional settings.
 * @private @enum {!number}
 */
const OPTION_DEFAULTS_ = {
  duration: 500,
  offset: {
    x: 0,
    y: 0,
  },
  containerSelector: null,
  container: document.documentElement,
  easing: __WEBPACK_IMPORTED_MODULE_1__providers_easing__["a" /* easeInOutQuad */],
};


/**
* Class that scrolls a container to a new position.
* @final
*/
class AutoScroll {
  constructor(options = {}) {
    /** @private {!Object} */
    this.options_ = Object.assign({}, OPTION_DEFAULTS_, options);
    this.options_.offset = this.transformOffsetOptions_(this.options_.offset);
    this.options_.container = this.setContainer_(this.options_);

    /**
     * An array of element/position objects.
     * TODO(mosney): Change this to a WeakMap?
     * @private {!Array<Object>}
     */
    this.elementPositionCache_ = [];

    // Invalidate the element position cache after window resize.
    window.addEventListener('resize', () => {
      this.elementPositionCache_ = [];
    });
  }

  /**
   * Sets default options on the offset key of options, which Object.assign,
   * used in setting defaults, cannot do.
   * @param {ElementPosition|number} offset The offset options, either an
   * object with x/y keys, or a number, representing the y offset.
   * @return {object} The adjusted options.
   * @private
   */
  transformOffsetOptions_(offset) {
    if (typeof offset === 'number') {
      offset = {
        y: offset,
      };
    }
    if (typeof offset.x !== 'number') {
      offset.x = OPTION_DEFAULTS_.offset.x;
    }
    if (typeof offset.y !== 'number') {
      offset.y = OPTION_DEFAULTS_.offset.y;
    }
    return offset;
  }

  /**
   * Sets the container to scroll. If the user set a 'containerSelector' option,
   * find that element and set 'container' to it. Otherwise use the default.
   * @param {string} containerSelector A DOM querySelector.
   * @param {Element} container The default scroll container.
   * @return {Element} The container element.
   * @private
   */
  setContainer_({containerSelector, container}) {
    if (containerSelector) {
      container = document.querySelector(containerSelector);
    }

    if (!container) {
      throw new Error(`(LB AutoScroll) No valid scrollable container found.`);
    }

    return container;
  }

  /**
   * Gets the x/y position of an element relative to the defined scroll
   * container. Checks for the element in a cache or invalidates the cache and
   * reads the position directly.
   * @private
   * @param {Element} element The element to get the position of.
   * @return {ElementPosition} The x/y position of the element.
   */
  getPosition_(element) {
    const cachedElement = this.elementPositionCache_.find((cacheItem) => {
      return cacheItem.element === element;
    });

    if (cachedElement) {
      return cachedElement;
    }

    const elementRect = element.getBoundingClientRect();
    const containerRect = this.options_.container.getBoundingClientRect();
    let containerScroll = {
      top: 0,
      left: 0,
    };

    if (this.options_.container !== document.documentElement) {
      containerScroll = {
        top: this.options_.container.scrollTop,
        left: this.options_.container.scrollLeft,
      };
    }

    const elementPosition = {
      element,
      y: elementRect.top - containerRect.top + containerScroll.top,
      x: elementRect.left - containerRect.left + containerScroll.left,
    };

    return elementPosition;
  };

  /**
   * Gets the current scrolled amount of the scrollable container.
   * @return {ElementPosition} The current x/y scroll amount, e.g. {x:10, y:20}.
   */
  getContainerScroll_() {
    return {
      x: this.options_.container.scrollLeft,
      y: this.options_.container.scrollTop,
    };
  };

  /**
   * Enables and disables a handler to capture and preventDefault on scroll
   * events (i.e. scrolling the page) during an auto-scroll.
   * @param {boolean} enable Whether to enable the scroll capture.
   */
  toggleScrollHandler_(enable = true) {
    if (enable) {
      document.addEventListener('scroll', (e) => {
        e.preventDefault();
      });
    } else {
      document.removeEventListener('scroll', (e) => {
        e.preventDefault();
      });
    }
  };

  /**
   * Scrolls the container to a given element in a promise.
   * @param {!Element} element The element to scroll to.
   * @param {number} duration The duration of the scroll.
   * @param {ElementPosition} offset Pixel offset to apply to
   * smoothScrollTo_.
   * @return {Promise} A promise that resolves after the scroll completes.
   * @private
   */
  scrollToElement(element,
      duration = this.options_.duration,
      offset = this.options_.offset) {
    const scrollPromise = new Promise((resolve) => {
      const elementPosition = this.getPosition_(element);
      const elementOffsetPosition = {
        x: elementPosition.x + offset.x,
        y: elementPosition.y + offset.y,
      };
      this.smoothScrollTo_(
          elementOffsetPosition,
          duration,
          resolve);
    });
    return scrollPromise;
  }

  /**
   * Animates a container's scroll to a given x/y position.
   * @param {ElementPosition} to The x/y position to scroll to.
   * @param {number} duration The duration of the scroll.
   * @param {Function} resolve A callback to run after the animation ends.
   */
  smoothScrollTo_(
      to,
      duration = this.options_.duration,
      resolve) {

    const startPosition = this.getContainerScroll_();
    const netChange = {
      x: to.x - startPosition.x,
      y: to.y - startPosition.y,
    };

    const animateScroll = (progress) => {
      const easedProgress = this.options_.easing(progress);
      const easedPosition = {
        x: easedProgress * netChange.x,
        y: easedProgress * netChange.y,
      };
      const scrollToPosition = {
        x: startPosition.x + easedPosition.x,
        y: startPosition.y + easedPosition.y,
      };
      this.options_.container.scroll(scrollToPosition.x, scrollToPosition.y);
    };

    this.timer_ = new __WEBPACK_IMPORTED_MODULE_0__timer_timer__["a" /* default */](animateScroll, () => {
      this.toggleScrollHandler_(false);
      resolve();
    }, duration);

    // Start the scroll.
    this.toggleScrollHandler_();
    this.timer_.start();
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AutoScroll;



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @const {number} */
const DEFAULT_DURATION = 3000;

/** @const {Function} */
const NOOP = () => {};

/**
 * Class that runs a timer using Request Animation Frame.
 * @final
 */
class Timer {
  constructor(progressCallback = NOOP,
      completeCallback = NOOP,
      duration = DEFAULT_DURATION) {
    /**
     * @private {!Function} - A function to be called on each loop.
     */
    this.progressCallback_ = progressCallback;
    /**
     * @private {!Function} - A function to be called when the timer has
     * completed.
     */
    this.completeCallback_ = completeCallback;
    /** @private {number} - The duration of the timer in milliseconds. */
    this.duration_ = duration;
    /** @private {number} - The progress of the timer over time, from 0-1. */
    this.progress_ = 0;
    /** @private {number} - The current rAF identifier. */
    this.rafId_ = 0;
    /** @private {number} - The timestamp for when the timer started. */
    this.startTime_;
  }

  /**
   * Starts the timer.
   */
  start() {
    this.rafId_ = requestAnimationFrame(this.step_.bind(this));
    const now = performance.now();

    // If this.startTime_ has a value, the timer is starting from a paused
    // state. In that case we reset it to an interpolated value.
    // For example, if the timer duration is 10 seconds and the timer was
    // paused at 2 seconds, this.progress_ would be .2 or 2 seconds. We set
    // this.startTime_ to 2 seconds before now to reflect the progress.
    if (!this.startTime_) {
      this.startTime_ = now;
    } else {
      this.startTime_ = now - (this.duration_ * this.progress_);
    }
  }

  /**
   * Pauses the timer. It can be restarted again at the same point with start().
   */
  pause() {
    cancelAnimationFrame(this.rafId_);
  }

  /**
   * Stops the timer.
   */
  stop() {
    cancelAnimationFrame(this.rafId_);
    this.progress_ = 0;
  }

  /**
   * Runs periodically to assess the timer progress and run callbacks.
   */
  step_() {
    const now = performance.now();
    const relativeTime = now - this.startTime_;
    this.progress_ = relativeTime / this.duration_;

    this.progress_ = Math.min(this.progress_, 1);
    this.progressCallback_(this.progress_);

    if (this.progress_ === 1) {
      this.stop();
      this.completeCallback_();
      return;
    }

    this.rafId_ = requestAnimationFrame(this.step_.bind(this));
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Timer;



/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @fileoverview A series of utility functions for use in implementing easing in
 * javascript animations. Copied from Glue.
 *
 * Example usage: Say you have a DOM element that you want to animate by moving
 * it between two arbitrary locations in a page, over 2 seconds. Normally you'd
 * determine its starting position, its ending position, set up an interval,
 * then with each iteration, determine the position you should move it to based
 * on its initial and ending position values and a percentage that represents
 * its progress from start to finish, based on the 2 second duration. Call that
 * percentage T. In order to implement an easing method using glue.fx.easing,
 * simply pass T through your desired easing method, and the returned value is
 * an "eased" value of T. Using that new T, you set the element's position,
 * and the resulting animation will have a smooth ease to it, instead of its
 * original, jarring linear movement. It's hard to understand this without
 * seeing it in action, so visit the example link below for some live animation
 * utilizing all of the easing functions provided in this library.
 *
 * If you are more familiar with jQuery's style of easing methods which expect
 * four arguments (t, b, c, d), you can use glue.fx.easing.ease(), passing in
 * those four arguments and a reference to the easing method you'd like to use.
 * Whether you should use this, or directly call one of the single-argument
 * methods, is up to the developer, and largely depends on circumstance.
 *
 * Note: Frequently, you will have the easing method by name in string form (as
 * when contained in some JSON configuration data), so you can also call it
 * like: glue.fx.easing[methodName](percentage);
 *
 * For examples, see:
 * https://glue-docs.appspot.com/docs/components/raw/fx-easing
 */

/**
 * Eases values based on the typical four-argument easing method structure used
 * by popular libraries like jQuery. This is an adapter to interface with the
 * single-argument easing methods in this class.
 * @param {number} t Current time of the animation.
 * @param {number} b Beginning value of the property to be eased.
 * @param {number} c Total change in the property value across this animation.
 * @param {number} d Total duration of the animation.
 * @param {!function(number): number} func The easing method to call.
 * @return {number} The final eased value.
 */
const ease = (t, b, c, d, func) => {
  return b + c * func(t / d);
};
/* unused harmony export ease */


/**
 * Eases the value in with a Sine curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInSine = (t) => {
  return (t == 0 || t == 1) ? t : 1 - Math.cos(t * (Math.PI / 2));
};
/* unused harmony export easeInSine */


/**
 * Eases the value out with a Sine curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutSine = (t) => {
  return (t == 0 || t == 1) ? t : Math.sin(t * (Math.PI / 2));
};
/* unused harmony export easeOutSine */


/**
 * Eases the value in and out with a Sine curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutSine = (t) => {
  return (t == 0 || t == 1) ? t : -0.5 * (Math.cos(Math.PI * t) - 1);
};
/* unused harmony export easeInOutSine */


/**
 * Eases the value in with a quadratic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInQuad = (t) => {
  return (t == 0 || t == 1) ? t : t * t;
};
/* unused harmony export easeInQuad */


/**
 * Eases the value out with a quadratic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutQuad = (t) => {
  return (t == 0 || t == 1) ? t : t * (2 - t);
};
/* unused harmony export easeOutQuad */


/**
 * Eases the value in and out with a quadratic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutQuad = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return 2 * t * t;
  } else {
    return -1 + (4 - 2 * t) * t;
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = easeInOutQuad;


/**
 * Eases the value in with a cubic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInCubic = (t) => {
  return (t == 0 || t == 1) ? t : t * t * t;
};
/* unused harmony export easeInCubic */


/**
 * Eases the value out with a cubic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutCubic = (t) => {
  return (t == 0 || t == 1) ? t : (--t) * t * t + 1;
};
/* unused harmony export easeOutCubic */


/**
 * Eases the value in and out with a cubic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutCubic = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return 4 * t * t * t;
  } else {
    return (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }
};
/* unused harmony export easeInOutCubic */


/**
 * Eases the value in with a quartic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInQuart = (t) => {
  return (t == 0 || t == 1) ? t : t * t * t * t;
};
/* unused harmony export easeInQuart */


/**
 * Eases the value out with a quartic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutQuart = (t) => {
  return (t == 0 || t == 1) ? t : 1 - (--t) * t * t * t;
};
/* unused harmony export easeOutQuart */


/**
 * Eases the value in and out with a quartic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutQuart = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return 8 * t * t * t * t;
  } else {
    return 1 - 8 * (--t) * t * t * t;
  }
};
/* unused harmony export easeInOutQuart */


/**
 * Eases the value in with a quintic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInQuint = (t) => {
  return (t == 0 || t == 1) ? t : t * t * t * t * t;
};
/* unused harmony export easeInQuint */


/**
 * Eases the value out with a quintic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutQuint = (t) => {
  return (t == 0 || t == 1) ? t : 1 + (--t) * t * t * t * t;
};
/* unused harmony export easeOutQuint */


/**
 * Eases the value in and out with a quintic curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutQuint = (t) => {
  return (t == 0 || t == 1) ? t : t < .5 ? 16 * t * t * t * t * t : 1 + 16 *
      (--t) * t * t * t * t;
};
/* unused harmony export easeInOutQuint */


/**
 * Eases the value in with an exponential curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInExpo = (t) => {
  return (t == 0 || t == 1) ? t : Math.pow(2, 10 * (t - 1));
};
/* unused harmony export easeInExpo */


/**
 * Eases the value out with an exponential curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutExpo = (t) => {
  return (t == 0 || t == 1) ? t : (1 - Math.pow(2, -10 * t));
};
/* unused harmony export easeOutExpo */


/**
 * Eases the value in and out with an exponential curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutExpo = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return .5 * Math.pow(2, 10 * (t * 2 - 1));
  } else {
    return .5 * (2 - Math.pow(2, -10 * (t * 2 - 1)));
  }
};
/* unused harmony export easeInOutExpo */


/**
 * Eases the value in with a circular curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInCirc = (t) => {
  return (t == 0 || t == 1) ? t : 1 - Math.sqrt(1 - (t * t));
};
/* unused harmony export easeInCirc */


/**
 * Eases the value out with a circular curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutCirc = (t) => {
  return (t == 0 || t == 1) ? t : Math.sqrt(1 - (t - 1) * (t - 1));
};
/* unused harmony export easeOutCirc */


/**
 * Eases the value in and out with a circular curve.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutCirc = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return -.5 * (Math.sqrt(1 - t * t * 4) - 1);
  } else {
    return .5 * (Math.sqrt(1 - 4 * (t - 1) * (t - 1)) + 1);
  }
};
/* unused harmony export easeInOutCirc */


/**
 * Eases the value in after bounding backwards at the beginning.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInBack = (t) => {
  return (t == 0 || t == 1) ? t : t * t * (2.70158 * t - 1.70158);
};
/* unused harmony export easeInBack */


/**
 * Eases the value out after bounding past the end point and back.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutBack = (t) => {
  return (t == 0 || t == 1) ?
      t :
      (t - 1) * (t - 1) * (2.70158 * (t - 1) + 1.70158) + 1;
};
/* unused harmony export easeOutBack */


/**
 * Eases the value in and out with an initial and ending movement beyond the
 * full range.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutBack = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return .5 * (t * 2) * (t * 2) * (3.5949095 * (t * 2) - 2.5949095);
  } else {
    return .5 * ((t * 2 - 2) * (t * 2 - 2) *
        (3.5949095 * (t * 2 - 2) + 2.5949095) + 2);
  }
};
/* unused harmony export easeInOutBack */


/**
 * Eases the value in with an elastic springy motion.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInElastic = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else {
    return -1 * (
        Math.pow(2, 10 * (t - 1)) *
        Math.sin((t - 1.075) * (2 * Math.PI) / .3)
    );
  }
};
/* unused harmony export easeInElastic */


/**
 * Eases the value out with an elastic springy motion.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutElastic = (t) => {
  return (t == 0 || t == 1) ? t : Math.pow(2, -10 * t) *
      Math.sin((t - .075) * (2 * Math.PI) / .3) + 1;
};
/* unused harmony export easeOutElastic */


/**
 * Eases the value in and out with an elastic springy motion.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutElastic = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return -.5 * (Math.pow(2, 10 * ((t * 2) - 1)) *
        Math.sin((t * 2 - 1.1125) * 2 * Math.PI / .45));
  } else {
    return .5 * Math.pow(2, -10 * (t * 2 - 1)) *
        Math.sin((t * 2 - 1.1125) * 2 * Math.PI / .45) + 1;
  }
};
/* unused harmony export easeInOutElastic */


/**
 * Eases the value in with a simple physics bounce.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInBounce = (t) => {
  return (t == 0 || t == 1) ? t : 1 - easeOutBounce(1 - t);
};
/* unused harmony export easeInBounce */


/**
 * Eases the value out with a simple physics bounce.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeOutBounce = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < 1 / 2.75) {
    return 7.5625 * t * t;
  } else if (t < 2 / 2.75) {
    return 7.5625 * (t - 1.5 / 2.75) * (t - 1.5 / 2.75) + .75;
  } else if (t < 2.5 / 2.75) {
    return 7.5625 * (t - 2.25 / 2.75) * (t - 2.25 / 2.75) + .9375;
  } else {
    return 7.5625 * (t - 2.625 / 2.75) * (t - 2.625 / 2.75) + .984375;
  }
};
/* unused harmony export easeOutBounce */


/**
 * Eases the value in and out with starting and ending bounces.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const easeInOutBounce = (t) => {
  if (t == 0 || t == 1) {
    return t;
  } else if (t < .5) {
    return easeInBounce(t * 2) * .5;
  } else {
    return easeOutBounce(t * 2 - 1) * .5 + .5;
  }
};
/* unused harmony export easeInOutBounce */


/**
 * Returns the value without any easing. This is only useful if a script is
 * expecting an easing method, but one isn't needed in that instance.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 */
const linear = (t) => {
  return t;
};
/* unused harmony export linear */


/**
 * A map for easing functions.
 * We need this map to reference easing function based on name.
 * It is useful when the easing function is defined in run-time.
 */
const easingFuncMap = new Map([
  ['ease', ease],
  ['easeInSine', easeInSine],
  ['easeOutSine', easeOutSine],
  ['easeInOutSine', easeInOutSine],
  ['easeInQuad', easeInQuad],
  ['easeOutQuad', easeOutQuad],
  ['easeInOutQuad', easeInOutQuad],
  ['easeInCubic', easeInCubic],
  ['easeOutCubic', easeOutCubic],
  ['easeInOutCubic', easeInOutCubic],
  ['easeInQuart', easeInQuart],
  ['easeOutQuart', easeOutQuart],
  ['easeInOutQuart', easeInOutQuart],
  ['easeInQuint', easeInQuint],
  ['easeOutQuint', easeOutQuint],
  ['easeInOutQuint', easeInOutQuint],
  ['easeInExpo', easeInExpo],
  ['easeOutExpo', easeOutExpo],
  ['easeInOutExpo', easeInOutExpo],
  ['easeInCirc', easeInCirc],
  ['easeOutCirc', easeOutCirc],
  ['easeInOutCirc', easeInOutCirc],
  ['easeInBack', easeInBack],
  ['easeOutBack', easeOutBack],
  ['easeInOutBack', easeInOutBack],
  ['easeInElastic', easeInElastic],
  ['easeOutElastic', easeOutElastic],
  ['easeInOutElastic', easeInOutElastic],
  ['easeInBounce', easeInBounce],
  ['easeOutBounce', easeOutBounce],
  ['easeInOutBounce', easeInOutBounce],
  ['linear', linear],
]);
/* unused harmony export easingFuncMap */



/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {number} */
const TimeConversions = {
  SECONDS_IN_DAY: 86400,
  SECONDS_IN_HOUR: 3600,
  SECONDS_IN_MINUTE: 60,
};
/* unused harmony export TimeConversions */


/**
 * KeyboardEvent.keyCode values supported on all browsers:
 * https://caniuse.com/#search=KeyboardEvent.keyCode
 * @enum {number}
 */
const KeyCodes = {
  ENTER: 13,
  ESC: 27,
  SPACE: 32,
  TAB: 9,
};
/* harmony export (immutable) */ __webpack_exports__["a"] = KeyCodes;



/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tests__ = __webpack_require__(119);



/**
 * A utility for testing platform and feature support of the browser.
 * Adds utility classes onto the html element for each test.
 * Exposes tests for use in JavaScript, e.g.
 * const detect = new Detect();
 * if (detect.mac) { ... }
 */
class Detect {
  /**
   * Returns a utility for testing platform and feature support of the browser.
   * @param {string} platform The platform string or a stub for testing.
   * @param {object} win The window object or a stub for testing.
   */
  constructor(platform = navigator.platform, win = window) {
    this.htmlEl = document.documentElement;

    // Run each test and toggle on/off the classes:
    // e.g. browser is on iOS:
    // Add .ios, .no-mac, .no-android
    // e.g. browser supports touch:
    // Add .ontouchstart
    Object.keys(__WEBPACK_IMPORTED_MODULE_0__tests__["a" /* tests */]).forEach((key) => {
      const test = __WEBPACK_IMPORTED_MODULE_0__tests__["a" /* tests */][key];
      const passTest = test(win, platform);
      // Make the test accessible on the instance.
      this[key] = __WEBPACK_IMPORTED_MODULE_0__tests__["a" /* tests */][key](win, platform);
      this.htmlEl.classList.toggle(this.getClass_(key, true), passTest);
      this.htmlEl.classList.toggle(this.getClass_(key, false), !passTest);
    });
  }

  /**
   * Returns a string for a feature support class based on the parameters.
   * @param {string} test The name of the test.
   * @param {boolean} pass Whether or not the test passed.
   * @return a string for a feature support class.
   */
  getClass_(test, pass) {
    const prefix = pass ? '' : 'no-';
    return `${prefix}${test}`;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Detect;



/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixin__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pubsub_shared__ = __webpack_require__(120);


/**
 * @fileoverview LB Base Component:
 * Common base component that includes Lazy Bones specific
 * utility methods and properties.
 */
// ! TODO (claytonmisura@) Need to explore if this is unnecessary now.
class ComponentBase {
  /**
   * @param {!Element} root
   * @param {!Object|undefined} foundation
   * @param  {...any} args
   */
  constructor(root, foundation = undefined, ...args) {
    /** @private @const {!Object<string, boolean|number|string>} */
    this.options_ = {};

    /** @private @cont {!Element} */
    this.root_ = root;

    /** @private @const {!PubSub} */
    this.pubSubShared_ = __WEBPACK_IMPORTED_MODULE_1__pubsub_shared__["a" /* pubSubShared */];

    // We'll lazily invoke initialize w/ lbAutoInit.
    this.initialize = this.initialize.bind(this, ...args);
  }

  initialize(/* ...args */) {
    // Subclasses can override this to do any additional setup work that would be considered part of a
    // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
    // initialized. Any additional arguments besides root and foundation will be passed in here.
  }
}

class LBPlainComponent extends Object(__WEBPACK_IMPORTED_MODULE_0__mixin__["a" /* lbClassMixin */])(ComponentBase) {}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBPlainComponent;



/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pub_sub__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(122);




class BreakpointMonitor {
  /**
   * Creates a new BreakpointMonitor.
   * @param {Function} handleBreakpointChange A function to run when the
   *   breakpoint changes. Additional functions can be registered using
   *   watchBreakpointChange.
   */
  constructor(handleBreakpointChange) {
    /** @private @const {!PubSub} */
    this.pubSub_ = new __WEBPACK_IMPORTED_MODULE_0__pub_sub__["a" /* default */]();

    /** @private @const {!Element} */
    this.htmlEl_ = document.querySelector(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* strings */].HTML_SELECTOR);

    /** @private {string} */
    this.activeBreakpoint_ = '';

    this.initialize_(handleBreakpointChange);
  }

  get breakpoint() {
    const computedStyle =
        window.getComputedStyle(this.htmlEl_, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* strings */].BEFORE_SELECTOR);
    return computedStyle.getPropertyValue(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* strings */].CONTENT_PROPERTY)
        .replace(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* QUOTE_RE_ */], '');
  }

  /**
   * Runs the resize listener with a callback that broadcasts a message.
   * @param {Function} handleBreakpointChange A function to run when the
   *   breakpoint changes.
   */
  initialize_(handleBreakpointChange) {
    this.resizeListener(({breakpoint, event}) => {
      if (breakpoint !== this.activeBreakpoint_) {
        this.pubSub_.broadcast(
            __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* strings */].BREAKPOINT_CHANGE_EVENT_NAME,
            {breakpoint, event});
        this.activeBreakpoint_ = breakpoint;
      }
    });

    if (typeof handleBreakpointChange === 'function') {
      this.watchBreakpointChange(handleBreakpointChange);
    }
  }

  /**
   * Registers a callback to be run when the breakpoint changes.
   * @param {!Function} handleBreakpointChange A function to run when the
   *   breakpoint changes.
   */
  watchBreakpointChange(handleBreakpointChange) {
    this.pubSub_.subscribe(
        __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* strings */].BREAKPOINT_CHANGE_EVENT_NAME,
        handleBreakpointChange);
  }

  /**
   * Registers a window resize listener with a callback.
   * @param {!Function} resizeCallback A function to run when the
   *   window is resized.
   */
  resizeListener(resizeCallback) {
    let timeout = null;

    const handler = (event) => {
      timeout && window.cancelAnimationFrame(timeout);
      timeout = window.requestAnimationFrame(() => {
        const breakpoint = this.breakpoint;
        const payload = {breakpoint, event};
        resizeCallback(payload);
      });
    };

    window.addEventListener(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* strings */].RESIZE_EVENT_NAME, handler);
    return () => window.removeEventListener(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* strings */].RESIZE_EVENT_NAME, handler);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BreakpointMonitor;



/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @const {string} */
const EXPIRATION_KEY = 'expiration';

/** @const {number} One day, in milliseconds. */
const DEFAULT_EXPIRE_MS = 86400000;

/** @private {?LocalStore} */
let instance;


/**
 * Class that adds functionality to LocalStorage.
 * Enables storing object-scale values in a single native LocalStorage key.
 * This is done by maintaining an object in memory and using JSON.parse and
 * JSON.stringify to read/write sync to LocalStorage.
 * Includes default expiration date setting and checking. If the store is found
 * to be expired, it is removed and reset.
 *
 * Usage
 * -----
 * const localStore = new LocalStore('lazybones');
 * localStore.insert({
 *   'test': 12345,
 * });
 * const value = localStore.redeem('test');
 * @final
 */
class LocalStore {
  /**
   * Gets the value of the LocalStorage for the given key and converts it
   * to an object.
   * @param {string} storeKey The name of the LocalStorage key.
   * @param {=number} lifetime How many milliseconds the item should live
   *   in LocalStorage.
   * @return {LocalStore} A new LocalStore instance.
   */
  constructor(storeKey, lifetime = DEFAULT_EXPIRE_MS) {
    if (!instance) {
      instance = this;
    }

    if (!storeKey) {
      throw new Error('A name must be provided for the key in LocalStorage.');
    }

    /** @private @const {object} */
    this.config_ = {storeKey, lifetime};

    /** @private @const {!window.localStorage} */
    this.localStorage_ = window.localStorage;

    this.initializeStore(storeKey);

    this.checkExpiration_(this.store_);

    return instance;
  }

  /**
   * Gets the value of the LocalStorage for the given key and converts it
   * to an object.
   * @param {string} key The LocalStorage key to get.
   * @return {!Object<string, *>} The store retreived from LocalStorage, or a
   *   new empty object.
   */
  initializeStore(key) {
    if (this.localStorageContains_(key)) {
      this.store_ =
          JSON.parse(this.localStorage_.getItem(this.config_.storeKey));
    } else {
      this.store_ = {
        [EXPIRATION_KEY]:
            this.getNewExpirationDateTime_(this.config_.lifetime),
      };
      this.save_(this.store_);
    }
    return this.store_;
  }

  /**
   * Updates the store object and updates LocalStorage.
   * @param {!Object<string, *>} data The data to update with.
   * @param {number|undefined} lifetime Optional amount of time from now to set
   *   the new expiration.
   * @return {!Object<string, *>} The store object.
   */
  insert(data, lifetime) {
    if (lifetime) {
      data = this.updateExpiration_(data, lifetime);
    }
    this.store_ = Object.assign({}, this.store_, data);
    this.save_(this.store_);
    return this.store_;
  }

  /**
   * Gets the value of a given key from the store.
   * @param {string} key The key to get.
   * @return {*} The value of the given key in the store.
   */
  redeem(key) {
    return this.store_[key];
  }

  /**
   * Removes an object key/value from the store and updates LocalStorage.
   * @param {string} key The key to delete.
   * @return {!Object<string, *>} The store object.
   */
  remove(key) {
    delete this.store_[key];
    this.save_(this.store_);
    return this.store_;
  }

  /**
   * Removes the instance's entry in LocalStorage and resets the store to an
   * empty object with a fresh expiration.
   */
  empty() {
    this.localStorage_.removeItem(this.config_.storeKey);
    this.store_ = this.initializeStore(this.config_.storeKey);
  }

  /**
   * Gets the value of the expiration key from the store.
   * @return {number} The expiration datetime.
   */
  getExpiration() {
    return this.redeem(EXPIRATION_KEY);
  }

  /**
   * Updates the value of the 'expiration' key.
   * @param {Object<string, *>} data The data to update the key on.
   * @param {number} lifetime The amount of time from now to set the new
   *   expiration.
   * @return {!Object} The data with an updated expiration key.
   */
  updateExpiration_(data, lifetime) {
    data[EXPIRATION_KEY] = this.getNewExpirationDateTime_(lifetime);
    return data;
  }

  /**
   * Checks if the localStorage entry is expired, and if it is, removes it.
   * @param {!Object<string, *>} store The store object.
   */
  checkExpiration_(store) {
    const expirationDateTime = store[EXPIRATION_KEY];
    if (expirationDateTime && Date.now() > expirationDateTime) {
      this.empty();
    }
  }

  /**
   * Returns a new datetime number by adding the current datetime and a lifetime.
   * @param {number} lifetime The amount of time from now to set the new
   *   expiration.
   * @return {number} A new 13-digit epoch time.
   */
  getNewExpirationDateTime_(lifetime) {
    return +new Date + lifetime;
  }

  /**
   * Whether LocalStorage contains a given key.
   * @param {string} key The key to look up.
   * @return {boolean} Whether LocalStorage contains the given key.
   */
  localStorageContains_(key) {
    return !!this.localStorage_.getItem(key);
  }

  /**
   * Converts the current store object to a string and saves it to LocalStorage.
   * @param {!Object<string, *>} store The store object.
   */
  save_(store) {
    const value = JSON.stringify(store);
    this.localStorage_.setItem(this.config_.storeKey, value);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LocalStore;



/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Cancel Animation Frame shim.
const cancelAnimFrame =
    window.cancelAnimationFrame ||
    window.mozCancelAnimationFrame;

 // Request Animation Frame shim.
const requestAnimFrame =
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame;

/**
 * Class that encapsulates Request Animation Frame.
 * @final
 */
class Raf {
  constructor() {
    /** @private {number} - Current Raf loops unique non-zero identifier. */
    this.loop_ = 0;

    /** @private {boolean} - Flag that will pause Raf loop. */
    this.stop_ = false;
  }

  /**
   * Fires up Raf and executes the `callback` on each frame.
   * @param {!Function} callback
   * @param {?Object} context
   */
  ticker(callback, context) {
    // Raf renderer.
    const render = (timestamp) => {
      if (!this.stop_) {
        // Callback to run on each Raf tick.
        callback.call(context, timestamp);
        this.loop_ = requestAnimFrame(render);
      }
    };

    // Start Raf loop.
    this.loop_ = requestAnimFrame(render);
  }

  /**
   * Plays the Raf loop.
   */
  resume() {
    this.stop_ = false;
  }

  /**
   * Stops the Raf loop.
   */
  stop() {
    this.stop_ = true;
  }

  /**
   * Cancels the Raf instance.
   */
  cancel() {
    cancelAnimFrame(this.loop_);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Raf;



/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__auth__ = __webpack_require__(31);



/**
 * Milleseconds in 24 hours.
 *     24 hrs in a day * 60 mins in an hour *
 *     60 secs in a minute * 1000 mills in a second
 * @private {number}
 */
const ONE_DAY_ = 24 * 60 * 60 * 1000;

/** @private {enum} */
const SessionStorageKeys_ = {
  DATA: 'YTCreatorsDataAPI',
  TIMESTAMP: 'YTCreatorsTimestamp',
  TOKEN: 'YTCreatorsAccessToken',
  UID: 'YTCreatorsUID',
};

/** @private @const {string} */
const YT_DATA_ENDPOINT_ =
    'https://www.googleapis.com/youtube/v3/channels' +
    '?key=AIzaSyDHXr4OLsRhbxqQaaC9gMGKWPqhIPM88Qk' +
    '&part=snippet,statistics' +
    '&mine=true' +
    '&access_token=';


/**
 * Retrieves user YouTube Data (snippet,statistics) with help from the YTC Auth
 * provider. It exposes a callback method that is called when the data request
 * is successful.
 */
class YTData extends __WEBPACK_IMPORTED_MODULE_0__auth__["default"] {
  constructor() {
    super();
  }

  /**
   * Requests user YT Data once the access token is recieved on sign in before
   * firing the callback.
   * @param {!Object} user The user data tree given by Firebase when signed in.
   */
  onSignIn(user) {
    this.getAccessToken_(user).then((token) => {
      const data = window.sessionStorage.getItem(SessionStorageKeys_.DATA);
      const uid = window.sessionStorage.getItem(SessionStorageKeys_.UID);
      const timestamp =
          window.sessionStorage.getItem(SessionStorageKeys_.TIMESTAMP);
      const hasBeen24hrs = Date.now() - timestamp >= ONE_DAY_;

      if (data && (uid === user.uid) && !hasBeen24hrs) {
        // Session storage data is available, it belongs to the same user and
        // and it has been less than 24hrs old.
        this.onYTDataReady(user, JSON.parse(data));
      } else {
        // Session storage data is not availabe; make a new request.
        this.dataRequest_(user, token);
      }
    });
  }

  /**
   * Removes the access token from session storage on sign out.
   */
  onSignOut() {
    window.sessionStorage.clear();
  }

  /**
   * Empty method that is called when the data request is successful.
   * @param {!Object} user The user data tree given by Firebase when signed in.
   * @param {!Object} data The user's YouTube data tree.
   */
  onYTDataReady(user, data) {};

  /**
   * Gets an access token from the sign in results and stores it in session
   * storage. If the user is returning to the page and is still signed in, then
   * the access token in session storage is used. If that's missing, the user is
   * forced to sign back in to create a new access token.
   * @param {!Object} user The user data tree given by Firebase when signed in.
   * @return {!Promise}
   * @private
   */
  getAccessToken_(user) {
    const promise = new Promise((resolve, reject) => {
      let token;

      __WEBPACK_IMPORTED_MODULE_0__auth__["default"].FB_AUTH.getRedirectResult().then((result) => {
        if (result.credential) {
          // User newly signed in so store the access token.
          token = result.credential.accessToken;

          window.sessionStorage.setItem(SessionStorageKeys_.TOKEN, token);
          resolve(token);
          return;
        };

        // Previously stored access token.
        token = window.sessionStorage.getItem(SessionStorageKeys_.TOKEN);

        if (token) {
          // Acess token is available in session storage.
          resolve(token);
        } else {
          // The access token is missing from session storage, so the user needs
          // to sign in to get a new one.
          __WEBPACK_IMPORTED_MODULE_0__auth__["default"].signOut();
          reject();
        }
      });
    });

    return promise;
  }

  /**
   * Makes a request to the YT Data API.
   * @param {!Object} user The user data tree given by Firebase when signed in.
   * @param {string} token The access token.
   * @private
   */
  dataRequest_(user, token) {
    const http = new XMLHttpRequest();

    http.onreadystatechange = () => {
      if (http.readyState == 4 && http.status == 200) {
        // Successful request.
        const data = JSON.parse(http.responseText);

        // Store data.
        window.sessionStorage.setItem(
            SessionStorageKeys_.DATA, http.responseText);

        // Store UID.
        window.sessionStorage.setItem(SessionStorageKeys_.UID, user.uid);

        // Store Timestamp.
        window.sessionStorage.setItem(
            SessionStorageKeys_.TIMESTAMP, Date.now());

        // Callback.
        this.onYTDataReady(user, data);
      } else if (http.status == 401) {
        // Time to refresh the access token.
        __WEBPACK_IMPORTED_MODULE_0__auth__["default"].signOut();
      }
    };

    http.open('GET', YT_DATA_ENDPOINT_ + token, true);
    http.send();
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = YTData;



/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(68);
__webpack_require__(141);
__webpack_require__(53);
__webpack_require__(28);
__webpack_require__(4);
__webpack_require__(33);
__webpack_require__(31);
__webpack_require__(66);
__webpack_require__(142);
__webpack_require__(34);
__webpack_require__(35);
__webpack_require__(23);
__webpack_require__(10);
__webpack_require__(36);
__webpack_require__(37);
__webpack_require__(52);
__webpack_require__(51);
__webpack_require__(143);
__webpack_require__(144);
__webpack_require__(145);
__webpack_require__(47);
__webpack_require__(48);
__webpack_require__(49);
module.exports = __webpack_require__(50);


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_ripple__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pages__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__pages_benefits_bronze__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pages_benefits_graphite__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pages_benefits_opal__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pages_benefits_silver__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pages_benefits__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pages_awards__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__creators_banner_banner__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__creators_banner_constants__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__google_youtube_src_components_accordion__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__google_youtube_src_components_accordion_accordion_drawer__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__google_youtube_src_components_auto_scroll__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__google_youtube_src_components_header_nav__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__google_youtube_src_components_footer__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__google_youtube_src_providers_local_store_local_store__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__google_youtube_src_components_yt_player__ = __webpack_require__(123);
// Import MDCs.


// Import Page constructors.










// Import Lazy Bones components amd providers.









// Register and autoinit Page constructors.
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('IndexPage', __WEBPACK_IMPORTED_MODULE_1__pages__["default"]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('Benefits', __WEBPACK_IMPORTED_MODULE_6__pages_benefits__["default"]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('Graphite', __WEBPACK_IMPORTED_MODULE_3__pages_benefits_graphite__["default"]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('Opal', __WEBPACK_IMPORTED_MODULE_4__pages_benefits_opal__["default"]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('Bronze', __WEBPACK_IMPORTED_MODULE_2__pages_benefits_bronze__["default"]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('Silver', __WEBPACK_IMPORTED_MODULE_5__pages_benefits_silver__["default"]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('Awards', __WEBPACK_IMPORTED_MODULE_7__pages_awards__["default"]);

// Register and autoinit MDCs and Lazy Bones components.
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('LBAccordion', __WEBPACK_IMPORTED_MODULE_10__google_youtube_src_components_accordion__["a" /* LBAccordion */]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('LBAccordionDrawer', __WEBPACK_IMPORTED_MODULE_11__google_youtube_src_components_accordion_accordion_drawer__["a" /* LBAccordionDrawer */]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('MDCRipple', __WEBPACK_IMPORTED_MODULE_0__material_ripple__["a" /* MDCRipple */]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('LBAutoScroll', __WEBPACK_IMPORTED_MODULE_12__google_youtube_src_components_auto_scroll__["a" /* LBAutoScroll */]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('LBNav', __WEBPACK_IMPORTED_MODULE_13__google_youtube_src_components_header_nav__["a" /* LBNav */]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('LBFooter', __WEBPACK_IMPORTED_MODULE_15__google_youtube_src_components_footer__["a" /* LBFooter */]);
__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */].register('YTPlayer', __WEBPACK_IMPORTED_MODULE_17__google_youtube_src_components_yt_player__["a" /* default */]);


const localStore = new __WEBPACK_IMPORTED_MODULE_16__google_youtube_src_providers_local_store_local_store__["a" /* default */](__WEBPACK_IMPORTED_MODULE_9__creators_banner_constants__["localStorageBannerKey"]);
  new __WEBPACK_IMPORTED_MODULE_8__creators_banner_banner__["default"](localStore);

Object(__WEBPACK_IMPORTED_MODULE_14__google_youtube_src_providers_auto_init_auto_init__["a" /* lbAutoInit */])();


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_foundation__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util__ = __webpack_require__(22);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */






/**
 * @typedef {{
 *   isActivated: (boolean|undefined),
 *   hasDeactivationUXRun: (boolean|undefined),
 *   wasActivatedByPointer: (boolean|undefined),
 *   wasElementMadeActive: (boolean|undefined),
 *   activationEvent: Event,
 *   isProgrammatic: (boolean|undefined)
 * }}
 */
let ActivationStateType;

/**
 * @typedef {{
 *   activate: (string|undefined),
 *   deactivate: (string|undefined),
 *   focus: (string|undefined),
 *   blur: (string|undefined)
 * }}
 */
let ListenerInfoType;

/**
 * @typedef {{
 *   activate: function(!Event),
 *   deactivate: function(!Event),
 *   focus: function(),
 *   blur: function()
 * }}
 */
let ListenersType;

/**
 * @typedef {{
 *   x: number,
 *   y: number
 * }}
 */
let PointType;

// Activation events registered on the root element of each instance for activation
const ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

// Deactivation events registered on documentElement when a pointer-related down event occurs
const POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

// Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
/** @type {!Array<!EventTarget>} */
let activatedTargets = [];

/**
 * @extends {MDCFoundation<!MDCRippleAdapter>}
 */
class MDCRippleFoundation extends __WEBPACK_IMPORTED_MODULE_0__material_base_foundation__["a" /* default */] {
  static get cssClasses() {
    return __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */];
  }

  static get strings() {
    return __WEBPACK_IMPORTED_MODULE_2__constants__["c" /* strings */];
  }

  static get numbers() {
    return __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* numbers */];
  }

  static get defaultAdapter() {
    return {
      browserSupportsCssVars: () => /* boolean - cached */ {},
      isUnbounded: () => /* boolean */ {},
      isSurfaceActive: () => /* boolean */ {},
      isSurfaceDisabled: () => /* boolean */ {},
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      containsEventTarget: (/* target: !EventTarget */) => {},
      registerInteractionHandler: (/* evtType: string, handler: EventListener */) => {},
      deregisterInteractionHandler: (/* evtType: string, handler: EventListener */) => {},
      registerDocumentInteractionHandler: (/* evtType: string, handler: EventListener */) => {},
      deregisterDocumentInteractionHandler: (/* evtType: string, handler: EventListener */) => {},
      registerResizeHandler: (/* handler: EventListener */) => {},
      deregisterResizeHandler: (/* handler: EventListener */) => {},
      updateCssVariable: (/* varName: string, value: string */) => {},
      computeBoundingRect: () => /* ClientRect */ {},
      getWindowPageOffset: () => /* {x: number, y: number} */ {},
    };
  }

  constructor(adapter) {
    super(Object.assign(MDCRippleFoundation.defaultAdapter, adapter));

    /** @private {number} */
    this.layoutFrame_ = 0;

    /** @private {!ClientRect} */
    this.frame_ = /** @type {!ClientRect} */ ({width: 0, height: 0});

    /** @private {!ActivationStateType} */
    this.activationState_ = this.defaultActivationState_();

    /** @private {number} */
    this.initialSize_ = 0;

    /** @private {number} */
    this.maxRadius_ = 0;

    /** @private {function(!Event)} */
    this.activateHandler_ = (e) => this.activate_(e);

    /** @private {function(!Event)} */
    this.deactivateHandler_ = (e) => this.deactivate_(e);

    /** @private {function(?Event=)} */
    this.focusHandler_ = () => this.handleFocus();

    /** @private {function(?Event=)} */
    this.blurHandler_ = () => this.handleBlur();

    /** @private {!Function} */
    this.resizeHandler_ = () => this.layout();

    /** @private {{left: number, top:number}} */
    this.unboundedCoords_ = {
      left: 0,
      top: 0,
    };

    /** @private {number} */
    this.fgScale_ = 0;

    /** @private {number} */
    this.activationTimer_ = 0;

    /** @private {number} */
    this.fgDeactivationRemovalTimer_ = 0;

    /** @private {boolean} */
    this.activationAnimationHasEnded_ = false;

    /** @private {!Function} */
    this.activationTimerCallback_ = () => {
      this.activationAnimationHasEnded_ = true;
      this.runDeactivationUXLogicIfReady_();
    };

    /** @private {?Event} */
    this.previousActivationEvent_ = null;
  }

  /**
   * We compute this property so that we are not querying information about the client
   * until the point in time where the foundation requests it. This prevents scenarios where
   * client-side feature-detection may happen too early, such as when components are rendered on the server
   * and then initialized at mount time on the client.
   * @return {boolean}
   * @private
   */
  supportsPressRipple_() {
    return this.adapter_.browserSupportsCssVars();
  }

  /**
   * @return {!ActivationStateType}
   */
  defaultActivationState_() {
    return {
      isActivated: false,
      hasDeactivationUXRun: false,
      wasActivatedByPointer: false,
      wasElementMadeActive: false,
      activationEvent: null,
      isProgrammatic: false,
    };
  }

  /** @override */
  init() {
    const supportsPressRipple = this.supportsPressRipple_();

    this.registerRootHandlers_(supportsPressRipple);

    if (supportsPressRipple) {
      const {ROOT, UNBOUNDED} = MDCRippleFoundation.cssClasses;
      requestAnimationFrame(() => {
        this.adapter_.addClass(ROOT);
        if (this.adapter_.isUnbounded()) {
          this.adapter_.addClass(UNBOUNDED);
          // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
          this.layoutInternal_();
        }
      });
    }
  }

  /** @override */
  destroy() {
    if (this.supportsPressRipple_()) {
      if (this.activationTimer_) {
        clearTimeout(this.activationTimer_);
        this.activationTimer_ = 0;
        this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
      }

      if (this.fgDeactivationRemovalTimer_) {
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.fgDeactivationRemovalTimer_ = 0;
        this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
      }

      const {ROOT, UNBOUNDED} = MDCRippleFoundation.cssClasses;
      requestAnimationFrame(() => {
        this.adapter_.removeClass(ROOT);
        this.adapter_.removeClass(UNBOUNDED);
        this.removeCssVars_();
      });
    }

    this.deregisterRootHandlers_();
    this.deregisterDeactivationHandlers_();
  }

  /**
   * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
   * @private
   */
  registerRootHandlers_(supportsPressRipple) {
    if (supportsPressRipple) {
      ACTIVATION_EVENT_TYPES.forEach((type) => {
        this.adapter_.registerInteractionHandler(type, this.activateHandler_);
      });
      if (this.adapter_.isUnbounded()) {
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }

    this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
    this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
  }

  /**
   * @param {!Event} e
   * @private
   */
  registerDeactivationHandlers_(e) {
    if (e.type === 'keydown') {
      this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
    } else {
      POINTER_DEACTIVATION_EVENT_TYPES.forEach((type) => {
        this.adapter_.registerDocumentInteractionHandler(type, this.deactivateHandler_);
      });
    }
  }

  /** @private */
  deregisterRootHandlers_() {
    ACTIVATION_EVENT_TYPES.forEach((type) => {
      this.adapter_.deregisterInteractionHandler(type, this.activateHandler_);
    });
    this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
    this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

    if (this.adapter_.isUnbounded()) {
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  }

  /** @private */
  deregisterDeactivationHandlers_() {
    this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
    POINTER_DEACTIVATION_EVENT_TYPES.forEach((type) => {
      this.adapter_.deregisterDocumentInteractionHandler(type, this.deactivateHandler_);
    });
  }

  /** @private */
  removeCssVars_() {
    const {strings} = MDCRippleFoundation;
    Object.keys(strings).forEach((k) => {
      if (k.indexOf('VAR_') === 0) {
        this.adapter_.updateCssVariable(strings[k], null);
      }
    });
  }

  /**
   * @param {?Event} e
   * @private
   */
  activate_(e) {
    if (this.adapter_.isSurfaceDisabled()) {
      return;
    }

    const activationState = this.activationState_;
    if (activationState.isActivated) {
      return;
    }

    // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
    const previousActivationEvent = this.previousActivationEvent_;
    const isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
    if (isSameInteraction) {
      return;
    }

    activationState.isActivated = true;
    activationState.isProgrammatic = e === null;
    activationState.activationEvent = e;
    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : (
      e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown'
    );

    const hasActivatedChild =
      e && activatedTargets.length > 0 && activatedTargets.some((target) => this.adapter_.containsEventTarget(target));
    if (hasActivatedChild) {
      // Immediately reset activation state, while preserving logic that prevents touch follow-on events
      this.resetActivationState_();
      return;
    }

    if (e) {
      activatedTargets.push(/** @type {!EventTarget} */ (e.target));
      this.registerDeactivationHandlers_(e);
    }

    activationState.wasElementMadeActive = this.checkElementMadeActive_(e);
    if (activationState.wasElementMadeActive) {
      this.animateActivation_();
    }

    requestAnimationFrame(() => {
      // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
      activatedTargets = [];

      if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
        // If space was pressed, try again within an rAF call to detect :active, because different UAs report
        // active states inconsistently when they're called within event handling code:
        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
        // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
        // variable is set within a rAF callback for a submit button interaction (#2241).
        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);
        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }
      }

      if (!activationState.wasElementMadeActive) {
        // Reset activation state immediately if element was not made active.
        this.activationState_ = this.defaultActivationState_();
      }
    });
  }

  /**
   * @param {?Event} e
   * @private
   */
  checkElementMadeActive_(e) {
    return (e && e.type === 'keydown') ? this.adapter_.isSurfaceActive() : true;
  }

  /**
   * @param {?Event=} event Optional event containing position information.
   */
  activate(event = null) {
    this.activate_(event);
  }

  /** @private */
  animateActivation_() {
    const {VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END} = MDCRippleFoundation.strings;
    const {FG_DEACTIVATION, FG_ACTIVATION} = MDCRippleFoundation.cssClasses;
    const {DEACTIVATION_TIMEOUT_MS} = MDCRippleFoundation.numbers;

    this.layoutInternal_();

    let translateStart = '';
    let translateEnd = '';

    if (!this.adapter_.isUnbounded()) {
      const {startPoint, endPoint} = this.getFgTranslationCoordinates_();
      translateStart = `${startPoint.x}px, ${startPoint.y}px`;
      translateEnd = `${endPoint.x}px, ${endPoint.y}px`;
    }

    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
    // Cancel any ongoing activation/deactivation animations
    clearTimeout(this.activationTimer_);
    clearTimeout(this.fgDeactivationRemovalTimer_);
    this.rmBoundedActivationClasses_();
    this.adapter_.removeClass(FG_DEACTIVATION);

    // Force layout in order to re-trigger the animation.
    this.adapter_.computeBoundingRect();
    this.adapter_.addClass(FG_ACTIVATION);
    this.activationTimer_ = setTimeout(() => this.activationTimerCallback_(), DEACTIVATION_TIMEOUT_MS);
  }

  /**
   * @private
   * @return {{startPoint: PointType, endPoint: PointType}}
   */
  getFgTranslationCoordinates_() {
    const {activationEvent, wasActivatedByPointer} = this.activationState_;

    let startPoint;
    if (wasActivatedByPointer) {
      startPoint = Object(__WEBPACK_IMPORTED_MODULE_3__util__["c" /* getNormalizedEventCoords */])(
        /** @type {!Event} */ (activationEvent),
        this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect()
      );
    } else {
      startPoint = {
        x: this.frame_.width / 2,
        y: this.frame_.height / 2,
      };
    }
    // Center the element around the start point.
    startPoint = {
      x: startPoint.x - (this.initialSize_ / 2),
      y: startPoint.y - (this.initialSize_ / 2),
    };

    const endPoint = {
      x: (this.frame_.width / 2) - (this.initialSize_ / 2),
      y: (this.frame_.height / 2) - (this.initialSize_ / 2),
    };

    return {startPoint, endPoint};
  }

  /** @private */
  runDeactivationUXLogicIfReady_() {
    // This method is called both when a pointing device is released, and when the activation animation ends.
    // The deactivation animation should only run after both of those occur.
    const {FG_DEACTIVATION} = MDCRippleFoundation.cssClasses;
    const {hasDeactivationUXRun, isActivated} = this.activationState_;
    const activationHasEnded = hasDeactivationUXRun || !isActivated;

    if (activationHasEnded && this.activationAnimationHasEnded_) {
      this.rmBoundedActivationClasses_();
      this.adapter_.addClass(FG_DEACTIVATION);
      this.fgDeactivationRemovalTimer_ = setTimeout(() => {
        this.adapter_.removeClass(FG_DEACTIVATION);
      }, __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* numbers */].FG_DEACTIVATION_MS);
    }
  }

  /** @private */
  rmBoundedActivationClasses_() {
    const {FG_ACTIVATION} = MDCRippleFoundation.cssClasses;
    this.adapter_.removeClass(FG_ACTIVATION);
    this.activationAnimationHasEnded_ = false;
    this.adapter_.computeBoundingRect();
  }

  resetActivationState_() {
    this.previousActivationEvent_ = this.activationState_.activationEvent;
    this.activationState_ = this.defaultActivationState_();
    // Touch devices may fire additional events for the same interaction within a short time.
    // Store the previous event until it's safe to assume that subsequent events are for new interactions.
    setTimeout(() => this.previousActivationEvent_ = null, MDCRippleFoundation.numbers.TAP_DELAY_MS);
  }

  /**
   * @param {?Event} e
   * @private
   */
  deactivate_(e) {
    const activationState = this.activationState_;
    // This can happen in scenarios such as when you have a keyup event that blurs the element.
    if (!activationState.isActivated) {
      return;
    }

    const state = /** @type {!ActivationStateType} */ (Object.assign({}, activationState));

    if (activationState.isProgrammatic) {
      const evtObject = null;
      requestAnimationFrame(() => this.animateDeactivation_(evtObject, state));
      this.resetActivationState_();
    } else {
      this.deregisterDeactivationHandlers_();
      requestAnimationFrame(() => {
        this.activationState_.hasDeactivationUXRun = true;
        this.animateDeactivation_(e, state);
        this.resetActivationState_();
      });
    }
  }

  /**
   * @param {?Event=} event Optional event containing position information.
   */
  deactivate(event = null) {
    this.deactivate_(event);
  }

  /**
   * @param {Event} e
   * @param {!ActivationStateType} options
   * @private
   */
  animateDeactivation_(e, {wasActivatedByPointer, wasElementMadeActive}) {
    if (wasActivatedByPointer || wasElementMadeActive) {
      this.runDeactivationUXLogicIfReady_();
    }
  }

  layout() {
    if (this.layoutFrame_) {
      cancelAnimationFrame(this.layoutFrame_);
    }
    this.layoutFrame_ = requestAnimationFrame(() => {
      this.layoutInternal_();
      this.layoutFrame_ = 0;
    });
  }

  /** @private */
  layoutInternal_() {
    this.frame_ = this.adapter_.computeBoundingRect();
    const maxDim = Math.max(this.frame_.height, this.frame_.width);

    // Surface diameter is treated differently for unbounded vs. bounded ripples.
    // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
    // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
    // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
    // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
    // `overflow: hidden`.
    const getBoundedRadius = () => {
      const hypotenuse = Math.sqrt(Math.pow(this.frame_.width, 2) + Math.pow(this.frame_.height, 2));
      return hypotenuse + MDCRippleFoundation.numbers.PADDING;
    };

    this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

    // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
    this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
    this.fgScale_ = this.maxRadius_ / this.initialSize_;

    this.updateLayoutCssVars_();
  }

  /** @private */
  updateLayoutCssVars_() {
    const {
      VAR_FG_SIZE, VAR_LEFT, VAR_TOP, VAR_FG_SCALE,
    } = MDCRippleFoundation.strings;

    this.adapter_.updateCssVariable(VAR_FG_SIZE, `${this.initialSize_}px`);
    this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

    if (this.adapter_.isUnbounded()) {
      this.unboundedCoords_ = {
        left: Math.round((this.frame_.width / 2) - (this.initialSize_ / 2)),
        top: Math.round((this.frame_.height / 2) - (this.initialSize_ / 2)),
      };

      this.adapter_.updateCssVariable(VAR_LEFT, `${this.unboundedCoords_.left}px`);
      this.adapter_.updateCssVariable(VAR_TOP, `${this.unboundedCoords_.top}px`);
    }
  }

  /** @param {boolean} unbounded */
  setUnbounded(unbounded) {
    const {UNBOUNDED} = MDCRippleFoundation.cssClasses;
    if (unbounded) {
      this.adapter_.addClass(UNBOUNDED);
    } else {
      this.adapter_.removeClass(UNBOUNDED);
    }
  }

  handleFocus() {
    requestAnimationFrame(() =>
      this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED));
  }

  handleBlur() {
    requestAnimationFrame(() =>
      this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (MDCRippleFoundation);


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return strings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return numbers; });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

const cssClasses = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  ROOT: 'mdc-ripple-upgraded',
  UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
};

const strings = {
  VAR_LEFT: '--mdc-ripple-left',
  VAR_TOP: '--mdc-ripple-top',
  VAR_FG_SIZE: '--mdc-ripple-fg-size',
  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
};

const numbers = {
  PADDING: 10,
  INITIAL_ORIGIN_SCALE: 0.6,
  DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
  FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
  TAP_DELAY_MS: 300, // Delay between touch and simulated mouse events on touch devices
};




/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_index__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ripple_index__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util__ = __webpack_require__(74);
/* unused harmony reexport MDCDialogFoundation */
/* unused harmony reexport util */
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */










class MDCDialog extends __WEBPACK_IMPORTED_MODULE_0__material_base_index__["a" /* MDCComponent */] {
  static attachTo(root) {
    return new MDCDialog(root);
  }

  get open() {
    return this.foundation_.isOpen();
  }

  get acceptButton_() {
    return this.root_.querySelector(__WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* default */].strings.ACCEPT_SELECTOR);
  }

  get dialogSurface_() {
    return this.root_.querySelector(__WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* default */].strings.DIALOG_SURFACE_SELECTOR);
  }

  initialize() {
    this.focusTrap_ = __WEBPACK_IMPORTED_MODULE_3__util__["a" /* createFocusTrapInstance */](this.dialogSurface_, this.acceptButton_);
    this.footerBtnRipples_ = [];

    const footerBtns = this.root_.querySelectorAll('.mdc-dialog__footer__button');
    for (let i = 0, footerBtn; footerBtn = footerBtns[i]; i++) {
      this.footerBtnRipples_.push(new __WEBPACK_IMPORTED_MODULE_1__material_ripple_index__["a" /* MDCRipple */](footerBtn));
    }
  }

  destroy() {
    this.footerBtnRipples_.forEach((ripple) => ripple.destroy());
    super.destroy();
  }

  show() {
    this.foundation_.open();
  }

  close() {
    this.foundation_.close();
  }

  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* default */]({
      addClass: (className) => this.root_.classList.add(className),
      removeClass: (className) => this.root_.classList.remove(className),
      addBodyClass: (className) => document.body.classList.add(className),
      removeBodyClass: (className) => document.body.classList.remove(className),
      eventTargetHasClass: (target, className) => target.classList.contains(className),
      registerInteractionHandler: (evt, handler) => this.root_.addEventListener(evt, handler),
      deregisterInteractionHandler: (evt, handler) => this.root_.removeEventListener(evt, handler),
      registerSurfaceInteractionHandler: (evt, handler) => this.dialogSurface_.addEventListener(evt, handler),
      deregisterSurfaceInteractionHandler: (evt, handler) => this.dialogSurface_.removeEventListener(evt, handler),
      registerDocumentKeydownHandler: (handler) => document.addEventListener('keydown', handler),
      deregisterDocumentKeydownHandler: (handler) => document.removeEventListener('keydown', handler),
      notifyAccept: () => this.emit(__WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* default */].strings.ACCEPT_EVENT),
      notifyCancel: () => this.emit(__WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* default */].strings.CANCEL_EVENT),
      trapFocusOnSurface: () => this.focusTrap_.activate(),
      untrapFocusOnSurface: () => this.focusTrap_.deactivate(),
      isDialog: (el) => el === this.dialogSurface_,
    });
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MDCDialog;



/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_index__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(73);
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */




class MDCDialogFoundation extends __WEBPACK_IMPORTED_MODULE_0__material_base_index__["b" /* MDCFoundation */] {
  static get cssClasses() {
    return __WEBPACK_IMPORTED_MODULE_1__constants__["a" /* cssClasses */];
  }

  static get strings() {
    return __WEBPACK_IMPORTED_MODULE_1__constants__["c" /* strings */];
  }

  static get numbers() {
    return __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* numbers */];
  }

  static get defaultAdapter() {
    return ({
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      addBodyClass: (/* className: string */) => {},
      removeBodyClass: (/* className: string */) => {},
      eventTargetHasClass: (/* target: EventTarget, className: string */) => /* boolean */ false,
      registerInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      deregisterInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      registerSurfaceInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      deregisterSurfaceInteractionHandler: (/* evt: string, handler: EventListener */) => {},
      registerDocumentKeydownHandler: (/* handler: EventListener */) => {},
      deregisterDocumentKeydownHandler: (/* handler: EventListener */) => {},
      notifyAccept: () => {},
      notifyCancel: () => {},
      trapFocusOnSurface: () => {},
      untrapFocusOnSurface: () => {},
      isDialog: (/* el: Element */) => /* boolean */ false,
    });
  }

  constructor(adapter) {
    super(Object.assign(MDCDialogFoundation.defaultAdapter, adapter));
    this.isOpen_ = false;
    this.componentClickHandler_ = (evt) => {
      if (this.adapter_.eventTargetHasClass(evt.target, __WEBPACK_IMPORTED_MODULE_1__constants__["a" /* cssClasses */].BACKDROP)) {
        this.cancel(true);
      }
    };
    this.dialogClickHandler_ = (evt) => this.handleDialogClick_(evt);
    this.documentKeydownHandler_ = (evt) => {
      if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
        this.cancel(true);
      }
    };

    this.timerId_ = 0;
    this.animationTimerEnd_ = (evt) => this.handleAnimationTimerEnd_(evt);
  };

  destroy() {
    // Ensure that dialog is cleaned up when destroyed
    if (this.isOpen_) {
      this.close();
    }
    // Final cleanup of animating class in case the timer has not completed.
    this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
    clearTimeout(this.timerId_);
  }

  open() {
    this.isOpen_ = true;
    this.disableScroll_();
    this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
    this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
    clearTimeout(this.timerId_);
    this.timerId_ = setTimeout(this.animationTimerEnd_, MDCDialogFoundation.numbers.DIALOG_ANIMATION_TIME_MS);
    this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
    this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
  }

  close() {
    this.isOpen_ = false;
    this.enableScroll_();
    this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
    this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
    this.adapter_.untrapFocusOnSurface();
    clearTimeout(this.timerId_);
    this.timerId_ = setTimeout(this.animationTimerEnd_, MDCDialogFoundation.numbers.DIALOG_ANIMATION_TIME_MS);
    this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
    this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
  }

  isOpen() {
    return this.isOpen_;
  }

  accept(shouldNotify) {
    if (shouldNotify) {
      this.adapter_.notifyAccept();
    }

    this.close();
  }

  cancel(shouldNotify) {
    if (shouldNotify) {
      this.adapter_.notifyCancel();
    }

    this.close();
  }

  handleDialogClick_(evt) {
    const {target} = evt;
    if (this.adapter_.eventTargetHasClass(target, __WEBPACK_IMPORTED_MODULE_1__constants__["a" /* cssClasses */].ACCEPT_BTN)) {
      this.accept(true);
    } else if (this.adapter_.eventTargetHasClass(target, __WEBPACK_IMPORTED_MODULE_1__constants__["a" /* cssClasses */].CANCEL_BTN)) {
      this.cancel(true);
    }
  }

  handleAnimationTimerEnd_() {
    this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
    if (this.isOpen_) {
      this.adapter_.trapFocusOnSurface();
    }
  };

  disableScroll_() {
    this.adapter_.addBodyClass(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* cssClasses */].SCROLL_LOCK);
  }

  enableScroll_() {
    this.adapter_.removeBodyClass(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* cssClasses */].SCROLL_LOCK);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MDCDialogFoundation;



/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return strings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return numbers; });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

const cssClasses = {
  ROOT: 'mdc-dialog',
  OPEN: 'mdc-dialog--open',
  ANIMATING: 'mdc-dialog--animating',
  BACKDROP: 'mdc-dialog__backdrop',
  SCROLL_LOCK: 'mdc-dialog-scroll-lock',
  ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
  CANCEL_BTN: 'mdc-dialog__footer__button--cancel',
};

const strings = {
  OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
  DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
  ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
  ACCEPT_EVENT: 'MDCDialog:accept',
  CANCEL_EVENT: 'MDCDialog:cancel',
};

const numbers = {
  DIALOG_ANIMATION_TIME_MS: 120,
};




/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createFocusTrapInstance;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_focus_trap__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_focus_trap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_focus_trap__);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



function createFocusTrapInstance(surfaceEl, acceptButtonEl, focusTrapFactory = __WEBPACK_IMPORTED_MODULE_0_focus_trap___default.a) {
  return focusTrapFactory(surfaceEl, {
    initialFocus: acceptButtonEl,
    clickOutsideDeactivates: true,
  });
}


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var tabbable = __webpack_require__(76);

var listeningFocusTrap = null;

function focusTrap(element, userOptions) {
  var tabbableNodes = [];
  var firstTabbableNode = null;
  var lastTabbableNode = null;
  var nodeFocusedBeforeActivation = null;
  var active = false;
  var paused = false;
  var tabEvent = null;

  var container = (typeof element === 'string')
    ? document.querySelector(element)
    : element;

  var config = userOptions || {};
  config.returnFocusOnDeactivate = (userOptions && userOptions.returnFocusOnDeactivate !== undefined)
    ? userOptions.returnFocusOnDeactivate
    : true;
  config.escapeDeactivates = (userOptions && userOptions.escapeDeactivates !== undefined)
    ? userOptions.escapeDeactivates
    : true;

  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause,
  };

  return trap;

  function activate(activateOptions) {
    if (active) return;

    var defaultedActivateOptions = {
      onActivate: (activateOptions && activateOptions.onActivate !== undefined)
        ? activateOptions.onActivate
        : config.onActivate,
    };

    active = true;
    paused = false;
    nodeFocusedBeforeActivation = document.activeElement;

    if (defaultedActivateOptions.onActivate) {
      defaultedActivateOptions.onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!active) return;

    var defaultedDeactivateOptions = {
      returnFocus: (deactivateOptions && deactivateOptions.returnFocus !== undefined)
        ? deactivateOptions.returnFocus
        : config.returnFocusOnDeactivate,
      onDeactivate: (deactivateOptions && deactivateOptions.onDeactivate !== undefined)
        ? deactivateOptions.onDeactivate
        : config.onDeactivate,
    };

    removeListeners();

    if (defaultedDeactivateOptions.onDeactivate) {
      defaultedDeactivateOptions.onDeactivate();
    }

    if (defaultedDeactivateOptions.returnFocus) {
      setTimeout(function () {
        tryFocus(nodeFocusedBeforeActivation);
      }, 0);
    }

    active = false;
    paused = false;
    return this;
  }

  function pause() {
    if (paused || !active) return;
    paused = true;
    removeListeners();
  }

  function unpause() {
    if (!paused || !active) return;
    paused = false;
    addListeners();
  }

  function addListeners() {
    if (!active) return;

    // There can be only one listening focus trap at a time
    if (listeningFocusTrap) {
      listeningFocusTrap.pause();
    }
    listeningFocusTrap = trap;

    updateTabbableNodes();
    // Ensure that the focused element doesn't capture the event that caused the focus trap activation
    setTimeout(function () {
      tryFocus(firstFocusNode());
    }, 0);
    document.addEventListener('focus', checkFocus, true);
    document.addEventListener('click', checkClick, true);
    document.addEventListener('mousedown', checkPointerDown, true);
    document.addEventListener('touchstart', checkPointerDown, true);
    document.addEventListener('keydown', checkKey, true);

    return trap;
  }

  function removeListeners() {
    if (!active || listeningFocusTrap !== trap) return;

    document.removeEventListener('focus', checkFocus, true);
    document.removeEventListener('click', checkClick, true);
    document.removeEventListener('mousedown', checkPointerDown, true);
    document.removeEventListener('touchstart', checkPointerDown, true);
    document.removeEventListener('keydown', checkKey, true);

    listeningFocusTrap = null;

    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;
    if (!optionValue) {
      return null;
    }
    if (typeof optionValue === 'string') {
      node = document.querySelector(optionValue);
      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }
    if (typeof optionValue === 'function') {
      node = optionValue();
      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }
    return node;
  }

  function firstFocusNode() {
    var node;
    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(document.activeElement)) {
      node = document.activeElement;
    } else {
      node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error('You can\'t have a focus-trap without at least one focusable element');
    }

    return node;
  }

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event
  function checkPointerDown(e) {
    if (config.clickOutsideDeactivates && !container.contains(e.target)) {
      deactivate({ returnFocus: false });
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) return;
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function checkFocus(e) {
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
    // Checking for a blur method here resolves a Firefox issue (#15)
    if (typeof e.target.blur === 'function') e.target.blur();

    if (tabEvent) {
      readjustFocus(tabEvent);
    }
  }

  function checkKey(e) {
    if (e.key === 'Tab' || e.keyCode === 9) {
      handleTab(e);
    }

    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      deactivate();
    }
  }

  function handleTab(e) {
    updateTabbableNodes();

    if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
      return tabEvent = e;
    }

    e.preventDefault();
    var currentFocusIndex = tabbableNodes.indexOf(e.target);

    if (e.shiftKey) {
      if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
        return tryFocus(lastTabbableNode);
      }
      return tryFocus(tabbableNodes[currentFocusIndex - 1]);
    }

    if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);

    tryFocus(tabbableNodes[currentFocusIndex + 1]);
  }

  function updateTabbableNodes() {
    tabbableNodes = tabbable(container);
    firstTabbableNode = tabbableNodes[0];
    lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
  }

  function readjustFocus(e) {
    if (e.shiftKey) return tryFocus(lastTabbableNode);

    tryFocus(firstTabbableNode);
  }
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function tryFocus(node) {
  if (!node || !node.focus) return;
  if (node === document.activeElement)  return;

  node.focus();
  if (node.tagName.toLowerCase() === 'input') {
    node.select();
  }
}

module.exports = focusTrap;


/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = function(el, options) {
  options = options || {};

  var elementDocument = el.ownerDocument || el;
  var basicTabbables = [];
  var orderedTabbables = [];

  // A node is "available" if
  // - it's computed style
  var isUnavailable = createIsUnavailable(elementDocument);

  var candidateSelectors = [
    'input',
    'select',
    'a[href]',
    'textarea',
    'button',
    '[tabindex]',
  ];

  var candidates = el.querySelectorAll(candidateSelectors.join(','));

  if (options.includeContainer) {
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    if (
      candidateSelectors.some(function(candidateSelector) {
        return matches.call(el, candidateSelector);
      })
    ) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var candidate, candidateIndexAttr, candidateIndex;
  for (var i = 0, l = candidates.length; i < l; i++) {
    candidate = candidates[i];
    candidateIndexAttr = parseInt(candidate.getAttribute('tabindex'), 10)
    candidateIndex = isNaN(candidateIndexAttr) ? candidate.tabIndex : candidateIndexAttr;

    if (
      candidateIndex < 0
      || (candidate.tagName === 'INPUT' && candidate.type === 'hidden')
      || candidate.disabled
      || isUnavailable(candidate, elementDocument)
    ) {
      continue;
    }

    if (candidateIndex === 0) {
      basicTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        index: i,
        tabIndex: candidateIndex,
        node: candidate,
      });
    }
  }

  var tabbableNodes = orderedTabbables
    .sort(function(a, b) {
      return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
    })
    .map(function(a) {
      return a.node
    });

  Array.prototype.push.apply(tabbableNodes, basicTabbables);

  return tabbableNodes;
}

function createIsUnavailable(elementDocument) {
  // Node cache must be refreshed on every check, in case
  // the content of the element has changed
  var isOffCache = [];

  // "off" means `display: none;`, as opposed to "hidden",
  // which means `visibility: hidden;`. getComputedStyle
  // accurately reflects visiblity in context but not
  // "off" state, so we need to recursively check parents.

  function isOff(node, nodeComputedStyle) {
    if (node === elementDocument.documentElement) return false;

    // Find the cached node (Array.prototype.find not available in IE9)
    for (var i = 0, length = isOffCache.length; i < length; i++) {
      if (isOffCache[i][0] === node) return isOffCache[i][1];
    }

    nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);

    var result = false;

    if (nodeComputedStyle.display === 'none') {
      result = true;
    } else if (node.parentNode) {
      result = isOff(node.parentNode);
    }

    isOffCache.push([node, result]);

    return result;
  }

  return function isUnavailable(node) {
    if (node === elementDocument.documentElement) return false;

    var computedStyle = elementDocument.defaultView.getComputedStyle(node);

    if (isOff(node, computedStyle)) return true;

    return computedStyle.visibility === 'hidden';
  }
}


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base__ = __webpack_require__(0);



/**
 * Returns an empty foundation in order to have the YT Iframe API load via the
 * adapter.
 */
class LBIframeApiFoundation extends __WEBPACK_IMPORTED_MODULE_0__material_base__["b" /* MDCFoundation */] {
  static get defaultAdapter() {
    return {};
  }

  /**
   * @param {!Object} adapter
   */
  constructor(adapter) {
    super(Object.assign(LBIframeApiFoundation.defaultAdapter, adapter));
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBIframeApiFoundation;



/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_base__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);





/** @enum {!YT.Player} */
const YTPlayers = __WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* LBPlayerFoundation */].YTPlayers;

/**
 * Defines the YTPlayer adapter methods.
 */
class YTPlayer extends __WEBPACK_IMPORTED_MODULE_1__material_base__["a" /* MDCComponent */] {
  /**
   * Creates a new instance of the YTPlayer component.
   * @param {string} root The selector of the parent element.
   * @return {!YTPlayer}
   */
  static attachTo(root) {
    return new YTPlayer(root);
  }

  /**
   * Returns an instance of LBPlayerFoundation.
   * @return {!LBPlayerFoundation}
   */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_2__foundation__["a" /* LBPlayerFoundation */]({
      getAttr: (el, attr) => {
        return el.getAttribute(attr);
      },
      storePlayer: (list, player, id) => {
        list[id] = player;
      },
      play: (player) => {
        return player.playVideo();
      },
      pause: (player) => {
        return player.pauseVideo();
      },
      stop: (player) => {
        return player.stopVideo();
      },
      next: (player) => {
        return player.nextVideo();
      },
      previous: (player) => {
        return player.previousVideo();
      },
      cueVideo: (player, cueId) => {
        return player.cueVideoById(cueId);
      },
      cuePlaylist: (player, cueId) => {
        return player.cuePlaylist({
          listType: 'playlist',
          list: cueId,
        });
      },
      delegateEventHandler: (selector, eventType, handler) => {
        return Object(__WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* delegate */])(document, selector, eventType, handler);
      },
      undelegateEventHandler: (selector, eventType, handler) => {
        return Object(__WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["e" /* undelegate */])(document, selector, eventType, handler);
      },
    });
  }

  /**
   * Pauses all YouTube videos on the page before
   * playing current video.
   */
  playVideo() {
    this.foundation_.pauseAllOtherVideos({
      data: -1,
      target: this.playerInstance_,
    });

    this.pollPlayerState_(() => this.playerInstance_.playVideo());
  }

  /**
   * Ensures the `YT.Player` interface has loaded
   * before firing the `completeCallback`.
   * @param {?Function} completeCallback
   * @private
   */
  pollPlayerState_(completeCallback) {
    if ('playVideo' in this.playerInstance_) {
      completeCallback();
      window.clearTimeout(this.pollTimerId_);
      this.pollTimerId_ = null;
    } else {
      this.pollTimerId_ = window.setTimeout(
          this.pollPlayerState_.bind(this, completeCallback), 100);
    }
  }

  /**
   * Resets relevant `YTPlayer` and `YT.Player` states.
   */
  destroy() {
    if (this.playerInstance_ && ('stopVideo' in this.playerInstance_)) {
      this.playerInstance_.stopVideo();
      this.playerInstance_ = null;
    }

    if (this.pollTimerId_) {
      window.clearTimeout(this.pollTimerId_);
      this.pollTimerId_ = null;
    }

    if (YTPlayers[this.videoId_]) {
      delete YTPlayers[this.videoId_];
      this.videoId_ = '';
    }
  }

  /**
   * Gets and passes in the player settings to render.
   * @private
   */
  initialize() {
    /** @private {number} */
    this.pollTimerId_;

    /** @private {?window.YT.Player} */
    this.playerInstance_;

    /** @private {string} */
    this.videoId_ = '';

    const videoId = this.root_.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* Attrs */].VIDEO_ID);
    const parsedJSON = JSON.parse(this.root_.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* Attrs */].SETTINGS));
    // The following Object constructor coerces the result of JSON.parse to an
    // object, satisfying a GCC type warning.
    const userSettings =
        new Object(parsedJSON); // eslint-disable-line no-new-object
    const settings = Object.assign({}, __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* DEFAULT_SETTINGS */], userSettings);

    this.renderPlayer_(videoId, settings);
  }

  /**
   * Renders a YT player with the given settings.
   * @param {?string} videoId
   * @param {!Object<string, string|number>} settings
   * @private
   */
  renderPlayer_(videoId, settings) {
    videoId = settings.list ? undefined : videoId;

    const player = new window.YT.Player(this.root_, {
      height: '100',
      width: '100',
      videoId,
      // Learn more about events here:
      // https://developers.google.com/youtube/iframe_api_reference#Events
      events: {
        onReady: () => {
          this.foundation_.storePlayer(videoId, settings, player);
          this.foundation_.registerPlayerEvents();
        },
        onStateChange: (e) => {
          this.foundation_.pauseAllOtherVideos(e);
        },
      },
      // See all supported player vars here:
      // https://developers.google.com/youtube/player_parameters?playerVersion=HTML5#Parameters
      playerVars: settings,
    });

    this.playerInstance_ = player;
    this.videoId_ = videoId;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = YTPlayer;



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_base__ = __webpack_require__(0);




class LBPlayerFoundation extends __WEBPACK_IMPORTED_MODULE_1__material_base__["b" /* MDCFoundation */] {
  static get YTPlayers() {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["f" /* YTPlayers */];
  }

  /**
   * Returns an adapter with all functions defined.
   */
  static get defaultAdapter() {
    return {
      getAttr: (/* el: !Element, attr: string */) => /* string */ {},
      storePlayer: (/* list: !Array, player: !YT.Player, id: string */) => {},
      play: (/* player: !YT.Player */) => {},
      pause: (/* player: !YT.Player */) => {},
      stop: (/* player: !YT.Player */) => {},
      next: (/* player: !YT.Player */) => {},
      previous: (/* player: !YT.Player */) => {},
      cueVideo: (/* player: !YT.Player, cueId: string */) => {},
      cuePlaylist: (/* player: !YT.Player, cueId: string */) => {},
      delegateEventHandler: (/* selector: string, eventType: string,
          handler: !Function(?) */) => {},
      undelegateEventHandler: (/* selector: string, eventType: string,
          handler: !Function(?) */) => {},
    };
  }

  /**
   * Uses the YT Iframe API to attach a YT player onto each designated element
   * in the DOM. Event delegation is added to allow custom controls for each
   * player rendered.
   * @param {!Object} adapter
   */
  constructor(adapter) {
    super(Object.assign(LBPlayerFoundation.defaultAdapter, adapter));
    /**
     * Prevents adding the same event listeners multiple times.
     * @private {boolean}
     */
    this.eventsRegistered_ = false;
  }

  /**
   * Stores the YT player into an object in order to get it later. The key is
   * the initial video or playlist ID and the value is the YT.Player instance.
   * @param {?string} videoId
   * @param {!Object<string, string|number>} settings
   * @param {!YT.Player} player
   */
  storePlayer(videoId, settings, player) {
    const id = settings.list || videoId;
    this.adapter_.storePlayer(__WEBPACK_IMPORTED_MODULE_0__constants__["f" /* YTPlayers */], player, id);
  }

  /**
   * Pauses all other players when one is played.
   * @param {{
   *   data: !YT.PlayerState,
   *   target: !YT.Player,
   * }} e
   */
  pauseAllOtherVideos(e) {
    if (e.data == window.YT.PlayerState.PLAYING) {
      for (let key in __WEBPACK_IMPORTED_MODULE_0__constants__["f" /* YTPlayers */]) {
        if (e.target != __WEBPACK_IMPORTED_MODULE_0__constants__["f" /* YTPlayers */][key]) {
          this.adapter_.pause(__WEBPACK_IMPORTED_MODULE_0__constants__["f" /* YTPlayers */][key]);
        }
      }
    }
  }

  /**
   * Gets the value from the target's event attribute and parses it to decide
   * which YT API event to trigger.
   * @param {!Element} target The element being interacted with to manipulate
   *     the YT player.
   * @private
   */
  playerEventHandler_(target) {
    const parsedEvent = JSON.parse(this.adapter_.getAttr(target, __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* Attrs */].EVENT));
    const playerEvent = parsedEvent[__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* JsonKeys */].EVENT_TYPE];
    const playerId = parsedEvent[__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* JsonKeys */].PLAYER_ID];
    const cueId = parsedEvent[__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* JsonKeys */].CUE_ID];

    if (cueId) {
      this.adapter_[playerEvent](__WEBPACK_IMPORTED_MODULE_0__constants__["f" /* YTPlayers */][playerId], cueId);
    } else {
      this.adapter_[playerEvent](__WEBPACK_IMPORTED_MODULE_0__constants__["f" /* YTPlayers */][playerId]);
    }
  }

  /**
   * Delegates an event for elements with a specific selector that will allow
   * developers to build custom control for the YT players.
   */
  registerPlayerEvents() {
    if (this.eventsRegistered_) {
      return;
    }

    this.eventsRegistered_ = true;

    this.adapter_.delegateEventHandler(__WEBPACK_IMPORTED_MODULE_0__constants__["e" /* Selectors */].EVENT, 'click',
        this.playerEventHandler_.bind(this));
  }

  /**
   * Removes events from elements.
   */
  unregisterPlayerEvents() {
    if (!this.eventsRegistered_) {
      return;
    }

    this.eventsRegistered_ = false;

    this.adapter_.undelegateEventHandler(__WEBPACK_IMPORTED_MODULE_0__constants__["e" /* Selectors */].EVENT, 'click',
        this.playerEventHandler_.bind(this));
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBPlayerFoundation;



/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {string} */
const cssClasses = {};
/* unused harmony export cssClasses */


/** @const {!Object<string, string>} */
const re = {
  SINGLE_QUOTE: '\'',
  SINGLE_QUOTE_WITH_ALPHA_NUM: '[a-zA-Z0-9](\')[a-zA-Z0-9]',
  SINGLE_QUOTE_SLASH: '\\\\\'',
  SINGLE_QUOTE_ESCAPED: '&#39;',
  SINGLE_QUOTE_ENTITY: '&apos;',
  DOUBLE_QUOTE_ESCAPED: '&#34;',
  DOUBLE_QUOTE_ENTITY: '&quot;',
};
/* harmony export (immutable) */ __webpack_exports__["b"] = re;


/** @enum {string} */
const strings = {
  DEFAULT_OPTIONS_KEY: 'data-lb-options',
  DEFAULT_OPTIONS_KEY_LB: 'lb-options',
  EVENT_KEY_PREFIX: 'target.',
  CLICK_ACTION: 'click',
  IMPRESSION_ACTION: 'impression',
};
/* harmony export (immutable) */ __webpack_exports__["c"] = strings;


/** @enum {number} */
const numbers = {};
/* unused harmony export numbers */


/** @const {!Object<string, Array<*>>} */
const lists = {
  TRANSFORMS: [
    'translate',
    'translateX',
    'translateY',
    'translateZ',
    'translate3d',
    'scale',
    'scaleX',
    'scaleY',
    'scaleZ',
    'scale3d',
    'skew',
    'skewX',
    'skewY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'rotate3d',
    ],
};
/* harmony export (immutable) */ __webpack_exports__["a"] = lists;



/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base__ = __webpack_require__(0);


class LBGlueCarouselFoundation extends __WEBPACK_IMPORTED_MODULE_0__material_base__["b" /* MDCFoundation */] {
  static get defaultAdapter() {
    return {
      getOptions: () => /* Object */ ({}),
    };
  }

  constructor(adapter) {
    super(Object.assign(LBGlueCarouselFoundation.defaultAdapter, adapter));
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBGlueCarouselFoundation;



/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {string} */
const cssClasses = {};
/* unused harmony export cssClasses */


/** @enum {string} */
const strings = {
  OPTIONS_KEY: 'glue-carousel',
  MODEL_PREFIX: 'lb-carousel-model-',
  // Selectors
  GLUE_CAROUSEL_SELECTOR: '.glue-carousel',
  GLUE_PAGINATION_NEXT_SELECTOR: '.glue-pagination-next',
  GLUE_PAGINATION_PAGE_LIST_SELECTOR: '.glue-pagination-page-list',
  GLUE_PAGINATION_PREVIOUS_SELECTOR: '.glue-pagination-previous',
  // Attributes
  GLUE_PAGINATION_DATA: 'data-glue-pagination',
  CURRENT_PAGE_EVENT: 'gluepaginationcurrentpage',
};
/* harmony export (immutable) */ __webpack_exports__["b"] = strings;


/** @enum {Array<*>} */
const lists = {
  IGNORE_OPTIONS: ['startPage', 'cyclical'],
};
/* harmony export (immutable) */ __webpack_exports__["a"] = lists;



/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Carousel; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__image_adapter__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__image_foundation__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__elementstoggler__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__mdc_component__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pagination_modelfactory__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__options__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__mq_responsivemonitor__ = __webpack_require__(98);












/**
 * @final @extends {MDCComponent<!CarouselFoundation>}
 */
class Carousel extends __WEBPACK_IMPORTED_MODULE_5__mdc_component__["a" /* MDCComponent */] {

  static attachTo(root, options = {}) {
    return new Carousel(root, undefined, options);
  }

  constructor(root, foundation = undefined, ...args) {
    super(root, foundation, ...args);

    /** @private {Options|undefined} */
    this.options_;

    /** @private {ResponsiveMonitor|undefined} */
    this.rm_;

    this.monitorUnknownSizeImages_();

    const breakpoints = this.root_.dataset['glueCarouselBreakpoints'];
    if (breakpoints) {
      this.rm_ = new __WEBPACK_IMPORTED_MODULE_8__mq_responsivemonitor__["a" /* ResponsiveMonitor */]({
        breakpoint: breakpoints.split(','),
        enter: () => this.foundation_.start(),
        leave: () => this.foundation_.destroy(),
      });
    } else {
      this.foundation_.start();
    }
  }

  /** @param {Options=} opt_options */
  initialize(opt_options) {
    this.options_ = opt_options;
  }

  getDefaultFoundation() {
    const paginationModel = __WEBPACK_IMPORTED_MODULE_6__pagination_modelfactory__["a" /* ModelFactory */].get(
        this.root_.dataset['gluePagination']);
    const toggler = new __WEBPACK_IMPORTED_MODULE_4__elementstoggler__["a" /* ElementsToggler */](this.root_);
    const docEl = document.documentElement;

    const hammer = new Hammer.Manager(/** @type {!HTMLElement} */ (this.root_));
    hammer.add(new Hammer.Pan({direction: Hammer.DIRECTION_HORIZONTAL}));

    const /** !CarouselAdapter */ adapter = {
      countItems: () => this.root_.children.length,
      getPaginationModel: () => paginationModel,
      toggleElements: (displayMap, callback) => {
        toggler.toggleElements(displayMap);
        // {@code ElementsToggler} renders DOM updates immediately.
        callback();
      },
      resetElements: (callback) => {
        toggler.resetElements();
        // {@code ElementsToggler} renders DOM updates immediately.
        callback();
      },
      isRtl: () => docEl.dir == 'rtl',
      addClass: (className) => this.root_.classList.add(className),
      removeClass: (className) => this.root_.classList.remove(className),
      setStyle: (prop, value) => this.root_.style[prop] = value,
      focusTile: (el) => el.focus(),
      getParentElementWidth: () =>
          this.root_.parentNode.getBoundingClientRect().width,
      getChildElements: () => [...this.root_.children],
      getTileDimensions: (el) => el.getBoundingClientRect(),
      setTileStyle: (el, prop, value) => el.style[prop] = value,
      setTileAttr: (el, attr, value) => el.setAttribute(attr, value),
      rmTileAttr: (el, attr) => el.removeAttribute(attr),
      registerResizeHandler: (handler) =>
          window.addEventListener('resize', handler),
      deregisterResizeHandler: (handler) =>
          window.removeEventListener('resize', handler),
      registerSwipeStart: (handler) => {
        hammer.on('panstart', (event) => {
          handler({x: event.deltaX, y: event.deltaY});
        });
      },
      deregisterSwipeStart: (handler) => hammer.off('panstart', handler),
      registerSwipeMove: (handler) => {
        hammer.on('panmove', (event) => {
          handler({x: event.deltaX, y: event.deltaY});
        });
      },
      deregisterSwipeMove: (handler) => hammer.off('panmove', handler),
      registerSwipeEnd: (handler) => hammer.on('panend', handler),
      deregisterSwipeEnd: (handler) => hammer.off('panend', handler),
      registerSwipeCancel: (handler) => hammer.on('pancancel', handler),
      deregisterSwipeCancel: (handler) => hammer.off('pancancel', handler),
      registerMouseLeave: (handler) =>
          this.root_.addEventListener('mouseleave', handler),
      deregisterMouseLeave: (handler) =>
          this.root_.removeEventListener('mouseleave', handler),
    };

    return new __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* CarouselFoundation */](adapter, this.options_);
  }

  destroy() {
    super.destroy();
    this.rm_ && this.rm_.destroy();
  }

  refresh() {
    this.foundation_.refresh();
  }

  /** @return {!Array<Element>} */
  getAddedElements() {
    return this.foundation_.getAddedElements();
  }

  /**
   * @private
   */
  monitorUnknownSizeImages_() {
    const {UNKNOWN_SIZE_IMAGE_ELEMENTS} = __WEBPACK_IMPORTED_MODULE_3__image_foundation__["a" /* CarouselImageFoundation */].strings;
    const imageElements =
        this.root_.querySelectorAll(UNKNOWN_SIZE_IMAGE_ELEMENTS);

    for (let i = 0, len = imageElements.length; i < len; i++) {
      const imgEl = /** @type {!HTMLImageElement} */ (imageElements[i]);
      this.createCarouselImageComponent_(imgEl);
    }
  }

  /**
   * Components are created here instead of in distinct component classes,
   * because child images are unable to get a reference to the parent carousel
   * component instance, nor dispatch bubbling events to it since they can be
   * removed from the DOM when their load event is fired.
   * @param {!HTMLImageElement} el Image element
   * @private
   */
  createCarouselImageComponent_(el) {
    const /** @type {!CarouselImageAdapter} */ adapter = {
      getWidth: () => el.width,
      getHeight: () => el.height,
      isFetchingComplete: () => el.complete,
      registerLoadHandler: (handler) => el.addEventListener('load', handler),
      deregisterLoadHandler: (handler) =>
          el.removeEventListener('load', handler),
      notifyLoad: () => this.refresh(),
    };

    const carouselImageFoundation = new __WEBPACK_IMPORTED_MODULE_3__image_foundation__["a" /* CarouselImageFoundation */](adapter);
    carouselImageFoundation.init();
  }

}




/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Options */



/** @record */
function Options() {}

/** @type {number} */
Options.prototype.currentPage;

/** @type {number} */
Options.prototype.totalPages;

/** @type {number} */
Options.prototype.totalItems;

/** @type {number} */
Options.prototype.itemsPerPage;

/** @type {boolean} */
Options.prototype.cyclical;

/** @type {!Array<string>} */
Options.prototype.titles;

/** @type {number} */
Options.prototype.maxLength;

/** @type {number} */
Options.prototype.timer;

/** @type {string} */
Options.prototype.activeEl;




/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CarouselFoundation; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__options__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mdc_foundation__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__navigator__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pagination_model__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pagination_constants__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__renderer__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__swipe__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__tilemap_tilemap__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__constants__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__fx_easing__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__debounce_debounce__ = __webpack_require__(93);















/**
 * @final @extends {MDCFoundation<!glue.ui.carousel.CarouselAdapter>}
 */
class CarouselFoundation extends __WEBPACK_IMPORTED_MODULE_2__mdc_foundation__["a" /* MDCFoundation */] {

  static get cssClasses() {
    return __WEBPACK_IMPORTED_MODULE_9__constants__["a" /* cssClasses */];
  }

  static get numbers() {
    return __WEBPACK_IMPORTED_MODULE_9__constants__["b" /* numbers */];
  }

  /** @return {!Options} */
  static get defaults() {
    return {
      /** @export */
      elasticEdge: true,
      /** @export */
      edgeFriction: 4,
      /** @export */
      easing: __WEBPACK_IMPORTED_MODULE_10__fx_easing__["b" /* easeOutQuart */],
      /** @export */
      transitionDuration: .75,
      /** @export */
      expand: 0,
      /** @export */
      jump: false,
      /** @export */
      center: true,
      /** @export */
      group: false,
    };
  }

  /**
   * @param {!CarouselAdapter} adapter
   * @param {Object=} options
   */
  constructor(adapter, options = {}) {
    super(adapter);

    /** @private {!Element} */
    this.element_;

    /** @private {!PaginationModel} */
    this.paginationModel_;

    /** @private {!TileMap} */
    this.tileMap_;

    /** @private {!Renderer} */
    this.renderer_;

    /** @private {!Navigator} */
    this.navigator_;

    /** @private {!Swipe} */
    this.swipe_;

    /** @private {!Options} */
    this.options_ = /** @type {!Options} */ (
        Object.assign(CarouselFoundation.defaults, options));

    /** @private {!Function} */
    this.resizeDbcHandler_ = Object(__WEBPACK_IMPORTED_MODULE_11__debounce_debounce__["a" /* debounce */])(
        () => this.handleResize_(), CarouselFoundation.numbers.RESIZE_DELAY);

    /** @private {!Function} */
    this.currentPageHandler_ = this.update_.bind(this);

    /** @private {!Function} */
    this.previousTileHandler_ = this.selectPrevious_.bind(this);

    /** @private {!Function} */
    this.nextTileHandler_ = this.selectNext_.bind(this);

    /** @private {boolean} */
    this.isEnabled_ = false;
  }

  init() {
    this.paginationModel_ = this.adapter.getPaginationModel();
    this.paginationModel_.totalPages = this.adapter.countItems();
    this.paginationModel_.totalItems = this.paginationModel_.totalPages;
    this.paginationModel_.setFocusMainElementHandler(() => {
      const el = this.renderer_.getSnappedTileElement();
      el && this.adapter.focusTile(el);
    });

    this.tileMap_ = new __WEBPACK_IMPORTED_MODULE_8__tilemap_tilemap__["a" /* TileMap */](
        this.paginationModel_.cyclical,
        this.options_.elasticEdge,
        this.options_.center);

    this.tileMap_.frameExpand = this.options_.expand;

    this.renderer_ = new __WEBPACK_IMPORTED_MODULE_6__renderer__["a" /* Renderer */](this.tileMap_, this.adapter,
        this.options_.group);
    this.renderer_.resetElements();

    this.navigator_ = new __WEBPACK_IMPORTED_MODULE_3__navigator__["a" /* Navigator */](this.tileMap_, this.renderer_,
        this.options_);

    this.swipe_ = new __WEBPACK_IMPORTED_MODULE_7__swipe__["a" /* Swipe */](this.tileMap_, this.navigator_, this.adapter,
        this.updatePagination_.bind(this), this.options_);
  }

  start() {
    if (this.isEnabled_) return;
    this.isEnabled_ = true;

    this.swipe_.init();
    this.renderer_.init(() => {
      this.adapter.addClass(CarouselFoundation.cssClasses.READY);
      this.navigator_.selectTile(this.paginationModel_.currentPage - 1);
    });

    this.adapter.registerResizeHandler(this.resizeDbcHandler_);

    const {CURRENT_PAGE_EVENT, PREVIOUS_EVENT, NEXT_EVENT} = __WEBPACK_IMPORTED_MODULE_5__pagination_constants__["a" /* strings */];
    this.paginationModel_.listen(CURRENT_PAGE_EVENT, this.currentPageHandler_);
    this.paginationModel_.listen(PREVIOUS_EVENT, this.previousTileHandler_);
    this.paginationModel_.listen(NEXT_EVENT, this.nextTileHandler_);
  }

  destroy() {
    if (!this.isEnabled_) return;
    this.isEnabled_ = false;

    this.navigator_ && this.navigator_.stopAnimation();
    this.renderer_ && this.renderer_.resetElements();
    this.swipe_ && this.swipe_.destroy();

    this.adapter.removeClass(CarouselFoundation.cssClasses.READY);
    this.adapter.deregisterResizeHandler(this.resizeDbcHandler_);

    const {CURRENT_PAGE_EVENT, PREVIOUS_EVENT, NEXT_EVENT} = __WEBPACK_IMPORTED_MODULE_5__pagination_constants__["a" /* strings */];
    this.paginationModel_.unlisten(CURRENT_PAGE_EVENT,
        this.currentPageHandler_);
    this.paginationModel_.unlisten(PREVIOUS_EVENT, this.previousTileHandler_);
    this.paginationModel_.unlisten(NEXT_EVENT, this.nextTileHandler_);

    this.resizeDbcHandler_.cancel();

    this.paginationModel_.clearFocusMainElementHandler();
  }

  refresh() {
    if (!this.isEnabled_) return;
    this.renderer_.init(() => {
      this.navigator_.selectTile(this.paginationModel_.currentPage - 1);
    });
  }

  /**
   * Exposes the list of elements that were injected in the DOM during the last
   * draw cycle of the renderer.
   * @return {!Array<Element>}
   */
  getAddedElements() {
    return this.renderer_.getAddedElements();
  }

  /** @private */
  selectPrevious_() {
    this.navigator_.selectPrevious(this.updatePagination_.bind(this));
  }

  /** @private */
  selectNext_() {
    this.navigator_.selectNext(this.updatePagination_.bind(this));
  }

  /** @private */
  update_() {
    if (this.swipe_.isSwiping()) return;
    const snappedTile = this.tileMap_.getCurrentSnappedTile();
    if (snappedTile &&
        this.paginationModel_.currentPage != snappedTile.index + 1) {
      this.navigator_.selectTile(this.paginationModel_.currentPage - 1, true);
    }
  }

  /** @private */
  updatePagination_() {
    const snappedTile = this.tileMap_.getCurrentSnappedTile();
    if (snappedTile) {
      this.paginationModel_.currentPage = snappedTile.index + 1;
    }
  }

  /** @private */
  handleResize_() {
    const newFrameWidth = this.adapter.getParentElementWidth();
    if (newFrameWidth != this.tileMap_.frameWidth) {
      this.refresh();
    }
  }

}




/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FOCUSABLE_ELEMENT_SELECTORS; });
/* unused harmony export isElementFocusable */
/* unused harmony export getFocusableElements */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shim_elementmatches_elementmatches__ = __webpack_require__(87);
/**
 * @fileoverview Utilities relating to keyboard focus.
 *
 * TODO(glue-dev): Update modal and herc header to have utils here. b/34387433
 */





Object(__WEBPACK_IMPORTED_MODULE_0__shim_elementmatches_elementmatches__["a" /* enable */])();


/**
 * Query selectors for elements that can receive focus.
 * @const {Array<string>}
 */
const FOCUSABLE_ELEMENT_SELECTORS = [
  'input',
  'textarea',
  'select',
  'button',
  'iframe',
  '[role="button"]',
  'a',
  '[tabindex]',
];


/**
 * Returns true if the element is able to receive focus. Note that this will
 * return true even for elements where the user isn't able to move focus
 * to the element but javascript is able to move focus.
 * @param {HTMLElement} el The Element to check for focusability.
 * @return {boolean} Returns true if the element is focusable
 */
function isElementFocusable(el) {
  return FOCUSABLE_ELEMENT_SELECTORS.filter((selector) => {
    return el.matches(selector);
  }).length > 0;
};


/**
 * Get all child focusable elements.
 * @param {Element} el The parent element.
 * @return {!Array<Element>} Array containing all child focusable elements.
 */
function getFocusableElements(el) {
  var inputs = [].slice.apply(el.querySelectorAll('input'));
  var anchors = [].slice.apply(el.querySelectorAll('a'));
  var textareas = [].slice.apply(el.querySelectorAll('textarea'));
  var selects = [].slice.apply(el.querySelectorAll('select'));
  var buttons = [].slice.apply(el.querySelectorAll('button'));
  var iframes = [].slice.apply(el.querySelectorAll('iframe'));
  var roleBtnElements = [].slice.apply(el.querySelectorAll(
    '[role="button"]' +
    ':not(input)' +
    ':not(a)' +
    ':not(textarea)' +
    ':not(select)' +
    ':not(button)' +
    ':not(iframe)'));
  var tabindexElements =  [].slice.apply(el.querySelectorAll(
    '[tabindex="0"]' +
    ':not([role="button"])' +
    ':not(input)' +
    ':not(a)' +
    ':not(textarea)' +
    ':not(select)' +
    ':not(button)' +
    ':not(iframe)'));
  return inputs.concat(anchors).concat(textareas).concat(selects)
      .concat(buttons).concat(iframes).concat(roleBtnElements)
      .concat(tabindexElements);
};





/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = enable;
/**
 * @fileoverview Polyfill for Element.matches().
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
 */



/**
 * Enables polyfill for Element.matches().
 * @param {Window=} opt_window Reference to a window object.
 * @return {boolean} Whether the polyfill has been enabled. Will be false if
 *     already supported natively.
 */
function enable(opt_window) {
  var win = opt_window || window;
  if (!win.Element.prototype.matches) {
    let node = win.Element;
    win.Element.prototype.matches =
        win.Element.prototype.matchesSelector ||
        win.Element.prototype.mozMatchesSelector ||
        win.Element.prototype.msMatchesSelector ||
        win.Element.prototype.oMatchesSelector ||
        win.Element.prototype.webkitMatchesSelector ||
        function(s) {
          var matches = (node.document || node.ownerDocument)
              .querySelectorAll(s);
          var i = matches.length;
          while (--i >= 0 && matches.item(i) !== node) {}
          return i > -1;
        };
    return true;
  }
  return false;
};


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ContainedTileIterator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__iterabletilemap__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tile__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tileiterator__ = __webpack_require__(26);







/**
 * Iterates all tiles contained between and inside two frame bounds.
 */
class ContainedTileIterator {

  /**
   * @param {!IterableTileMap} tileMap A tile map.
   * @param {number=} opt_fromFrameX The frame position to iterate from.
   *     If not provided, will use the tilemap's frame position.
   * @param {number=} opt_toFrameX The frame position to iterate to.
   *     If not provided, will iterate over all tiles contained in the frame
   *     positioned at {@code opt_fromFrameX}.
   */
  constructor(tileMap, opt_fromFrameX, opt_toFrameX) {
    /** @private {!IterableTileMap} */
    this.tileMap_ = tileMap;

    /** @private {boolean} Whether iteration has completed. */
    this.done_ = false;

    if (!this.tileMap_.isValid()) {
      this.done_ = true;
      return;
    }

    /** @private {number} */
    this.fromFrameX_ = (opt_fromFrameX != undefined) ?
        opt_fromFrameX : this.tileMap_.getFrameX();

    /** @private {number} */
    this.toFrameX_ = (opt_toFrameX != undefined) ?
        opt_toFrameX : this.fromFrameX_;

    /** @private {boolean} Whether to iterate tiles forward. */
    this.moveForward_ = this.toFrameX_ >= this.fromFrameX_;

    var startTile = this.getStartTile_();
    if (!startTile) {
      this.done_ = true;
      return;
    }

    this.tileIterator_ =
        new __WEBPACK_IMPORTED_MODULE_2__tileiterator__["a" /* TileIterator */](tileMap, startTile, null, this.moveForward_);
  }


  /**
   * Moves the iterator to the next tile.
   * @return {!IteratorObject}
   */
  next() {
    if (this.done_) {
      return {value: undefined, done: true};
    }

    const tile = this.tileIterator_.next().value;
    if (!tile) {
      this.done_ = true;

    } else if (this.moveForward_) {
      var frameRightBound = this.toFrameX_ + this.tileMap_.frameWidth;
      if (tile.x + tile.width >= frameRightBound) {
        this.done_ = true;
      }

    } else if (tile.x <= this.toFrameX_) {
      this.done_ = true;
    }

    return {
      value: tile,
      done: false,
    };
  }


  /**
   * Gets the first tile to iterate from.
   * @return {Tile|undefined}
   * @private
   */
  getStartTile_() {
    var bound = this.fromFrameX_ +
        (this.moveForward_ ? 0 : this.tileMap_.frameWidth - 1);

    var isTileBeyondBound;

    if (bound >= 0) {
      isTileBeyondBound = function(tile) {
        return tile && (tile.x + tile.width - 1) < bound;
      };
    } else {
      isTileBeyondBound = function(tile) {
        return tile && tile.x > bound;
      };
    }

    var /** !Tile */ firstTile = {
      index: 0,
      x: 0,
    };

    var iterator =
        new __WEBPACK_IMPORTED_MODULE_2__tileiterator__["a" /* TileIterator */](this.tileMap_, firstTile, null, (bound >= 0));

    var tile;
    do {
      tile = iterator.next().value;
    } while (isTileBeyondBound(tile));

    return tile;
  }

}


/**
 * Iterator object.
 * @typedef {!{
 *   value: (Tile|undefined),
 *   done: boolean
 * }}
 */
let IteratorObject;




/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IndexIterator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__iterabletilemap__ = __webpack_require__(8);





/**
 * Iterates tile indexes.
 */
class IndexIterator {

  /**
   * @param {!IterableTileMap} tileMap A tile map.
   * @param {?number=} opt_fromIndex The tile index to iterate from.
   * @param {?number=} opt_toIndex The tile index to iterate to.
   * @param {?boolean=} opt_moveForward Whether to iterate forward.
   *     (Default: true)
   */
  constructor(tileMap, opt_fromIndex, opt_toIndex, opt_moveForward) {
    /** @private {!IterableTileMap} */
    this.tileMap_ = tileMap;

    /** @private {number} The current tile index. */
    this.index_ = (opt_fromIndex != undefined) ? opt_fromIndex : 0;

    /** @private {?number} The tile index where the iterator should stop. */
    this.toIndex_ = (opt_toIndex != undefined) ?
        Math.min(Math.max(opt_toIndex, 0), this.tileMap_.getTilesCount() - 1) :
        null;

    /** @private {boolean} Whether to iterate tiles forward. */
    this.moveForward_ = (opt_moveForward != false);

    /** @private {boolean} Whether iteration has completed. */
    this.done_ = false;
  }


  /**
   * Moves the iterator to the next tile.
   * @return {!IteratorObject}
   */
  next() {
    if (this.done_) {
      return {value: undefined, done: true};
    }

    var index = this.index_;
    this.index_ += this.moveForward_ ? 1 : -1;

    if (index == this.toIndex_) {
      this.done_ = true;
    }

    if (this.index_ < 0) {
      if (this.tileMap_.isCyclical()) {
        this.index_ = this.tileMap_.getTilesCount() - 1;
      } else {
        this.done_ = true;
      }

    } else if (this.index_ >= this.tileMap_.getTilesCount()) {
      if (this.tileMap_.isCyclical()) {
        this.index_ = 0;
      } else {
        this.done_ = true;
      }
    }

    return {value: index, done: false};
  }

}


/**
 * Iterator object.
 * @typedef {!{
 *   value: (undefined|number),
 *   done: boolean
 * }}
 */
let IteratorObject;




/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VisibilityIterator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__iterabletilemap__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tile__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tileiterator__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__visibility__ = __webpack_require__(3);








/**
 * Iterates over the visibility status of each tile in a tile map.
 */
class VisibilityIterator {

  /**
   * @param {!IterableTileMap} tileMap A tile map.
   */
  constructor(tileMap) {
    /** @private {!IterableTileMap} */
    this.tileMap_ = tileMap;

    /** @private {number} How many tiles were iterated. */
    this.tileCount_ = 0;

    var firstTileX = 0;
    if (this.tileMap_.isCyclical() && this.tileMap_.isValid()) {
      while (firstTileX > this.tileMap_.getFrameX()) {
        firstTileX -= this.tileMap_.getAllTilesWidth();
      }
    }

    var /** !Tile */ firstTile = {
      index: 0,
      x: firstTileX,
    };

    /**
     * Tile iterator.
     * @private {!TileIterator}
     */
    this.tileIterator_ = new __WEBPACK_IMPORTED_MODULE_2__tileiterator__["a" /* TileIterator */](this.tileMap_, firstTile, null);

    /** @private {boolean} Whether iteration has completed. */
    this.done_ = false;

    // Don't iterate if all tiles have a zero width
    if (!this.tileMap_.isValid()) {
      this.done_ = true;
      return;
    }
  }


  /**
   * Moves the iterator to the next tile.
   * @return {!IteratorObject}
   */
  next() {
    var tile = this.tileIterator_.next().value;
    if (!tile || this.done_) {
      return {value: undefined, done: true};
    }

    var cycledOnce = (this.tileCount_ >= this.tileMap_.getTilesCount());
    var frameRightBound = this.tileMap_.getFrameX() + this.tileMap_.frameWidth +
        this.tileMap_.frameExpand;
    if (cycledOnce && tile.x >= frameRightBound) {
      return {value: undefined, done: true};
    }

    var vsb = this.tileMap_.getTileVisibility(tile.index, tile.x);
    this.tileCount_++;

    return {
      value: {
        index: tile.index,
        vsb: vsb,
      },
      done: false,
    };
  }

}


/**
 * Iterator value.
 * @typedef {!{
 *   index: number,
 *   vsb: Visibility
 * }}
 */
let Value;


/**
 * Iterator object.
 * @typedef {!{
 *   value: (undefined|Value),
 *   done: boolean
 * }}
 */
let IteratorObject;




/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tween; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__easing__ = __webpack_require__(42);




/**
 * A super lightweight drop-in replacement for TweenLite.
 * Somehow it's TweenLiteLite. API is identical but
 *   - it can only tween objects with number properties,
 *   - it can not accept an array of objects,
 *   - it can not retrieve elements from a selector,
 *   - only a handful of configuration properties are supported (listed in
 *     {@code RESERVED_PROPS},
 *   – animations always play immediately and can only be killed, not paused
 *     or resumed.
 */
class Tween {

  /**
   * @see https://greensock.com/docs/#/HTML5/GSAP/TweenLite/TweenLite/
   * @param {!Object} target Target object whose properties should be tweened.
   * @param {number} duration Duration in seconds.
   * @param {!Object} vars End values of properties that should be tweened,
   *     and configuration properties.
   */
  constructor(target, duration, vars) {
    /** @private {!Object} */
    this.target_ = target;

    /** @private {number} */
    this.duration_ = duration;

    /** @private {Object} */
    this.options_ = vars;

    /**
     * Clone of target object, to keep references of start values.
     * @private {!Object}
     */
    this.startProps_ = Object.assign({}, target);

    /** @private {function(number): number} Easing method. */
    this.easeFunc_ = vars['ease'] || __WEBPACK_IMPORTED_MODULE_0__easing__["c" /* linear */];

    /** @private {Function} Handler called on each frame. */
    this.onUpdate_ = vars['onUpdate'] || function() {};

    /**
     * Parameters passed to {@code onUpdate} handler.
     * @private {Array<!Object>}
     */
    this.onUpdateParams_ = vars['onUpdateParams'] || null;

    /** @private {Function} Handler called when the animation ends. */
    this.onComplete_ = vars['onComplete'] || function() {};

    /**
     * Clone of end values object without the configuration properties.
     * @private {!Object}
     */
    this.endProps_ = {};

    /** @private {number} Timestamp when the animation starts playing. */
    this.startTime_ = 0;

    /** @private {number} Timestamp after which the animation must end. */
    this.endTime_ = 0;

    /** @private {number} Animation frame request id */
    this.frameRequestId_ = 0;

    this.play_();
  }


  /**
   * Starts playing the animation.
   * @private
   */
  play_() {
    // Isolate the end of values of tweened properties from the configuration
    // properties.
    for (let option in this.options_) {
      if (RESERVED_PROPS.indexOf(option) == -1) {
        this.endProps_[option] = this.options_[option] -
            this.startProps_[option];
      }
    }

    this.startTime_ = Date.now();
    this.endTime_ = this.startTime_ + this.duration_ * 1000;
    this.frameRequestId_ = window.requestAnimationFrame(this.tick_.bind(this));
  }


  /**
   * Sets the animation progress.
   * @param {number} value A number between 0 and 1 indicating the progress.
   * @private
   */
  progress_(value) {
    value = Math.max(0, Math.min(1, value));
    const elapsed = value * (this.endTime_ - this.startTime_) / 1000;
    for (let prop in this.endProps_) {
      if (!this.endProps_.hasOwnProperty(prop)) continue;
      this.target_[prop] = Object(__WEBPACK_IMPORTED_MODULE_0__easing__["a" /* ease */])(
          elapsed,
          this.startProps_[prop],
          this.endProps_[prop],
          this.duration_,
          this.easeFunc_);
    }

    this.onUpdate_ && this.onUpdate_.apply(null, this.onUpdateParams_);
  }

  /**
   * Kills the animation.
   */
  kill() {
    window.cancelAnimationFrame(this.frameRequestId_);
    this.options_ = null;
    this.onUpdate_ = null;
    this.onComplete_ = null;
  }


  /**
   * Plays the next animation frame.
   * @private
   */
  tick_() {
    const now = Date.now();
    const progress = (now - this.startTime_) / this.duration_ / 1000;
    this.progress_(progress);

    if (Date.now() < this.endTime_) {
      this.frameRequestId_ =
          window.requestAnimationFrame(this.tick_.bind(this));
    } else {
      this.progress_(1);
      this.onComplete_ && this.onComplete_();
      this.kill();
    }
  }


  /**
   * Creates a tween instance that animates to the specified destination values.
   * @param {!Object} target Target object whose properties should be tweened.
   * @param {number} duration Duration in seconds.
   * @param {!Object} vars End values of properties that should be tweened,
   *     and configuration properties.
   * @return {!Tween}
   */
  static to(target, duration, vars) {
    return new Tween(target, duration, vars);
  };
}


/**
 * Configuration properties.
 * @const {!Array<string>}
 */
const RESERVED_PROPS = [
  'ease', 'onUpdate', 'onUpdateParams', 'onComplete',
];




/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Swipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__navigator__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__options__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tilemap_tilemap__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants__ = __webpack_require__(27);









/**
 * Manages swipe interactions.
 */
class Swipe {

  /**
   * @param {!TileMap} tileMap The tile map definition.
   * @param {!Navigator} navigator The carousel navigation
   *     manager.
   * @param {!CarouselAdapter} adapter The adapter interface.
   * @param {!Function} moveHandler A callback executed on every swipe update.
   * @param {!Options} options The carousel options.
   */
  constructor(tileMap, navigator, adapter, moveHandler, options) {
    /** @private */
    this.tileMap_ = tileMap;

    /** @private */
    this.adapter_ = adapter;

    /** @private */
    this.navigator_ = navigator;

    /** @private */
    this.moveHandler_ = moveHandler;

    /** @private */
    this.options_ = options;

    /** @private {boolean} */
    this.isRtl_ = this.adapter_.isRtl();

    /** @private {boolean} Whether a swipe gesture is ongoing. */
    this.isSwiping_ = false;

    /** @private {number} The timestamp when the last swipe gesture started. */
    this.startTime_ = 0;

    /** @private {number} The frame position when the swipe gesture started. */
    this.startFrameX_ = 0;

    /**
     * The pointer position when the swipe gesture started.
     * @private {number}
     */
    this.startSwipeX_ = 0;

    /**
     * The total distance the user has moved their finger since swipeStart.
     * @private {number}
     */
    this.swipeDelta_ = 0;

    /** @private {!Function} */
    this.handleStartHandler_ = this.handleStart_.bind(this);

    /** @private {!Function} */
    this.handleMoveHandler_ = this.handleMove_.bind(this);

    /** @private {!Function} */
    this.handleEndHandler_ = this.handleEnd_.bind(this);

    /** @private {!Function} */
    this.handleMouseLeaveHandler_ = this.handleMouseLeave_.bind(this);

    /** @type {boolean} */
    this.swipeLocked_ = false;
  }

  /**
   * Initializes events listening.
   */
  init() {
    this.adapter_.registerSwipeStart(this.handleStartHandler_);
    this.adapter_.registerSwipeMove(this.handleMoveHandler_);
    this.adapter_.registerSwipeEnd(this.handleEndHandler_);
    this.adapter_.registerSwipeCancel(this.handleEndHandler_);
    this.adapter_.registerMouseLeave(this.handleMouseLeaveHandler_);
  }


  /**
   * Stops events listening.
   */
  destroy() {
    this.adapter_.deregisterSwipeStart(this.handleStartHandler_);
    this.adapter_.deregisterSwipeMove(this.handleMoveHandler_);
    this.adapter_.deregisterSwipeEnd(this.handleEndHandler_);
    this.adapter_.deregisterSwipeCancel(this.handleEndHandler_);
    this.adapter_.deregisterMouseLeave(this.handleMouseLeaveHandler_);
  }


  /**
   * Whether a swipe gesture is ongoing.
   * @return {boolean}
   */
  isSwiping() {
    return this.isSwiping_;
  }

  /**
   * Get the current lock status of swiping.
   * @return {boolean}
   */
  isSwipeLocked() {
    return this.swipeLocked_;
  }

  /**
   * Event handler for a swipe start event.
   * @param {!Object} coords The coordinates of the swipe.
   * @private
   */
  handleStart_(coords) {
    this.navigator_.stopAnimation();

    // In case we are interrupting a skip transition, re-enable all tiles
    this.tileMap_.enableHiddenTiles();

    this.startTime_ = +new Date();
    this.startFrameX_ = this.tileMap_.getFrameX();
    this.startSwipeX_ = coords.x;
    this.isSwiping_ = true;
    this.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */].SWIPING);
  }


  /**
   * Event handler for a swipe move event.
   * @param {!Object} coords The coordinates of the swipe.
   * @private
   */
  handleMove_(coords) {
    if (!this.isSwiping_) {
      return;
    }

    this.swipeDelta_ = (coords.x - this.startSwipeX_) * (this.isRtl_ ? -1 : 1);
    var frameX = this.startFrameX_ - this.swipeDelta_;

    // update the swipe lock status
    this.swipeLocked_ = this.lockSwipe_(frameX);

    // Apply friction on non-cyclical carousels when the frame exceeds its
    // bounds by applying a coefficient to the amount of pixels that exceeded
    // one of the two boundaries.
    if (this.tileMap_.isFrameXExceedingBounds(frameX)) {
      var exceed;
      var friction = this.options_.edgeFriction;
      if (frameX > this.tileMap_.getMaxFrameX() + 1) {
        exceed = frameX - this.tileMap_.getMaxFrameX();
        frameX = this.tileMap_.getMaxFrameX() + (exceed / friction);
      } else if (frameX < this.tileMap_.getMinFrameX() - 1) {
        exceed = this.tileMap_.getMinFrameX() - frameX;
        frameX = this.tileMap_.getMinFrameX() - (exceed / friction);
      }
    }

    if (!this.isSwipeLocked()) {
      this.navigator_.setFramePosition(frameX);
      this.moveHandler_();
    }
  }


  /**
   * Event handler for a swipe end event.
   * @private
   */
  handleEnd_() {
    this.isSwiping_ = false;
    this.adapter_.removeClass(__WEBPACK_IMPORTED_MODULE_4__constants__["a" /* cssClasses */].SWIPING);

    var snappedTile = this.tileMap_.getCurrentSnappedTile();
    if (!snappedTile) {
      return;
    }

    if (this.didFlick_()) {
      // Go one tile further in the swipe direction
      var handler = this.moveHandler_.bind(this);

      // If carousel does not paginate groups of tiles, move from the current
      // frame position, otherwise from the current animation destination.
      var frameX = !this.navigator_.isPaginatingGroups() ?
          this.startFrameX_ : null;

      if (this.swipeDelta_ >= 0) {
        this.navigator_.selectPrevious(handler, frameX);
      } else {
        this.navigator_.selectNext(handler, frameX);
      }
    } else {
      // Go to the tile overlapping with the snap position.
      var index = snappedTile.index;
      this.navigator_.selectTile(index, true);
    }

    this.swipeDelta_ = 0;
  }


  /**
   * Determines whether the gesture that just ended is considered a 'flick'.
   * @return {boolean} Whether or not the last gesture is considered a 'flick'.
   * @private
   */
  didFlick_() {
    var now = +new Date();
    var duration = now - this.startTime_;
    var distance = Math.abs(this.swipeDelta_);
    var flicked = (duration < Swipe.FLICK_DURATION_) &&
        (distance > Swipe.FLICK_DISTANCE_);

    return flicked;
  }


  /**
   * When the user's mouse leaves the pages element, process as a swipe end
   * event only when the user is pressing. This is necessary because the user
   * could have started to drag the carousel and lifted the mouse button
   * outside of the element.
   * @private
   */
  handleMouseLeave_() {
    // Make sure the user actually intended to flick/swipe rather than just
    // happening to mouse over when the carousel is in transit. Without this
    // check the carousel could stop at the wrong slide (such as the last slide
    // they moused over).
    this.isSwiping_ && this.handleEnd_();
  }

  /**
   * Compares current frame with last frame to get the swipe direction. If
   * swiping right and last page is shown, swiping will be disabled.
   * @param {number} currentFrame
   * @return {boolean}
   */
  lockSwipe_(currentFrame) {
    const paginationModel = (this.adapter_.getPaginationModel)
        ? this.adapter_.getPaginationModel() : undefined;

    // Check if cyclical flag is set to true, no locking on cyclical.
    const cyclical = (paginationModel) ? paginationModel.cyclical : undefined;

    // Get total pages and current page number.
    const totalPages = (paginationModel) ? paginationModel.totalPages : 0;
    const currentPage = (paginationModel) ? paginationModel.currentPage : 0;

    // Get swipe direction
    const direction = (this.navigator_.currentFrame > currentFrame)
        ? __WEBPACK_IMPORTED_MODULE_4__constants__["c" /* swipeDirection */].SWIPE_LEFT : __WEBPACK_IMPORTED_MODULE_4__constants__["c" /* swipeDirection */].SWIPE_RIGHT;

    // If last page is active and user is swiping right
    return !!(!cyclical && totalPages === currentPage
        && direction === __WEBPACK_IMPORTED_MODULE_4__constants__["c" /* swipeDirection */].SWIPE_RIGHT);
  }
}


/**
 * The distance in pixels a swipe must surpass to be considered a 'flick'.
 * @const
 * @private {number}
 */
Swipe.FLICK_DISTANCE_ = 50;


/**
 * The duration in milliseconds a swipe should not exceed to be considered a
 * 'flick'.
 * @const
 * @private {number}
 */
Swipe.FLICK_DURATION_ = 500;




/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return debounce; });
/**
 * @fileoverview A simple function to create a debounced function.
 * A debounced function wraps a function, and delay its execution every time
 * the debounced function is called. This is equivalent to goog.async.Debouncer
 * but lighter and a simpler API.
 *
 * @see https://glue-docs.appspot.com/docs/components/raw/debounce
 *
 * Example:
 *
 * // Call a function 250ms after the last scroll event fires.
 * var handleScroll = function() {};
 * window.addEventListener('scroll', debounce(handleScroll, 250));
 *
 */



/**
 * Convenience factory method to create a debounced function.
 * @this {!Object}
 * @param {!Function} fn The function to debounce.
 * @param {number} delay The delay in ms until the function should be executed.
 * @return {!Function} The debounced function.
 */
function debounce(fn, delay) {
  const instance = new debounce.Debounce(fn, delay);
  const output = instance.debounce.bind(instance);

  // Make cancel API available on the returned function
  const cancel = (() => {
    instance.cancel();

    // Returns the debounce instance to allow chaining when unsubscribing from
    // an event.
    return output;
  });
  output.cancel = cancel.bind(this);

  return output;
}


/**
 * Debounces a function after a given delay.
 */
class Debounce {

  /**
   * @param {!Function} fn The function to debounce.
   * @param {number} delay The delay in ms until the function should be executed.
   */
  constructor(fn, delay) {
    /** @private */
    this.fn_ = fn;

    /** @private */
    this.delay_ = delay;

    /** @private {?number} ID of the last debounce timeout */
    this.timeoutId_ = null;
  }

  /**
   * Debounces by reinitializing the timer until the function should execute.
   */
  debounce() {
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(this.fn_, this.delay_);
  }


  /**
   * Cancels any ongoing debouncing timer.
   */
  cancel() {
    clearTimeout(this.timeoutId_);
  }
}

debounce.Debounce = Debounce;





/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CarouselImageFoundation; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mdc_foundation_js__ = __webpack_require__(7);





/**
 * @final @extends {MDCFoundation<!CarouselImageAdapter>}
 */
class CarouselImageFoundation extends __WEBPACK_IMPORTED_MODULE_1__mdc_foundation_js__["a" /* MDCFoundation */] {

  static get strings() {
    return {
      LOADED_EVENT: 'gluecarouselimageloaded',
      UNKNOWN_SIZE_IMAGE_ELEMENTS:
          '.glue-carousel-image, [data-glue-carousel-image]',
    };
  }

  /**
   * @param {!CarouselImageAdapter} adapter
   */
  constructor(adapter) {
    super(adapter);

    /** @private {number} */
    this.initialWidth_;

    /** @private {number} */
    this.initialHeight_;

    /** @private {!Function} */
    this.loadHandler_;
  }

  init() {
    this.initialWidth_ = this.adapter.getWidth();
    this.initialHeight_ = this.adapter.getHeight();

    // Image has already been loaded, stop here
    if (this.adapter.isFetchingComplete()) {
      return;
    }

    this.loadHandler_ = this.handleLoad_.bind(this);
    this.adapter.registerLoadHandler(this.loadHandler_);
  }

  destroy() {
    this.adapter.deregisterLoadHandler(this.loadHandler_);
  }

  /**
   * @private
   */
  handleLoad_() {
    // The image size has changed after loading, we need to ask the carousel
    // to update its internal measurements.
    const dimensionsHaveChanged =
        (this.adapter.getWidth() != this.initialWidth_) ||
        (this.adapter.getHeight() != this.initialHeight_);

    dimensionsHaveChanged && this.adapter.notifyLoad();
    this.adapter.deregisterLoadHandler(this.loadHandler_);
  }

}




/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElementsToggler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__toggler__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tilemap_visibility__ = __webpack_require__(3);






/**
 * Add or remove child elements of a container based on a display map.
 */
class ElementsToggler extends __WEBPACK_IMPORTED_MODULE_0__toggler__["a" /* Toggler */] {

  /**
   * @param {!Element} containerEl The elements immediate parent.
   */
  constructor(containerEl) {
    super();

    /** @private */
    this.containerEl_ = containerEl;

    /**
     * The original list of child elements.
     * @private {!Array<Element>}
     */
    this.els_ = [];

    /**
     * The list of visible elements, but where each element index is identical
     * to its associated tile in the display map.
     * @private {!Array<Element>}
     */
    this.visibleElsMap_ = [];

    /**
     * The cache of all tile elements and the clones created when a tile is
     * visible several times in the viewport. These elements are reused as much
     * as possible for performance sake.
     * @private {!Array<Element>}
     */
    this.elCache_ = [];

    /**
     * The number of available tiles.
     * @private {number}
     */
    this.tilesCount_ = 0;
  }


  /**
   * Toggles the tile elements based on a display map.
   * @param {!Array<Visibility>} newMap A display map.
   * @override
   */
  toggleElements(newMap) {
    if (this.isMapIdentical(newMap)) {
      return;
    }

    var pagesLen = this.tilesCount_;
    if (!pagesLen) {
      return;
    }

    var oldMap = this.visibleElsMap_;

    // Display map is cloned to replace visible items with a reference to their
    // associated element.
    newMap = Array.prototype.slice.apply(newMap);
    var vsbHidden = __WEBPACK_IMPORTED_MODULE_1__tilemap_visibility__["a" /* Visibility */].HIDDEN;

    // Convert old and new display maps into a temporary data model.
    // If an item is visible (partially or not) its TileMap.Visibility value
    // is replaced by its index. If it is not visible, the value becomes
    // 'false'. For example, given a tile map of 4 available tiles:
    //
    // [PARTIALLY, VISIBLE, PARTIALLY, HIDDEN] → [0, 1, 2, false]
    //
    // [HIDDEN, HIDDEN, HIDDEN, PARTIALLY, VISIBLE, VISIBLE, PARTIALLY]
    // → [false, false, false, 3, 0, 1, 2]
    //
    // This data model makes easier comparing old and new display maps, to find
    // which DOM elements need to be preserved, added or removed.
    var replaceWithIndex = function(item, index) {
      // Based on the provenance of the display map, item can be either a
      // DOM element or a TileMap.Visibility value.
      return (item > vsbHidden || !!item) ? index % pagesLen : false;
    };
    var oldMapIndexes = oldMap.map(replaceWithIndex);
    var newMapIndexes = newMap.map(replaceWithIndex);

    // Find largest intersection between old and new maps. This will describe
    // the chain of DOM elements that need to be preserved.
    var intersect = ElementsToggler
        .getMapsIntersection_(oldMapIndexes, newMapIndexes);

    // First pass: remove elements non visible anymore
    for (var i = 0, len = oldMap.length; i < len; i++) {
      var lastIndex = intersect.map1 + intersect.length;
      var el = oldMap[i];

      if (i < intersect.map1 || i >= lastIndex || !intersect) {
        // Element is outside the intersection in the old map or there's no
        // intersection, so remove it from DOM.
        el.parentNode && el.parentNode.removeChild(el);

      } else if (i >= intersect.map1 && i < lastIndex) {
        // Element is inside the intersection so it should be preserved, add a
        // reference to the new map.
        var newIndex = intersect.map2 + i - intersect.map1;
        newMap[newIndex] = el;
      }
    }

    // Second pass: add newly visible elements
    var firstEl = newMap[intersect.map2] || this.containerEl_.firstChild;
    for (var i = 0, len = newMap.length; i < len; i++) {
      if (newMap[i] > vsbHidden) {
        var el = this.reusePageElement_(i);

        // Keep a reference to the new added element
        newMap[i] = el;

        if (i < intersect.map2) {
          // Element should be prepended before the intersection
          this.containerEl_.insertBefore(el, firstEl);

        } else {
          // Element should be appended after the intersection
          this.containerEl_.appendChild(el);
        }
      }
    }

    this.visibleElsMap_ = newMap;
  }


  /**
   * Restores all tiles as they initially were.
   * @override
   */
  resetElements() {
    var vsbValue = __WEBPACK_IMPORTED_MODULE_1__tilemap_visibility__["a" /* Visibility */].VISIBLE;
    var displayMap = new Array(this.tilesCount_).fill(vsbValue);
    this.toggleElements(displayMap);

    this.cacheElements_();
  }


  /**
   * Builds a cache of references to child elements.
   * @private
   */
  cacheElements_() {
    var els = this.containerEl_.children;

    this.els_ = [];
    this.visibleElsMap_ = [];
    this.elCache_ = [];

    for (var i = 0, el; el = els[i]; i++) {
      this.els_.push(el);
      this.visibleElsMap_.push(el);
      this.elCache_.push(el);
    }

    this.tilesCount_ = els.length;
  }


  /**
   * Returns the DOM element for a specified tile index. If there is no element
   * available (ie. not added to the DOM yet), creates a new clone and stores
   * it in cache as a secondary clone.
   * @param {number} i The index of the tile in the tile map.
   * @return {!Element} A DOM element for a tile.
   * @private
   */
  reusePageElement_(i) {
    var el;
    var j = i % this.tilesCount_;
    while (j < this.tilesCount_) {
      el = this.elCache_[j];
      if (el && !el.parentNode) {
        // Reuse a cached element.
        return el;
      }
      j += this.tilesCount_;
    }

    // Can't find a cached element available for this tile, so create a new
    // clone
    el = this.els_[i % this.tilesCount_].cloneNode(true);
    this.elCache_[i] = el;
    return el;
  }

}


/**
 * Looks for a sub-array inside an array.
 * @param {!Array} sub A sub-array to look for.
 * @param {!Array} list The array where to look the sub-array into.
 * @return {number} Returns the index of the sub-array in the array, or -1 if
 *     it could not be found.
 * @private
 */
ElementsToggler.isArrayIncluded_ = function(sub, list) {
  for (var i = 0, len1 = list.length; i < len1; i++) {
    for (var j = 0, len2 = sub.length; j < len2; j++) {
      if (list[i + j] !== sub[j]) {
        break;
      }
    }
    if (j == len2) {
      // Successfully parsed all sub-array, this means it is entirely included
      return i;
    }
  }
  // Sub-array is not included
  return -1;
};


/**
 * Returns information about the intersection of two display maps.
 * @param {!Array<number|boolean>} map1 A list of indexes of visible elements.
 * @param {!Array<number|boolean>} map2 A list of indexes of visible elements.
 * @return {Object|boolean} An object describing the intersection of two
 *     display maps, or false if there was no intersection.
 * @private
 */
ElementsToggler.getMapsIntersection_ = function(map1, map2) {
  for (var len = map1.length; len >= 1; len--) {
    for (var i1 = 0; i1 <= map1.length - len; i1++) {

      if (map1[i1] === false || map1[i1 + len - 1] === false) {
        continue;
      }

      var slice = map1.slice(i1, i1 + len);
      var i2 = ElementsToggler.isArrayIncluded_(slice, map2);

      if (i2 != -1) {
        return {
          // The index of the intersection in the first map
          map1: i1,
          // The index of the intersection in the second map
          map2: i2,
          // The length of the intersection
          length: len,
          // The list of items in the intersection
          slice: slice,
        };
      }
    }
  }
  // No intersection between the maps
  return false;
};




/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Toggler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tilemap_visibility__ = __webpack_require__(3);





/**
 * An abstract implementation for a class that will add or remove tile
 * elements to the DOM based on a display map.
 */
class Toggler {

  constructor() {
    /**
     * A copy of the last applied display map.
     * @private {!Array<Visibility>}
     */
    this.currentMap_ = [];
  }


  /**
   * Toggles the tile elements based on a display map.
   * @param {!Array<Visibility>} newMap A
   *     display map.
   */
  toggleElements(newMap) {}


  /**
   * Restores all elements as they initially were.
   */
  resetElements() {}


  /**
   * Compares a display map with the last applied.
   * @param {!Array<Visibility>} newMap A display map.
   * @return {boolean} Whether the display map is different from the current.
   * @protected
   */
  isMapIdentical(newMap) {
    var isMapItemIdentical = (item, i, map) => {
      return !!map[i] == !!this.currentMap_[i];
    };
    if (newMap.length == this.currentMap_.length &&
        newMap.every(isMapItemIdentical)) {
      return true;
    }
    this.currentMap_ = newMap.slice();
    return false;
  }

}




/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventTarget; });
/* unused harmony export EventLike */
/**
 * @fileoverview A lightweight implementation of the Observable pattern, with
 * a Closure-like API.
 */



class EventTarget {

  constructor() {
    /** @private {!ListenerMap} */
    this.listeners_ = {};
  }

  /**
   * Emits an event.
   * Note: This interface differs from the Closure dispatchEvent method. The
   * parameters are different. See {@code goog.events.Listenable.dispatchEvent}
   * @param {string} evtType
   * @param {EventLike=} eventData Additional event data.
   */
  dispatchEvent(evtType, eventData = undefined) {
    const listeners = this.getListenersList_(evtType);
    for (let i = 0, listener; listener = listeners[i]; i++) {
      listener(eventData);
    }
  }

  /**
   * Listens to an event, and executes a handler function when it fires.
   * @param {string} evtType
   * @param {!Function} handler
   */
  listen(evtType, handler) {
    const listeners = this.getListenersList_(evtType);
    listeners.push(handler);
  }

  /**
   * Stops listening to an event.
   * @param {string} evtType
   * @param {!Function} handler
   */
  unlisten(evtType, handler) {
    const listeners = this.getListenersList_(evtType);
    for (let i = listeners.length - 1; i >= 0; i--) {
      const h = listeners[i];
      if (h == handler) {
        listeners.splice(i, 1);
      }
    }
  }

  /**
   * Returns the list of listeners for a specific event type.
   * @param {string} evtType
   * @return {!Array<!Function>}
   * @private
   */
  getListenersList_(evtType) {
    if (!this.listeners_[evtType]) {
      this.listeners_[evtType] = [];
    }
    return this.listeners_[evtType];
  }

  /**
   * Removes all listeners on the host component.
   */
  removeAllListeners() {
    for (let evtType in this.listeners_) {
      if (this.listeners_.hasOwnProperty(evtType)) {
        this.listeners_[evtType].forEach((handler) => {
          this.unlisten(evtType, handler);
        });
      }
    }
  }
}


/**
 * Also see {@code goog.events.EventLike}
 * @typedef {string|Object}
 */
let EventLike;


/** @typedef {!Object<string, !Array<!Function>>} */
let ListenerMap;





/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ResponsiveMonitor; });



/**
 * Calls handler functions when the document object matches a media query, or
 * when a CSS-injected named breakpoint is included in a list of strings. Can
 * also call another handler when one of the condition above does not apply
 * anymore.
 *
 * This typically can be used to enable or disable a UI component based on the
 * viewport size.
 *
 * Example:
 *
 * new ResponsiveMonitor({
 *   breakpoint: ['medium', 'large'],
 *   enter: (size) => component.start(),
 *   leave: (size) => component.stop(),
 * });
 *
 * new ResponsiveMonitor({
 *   media: '(min-width: 600px)',
 *   transform: (mql) => component.start(),
 *   revert: (mql) => component.stop(),
 * });
 *
 * new ResponsiveMonitor([{
 *   media: '(max-width: 400px)',
 *   transform: (mql) => component1.start(),
 * }, {
 *   media: '(min-width: 501px) and (max-width: 800px)',
 *   transform: component2.start(),
 * }]);
 *
 * For simpler use cases, it is also possible to have a function called every
 * time the current breakpoint changes.
 *
 * const rm = new ResponsiveMonitor();
 * rm.listen((size) => {
 *   if (size == 'medium') {
 *     component.start();
 *   }
 * });
 */
class ResponsiveMonitor {

  /**
   * @param {ResponsiveMonitor.RuleSet=} configRules One or several
   *     media queries associated with callbacks to trigger when their result
   *     changes.
   */
  constructor(configRules = []) {

    /**
     * Registered media query rules;
     * @private {!Array<!ResponsiveMonitor.MediaQueryRuleHandlerMap>}
     */
    this.mqRuleHandlerMaps_ = [];

    /**
     * Callback functions used to listen to breakpoint changes.
     * @private {!Array<!function(string)>}
     */
    this.bpChangeHandlers_ = [];

    /**
     * Registered breakpoint rules.
     * @private {!Array<!ResponsiveMonitor.BreakpointRuleHandlerMap>}
     */
    this.bpRuleHandlerMaps_ = [];

    /**
     * The current named breakpoint.
     * @private {string}
     */
    this.currentBreakpoint_ = this.readBreakpoint_();

    /**
     * The previous named breakpoint.
     * @private {string}
     */
    this.previousBreakpoint_ = '';

    // Setup media query rules
    if (!Array.isArray(configRules)) {
      configRules = [configRules];
    }
    configRules.forEach(this.addRule_.bind(this));

    // Setup named breakpoints listening

    /** @private {!Function} */
    this.vpUpdateHandler_ = this.handleViewportUpdate_.bind(this);

    window.addEventListener('DOMContentReady', this.vpUpdateHandler_);
    window.addEventListener('resize', this.vpUpdateHandler_);
    window.addEventListener('orientationchange', this.vpUpdateHandler_);
  }

  /**
   * Listens to media query or breakpoint changes.
   * @param {!Function|!ResponsiveMonitor.Rule} handler
   */
  listen(handler) {
    if (typeof handler == 'function') {
      this.bpChangeHandlers_.push(/** !Function */ handler);
    } else {
      this.addRule_(/** !ResponsiveMonitor.Rule */ handler);
    }
  }

  /**
   * Stops listening to media query or breakpoint changes.
   * @param {!Function|!ResponsiveMonitor.Rule} handler
   */
  unlisten(handler) {
    if (typeof handler == 'function') {
      for (let i = 0, handler; handler = this.bpChangeHandlers_[i]; i++) {
        if (handler == handler) {
          this.bpChangeHandlers_.splice(i, 1);
          return;
        }
      }
    } else {
      this.removeRule_(/** !ResponsiveMonitor.Rule */ handler);
    }
  }

  /**
   * Stops listening to all media query and breakpoint rules.
   */
  destroy() {
    this.currentBreakpoint_ = '';

    for (let i = 0, mq; mq = this.mqRuleHandlerMaps_[i]; i++) {
      mq.mql.removeListener(mq.handler);
    }

    this.mqRuleHandlerMaps_ = [];
    this.bpRuleHandlerMaps_ = [];
    this.bpChangeHandlers_ = [];

    window.removeEventListener('DOMContentReady', this.vpUpdateHandler_);
    window.removeEventListener('resize', this.vpUpdateHandler_);
    window.removeEventListener('orientationchange', this.vpUpdateHandler_);
  }

  /**
   * Returns the last known named breakpoint.
   * @return {string}
   */
  getCurrentBreakpoint() {
    return this.currentBreakpoint_;
  }

  /**
   * Setup callback functions on a media query or a set of named breakpoints.
   * @param {!ResponsiveMonitor.Rule} rule Configuration properties.
   * @private
   */
  addRule_(rule) {
    const bpRule = /** @type {ResponsiveMonitor.BreakpointRule} */ (rule);
    if (bpRule.breakpoint) {
      this.addBreakpointRule_(bpRule);
      return;
    }

    const mqRule = /** @type {ResponsiveMonitor.MediaQueryRule} */ (rule);
    if (mqRule.media) {
      this.addMediaQueryRule_(mqRule);
      return;
    }
  }

  /**
   * Disable callback functions on a media query or a set of named breakpoints.
   * @param {!ResponsiveMonitor.Rule} rule Configuration properties.
   * @private
   */
  removeRule_(rule) {
    const bpRule = /** @type {ResponsiveMonitor.BreakpointRule} */ (rule);
    if (bpRule.breakpoint) {
      this.removeBreakpointRule_(bpRule);
      return;
    }

    const mqRule = /** @type {ResponsiveMonitor.MediaQueryRule} */ (rule);
    if (mqRule.media) {
      this.removeMediaQueryRule_(mqRule);
      return;
    }
  }

  /**
   * Setup callback functions on a set of named breakpoints.
   * @param {!ResponsiveMonitor.BreakpointRule} rule
   * @private
   */
  addBreakpointRule_(rule) {
    const checkBreakpoint = (size) => {
      const bps = rule.breakpoint;
      const enterBreakpoint =
          bps.indexOf(this.previousBreakpoint_) == -1 &&
          bps.indexOf(this.currentBreakpoint_) != -1;

      if (enterBreakpoint) {
        rule.enter(size);
        return;
      }

      const leaveBreakpoint =
          rule.leave &&
          bps.indexOf(this.previousBreakpoint_) != -1 &&
          bps.indexOf(this.currentBreakpoint_) == -1;

      if (leaveBreakpoint) {
        rule.leave(size);
      }
    };

    // Keeps references for later unregistration purposes
    this.bpRuleHandlerMaps_.push({
      rule: rule,
      handler: checkBreakpoint,
    });

    checkBreakpoint(this.getCurrentBreakpoint());
    this.listen(checkBreakpoint);
  }

  /**
   * Disable callback functions on a set of named breakpoints.
   * @param {!ResponsiveMonitor.BreakpointRule} rule
   * @private
   */
  removeBreakpointRule_(rule) {
    for (let i = 0, bpMap; bpMap = this.bpRuleHandlerMaps_[i]; i++) {
      if (bpMap.rule == rule) {
        this.unlisten(bpMap.handler);
      }
    }
  }

  /**
   * Setup callback functions on a media query.
   * @param {!ResponsiveMonitor.MediaQueryRule} rule
   * @private
   */
  addMediaQueryRule_(rule) {
    const callback = this.handleMediaQueryChange_(rule.transform, rule.revert);
    const handler = callback.bind(this);
    const mql = window.matchMedia(rule.media);
    mql.addListener(handler);

    // Keeps references for later unregistration purposes
    this.mqRuleHandlerMaps_.push({
      rule: rule,
      mql: mql,
      handler: handler,
    });

    // Triggers callback at once if the media query result is true.
    if (mql.matches) {
      callback(mql);
    }
  }

  /**
   * Disable callback functions on a media query.
   * @param {!ResponsiveMonitor.MediaQueryRule} rule
   * @private
   */
  removeMediaQueryRule_(rule) {
    for (let i = 0, mqMap; mqMap = this.mqRuleHandlerMaps_[i]; i++) {
      if (mqMap.rule == rule) {
        mqMap.mql.removeListener(mqMap.handler);
      }
    }
  }

  /**
   * Creates a closure function that will trigger callbacks based on the media
   * query's result.
   * @param {!Function} transformFunc Function to call if the media query
   *     result is true.
   * @param {Function=} opt_revertFunc Function to call if the media query
   *     result reverts to false.
   * @return {!function(MediaQueryList)} A function used as handler of a media
   *     query list.
   * @private
   */
  handleMediaQueryChange_(transformFunc, opt_revertFunc) {
    return function(mql) {
      if (mql.matches) {
        transformFunc(mql);
      } else if (opt_revertFunc) {
        opt_revertFunc(mql);
      }
    };
  }

  /**
   * Fires breakpoint callbacks if the current named breakpoint parsed from the
   * DOM has changed since the previous call.
   * @private
   */
  handleViewportUpdate_() {
    const breakpoint = this.readBreakpoint_();
    if (this.currentBreakpoint_ == breakpoint) {
      return;
    }

    this.previousBreakpoint_ = this.currentBreakpoint_;
    this.currentBreakpoint_ = breakpoint;

    // Call breakpoint handlers
    for (let i = 0, handler; handler = this.bpChangeHandlers_[i]; i++) {
      handler(this.currentBreakpoint_);
    }
  }

  /**
   * Retrieves the named breakpoint currently injected in DOM.
   * @return {string}
   * @private
   */
  readBreakpoint_() {
    const styles = window.getComputedStyle(document.body, ':after');
    const content = styles.getPropertyValue('content');
    const breakpoint = content.replace(/["\']/g, '');
    return breakpoint;
  }

}


/**
 * Returns unique monitor instance.
 * @return {!ResponsiveMonitor}
 */
ResponsiveMonitor.getInstance = function() {
  if (!ResponsiveMonitor.instance_) {
    ResponsiveMonitor.instance_ = new ResponsiveMonitor();
  }
  return ResponsiveMonitor.instance_;
};


/**
 * @typedef {!{
 *   media: string,
 *   transform: function(MediaQueryList),
 *   revert: (undefined|function(MediaQueryList))
 * }}
 */
ResponsiveMonitor.MediaQueryRule;


/**
 * @typedef {!{
 *   rule: !ResponsiveMonitor.MediaQueryRule,
 *   mql: MediaQueryList,
 *   handler: function(MediaQueryList)
 * }}
 */
ResponsiveMonitor.MediaQueryRuleHandlerMap;


/**
 * @typedef {!{
 *   breakpoint: (string|Array<string>),
 *   enter: function(string),
 *   leave: (undefined|function(string))
 * }}
 */
ResponsiveMonitor.BreakpointRule;


/**
 * @typedef {!{
 *   rule: !ResponsiveMonitor.BreakpointRule,
 *   handler: function(string)
 * }}
 */
ResponsiveMonitor.BreakpointRuleHandlerMap;


/**
 * @typedef {(ResponsiveMonitor.MediaQueryRule|ResponsiveMonitor.BreakpointRule)}
 */
ResponsiveMonitor.Rule;


/**
 * @typedef {(!ResponsiveMonitor.Rule|!Array<!ResponsiveMonitor.Rule>)}
 */
ResponsiveMonitor.RuleSet;




/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaginationNext; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mdc_component__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__modelfactory__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__adapter__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation__ = __webpack_require__(101);







/**
 * @final @extends {MDCComponent<!PaginationNextFoundation>}
 */
class PaginationNext extends __WEBPACK_IMPORTED_MODULE_0__mdc_component__["a" /* MDCComponent */] {

  static attachTo(root) {
    return new PaginationNext(root);
  }

  getDefaultFoundation() {
    const paginationModel =
        __WEBPACK_IMPORTED_MODULE_1__modelfactory__["a" /* ModelFactory */].get(this.root_.dataset['gluePagination']);

    const /** !NextAdapter */ adapter = {
      getPaginationModel: () => paginationModel,
      setDisabled: (disabled) => this.root_.disabled = disabled,
      getDataAttr: (name) => this.root_.dataset[name],
      registerClickHandler: (handler) => this.listen('click', handler),
      deregisterClickHandler: (handler) => this.unlisten('click', handler),
    };

    return new __WEBPACK_IMPORTED_MODULE_3__foundation__["a" /* PaginationNextFoundation */](adapter);
  }

}




/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export NextAdapter */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model__ = __webpack_require__(1);




/** @record */
class NextAdapter {

  /**
   * @return {!PaginationModel}
   */
  getPaginationModel() {}

  /**
   * @param {string} name
   * @return {string}
   */
  getDataAttr(name) {}

  /**
   * @param {boolean} disabled
   */
  setDisabled(disabled) {}

  /**
   * @param {!Function} handler
   */
  registerClickHandler(handler) {}

  /**
   * @param {!Function} handler
   */
  deregisterClickHandler(handler) {}

}




/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaginationNextFoundation; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mdc_foundation__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(6);







/**
 * Foundation for a component that paginates to the next page when clicked.
 * @final @extends {MDCFoundation<!glue.ui.pagination.NextAdapter>}
 */
class PaginationNextFoundation extends __WEBPACK_IMPORTED_MODULE_0__mdc_foundation__["a" /* MDCFoundation */] {

  constructor(adapter) {
    super(adapter);

    /** @private {!PaginationModel} */
    this.paginationModel_;

    /** @private {!Function} */
    this.clickHandler_ = () => {
      const updateModel =
          this.adapter.getDataAttr('gluePaginationUpdateModel') != 'false';
      this.paginationModel_.next(updateModel);
    };

    /** @private {!Function} */
    this.updateHandler_ = () => this.update_();
  }

  init() {
    this.paginationModel_ = this.adapter.getPaginationModel();

    this.adapter.registerClickHandler(this.clickHandler_);

    const {CURRENT_PAGE_EVENT, TOTAL_PAGES_EVENT} = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* strings */];
    this.paginationModel_.listen(CURRENT_PAGE_EVENT, this.updateHandler_);
    this.paginationModel_.listen(TOTAL_PAGES_EVENT, this.updateHandler_);

    this.update_();
  }

  destroy() {
    this.adapter.deregisterClickHandler(this.clickHandler_);

    const {CURRENT_PAGE_EVENT, TOTAL_PAGES_EVENT} = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* strings */];
    this.paginationModel_.unlisten(CURRENT_PAGE_EVENT, this.updateHandler_);
    this.paginationModel_.unlisten(TOTAL_PAGES_EVENT, this.updateHandler_);

  }

  /**
   * Updates the DOM attributes.
   * @private
   */
  update_() {
    this.adapter.setDisabled(this.paginationModel_.isLast());
  }

}




/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaginationPageList; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mdc_component__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__modelfactory__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__options__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__adapter__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shim_element_closest__ = __webpack_require__(106);









Object(__WEBPACK_IMPORTED_MODULE_5__shim_element_closest__["a" /* enable */])();

/**
 * @final @extends {MDCComponent<!PaginationPageListFoundation>}
 */
class PaginationPageList extends __WEBPACK_IMPORTED_MODULE_0__mdc_component__["a" /* MDCComponent */] {

  static attachTo(root, options = {}) {
    return new PaginationPageList(root, undefined, options);
  }

  constructor(root, foundation = undefined, ...args) {
    super(root, foundation, ...args);

    /** @private {!Options|Object} */
    this.options_;
  }

  /** @param {!Options|Object=} options */
  initialize(options = {}) {
    this.options_ = options;
  }

  getDefaultFoundation() {
    const paginationModel = __WEBPACK_IMPORTED_MODULE_1__modelfactory__["a" /* ModelFactory */].get(
        this.root_.dataset['gluePagination']);
    const childElements = this.root_.querySelectorAll('li');
    const pageElements = this.root_.querySelectorAll(
        '[data-glue-pagination-page]');

    let clickHandler = function() {};
    let blurHandlers_ = [];
    let focusHandlers_ = [];

    const /** !PageListAdapter */ adapter = {
      getPaginationModel: () => paginationModel,
      setAriaSelected: (index) => {
        for (let i = 0, el; el = pageElements[i]; i++) {
          const flag = (i == index - 1);
          el.setAttribute('aria-selected', flag);
        }
      },
      setActiveButton: (index) => {
        for (let i = 0, el; el = childElements[i]; i++) {
          const isActive = (i == index - 1);
          const {ACTIVE} = __WEBPACK_IMPORTED_MODULE_4__foundation__["a" /* PaginationPageListFoundation */].cssClasses;
          // classList.toggle()'s 2nd argument never implemented on IE
          if (isActive) {
            el.classList.add(ACTIVE);
          } else {
            el.classList.remove(ACTIVE);
          }
        }
      },
      setTabIndex: (index) => {
        for (let i = 0, el; el = pageElements[i]; i++) {
          // Make only the active tab focusable via tab.
          const tabIndex = (i === index - 1) ? '0' : '-1';
          el.setAttribute('tabindex', tabIndex);
        }
      },
      getAriaLabel: (index) => {
        const el = pageElements[index - 1];
        return el.getAttribute('aria-label');
      },
      setAriaLabel: (index, label) => {
        const el = pageElements[index - 1];
        el.setAttribute('aria-label', label);
      },
      registerClickHandler: (handler) => {
        clickHandler = (event) => {
          const pageId =
              parseInt(event.target.dataset['gluePaginationPage'], 10);
          pageId && handler(pageId);
        };
        this.listen('click', clickHandler);
      },
      deregisterClickHandler: (handler) => this.unlisten('click', clickHandler),
      registerKeyHandler: (handler) => {
        this.root_.addEventListener('keydown', handler);
      },
      deregisterKeyHandler: (handler) => this.unlisten('keydown', handler),
      registerFocusHandler: (handler) => {
        for (let i = 0, el; el = pageElements[i]; i++) {
          const focusHandler = () => handler(i + 1);
          focusHandlers_[i] = focusHandler;
          el.addEventListener('focus', focusHandler);
        }
      },
      deregisterFocusHandler: (handler) => {
        for (let i = 0, el; el = pageElements[i]; i++) {
          el.removeEventListener('focus', focusHandlers_[i]);
        }
      },
      registerBlurHandler: (handler) => {
        for (let i = 0, el; el = pageElements[i]; i++) {
          const blurHandler = () => handler(i + 1);
          blurHandlers_[i] = blurHandler;
          el.addEventListener('blur', blurHandler);
        }
      },
      deregisterBlurHandler: (handler) => {
        for (let i = 0, el; el = pageElements[i]; i++) {
          el.removeEventListener('blur', blurHandlers_[i]);
        }
      },
      setHasFocus: (isFocused) => {
        if (isFocused) {
          this.root_.classList.add(
              __WEBPACK_IMPORTED_MODULE_4__foundation__["a" /* PaginationPageListFoundation */].cssClasses.IS_FOCUSED_WITHIN);
        } else {
          this.root_.classList.remove(
              __WEBPACK_IMPORTED_MODULE_4__foundation__["a" /* PaginationPageListFoundation */].cssClasses.IS_FOCUSED_WITHIN);
        }
      },
      focus: (index) => {
        this.root_.querySelector(`[data-glue-pagination-page="${index}"]`)
            .focus();
      },
      isRtl: () => !!this.root_.closest('[dir=rtl]'),
    };

    return new __WEBPACK_IMPORTED_MODULE_4__foundation__["a" /* PaginationPageListFoundation */](adapter, this.options_);
  }

}




/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaginationPageListFoundation; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__events_key__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mdc_foundation__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__adapter__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__options__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__model__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__constants__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__constants__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__keyutil__ = __webpack_require__(105);













/**
 * Foundation for a component that handles a group of buttons which, when
 * clicked, paginate to a specific page. Compared to the Tab component, it also
 * has some a11y features like pausing any running timer when focused, or
 * redirect the focus to the main content element.
 * @final @extends {MDCFoundation<!PageListAdapter>}
 */
class PaginationPageListFoundation extends __WEBPACK_IMPORTED_MODULE_1__mdc_foundation__["a" /* MDCFoundation */] {

  static get cssClasses() {
    return __WEBPACK_IMPORTED_MODULE_5__constants__["a" /* cssClasses */];
  }

  static get strings() {
    return __WEBPACK_IMPORTED_MODULE_5__constants__["b" /* strings */];
  }

  /**
   * @param {!PageListAdapter} adapter
   * @param {!Options|Object=} options
   */
  constructor(adapter, options = {}) {
    super(adapter);

    /** @private {!Options} */
    this.options_ = /** @type {!Options} */ (options);

    /** @private {!PaginationModel} */
    this.paginationModel_;

    /** @private {!Function} */
    this.clickHandler_ = (index) => this.handleSelectPage_(index);

    /** @private @const {!Function} */
    this.keyHandler_ = (event) => this.handleKeyPress_(event);

    /** @private {!Function} */
    this.updateHandler_ = () => this.update_();

    /** @private {!Function} */
    this.focusHandler_ = () => this.handleFocus_();

    /** @private {!Function} */
    this.blurHandler_ = () => this.handleBlur_();
  }

  init() {
    this.paginationModel_ = this.adapter.getPaginationModel();

    this.adapter.registerClickHandler(this.clickHandler_);
    this.adapter.registerKeyHandler(this.keyHandler_);
    this.adapter.registerFocusHandler(this.focusHandler_);
    this.adapter.registerBlurHandler(this.blurHandler_);

    const {CURRENT_PAGE_EVENT} = __WEBPACK_IMPORTED_MODULE_6__constants__["a" /* strings */];
    this.paginationModel_.listen(CURRENT_PAGE_EVENT, this.updateHandler_);

    this.update_();
  }

  destroy() {
    this.adapter.deregisterClickHandler(this.clickHandler_);
    this.adapter.deregisterKeyHandler(this.keyHandler_);
    this.adapter.deregisterFocusHandler(this.focusHandler_);
    this.adapter.deregisterBlurHandler(this.blurHandler_);

    const {CURRENT_PAGE_EVENT} = __WEBPACK_IMPORTED_MODULE_6__constants__["a" /* strings */];
    this.paginationModel_.unlisten(CURRENT_PAGE_EVENT, this.updateHandler_);
  }

  /**
   * Updates the DOM attributes.
   * @private
   */
  update_() {
    this.adapter.setTabIndex(this.paginationModel_.currentPage);
    this.adapter.setAriaSelected(this.paginationModel_.currentPage);
    this.adapter.setActiveButton(this.paginationModel_.currentPage);
  }

  /**
   * @param {number} index
   * @private
   */
  handleSelectPage_(index) {
    if (index != this.paginationModel_.currentPage) {
      this.paginationModel_.currentPage = index;
    } else {
      this.paginationModel_.stopTimer();
      // Since the currentPage has not changed here, we assume that its
      // associated element is already visible and focusable in the DOM. That
      // may not necessarily true in the case where there is a delay until the
      // element becomes visible and focusable, for instance with an animated
      // carousel. In that case, the element that will get focus will not
      // necessary be the one associated to the pagination button that
      // previously had focus.
      this.paginationModel_.focusMainElement();
    }
  }

  /** @private */
  handleFocus_() {
    this.paginationModel_.stopTimer();
    this.adapter.setHasFocus(true);
  }

  /**
   * @private
   */
  handleBlur_() {
    this.adapter.setHasFocus(false);
    this.paginationModel_.startTimer();
  }

  /**
   * Moves the pagination model to the next or previous page when the user uses
   * the right/left arrow keys. Moves focus to the new current page button.
   * @param {!KeyboardEvent} e
   * @private
   */
  handleKeyPress_(e) {
    const isRtl = this.adapter.isRtl();
    Object(__WEBPACK_IMPORTED_MODULE_7__keyutil__["a" /* handleArrowKey */])(e, this.paginationModel_, isRtl,
        (page) => this.adapter.focus(page));
  }
}




/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return strings; });


/** @enum {string} */
const cssClasses = {
  ACTIVE: 'active',
  PAGE_LIST: 'glue-o-pagination__page-list',
  PAGE_LIST_BUTTON: 'glue-o-pagination__page-list-button',
  PAGE_LIST_BUTTON_CONTAINER: 'glue-o-pagination__page-list-button-container',
  IS_FOCUSED_WITHIN: 'glue-is-focused-within',
};

/** @enum {string} */
const strings = {
  PAGE_PLACEHOLDER: '_PAGE_',
};




/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return handleArrowKey; });
/* unused harmony export handleEnterKey */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__events_key_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_js__ = __webpack_require__(1);
/**
 * Utilities for handling keyboard events for pagination.
 * @package
 */





/**
 * Changes the active page of the pagination component based on left/right
 * arrow key presses and handles focus.
 * @param {!KeyboardEvent} e
 * @param {!PaginationModel} paginationModel
 * @param {boolean} isRtl False if left to right language. True if right to left
 *     language.
 * @param {!function(number)} triggerFocus A function to trigger focus on a tab.
 */
function handleArrowKey(e, paginationModel, isRtl, triggerFocus) {
  // `key` is the new standard but it is in draft form. Support `which` and
  // `keyCode` for backwards compatibility.
  const keyPressed = e.key || e.which || e.keyCode;

  // Create a reusable function for convenience for changing the current page
  // to the next or previous page.
  const changePage = (direction) => {
    (direction === 1) ?
        paginationModel.next() : paginationModel.previous();

    // Move focus to the new button.
    triggerFocus(paginationModel.currentPage);
  };

  switch (keyPressed) {
    case __WEBPACK_IMPORTED_MODULE_0__events_key_js__["a" /* Key */].RIGHT:
    case __WEBPACK_IMPORTED_MODULE_0__events_key_js__["b" /* KeyCode */].RIGHT:
      // Flip arrow key functionality for right to left languages.
      changePage(isRtl ? -1 : 1);
      break;
    case __WEBPACK_IMPORTED_MODULE_0__events_key_js__["a" /* Key */].LEFT:
    case __WEBPACK_IMPORTED_MODULE_0__events_key_js__["b" /* KeyCode */].LEFT:
      changePage(isRtl ? 1 : -1);
      break;
  }
}

/**
 * Handles ENTER key presses to change the current page to the page associated
 * with this tab and move the keyboard focus.
 * @param {!KeyboardEvent} e
 * @param {!PaginationModel} paginationModel
 * @param {number} focusedTabPage The page number associated with the element
 *     that received the keyboard event.
 * @param {!function(number)} triggerFocus A function to trigger focus on a tab.
 */
function handleEnterKey(e, paginationModel, focusedTabPage, triggerFocus) {
  const keyPressed = e.key || e.which || e.keyCode;

  if (keyPressed == __WEBPACK_IMPORTED_MODULE_0__events_key_js__["a" /* Key */].ENTER || keyPressed == __WEBPACK_IMPORTED_MODULE_0__events_key_js__["b" /* KeyCode */].ENTER) {
    e.preventDefault();
    paginationModel.currentPage = focusedTabPage;
    // Triggering focus is necessary on a delay as some screen readers
    // (Chromevox) weirdly move the focus to the first item in the list
    // because it's trying to find the element matching the id (and the
    // element doesn't exist).
    setTimeout(() => triggerFocus(paginationModel.currentPage), 1);
  }
}




/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = enable;
/**
 * @fileoverview Polyfill for IE9+ for element.closest which isn't supported
 * natively until Edge 15+ and not supported by IE at all.
 */



/**
 * Enables polyfill for Element.closest().
 * @param {Window=} win Reference to a window object.
 * @return {boolean} Whether the polyfill has been enabled. Will be false if
 *     already supported natively.
 */
function enable(win = window) {
  if (!win.Element.prototype.closest) {
    win.Element.prototype.closest =
        /** @this {window.Element} */
        function(s) {
      var el = this;
      if (!win.document.documentElement.contains(el)) return null;
      do {
        if (el.matches(s)) return el;
        el = el.parentElement || el.parentNode;
      } while (el !== null && el.nodeType === 1);
      return null;
    };
    return true;
  }
  return false;
};


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaginationPrevious; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mdc_component__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__modelfactory__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__adapter__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation__ = __webpack_require__(109);








/**
 * @final @extends {MDCComponent<!PaginationPreviousFoundation>}
 */
class PaginationPrevious extends __WEBPACK_IMPORTED_MODULE_0__mdc_component__["a" /* MDCComponent */] {

  static attachTo(root) {
    return new PaginationPrevious(root);
  }

  getDefaultFoundation() {
    const paginationModel = __WEBPACK_IMPORTED_MODULE_1__modelfactory__["a" /* ModelFactory */].get(

        this.root_.dataset['gluePagination']);

    const /** !PreviousAdapter */ adapter = {
      getPaginationModel: () => paginationModel,
      setDisabled: (disabled) => this.root_.disabled = disabled,
      getDataAttr: (name) => this.root_.dataset[name],
      registerClickHandler: (handler) => this.listen('click', handler),
      deregisterClickHandler: (handler) => this.unlisten('click', handler),
    };

    return new __WEBPACK_IMPORTED_MODULE_3__foundation__["a" /* PaginationPreviousFoundation */](adapter);
  }

}




/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export PreviousAdapter */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model__ = __webpack_require__(1);




/** @record */
class PreviousAdapter {

  /**
   * @return {!PaginationModel}
   */
  getPaginationModel() {}

  /**
   * @param {string} name
   * @return {string}
   */
  getDataAttr(name) {}

  /**
   * @param {boolean} disabled
   */
  setDisabled(disabled) {}

  /**
   * @param {!Function} handler
   */
  registerClickHandler(handler) {}

  /**
   * @param {!Function} handler
   */
  deregisterClickHandler(handler) {}

}




/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaginationPreviousFoundation; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mdc_foundation__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(6);







/**
 * Foundation for a component that paginates to the previous page when clicked.
 * @final @extends {MDCFoundation<!glue.ui.pagination.PreviousAdapter>}
 */
class PaginationPreviousFoundation extends __WEBPACK_IMPORTED_MODULE_0__mdc_foundation__["a" /* MDCFoundation */] {

  constructor(adapter) {
    super(adapter);

    /** @private {!PaginationModel} */
    this.paginationModel_;

    /** @private {!Function} */
    this.clickHandler_ = () => {
      const updateModel =
          this.adapter.getDataAttr('gluePaginationUpdateModel') != 'false';
      this.paginationModel_.previous(updateModel);
    };

    /** @private {!Function} */
    this.updateHandler_ = () => this.update_();
  }

  init() {
    this.paginationModel_ = this.adapter.getPaginationModel();

    this.adapter.registerClickHandler(this.clickHandler_);

    const {CURRENT_PAGE_EVENT, TOTAL_PAGES_EVENT} = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* strings */];
    this.paginationModel_.listen(CURRENT_PAGE_EVENT, this.updateHandler_);
    this.paginationModel_.listen(TOTAL_PAGES_EVENT, this.updateHandler_);

    this.update_();
  }

  destroy() {
    this.adapter.deregisterClickHandler(this.clickHandler_);

    const {CURRENT_PAGE_EVENT, TOTAL_PAGES_EVENT} = __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* strings */];
    this.paginationModel_.unlisten(CURRENT_PAGE_EVENT, this.updateHandler_);
    this.paginationModel_.unlisten(TOTAL_PAGES_EVENT, this.updateHandler_);
  }

  /**
   * Updates the DOM attributes.
   * @private
   */
  update_() {
    this.adapter.setDisabled(this.paginationModel_.isFirst());
  }

}




/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_base__ = __webpack_require__(0);



/**
 * Represents an options dict parsed from DOM `lb-options=` attribute value.
 * @typedef {Object} accordionOptions
 * @property {number} defaultOpen - Whether a drawer should be open by default.
 * @property {boolean} defaultHideAccordion - Indicates whether to hide the accordion by default.
 */

/** @const {string} - component strings */
const {LABEL_ARIA} = __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */];

/** @const {string} - component classes */
const {OPEN_CLASS,
       VISIBLE_CLASS,
       HAS_TOGGLED_CLASS} = __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* cssClasses */];

/** @const {number} - component numbers */
const {WAIT_UNTIL_VISIBLE_TIME, ENTER_KEY} = __WEBPACK_IMPORTED_MODULE_0__constants__["c" /* numbers */];

class LBAccordionFoundation extends __WEBPACK_IMPORTED_MODULE_1__material_base__["b" /* MDCFoundation */] {
   static get cssClasses() {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* cssClasses */];
  }

  static get events() {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* events */];
  }

  static get strings() {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */];
  }

  static get defaultAdapter() {
    return {
      getRoot: () => /* Element */ {},
      getDrawerIndexFromEvent: (/* event: Event */) => /* number */ 0,
      getOptions: () => /* Object */ ({}),
      getDrawers: () => /* Array: YTAccordionDrawerComponent */ [],
      setToggleButtonAttr: (/* attr: string, value: string */) => {},
      nodeEqualsToggleButton: (/* event: Event */) => /* boolean */ false,
      appendClassDrawers: (/* string: className */) => {},
      removeClassDrawers: (/* string: className */) => {},
      setDrawerStyles: (/* styles: Object */) => {},
      drawersHaveMaterialized: (/* string: className */) => /* boolean */ false,
      appendClassToggleButton: (/* className: string */) => {},
      removeClassToggleButton: (/* className: string */) => {},
      eventStopPropagation: (/* event: Event */) => {},
      eventPreventDefault: (/* event: Event */) => {},
      enableDrawersTabState: () => {},
      attachInteractionHandler: (
          /* type: string, handler: EventListener */) => {},
      detachInteractionHandler: (
          /* type: string, handler: EventListener */) => {},
      attachResizeHandler: (/* handler: EventListener */) => {},
      detachResizeHandler: (/* handler: EventListener */) => {},
    };
  }

  constructor(adapter) {
    super(Object.assign(LBAccordionFoundation.defaultAdapter, adapter));

    /** @private @const {!accordionOptions} */
    this.options_ = this.adapter_.getOptions();

    /** @private @const {string} */
    this.root_ = this.adapter_.getRoot();

    /** @private {boolean} */
    this.openDrawers_ = false;

    // Click Handler
    this.clickHandler_ = (event) => this.toggleApparatus_(event);

    // Resize Handler
    this.resizeHandler_ = () => this.computeDrawerResize_();

    // Keyboard Handler
    this.keyboardHandler_ = (event) => {
      switch (event.keyCode) {
        case ENTER_KEY:
          this.toggleApparatus_(event);
          break;
      }
    };

    // Open/Close/Toggle Drawer Handlers
    this.root_.addEventListener(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* events */].OPEN_DRAWER, (e) => {
        if (e.target.isEqualNode(this.root_)) {
          this.openDrawerByIndex(e.detail.index);
        }
      });

    this.root_.addEventListener(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* events */].CLOSE_DRAWER, (e) => {
        if (e.target.isEqualNode(this.root_)) {
          this.closeDrawerByIndex(e.detail.index);
        }
      });

    this.root_.addEventListener(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* events */].TOGGLE_DRAWER, (e) => {
        if (e.target.isEqualNode(this.root_)) {
          this.toggleDrawerByIndex(e.detail.index);
        }
      });
  }

  /**
   * Makes all the entire accordion elements visible.
   */
  makeAccordionVisible() {
    this.adapter_.setDrawerStyles({
      'height': 'auto',
    });

    setTimeout(() => {
      this.adapter_.appendClassDrawers(VISIBLE_CLASS);
      this.adapter_.appendClassToggleButton(HAS_TOGGLED_CLASS);
      this.adapter_.setToggleButtonAttr(
          LABEL_ARIA, this.options_.openAllFaqText);
      this.adapter_.enableDrawersTabState();
    }, WAIT_UNTIL_VISIBLE_TIME);
  }

  /**
   * Delegates event on accordion drawers
   * and on toggle all button.
   * @param {!Event} event
   * @private
   */
  toggleApparatus_(event) {
    // Check if `event.target` is the toggle all button.
    if (this.adapter_.nodeEqualsToggleButton(event)) {
      if (this.options_.defaultHideAccordion &&
         !this.adapter_.drawersHaveMaterialized()) {
        this.makeAccordionVisible();
      } else {
        this.adapter_.getDrawers()
            .forEach((drawer) => this.setDrawerLever_(drawer));

        this.stampToggleButtonState_();
      }
      return;
    }

    const index = this.adapter_.getDrawerIndexFromEvent(event);

    if (index === -1) {
      return;
    }

    this.getDrawerByIndex(index).openShutDrawer();
  }

  /**
   * Gets a drawer at the given index.
   * @param {number} index The 0-based index of the drawer to get.
   */
  getDrawerByIndex(index) {
    const drawer = this.adapter_.getDrawers()[index];
    return drawer;
  }

  /**
   * Opens a drawer.
   * @param {number} index The 0-based index of the drawer to open.
   */
  openDrawerByIndex(index) {
    this.getDrawerByIndex(index).openDrawer();
  }

  /**
   * Closes a drawer.
   * @param {number} index The 0-based index of the drawer to close.
   */
  closeDrawerByIndex(index) {
    this.getDrawerByIndex(index).shutDrawer();
  }

  /**
   * Toggles a drawer.
   * @param {number} index The 0-based index of the drawer to toggle.
   */
  toggleDrawerByIndex(index) {
    this.getDrawerByIndex(index).openShutDrawer();
  }

  /**
   * Updates toggle button state classes, attributes, and flags.
   * @private
   */
  stampToggleButtonState_() {
    if (this.openDrawers_) {
      this.adapter_.removeClassToggleButton(OPEN_CLASS);
      this.adapter_.setToggleButtonAttr(
          LABEL_ARIA, this.options_.openAllFaqText);
    } else {
      this.adapter_.appendClassToggleButton(OPEN_CLASS);
      this.adapter_.setToggleButtonAttr(
          LABEL_ARIA, this.options_.shutAllFaqText);
    }

    // Flip current state of `openDrawers_` flag;
    this.openDrawers_ = !this.openDrawers_;
  }

 /**
  * Opens or shuts accordion drawers contingent on `openDrawers_` flag.
  * @private
  */
  setDrawerLever_(drawer) {
    if (this.openDrawers_) {
      drawer.shutDrawer();
    } else {
      drawer.openDrawer();
    }
  }

  /**
   * Loops through all drawers and re-compute height.
   * @private
   */
  computeDrawerResize_() {
    this.adapter_.getDrawers().forEach((drawer) =>
        drawer.computeDrawerHeight());
  }

  /**
   * Resets accordion.
   */
  destroy() {
    this.adapter_.detachInteractionHandler('click', this.clickHandler_);
    this.adapter_.detachInteractionHandler('keydown', this.keyboardHandler_);
    this.adapter_.detachResizeHandler(this.resizeHandler_);
  }

  /**
   * Uses options map to configure special accordion characteristcs.
   * @private
   */
  configureAccordion_() {
    if (!this.options_.defaultHideAccordion) {
      this.makeAccordionVisible();
    } else {
      this.adapter_.setDrawerStyles({'height': 0});
    }

    // Check if we should open a drawer by default.
    if (this.options_.hasOwnProperty('defaultOpen')) {
      const drawer = this.adapter_.getDrawers()[this.options_.defaultOpen];
      drawer.openShutDrawer();
    }
  }

  /**
   * Initializes accordion states and bind event handlers.
   */
  init() {
    this.adapter_.attachInteractionHandler('keydown', this.keyboardHandler_);
    this.adapter_.attachInteractionHandler('click', this.clickHandler_);
    this.adapter_.attachResizeHandler(this.resizeHandler_);
    this.configureAccordion_();
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBAccordionFoundation;



/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_base__ = __webpack_require__(0);



/** @const {number} - component numbers */
const {ESCAPE_KEY, ENTER_KEY} = __WEBPACK_IMPORTED_MODULE_0__constants__["c" /* numbers */];

/** @const {string} - component classes */
const {OPEN_CLASS, ACTIVE_CLASS} = __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* cssClasses */];

/** @const {string} - component strings */
const {
    DRAWER_INDEX_KEY,
    HIDDEN_ARIA,
    EXPANDED_ARIA,
    CONTROLS_ARIA,
    ID,
    ID_PREFIX,
    OPEN_TRANSITION,
    SHUT_TRANSITION} = __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */];

class LBAccordionDrawerFoundation extends __WEBPACK_IMPORTED_MODULE_1__material_base__["b" /* MDCFoundation */] {
   /** @return {!Object<string, string>} */
   static get cssClasses() {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* cssClasses */];
  }

  /** @return {!Object<string, string>} */
  static get strings() {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */];
  }

  /** @return {!Object<string, number>} */
  static get numbers() {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["c" /* numbers */];
  }

  static get defaultAdapter() {
    return {
      getDrawerRoot: () => /* Element */ {},
      getDrawerBody: () => /* Element */ {},
      getDrawerHead: () => /* Element */ {},
      getDrawerIndex: () => /* number */ 0,
      setDrawerBodyAttr: (/* attrNames: Object */) => {},
      setDrawerHeadAttr: (/* attrNames: Object */) => {},
      removeDrawerBodyAttr: (/* attrName: string */) => {},
      removeDrawerHeadAttr: (/* attrName: string */) => {},
      getDrawerRootAttr: (/* attrName: string */) => /* string */ '',
      getDrawerBodyAttr: (/* attrName: string */) => /* string */ '',
      getDrawerHeadAttr: (/* attrName: string */) => /* string */ '',
      getDrawerBodyHeight: () => /* number */ 0,
      setDrawerBodyStyle: (/* propertyNames: Object */) => {},
      appendClassDrawerBody: (/* className: string */) => {},
      removeClassDrawerBody: (/* className: string */) => {},
      appendClassDrawerRoot: (/* className: string */) => {},
      removeClassDrawerRoot: (/* className: string */) => {},
      probeDOMForController: () =>  /* boolean */ false,
      eventStopPropagation: (/* event: Event */) => {},
      getFocusableElements: () => /* NodeList */ {},
      saveElementTabState: (/* element: Element */) => {},
      restoreElementTabState: (/* element: Element */) => {},
      preventElementTab: (/* element: Element */) => {},
      nameEqualsEventProperty: (
      /* event: Event, propertyName: string */) => /* boolean */ false,
      drawerHeadAttachInteractionHandler: (
        /* type: string, handler: EventListener */) => {},
      drawerHeadDetachInteractionHandler: (
        /* type: string, handler: EventListener */) => {},
      attachInteractionHandler: (
          /* type: string, handler: EventListener */) => {},
      detachInteractionHandler: (
          /* type: string, handler: EventListener */) => {},
    };
  }

  constructor(adapter) {
    super(
        Object.assign(LBAccordionDrawerFoundation.defaultAdapter, adapter)
      );

    /** @private {boolean} */
    this.inert_ = false;

    /** @private {boolean} */
    this.localClickBound_ = false;

    /** @private {string} - transition direction */
    this.transitionAction_ = OPEN_TRANSITION;

    /** @private {number} - Cache drawer body `scrollHeight`. */
    this.drawerBodyHeight_ = 0;

    /** @private {boolean} - Flag set when drawer is open/shut. */
    this.drawerOpen_ = false;

    /** @private {number} - Number of time key `enter` pressed. */
    // XXX(claytonmisura@) using a flag `drawerOpen_` doesn't seem
    // to work correctly with keyboard and `transitionend` handler.
    this.drawerEnterKey_ = 0;

    // Click Handler
    this.clickHandler_ = (event) => {
      this.openShutDrawer();
    };

    // Transition Handler
    this.transitionHandler_ = (event) => {
      this.transitionDrawerComplete_(event);
    };

    // KeyboardHandler
    this.keyboardHandler_ = (event) => {
      const which = (event.which || event.keyCode);
      // To guard against nested focusable elements, check that the event
      // target is equal to the drawer's head element before executing
      // the remainder of the function.
      if (!this.adapter_.getDrawerHead().isEqualNode(event.target)) {
        return;
      }

      switch (which) {
        case ESCAPE_KEY:
          this.shutDrawer();
          this.drawerEnterKey_ = 0;
          break;
        case ENTER_KEY:
          if (!this.drawerEnterKey_) {
            this.openDrawer();
            this.drawerEnterKey_++;
          } else {
            this.shutDrawer();
            this.drawerEnterKey_ = 0;
          }
          break;
      }
    };
  }

  /**
   * Makes open drawer child elements tabbable.
   * @private
   */
  restoreTabKey_() {
    if (!this.inert_) {
      return;
    }

    this.adapter_.getFocusableElements().forEach((element) => {
      this.adapter_.restoreElementTabState(element);
    });

    this.inert_ = false;
  }

  /**
   * Makes shut drawer child elements untabbable.
   * @private
   */
  preventTabKey_() {
    if (this.inert_) {
      return;
    }

    this.adapter_.getFocusableElements().forEach((element) => {
      this.adapter_.saveElementTabState(element);
      this.adapter_.preventElementTab(element);
    });

    this.inert_ = true;
  }


  /**
   * Computes and caches drawer height.
   */
  computeHeight() {
    this.drawerBodyHeight_ = this.adapter_.getDrawerBodyHeight();
    if (this.drawerOpen_) {
      this.adapter_.setDrawerBodyStyle({
        height: `${this.drawerBodyHeight_}px`,
      });
    }
  }

  /**
   * Method to run on `transitionend` event.
   * @param {!Event} event
   * @private
   */
  transitionDrawerComplete_(event) {
    // Only toggle state when the `opacity` transition is completed.
    if (!this.adapter_.nameEqualsEventProperty(event, 'opacity')) {
      return;
    }

    this.monitorTransitionActionLifecycle_(this.transitionAction_);
  }

  /**
   * Monitors drawer lifescycle.
   * @param {string} action
   * @private
   */
  monitorTransitionActionLifecycle_(action) {
    let futureAction = '';

    switch (action) {
      case OPEN_TRANSITION:
        this.adapter_.appendClassDrawerBody(ACTIVE_CLASS);
        futureAction = SHUT_TRANSITION;
        break;
      case SHUT_TRANSITION:
        this.adapter_.removeClassDrawerBody(ACTIVE_CLASS);
        futureAction = OPEN_TRANSITION;
        break;
    }

    this.transitionAction_ = futureAction;
  }

  /**
   * Assigns new drawer state. Update relevant drawer attributes and classes.
   * @param {boolean} state
   * @private
   */
  stampDrawerState_(state) {
    const drawerBodyAttrs = {};
    const drawerHeadAttrs = {};

    drawerBodyAttrs[HIDDEN_ARIA] = !state;
    drawerHeadAttrs[EXPANDED_ARIA] = state;
    drawerBodyAttrs[EXPANDED_ARIA] = state;

    this.adapter_.setDrawerBodyAttr(drawerBodyAttrs);
    this.adapter_.setDrawerHeadAttr(drawerHeadAttrs);

    this.drawerOpen_ = state;
  }

  /**
   * Sets drawer state to open.
   */
  openDrawer() {
    this.adapter_.setDrawerBodyStyle({
      height: `${this.drawerBodyHeight_}px`,
      opacity: 1,
    });

    this.restoreTabKey_();
    this.stampDrawerState_(true);
    this.adapter_.appendClassDrawerRoot(OPEN_CLASS);
  }

  /**
   * Sets drawer state to shut.
   */
  shutDrawer() {
    this.adapter_.setDrawerBodyStyle({height: 0, opacity: 0});
    this.preventTabKey_();
    this.stampDrawerState_(false);
    this.adapter_.removeClassDrawerRoot(OPEN_CLASS);
  }

  /**
   * Toggles drawer state.
   */
  openShutDrawer() {
    if (this.drawerOpen_) {
      this.shutDrawer();
    } else {
      this.openDrawer();
    }
  }

  /**
   * Resets drawer.
   */
  destroy() {
    this.drawerOpen_ = false;

    // Remove body attributes.
    this.adapter_.removeDrawerBodyAttr('style');
    this.adapter_.removeDrawerBodyAttr(ID);
    this.adapter_.removeDrawerBodyAttr(HIDDEN_ARIA);
    this.adapter_.removeDrawerBodyAttr(EXPANDED_ARIA);

    // Remove head attributes.
    this.adapter_.removeDrawerHeadAttr(CONTROLS_ARIA);
    this.adapter_.removeDrawerHeadAttr(EXPANDED_ARIA);
    this.adapter_.removeDrawerHeadAttr(DRAWER_INDEX_KEY);

    // Detach listeners
    this.adapter_.detachInteractionHandler(
        'transitionend', this.transitionHandler_);

    this.adapter_.detachInteractionHandler(
        'keyup', this.keyboardHandler_);

    if (this.localClickBound_) {
      this.adapter_.drawerHeadDetachInteractionHandler('click',
          this.clickHandler_);

      this.localClickBound_ = false;
    }
  }

  /**
   * Initializes drawer states and bind event handlers.
   */
  init() {
    if (this.adapter_.probeDOMForController()) {
      const index = this.adapter_.getDrawerIndex();
      this.adapter_.setDrawerBodyAttr(ID, (ID_PREFIX + index));
      this.adapter_.setDrawerHeadAttr(CONTROLS_ARIA, (ID_PREFIX + index));
    } else {
      const index = Math.floor(Math.random() * Date.now()) + 1;
      this.adapter_.setDrawerBodyAttr(ID, (ID_PREFIX + index));
      this.adapter_.setDrawerHeadAttr(CONTROLS_ARIA, (ID_PREFIX + index));
      this.adapter_.drawerHeadAttachInteractionHandler('click',
          this.clickHandler_);
      this.localClickBound_ = true;
    }

    this.adapter_.attachInteractionHandler('keyup', this.keyboardHandler_);
    this.stampDrawerState_(false);
    this.computeHeight();
    this.preventTabKey_();

    this.adapter_.attachInteractionHandler(
        'transitionend', this.transitionHandler_);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBAccordionDrawerFoundation;



/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const TAB_DATA = 'data-lb-tabindex';
const TAB_DATA_HANDLED = 'data-lb-tabindex-handled';


// Set single or multiple attributes on element.
const setAttr = (element, attrName, attrData) => {
  if (!attrData && attrName === Object(attrName)) {
    const attrData = attrName;

    Object.keys(attrData).forEach((attrName) => {
      const attrDatum = attrData[attrName];
      element.setAttribute(attrName, attrDatum);
    });
  } else if (attrName && (attrData !== undefined || attrData !== null)) {
    element.setAttribute(attrName, attrData);
  }
};
/* harmony export (immutable) */ __webpack_exports__["c"] = setAttr;


// Save the tab state for an element.
const saveElementTabState = (element) => {
  if (element.hasAttribute('tabindex')) {
    element.setAttribute(TAB_DATA, element.getAttribute('tabindex'));
  } else {
    element.setAttribute(TAB_DATA, '0');
  }
  element.setAttribute(TAB_DATA_HANDLED, true);
};
/* harmony export (immutable) */ __webpack_exports__["b"] = saveElementTabState;


// Restore the tab state for an element, if it was saved.
const restoreElementTabState = (element) => {
  // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
  if (element.hasAttribute(TAB_DATA_HANDLED)) {
    if (element.hasAttribute(TAB_DATA)) {
      element.setAttribute('tabindex', element.getAttribute(TAB_DATA));
      element.removeAttribute(TAB_DATA);
    } else {
      element.setAttribute('tabindex', '0');
    }
    element.removeAttribute(TAB_DATA_HANDLED);
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = restoreElementTabState;


// Walk DOM to find specific parent node.
// `onParentNodeMatch` must return a boolean.
const traverseDOMForParentElement = (startNode, onParentNodeMatch) => {
    // Set `parent` to startNode,
    let parent = startNode;
    let exists = false;
    // Traverse DOM if `parent` is truthy.
    while (parent) {
      if (onParentNodeMatch(parent)) {
        exists = true;
        break;
      }
      // Set `parent` to this element's parent.
      parent = parent.parentElement;
    }

    if (parent && onParentNodeMatch(parent)) {
      exists = true;
    }
    return exists;
};
/* harmony export (immutable) */ __webpack_exports__["d"] = traverseDOMForParentElement;



/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_index__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(114);




/**
 * Class that defines LBAutoScroll
 */
class LBAutoScroll extends __WEBPACK_IMPORTED_MODULE_0__base_index__["a" /* default */] {
  // Invoked by `mdc.autoInit()`
  static attachTo(root) {
    return new LBAutoScroll(root);
  }

  /**
   * Instantiate component foundation and pass it the adapter dict.
   * @return {LBAutoScrollFoundation}
   */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBAutoScrollFoundation */]({
      getOptions: () => {
        return this.options_;
      },
      attachClickHandler: (handler) => {
        this.root_.addEventListener('click', handler);
      },
      getElementScrollTarget: () => {
        if (!this.elementScrollTarget_) {
          const elementId = this.root_.getAttribute('href').replace(/^#/, '');
          this.elementScrollTarget_ = document.getElementById(elementId);
        }
        return this.elementScrollTarget_;
      },
      preventDefault: (event) => {
        event.preventDefault();
      },
    });
  }

  /**
   * Initialize component and parse options to use in adapter.
   */
  initialize() {
    this.parseOptionsString('auto-scroll');
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBAutoScroll;



/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_auto_scroll__ = __webpack_require__(57);



class LBAutoScrollFoundation extends __WEBPACK_IMPORTED_MODULE_0__material_base__["b" /* MDCFoundation */] {
  static get defaultAdapter() {
    return {
      getOptions: () => /* Object */ ({}),
      attachClickHandler: (/* handler: EventListener */) => {},
      preventDefault: (/* event: Event */) => {},
      getElementScrollTarget: () => /* Element */ {},
    };
  }

  constructor(adapter) {
    super(Object.assign(LBAutoScrollFoundation.defaultAdapter, adapter));

    /** @private @const {!Object<string, *>} */
    this.options_ = this.adapter_.getOptions();

    this.scrollProvider_ = new __WEBPACK_IMPORTED_MODULE_1__providers_auto_scroll__["a" /* default */](this.options_);
    this.adapter_.attachClickHandler(this.handleClick_.bind(this));
    this.elementScrollTarget_ = this.adapter_.getElementScrollTarget();
  }

  /**
   * Handles clicks on the scroll trigger.
   * @param {Event} e The event returned from the handler.
   */
  handleClick_(e) {
    this.adapter_.preventDefault(e);
    const el = this.elementScrollTarget_;
    el && this.scrollProvider_.scrollToElement(el);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBAutoScrollFoundation;



/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_index__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mobile_nav__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__nav_constants__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(2);







class LBNav extends __WEBPACK_IMPORTED_MODULE_0__base_index__["a" /* default */] {
  /**
   * Creates a new instance of the LBNav class.
   * @param {!Element} root The header component element.
   * @return {!LBNav}
   */
  static attachTo(root) {
    return new LBNav(root);
  }

  /**
   * @return {!LBNavFoundation}
   */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBNavFoundation */]({
      addClass: (el, className) => {
        el.classList.add(className);
      },
      addListener: (eventType, handler, el = window) => {
        el.addEventListener(eventType, handler);
      },
      containsClass: (el, className) => {
        return el.classList.contains(className);
      },
      delegateEvent: (selector, eventType, handler, el = document) => {
        Object(__WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* delegate */])(el, selector, eventType, handler);
      },
      getBoundingRect: (el) => {
        return el.getBoundingClientRect();
      },
      getHash: (link) => {
        return link ? link.split('#')[1] : '';
      },
      getOptions: () => {
        return this.options_;
      },
      getRootEl: () => {
        return this.root_;
      },
      getParentNavItem: (el) => {
        const navWrapperClass = __WEBPACK_IMPORTED_MODULE_3__nav_constants__["b" /* Classes */].NAV_ITEM_WRAPPER;
        const parentNavItemSelector = __WEBPACK_IMPORTED_MODULE_3__nav_constants__["f" /* Selectors */].NAV_ITEMS;
        let currentEl = el;

        // Mobile nav.
        if (!el.classList.contains(__WEBPACK_IMPORTED_MODULE_3__nav_constants__["b" /* Classes */].SUBNAV_ITEM)) {
          return el.parentElement.previousElementSibling;
        }

        while (!currentEl.classList.contains(navWrapperClass)) {
          currentEl = currentEl.parentElement;
        }

        return currentEl.querySelector(parentNavItemSelector);
      },
      getWindowWidth: () => {
        return window.innerWidth;
      },
      isPastBreakpoint: () => {
        const pseudoContent = window.getComputedStyle(this.mobileNavEl_,
            '::before').getPropertyValue('content');

        return pseudoContent !== '"mobile"';
      },
      queryEl: (selector, el) => {
        return el.querySelector(selector);
      },
      queryAll: (selector) => {
        return this.queryComponentSelectorAll(selector);
      },
      removeClass: (el, className) => {
        el.classList.remove(className);
      },
      setAttr: (attr, val, el = this.root_) => {
        this.setAttr(attr, val, el);
      },
      toggleClass: (className, addClass, el) => {
        this.toggleClass(className, addClass, el);
      },
    });
  }

  /**
   * Automatically gets called when `[data-mdc-auto-init]` is present on
   * the root element.
   * @private
   */
  initialize() {
    /** @private @const {!Element} */
    this.mobileNavEl_ = this.queryComponentSelector(__WEBPACK_IMPORTED_MODULE_3__nav_constants__["f" /* Selectors */].MOBILE_NAV);

    this.parseOptionsString('header');

    if (!this.options_.sticky) {
      this.initSlideAway_();
    } else {
      this.root_.classList.add(__WEBPACK_IMPORTED_MODULE_3__nav_constants__["b" /* Classes */].STICKY);
    }

    __WEBPACK_IMPORTED_MODULE_2__mobile_nav__["a" /* LBMobileNav */].attachTo(this.mobileNavEl_);
  }

  /**
   * Initializes the slide-away functionality that makes the header slide
   * upward out of the viewport when the user scrolls down the page, and back
   * into view when they scroll up the page.
   * @private
   */
  initSlideAway_() {
    this.lastScrollY_ = window.scrollY;
    this.netScrollY_ = 0;

    /**
     * The ID of a setTimeout that keeps track of if a mousemove event has
     * occurred recently.
     * @private {?number}
     */
    this.mouseMoveTimeoutId_;

    /**
     * The original coordinates of the mouse when the user starts
     * a timed mousemove.
     * @private {!Object}
     */
    this.mouseMoveOrigination_ = {
      x: null,
      y: null,
    };

    window.addEventListener('scroll', this.handleScroll_.bind(this));
    // If the user moves their mouse around over a threshold, reveal the nav.
    document.addEventListener('mousemove', this.handleMouseMove_.bind(this));
  }

  /**
   * Handles the window scroll event which causes the header to slide in or out
   * of view. Only responds after the user has scrolled a threshold distance.
   * @param {Event} e The DOM scroll event.
   * @private
   */
  handleScroll_(e) {
    const lastScrollIncrement = window.scrollY - this.lastScrollY_;
    this.netScrollY_ += lastScrollIncrement;

    // Ensure the header is always in view near the top of the page.
    if (window.scrollY < __WEBPACK_IMPORTED_MODULE_3__nav_constants__["e" /* Numbers */].SLIDE_AWAY_SCROLL_THRESHOLD) {
      this.toggleHeaderSlideAway(false);
      return;
    }

    // Otherwise toggle the header visibility if we've met the threshold.
    if (Math.abs(this.netScrollY_) > __WEBPACK_IMPORTED_MODULE_3__nav_constants__["e" /* Numbers */].SLIDE_AWAY_SCROLL_THRESHOLD) {
      // Determine if the user is scrolling up or down and trigger hide/show.
      const scrollingDown = this.netScrollY_ > 0;
      this.toggleHeaderSlideAway(scrollingDown);
    }

    this.lastScrollY_ = window.scrollY;
  }

  /**
   * Handles the mousemove event which causes the header to slide in or out
   * of view. Only responds after the user has moved a threshold distance.
   * @param {Event} e The DOM mousemove event.
   * @private
   */
  handleMouseMove_(e) {
    if (this.mouseMoveOrigination_.x === null) {
      this.mouseMoveOrigination_.y = e.clientY;
      this.mouseMoveOrigination_.x = e.clientX;
    }

    const deltaX = Math.abs(this.mouseMoveOrigination_.x - e.clientX);
    const deltaY = Math.abs(this.mouseMoveOrigination_.y - e.clientY);

    if (deltaX > __WEBPACK_IMPORTED_MODULE_3__nav_constants__["e" /* Numbers */].SLIDE_AWAY_MOUSEMOVE_THRESHOLD ||
        deltaY > __WEBPACK_IMPORTED_MODULE_3__nav_constants__["e" /* Numbers */].SLIDE_AWAY_MOUSEMOVE_THRESHOLD) {
      this.toggleHeaderSlideAway(false);
      clearTimeout(this.mouseMoveTimeoutId_);
    }

    // Cancel the existing and start a new setTimeout.
    this.mouseMoveTimeoutId_ && clearTimeout(this.mouseMoveTimeoutId_);
    this.mouseMoveTimeoutId_ = setTimeout(() => {
      // User moved mouse too slowly, reset.
      this.resetSlideAway_();
    }, __WEBPACK_IMPORTED_MODULE_3__nav_constants__["e" /* Numbers */].SLIDE_AWAY_MOUSEMOVE_RESET_TIME);
  }

  /**
   * Resets the netScrollY_ and mouseMoveDelta_ variables.
   * @private
   */
  resetSlideAway_() {
    this.netScrollY_ = 0;
    this.mouseMoveOrigination_.x = this.mouseMoveOrigination_.y = null;
  }

  /**
   * Causes the header to slide in or out of view.
   * @param {boolean} slideAway If the header should slide away.
   */
  toggleHeaderSlideAway(slideAway = true) {
    this.root_.classList.toggle(__WEBPACK_IMPORTED_MODULE_3__nav_constants__["b" /* Classes */].SLIDE_AWAY, slideAway);
    // Reset here since this method can also be called after a mousemove, or
    // as a public API.
    this.resetSlideAway_();
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBNav;



/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(20);




class LBNavFoundation extends __WEBPACK_IMPORTED_MODULE_0__material_base__["b" /* MDCFoundation */] {
  static get defaultAdapter() {
    return {
      addClass: (/* el: !Element, className: string */) => {},
      addListener: (/* eventType: string,
                       handler: !Function,
                       el: !Element|window */) => {},
      containsClass: (/* el: !Element,
                         className: string */) => /* boolean */ false,
      delegateEvent: (/* selector: string, eventType: string,
                         handler: !Function,
                         el: !Element|document */) => {},
      getBoundingRect: (/* el: !Element */) => /* !DOMRect */ {},
      getHash: (/* link: string */) => /* string */ '',
      getParentNavItem: (/* subnavEl: !Element */) => /* !Element */ {},
      getRootEl: () => /* !Element */ {},
      getWindowWidth: () => /* number */ 0,
      isPastBreakpoint: () => /* boolean */ false,
      queryEl: (/* selector: string,
                   el: !Element */) => /* !Element */ {},
      queryAll: (/* selector: string */) => /* !Array<!Element> */ [],
      removeClass: (/* el: !Element, className: string */) => {},
      setAttr: (/* attr: string, val: string, el: !Element */) => {},
      toggleClass: (/* className: string,
                       addClass: boolean,
                       el: !Element */) => {},
    };
  }

  constructor(adapter) {
    super(Object.assign(LBNavFoundation.defaultAdapter, adapter));

    /** @private @const {!Object<string, *>} */
    this.options_ = this.adapter_.getOptions();

    /**
     * All links with hashes.
     * @private {!Array<?Element>}
     */
    this.hashLinks_ = this.adapter_.queryAll(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].HASH_LINKS);

    if (this.hashLinks_) {
      /** @private {!Element} */
      this.allNavItems_ = this.adapter_.queryAll(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].NAV_ITEMS);

      this.adapter_.delegateEvent(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].HASH_LINKS, 'click',
          this.handleHashLinks_.bind(this));

      this.handleHashLinks_();
    }

    /** @private {!Array<?Element>} */
    this.subnavs_ = this.adapter_.queryAll(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].SUBNAV);

    // No need to go any further if there are no subnavs to worry about.
    if (!this.subnavs_.length) return;

    /**
     * Whether or not any of the subnavs are visible.
     * @private {boolean}
     */
    this.subnavIsVisible_ = false;

    /**
     * Header element.
     * @private {!Element}
     */
    this.root_ = this.adapter_.getRootEl();

    /**
     * Wrapper elements that contain individual nav items and their accompanying
     * subnav, if one exists.
     * @private {!Array<!Element>}
     */
    this.navItemWrappers_ = this.adapter_.queryAll(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].NAV_ITEM_WRAPPER);

    // Set active parent nav item when a subnav item is active on load.
    const activeSubnavItems = this.adapter_.queryAll(
        `${__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].ACTIVE_MOBILE_SUBNAV_ITEM},
         ${__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].ACTIVE_SUBNAV_ITEM}`);

    activeSubnavItems.forEach((item) => this.setActiveParent_(item));

    this.registerSubnavEvents_();
  }

  /** @private */
  registerSubnavEvents_() {
    this.navItemWrappers_.forEach((wrapper, i) => {
      const subnav = this.adapter_.queryEl(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].SUBNAV, wrapper);

      if (subnav) {
        this.adapter_.addListener(__WEBPACK_IMPORTED_MODULE_1__constants__["c" /* Events */].MOUSEENTER, (e) => {
            this.handleMouseEvent_(e, subnav);
        }, wrapper);

        this.adapter_.addListener(__WEBPACK_IMPORTED_MODULE_1__constants__["c" /* Events */].MOUSELEAVE, (e) => {
            this.handleMouseEvent_(e, subnav);
        }, wrapper);
      }
    });

    this.adapter_.delegateEvent(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].NAV_ITEM_WRAPPER, __WEBPACK_IMPORTED_MODULE_1__constants__["c" /* Events */].KEYUP,
        this.handleKeyUp_.bind(this), this.root_);

    this.adapter_.addListener(__WEBPACK_IMPORTED_MODULE_1__constants__["c" /* Events */].KEYUP,
        this.handleTabbingOffNav_.bind(this));

    this.adapter_.addListener(__WEBPACK_IMPORTED_MODULE_1__constants__["c" /* Events */].RESIZE, this.handleResize_.bind(this));
  }

  /**
   * Whether or not the given element is a desktop nav item.
   * @param {!Element} el DOM element.
   * @return {boolean}
   * @private
   */
  isNavItem(el) {
    return this.adapter_.containsClass(el, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].NAV_ITEM);
  }

  /**
   * Whether or not the given element is a mobile nav item.
   * @param {!Element} el DOM element.
   * @return {boolean}
   * @private
   */
  isMobileNavItem(el) {
    return this.adapter_.containsClass(el, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].MOBILE_NAV_ITEM);
  }

  /**
   * Whether or not the given element is a desktop subnav item.
   * @param {!Element} el DOM element.
   * @return {boolean}
   * @private
   */
  isSubNavItem(el) {
    return this.adapter_.containsClass(el, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].SUBNAV_ITEM);
  }

  /**
   * Whether or not the given element is a mobile subnav item.
   * @param {!Element} el DOM element.
   * @return {boolean}
   * @private
   */
  isMobileSubNavItem(el) {
    return this.adapter_.containsClass(el, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].MOBILE_SUBNAV_ITEM);
  }

  /**
   * Whether or not the given subnav's right edge overflows outside the
   * viewport.
   * @param {!Element} subnav The visible subnav element.
   * @return {boolean}
   * @private
   */
  subnavOverflowsRight_(subnav) {
    return this.adapter_.getBoundingRect(subnav).right >
        this.adapter_.getWindowWidth();
  }

  /**
   * Whether or not the given subnav's left edge overflows outside the viewport.
   * @param {!Element} subnav The visible subnav element.
   * @return {boolean}
   * @private
   */
  subnavOverflowsLeft_(subnav) {
    return this.adapter_.getBoundingRect(subnav).left < 0;
  }

  /**
   * Adds an `overflow` class to the given subnav if it overflows outside the
   * viewport by checking its right and left positions. The order of which side
   * to check first depends on the doucments `dir` value.
   * @param {!Element} subnav The visible subnav element.
   * @private
   */
  setSubnavAlignment_(subnav) {
    const isRtl = document.dir === 'rtl';
    const firstOverflowCheck = isRtl ?
        this.subnavOverflowsLeft_(subnav) : this.subnavOverflowsRight_(subnav);

    if (firstOverflowCheck) {
      // Subnav overflows right (left for RTL). This class right-aligns it to
      // its parent nav item.
      this.adapter_.addClass(subnav, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].SUBNAV_OVERFLOWING_RIGHT);
    }

    // Pertains to really long subnavs.
    const secondOverflowCheck = !isRtl ? this.subnavOverflowsLeft_(subnav) :
        this.subnavOverflowsRight_(subnav);

    if (secondOverflowCheck) {
      // Subnav overflows left (right for RTL) after the first align adjustment
      // was made. This removes the first `overflow` class and adds another one
      // that positions the subnav `fixed` and flush with the left side (right
      // side for RTL) of the viewport.
      this.adapter_.removeClass(subnav, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].SUBNAV_OVERFLOWING_RIGHT);
      this.adapter_.addClass(subnav, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].SUBNAV_OVERFLOWING_LEFT);
    }
  }

  /**
   * Toggles the appropriate `active` classes on all nav items to set their
   * proper active states when there is a hash in the URL. This happens on load
   * and when a hash link is clicked.
   * @param {?Element} target Clicked hash link.
   * @private
   */
  handleHashLinks_(target) {
    // Either the target's or URL's hash.
    const activeHash = target ? this.adapter_.getHash(target.href) :
                                this.adapter_.getHash(window.location.hash);

    // No need to do anything if no hash is present in the clicked nav item or
    // in the URL.
    if (!activeHash) return;

    // Checks if the `activeHash` is present in the nav.
    const activeHashInNav = this.allNavItems_.some((item) => {
      const link = item.href;

      // Sometimes nav items are just labels, not links.
      if (link) {
        const hash = link.split('#')[1];
        return (hash === activeHash);
      }
    });

    // No need to do anything if the `activeHash` is unrelated to the nav.
    if (!activeHashInNav) return;

    this.allNavItems_.forEach((item) => {
      // Whether or not the `activeHash` matches the nav item's.
      const isActive = activeHash === this.adapter_.getHash(item.href);

      // Toggles the appropriate `active` class depending on what type of nav
      // item it is.
      this.adapter_.toggleClass(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].ACTIVE_NAV_ITEM,
          isActive && this.isNavItem(item), item);
      this.adapter_.toggleClass(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].ACTIVE_MOBILE_NAV_ITEM,
          isActive && this.isMobileNavItem(item), item);
      this.adapter_.toggleClass(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].ACTIVE_SUBNAV_ITEM,
          isActive && this.isSubNavItem(item), item);
      this.adapter_.toggleClass(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].ACTIVE_MOBILE_SUBNAV_ITEM,
          isActive && this.isMobileSubNavItem(item), item);

      // Handle parent nav items for active subnav items.
      if (isActive && this.isSubNavItem(item) ||
          isActive && this.isMobileSubNavItem(item)) {
        // Item should be active and is a subnav item. Add the appropriate
        // `active` class to its parent.
        this.setActiveParent_(item);
      } else {
        // Item should NOT be active; remove `has active subnav` classes to
        // ensure that parent nav items have the appropriate styling.
        this.adapter_.removeClass(item, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].HAS_ACTIVE_SUBNAV);
        this.adapter_.removeClass(item, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].HAS_ACTIVE_MOBILE_SUBNAV);
      }
    });
  }

  /**
   * Adds the appropriate `has active subnav` class to the parent nav item of
   * the given subnav item.
   * @param {!Element} item Subnav item.
   * @private
   */
  setActiveParent_(item) {
    const parentItem = this.adapter_.getParentNavItem(item);

    this.adapter_.toggleClass(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].HAS_ACTIVE_SUBNAV,
        this.isSubNavItem(item), parentItem);

    this.adapter_.toggleClass(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].HAS_ACTIVE_MOBILE_SUBNAV,
        this.isMobileSubNavItem(item), parentItem);
  }

  /**
   * Toggles the `aria-hidden` value and sets the alignment of the subnav
   * belonging to the interacted nav wrapper.
   * @param {!Event} e Event object.
   * @param {!Element} subnav The visible subnav element.
   * @private
   */
  handleMouseEvent_(e, subnav) {
    const isMouseEnter = e.type === __WEBPACK_IMPORTED_MODULE_1__constants__["c" /* Events */].MOUSEENTER;

    // Removes `focused` class that was added to the nav item wrapper while
    // using the tab key to navigate and also removes the focus from the
    // active element. This allows users to seamlessly switch from keyboard to
    // mouse navigation.
    this.reset_(subnav);
    document.activeElement.blur();

    // Sets the given subnav `aria-hidden` to false.
    this.adapter_.setAttr(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* Attrs */].ARIA_HIDDEN, !isMouseEnter, subnav);

    if (isMouseEnter) {
      // Sets the alignment of the visible subnav.
      this.setSubnavAlignment_(subnav);
      this.subnavIsVisible_ = true;
    }
  }

  /**
   * Shows the subnav of a nav item when it is focused on with the tab key while
   * at the same time toggling the subnav `aria-hidden` value. Before all of
   * this happens, all other nav items and their subnavs are reset. An `Escape`
   * key press will reset all nav items and their subnavs before removing focus.
   * @param {!Element} target The target element.
   * @param {!Event} e Keyup event object.
   * @private
   */
  handleKeyUp_(target, e) {
    const subnav = this.adapter_.queryEl(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* Selectors */].SUBNAV, target);

    this.reset_();

    // Is on mobile view or there is no subnav to toggle.
    if (!this.adapter_.isPastBreakpoint() || !subnav) return;

    if (e.keyCode === __WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Keys */].TAB) {
      // Tab key is pressed so handle subnav visibility.
      this.setSubnavAlignment_(subnav);

      this.adapter_.addClass(target, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].NAV_ITEM_WRAPPER_FOCUSED);
      this.adapter_.setAttr(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* Attrs */].ARIA_HIDDEN, false, subnav);
      this.subnavIsVisible_ = true;
    } else if (e.keyCode === __WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Keys */].ESC && this.subnavIsVisible_) {
      // Escape key is pressed and a subnav is visible so reset everything.
      document.activeElement.blur();
    }
  }

  /**
   * Resets the nav when the viewport has been reduced to a size below the
   * the breakpoint but only if there is a subnav visible.
   * @param {!Event} e The window resize event object.
   * @private
   */
  handleResize_(e) {
    if (!this.adapter_.isPastBreakpoint() && this.subnavIsVisible_) {
      this.reset_();
    }
  }

  /**
   * Resets the nav when the user tabs off the nav all together.
   * @private
   */
  handleTabbingOffNav_() {
    if (!this.isNavItem(document.activeElement) &&
        !this.isSubNavItem(document.activeElement)) {
      this.reset_();
    }
  }

  /**
   * Removes `focused` class from all nav item wrappers while also setting all
   * subnav `aria-hidden` values to true. If a specific subnav is given, any
   * `overflow` class it may have will also be removed.
   * @param {!Element=} subnav Optional subnav element.
   * @private
   */
  reset_(subnav) {
    this.subnavIsVisible_ = false;

    this.navItemWrappers_.forEach((wrapper) => {
      this.adapter_.removeClass(wrapper, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].NAV_ITEM_WRAPPER_FOCUSED);
    });

    this.subnavs_.forEach((s) => {
      this.adapter_.setAttr(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* Attrs */].ARIA_HIDDEN, true, s);
    });

    if (subnav) {
      this.adapter_.removeClass(subnav, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].SUBNAV_OVERFLOWING_LEFT);
      this.adapter_.removeClass(subnav, __WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Classes */].SUBNAV_OVERFLOWING_RIGHT);
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBNavFoundation;



/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_index__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nav_constants__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(2);






class LBMobileNav extends __WEBPACK_IMPORTED_MODULE_0__base_index__["a" /* default */] {
  /**
   * Creates a new instance of the LBMobileNav class.
   * @param {!Element} root The mobile nav element.
   * @return {!LBMobileNav}
   */
  static attachTo(root) {
    return new LBMobileNav(root);
  }

  /**
   * @return {!LBMobileNavFoundation}
   */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* LBMobileNavFoundation */]({
      addListener: (eventType, handler, el = window) => {
        el.addEventListener(eventType, handler);
      },
      delegateEvent: (selector, eventType, handler, el = document) => {
        Object(__WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* delegate */])(el, selector, eventType, () => {
          handler();
        });
      },
      getMenuBtn: () => {
        return document.querySelector(__WEBPACK_IMPORTED_MODULE_2__nav_constants__["f" /* Selectors */].MENU_BTN);
      },
      getRootEl: () => {
        return this.root_;
      },
      isMobileNavOpened: () => {
        return this.root_.classList.contains(__WEBPACK_IMPORTED_MODULE_2__nav_constants__["b" /* Classes */].OPENED_MOBILE_NAV);
      },
      isPastBreakpoint: () => {
        const pseudoContent = window.getComputedStyle(this.root_,
            '::before').getPropertyValue('content');

        return pseudoContent !== '"mobile"';
      },
      queryAll: (selector) => {
        return this.queryComponentSelectorAll(selector);
      },
      removeAttr: (attr, el = this.root_) => {
        this.removeAttr(attr, el);
      },
      setAttr: (attr, val, el = this.root_) => {
        this.setAttr(attr, val, el);
      },
      toggleClass: (className, addClass, el) => {
        this.toggleClass(className, addClass, el);
      },
    });
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBMobileNav;



/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__nav_constants__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_detect_detect__ = __webpack_require__(61);





class LBMobileNavFoundation extends __WEBPACK_IMPORTED_MODULE_0__material_base__["b" /* MDCFoundation */] {
  static get defaultAdapter() {
    return {
      addListener: (/* eventType: string,
                       handler: !Function,
                       el: !Element|window */) => {},
      delegateEvent: (/* selector: string,
                         eventType: string,
                         handler: !Function,
                         el: !Element|document */) => {},
      getMenuBtn: () => /* !Element */ {},
      getRootEl: () => /* !Element */ {},
      isMobileNavOpened: () => /* boolean */ false,
      isPastBreakpoint: () => /* boolean */ false,
      queryAll: (/* selector: string */) => /* !Array<!Element> */ [],
      removeAttr: (/* attr: string, el: !Element*/) => {},
      setAttr: (/* attr: string, val: string, el: !Element */) => {},
      toggleClass: (/* className: string,
                       addClass: boolean,
                       el: !Element */) => {},
    };
  }

  constructor(adapter) {
    super(Object.assign(LBMobileNavFoundation.defaultAdapter, adapter));

    /**
     * Mobile nav element.
     * @private {!Element}
     */
    this.root_ = this.adapter_.getRootEl();

    /**
     * All anchor and button elements within the root element.
     * @private {!Array<!Element>}
     */
    this.tabableItems_ =
        this.adapter_.queryAll(__WEBPACK_IMPORTED_MODULE_1__nav_constants__["f" /* Selectors */].TABABLE_ELS);

    /** @private {!Detect} */
    this.detect_ = new __WEBPACK_IMPORTED_MODULE_2__providers_detect_detect__["a" /* default */]();

    this.registerEvents_();
  }

  /** @private */
  registerEvents_() {
    // Mobile nav menu btn.
    this.adapter_.delegateEvent(__WEBPACK_IMPORTED_MODULE_1__nav_constants__["f" /* Selectors */].MOBILE_NAV_TOGGLE, 'click',
        this.toggleMobileNav_.bind(this));

    // Window events.
    this.adapter_.addListener('resize', this.handleResize_.bind(this));
    this.adapter_.addListener('keyup', this.handleKeyPress_.bind(this));
  }

  /**
   * Toggles the `opened` class on the mobile nav element while at the same time
   * disabling scrolling and toggling aria attrs.
   * @return {boolean}
   * @private
   */
  toggleMobileNav_() {
    this.adapter_.toggleClass(__WEBPACK_IMPORTED_MODULE_1__nav_constants__["b" /* Classes */].OPENED_MOBILE_NAV,
        !this.adapter_.isMobileNavOpened(), this.root_);

    this.adapter_.setAttr(__WEBPACK_IMPORTED_MODULE_1__nav_constants__["a" /* Attrs */].ARIA_HIDDEN,
        !this.adapter_.isMobileNavOpened());

    if (this.adapter_.isMobileNavOpened()) {
      this.tabableItems_[0].focus();
    } else {
      this.adapter_.getMenuBtn().focus();
    }

    this.toggleMobileTabIndexing_();
    this.toggleMobileScrolling_();
  }

  /**
   * Toggles `[tabindex="-1"]` on mobile nav items to disable tab indexing
   * within the mabile nav when it is closed.
   * @private
   */
  toggleMobileTabIndexing_() {
    this.tabableItems_.forEach((item) => {
      if (this.adapter_.isMobileNavOpened()) {
        this.adapter_.removeAttr('tabindex', item);
      } else {
        this.adapter_.setAttr('tabindex', '-1', item);
      }
    });
  }

  /**
   * Toggles the `no-scroll` class on the html and body elements to disable
   * page scrolling.
   * @private
   */
  toggleMobileScrolling_() {
    const isNavOpened = this.adapter_.isMobileNavOpened();

    this.adapter_.toggleClass(__WEBPACK_IMPORTED_MODULE_1__nav_constants__["b" /* Classes */].NO_SCROLL, isNavOpened, document.body);

    // iOS doesn't recognize just `body {overflow: hidden}`. You have to
    // add it to the html element as well as setting 100% height. The 100%
    // height on the html element gives the unwanted effect of scrolling back to
    // the top, so we limit it to iOS devices only.
    if (this.detect_.ios) {
      this.adapter_.toggleClass(__WEBPACK_IMPORTED_MODULE_1__nav_constants__["b" /* Classes */].NO_SCROLL, isNavOpened,
          document.documentElement);
    }
  }

  /**
   * Resets the mobile nav element when a user resizes the browser window
   * to a size larger then or equal to the breakpoint, but only if it is
   * opened.
   * @private
   */
  handleResize_() {
    if (this.adapter_.isPastBreakpoint() &&
        this.adapter_.isMobileNavOpened()) {
      this.toggleMobileNav_();
    }
  }

  /**
   * Closes the mobile nav and focuses on the menu button if the Escape key
   * is pressed when the mobile nav is opened. It also handles.
   * @param {!Event} e keyup event object.
   * @private
   */
  handleKeyPress_(e) {
    if (e.keyCode === __WEBPACK_IMPORTED_MODULE_1__nav_constants__["d" /* Keys */].ESC && this.adapter_.isMobileNavOpened()) {
      this.toggleMobileNav_();
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBMobileNavFoundation;



/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @const {Object<string, function>} Tests to run. */
const tests = {
  'js': (win, platform) => {
    return true;
  },
  'ios': (win, platform) => {
    return /(iPhone|iPod|iPad)/i.test(platform);
  },
  'mac': (win, platform) => {
    return /(Mac)/i.test(platform);
  },
  'macOrIos': (win, platform) => {
    return tests.mac(win, platform) || tests.ios(win, platform);
  },
  'android': (win, platform) => {
    return /(Android)/i.test(platform);
  },
  'ontouchstart': (win, platform) => {
    return 'ontouchstart' in win;
  },
  'mobile': (win, platform) => {
    return (tests.android(win, platform) ||
            tests.ios(win, platform) ||
            /(webOS)/i.test(platform) ||
            /(BlackBerry)/i.test(platform) ||
            /(Windows Phone)/i.test(platform));
  },
};
/* harmony export (immutable) */ __webpack_exports__["a"] = tests;



/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__providers_pub_sub__ = __webpack_require__(30);

// Placing `PubSub` in it's own file allows other providers or code to
// use the shared instance without having to import LBPlainComponent,
// or inject an instance the user creates into each component that needs it.
const pubSubShared = new __WEBPACK_IMPORTED_MODULE_0__providers_pub_sub__["a" /* default */]();
/* harmony export (immutable) */ __webpack_exports__["a"] = pubSubShared;



/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__providers_breakpoint_monitor_index__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__accordion_index__ = __webpack_require__(54);




class LBFooter {
  /** @param {!Element} root Footer element. */
  constructor(root) {
    /** @const @private {?Element} */
    this.accordionEl_ = root.querySelector('.lb-js-accordion');

    // No accordion means a minimal footer is being used — there is no
    // functionality requiring JS.
    if (!this.accordionEl_) return;

    /** @private {boolean} */
    this.accordionInitialized_ = false;

    /** @private @const {!LBAccordion} */
    this.accordion_;

    new __WEBPACK_IMPORTED_MODULE_0__providers_breakpoint_monitor_index__["a" /* default */]((data) => this.initAccordion_(data));
    this.initAccordion_();
  }

  /**
   * Initializes the accordion if the breakpoint is not `desktop` and one has
   * not been created already. Otherwise, it's destroyed.
   * @param {!Object<string, string>=} data Breakpoint monitor provider data.
   * @private
   */
  initAccordion_(data=undefined) {
    if (data && data.breakpoint === 'desktop' && this.accordionInitialized_) {
      this.accordion_.destroy();
      this.accordionInitialized_ = false;
      return;
    }

    this.accordion_ = __WEBPACK_IMPORTED_MODULE_1__accordion_index__["a" /* LBAccordion */].attachTo(this.accordionEl_);
    this.accordionInitialized_ = true;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LBFooter;



/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {string} */
const strings = {
  BREAKPOINT_CHANGE_EVENT_NAME: 'lb-breakpoint-change',
  RESIZE_EVENT_NAME: 'resize',
  HTML_SELECTOR: 'html',
  BEFORE_SELECTOR: ':before',
  CONTENT_PROPERTY: 'content',
};
/* harmony export (immutable) */ __webpack_exports__["b"] = strings;


/** @const {!RegExp} */
const QUOTE_RE_ = /['"]+/g;
/* harmony export (immutable) */ __webpack_exports__["a"] = QUOTE_RE_;



/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_plain__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers__ = __webpack_require__(125);





class YTPlayer extends __WEBPACK_IMPORTED_MODULE_0__base_plain__["a" /* default */] {
  /**
   * Initializes the YTPlayer component.
   * @param {!Element} root The root element of the component.
   */
  constructor(root) {
    super(root);
    this.parseOptionsString();

    /** @type {?YouTubePlayer} A YouTube embedded player. */
    this.player;

    /** @private {Function} Resolve the player intialization promise. */
    this.resolvePlayerPromise_;

    /** @private {Function} Reject the player intialization promise. */
    this.rejectPlayerPromise_;

    /** @private {Promise} A promise for the player intialization. */
    this.playerPromise_ = new Promise((resolve, reject) => {
      this.resolvePlayerPromise_ = resolve;
      this.rejectPlayerPromise_ = reject;
    });

    /** @private {string} */
    this.videoId_ = this.root_.getAttribute(__WEBPACK_IMPORTED_MODULE_1__constants__["a" /* Attr */].VIDEO_ID);

    /** @private {Object} */
    this.options_ = Object.assign({}, __WEBPACK_IMPORTED_MODULE_1__constants__["c" /* DEFAULT_OPTIONS */], this.options_);
  }

  /**
   * Makes the player accessible as a promise.
   * @return {!Promise} A promise for a YouTube player.
   */
  getPlayer() {
    return this.playerPromise_;
  }

  /**
   * Prepares to initialize a YouTube player.
   */
  async initialize() {
    try {
      await __WEBPACK_IMPORTED_MODULE_2__providers__["b" /* YTIframeApiInit */].loadApi();

      if (this.options_.initType === __WEBPACK_IMPORTED_MODULE_1__constants__["e" /* InitType */].IMMEDIATE) {
        this.createPlayer(this.videoId_, this.options_.playerVars);
      } else if (this.options_.initType === __WEBPACK_IMPORTED_MODULE_1__constants__["e" /* InitType */].AUTO) {
        new __WEBPACK_IMPORTED_MODULE_2__providers__["a" /* ElementObserver */](this.root_, {
          onActivate: () => {
            this.createPlayer(this.videoId_, this.options_.playerVars);
          },
          activateThreshold: 0,
          activateOnce: true,
        });
      }
    } catch (error) {
      console.error(error);
    }
  }

  /**
   * Initializes a YouTube player using the API.
   * @param {string} videoId The ID of the video.
   * @param {Object=} playerVars Configuration for the player.
   * @return {!Promise} A promise for a YouTube player.
   */
  createPlayer(videoId = this.videoId_, playerVars = this.options_.playerVars) {
    this.videoId_ = videoId;
    this.root_.classList.add(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Class */].LOADING);
    const videoContainer = document.createElement('div');
    videoContainer.classList.add(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Class */].VIDEO_CONTAINER);
    this.root_.appendChild(videoContainer);

    this.player = new window.YT.Player(videoContainer, {
      videoId: playerVars.list ? undefined : videoId,
      // Learn more about events here:
      // https://developers.google.com/youtube/iframe_api_reference#Events
      events: {
        onError: this.handlePlayerOnError_.bind(this),
        onReady: this.handlePlayerOnReady_.bind(this),
        onStateChange: this.handlePlayerStateChange_.bind(this),
      },
      // See all supported player vars here:
      // https://developers.google.com/youtube/player_parameters?playerVersion=HTML5#Parameters
      playerVars,
    });

    return this.getPlayer();
  }

  /**
   * Handles the onError callback from the player.
   * @param {Event} error An error message from the YouTube Player.
   * @private
   */
   handlePlayerOnError_(error) {
     // Two ways of notifying that the player initialization errored:
     // Promise reject and pubsub.
     this.rejectPlayerPromise_(
         'There was an error initializing the player.', error);
     this.pubSubShared_.broadcast(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_ERROR,
         {
           videoId: this.videoId_,
           name: this.options_.name,
           error,
         });
   }

  /**
   * Handles the onReady callback from the player.
   * @param {Event} e An event from the YouTube Player.
   * @private
   */
   handlePlayerOnReady_(e) {
     this.root_.classList.remove(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Class */].LOADING);
     // Two ways of notifying that the player is ready to interact with:
     // Promise resolution and pubsub.
     this.resolvePlayerPromise_(this.player);
     this.pubSubShared_.broadcast(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_READY,
       {
         videoId: this.videoId_,
         name: this.options_.name,
         player: this.player,
       });
     this.subscribeEvents_();
   }

  /**
   * Handles the onStateChange callback from the player by broadcasting the info.
   * @param {Event} e An event from the YouTube Player.
   * @private
   */
  handlePlayerStateChange_(e) {
    let eventName;
    switch (e.data) {
      case YT.PlayerState.ENDED:
        eventName = __WEBPACK_IMPORTED_MODULE_1__constants__["f" /* State */].VIDEO_ENDED;
        break;
      case YT.PlayerState.PLAYING:
        eventName = __WEBPACK_IMPORTED_MODULE_1__constants__["f" /* State */].VIDEO_PLAYING;
        break;
      case YT.PlayerState.PAUSED:
        eventName = __WEBPACK_IMPORTED_MODULE_1__constants__["f" /* State */].VIDEO_PAUSED;
        break;
      case YT.PlayerState.BUFFERING:
        eventName = __WEBPACK_IMPORTED_MODULE_1__constants__["f" /* State */].VIDEO_BUFFERING;
        break;
      case YT.PlayerState.CUED:
        eventName = __WEBPACK_IMPORTED_MODULE_1__constants__["f" /* State */].VIDEO_CUED;
        break;
    }
    this.pubSubShared_.broadcast(eventName, {
      videoId: this.videoId_,
      name: this.options_.name,
      player: this.player,
    });
  }

  /**
   * Subscribes to events from the YouTube Player and the YTPlayer component.
   */
  subscribeEvents_() {
    this.pubSubShared_.subscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_PLAY,
        this.handlePlay_, this);

    this.pubSubShared_.subscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* State */].VIDEO_PLAYING,
      this.handlePlay_, this);

    this.pubSubShared_.subscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_PAUSE,
        this.handlePause_, this);

    this.pubSubShared_.subscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_STOP,
        this.handleStop_, this);

    this.pubSubShared_.subscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_STOP_ALL,
        this.handleStopAll_, this);

    this.pubSubShared_.subscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_SEEK_TO,
        this.handleSeekTo_, this);
  }

  /**
   * Handles a play event.
   * If the event is for this video, play it.
   * If it's for another video and this video is playing, pause it.
   * @param {!Event} e The event data.
   */
  handlePlay_(e) {
    if (this.validVideoIdMatch_(e.videoId) ||
        this.validNameMatch_(e.name)) {
      this.player.playVideo();
    } else if (this.player.getPlayerState() === YT.PlayerState.PLAYING) {
      this.player.pauseVideo();
    }
  }

  /**
   * Handles a pause event.
   * @param {!Event} e The event data.
   */
  handlePause_(e) {
    if (this.validVideoIdMatch_(e.videoId) ||
        this.validNameMatch_(e.name)) {
      this.player.pauseVideo();
    }
  }

  /**
   * Handles a stop event.
   * @param {!Event} e The event data.
   */
  handleStop_(e) {
    if (this.validVideoIdMatch_(e.videoId) ||
        this.validNameMatch_(e.name)) {
      this.player.stopVideo();
    }
  }

  /**
   * Handles a stop all event.
   */
  handleStopAll_() {
    this.player.stopVideo();
  }

  /**
   * Handles a seekTo event.
   * @param {!Event} e The event data.
   */
  handleSeekTo_(e) {
    if (this.validVideoIdMatch_(e.videoId) ||
        this.validNameMatch_(e.name)) {
      const params = {
        seconds: e.seconds || 0,
        allowSeekAhead: e.allowSeekAhead || false,
      };
      this.player.seekTo(params.seconds, params.allowSeekAhead);
    }
  }

  /**
   * Checks if the provided name has a value and matches the component's
   * name option.
   * @return {boolean} If the name matches.
   */
  validNameMatch_(name) {
    return this.options_.name && this.options_.name === name;
  }

  /**
   * Checks if the provided videoId has a value and matches the component's
   * videoId.
   * @return {boolean} If the videoId matches.
   */
  validVideoIdMatch_(videoId) {
    return this.videoId_ && this.videoId_ === videoId;
  }

  /**
   * Destroys the YouTube Player element, removes PubSub subscriptions,
   * and hides the loading image.
   */
  destroy() {
    this.player.destroy();

    this.pubSubShared_.unsubscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_PLAY, this.handlePlay_);
    this.pubSubShared_.unsubscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["f" /* State */].VIDEO_PLAYING, this.handlePlay_);
    this.pubSubShared_.unsubscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_PAUSE, this.handlePause_);
    this.pubSubShared_.unsubscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_STOP, this.handlePause_);
    this.pubSubShared_.unsubscribe(__WEBPACK_IMPORTED_MODULE_1__constants__["d" /* Event */].VIDEO_SEEK_TO, this.handleSeekTo_);

    this.root_.classList.add(__WEBPACK_IMPORTED_MODULE_1__constants__["b" /* Class */].DESTROYED);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = YTPlayer;



/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {string} */
const Attr = {
  VIDEO_ID: 'lb-video-id',
  PLAYER_NAME: 'lb-player-name',
};
/* harmony export (immutable) */ __webpack_exports__["a"] = Attr;


/** @enum {string} */
const Class = {
  VIDEO_CONTAINER: 'lb-yt-player__video',
  DESTROYED: 'lb-yt-player--destroyed',
  LOADING: 'lb-yt-player--loading',
};
/* harmony export (immutable) */ __webpack_exports__["b"] = Class;


/** @enum {string} */
const Event = {
  VIDEO_ERROR: 'lb-yt-player-error',
  VIDEO_READY: 'lb-yt-player-ready',
  VIDEO_PLAY: 'lb-yt-player-play',
  VIDEO_PAUSE: 'lb-yt-player-pause',
  VIDEO_STOP: 'lb-yt-player-stop',
  VIDEO_STOP_ALL: 'lb-yt-player-stop-all',
  VIDEO_SEEK_TO: 'lb-yt-player-seek-to',
};
/* harmony export (immutable) */ __webpack_exports__["d"] = Event;


/** @enum {string} */
const State = {
  VIDEO_ENDED: 'lb-player-state-ended',
  VIDEO_PLAYING: 'lb-player-state-playing',
  VIDEO_PAUSED: 'lb-player-state-paused',
  VIDEO_BUFFERING: 'lb-player-state-buffering',
  VIDEO_CUED: 'lb-player-state-cued',
};
/* harmony export (immutable) */ __webpack_exports__["f"] = State;


/** @enum {string} */
const InitType = {
  AUTO: 'auto',
  IMMEDIATE: 'immediate',
  MANUAL: 'manual',
};
/* harmony export (immutable) */ __webpack_exports__["e"] = InitType;


/** @type {Object} */
const DEFAULT_OPTIONS = {
  playerVars: {
    enablejsapi: 1,
    modestbranding: 1,
    rel: 0,
  },
  initType: InitType.AUTO,
  name: null,
};
/* harmony export (immutable) */ __webpack_exports__["c"] = DEFAULT_OPTIONS;



/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__auto_init_auto_init__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__easing___ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__a11y___ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__analytics_analytics__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__auto_scroll___ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__breakpoint_monitor___ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__detect_detect__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__element_observer_element_observer__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__template_template__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__local_store_local_store__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__url_parser_url_parser__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__polyfills_polyfills__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__pub_sub___ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__raf_raf__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__request_request__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__scale_scale__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__scroll_scroll__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__timer_timer__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__yt_api_yt_api__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__yt_iframe_api_init_yt_iframe_api_init__ = __webpack_require__(140);
/* unused harmony reexport A11y */
/* unused harmony reexport Analytics */
/* unused harmony reexport AutoScroll */
/* unused harmony reexport BreakpointMonitor */
/* unused harmony reexport Detect */
/* unused harmony reexport easing */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_7__element_observer_element_observer__["a"]; });
/* unused harmony reexport LBTemplate */
/* unused harmony reexport LocalStore */
/* unused harmony reexport Parser */
/* unused harmony reexport polyfills */
/* unused harmony reexport PubSub */
/* unused harmony reexport Raf */
/* unused harmony reexport Requestor */
/* unused harmony reexport Scale */
/* unused harmony reexport Scroll */
/* unused harmony reexport Timer */
/* unused harmony reexport YTApi */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_19__yt_iframe_api_init_yt_iframe_api_init__["a"]; });
/* unused harmony reexport lbAutoInit */
























/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(127);


class A11y {
  constructor() {
    /** @private @const {!Map} */
    this.focusTrapQueue_ = new Map();
  }

  /**
   * Convenience getter for retrieving common aria properties.
   * @return {!Object<string, string>}
   * @readonly
   */
  get aria() {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */];
  }

  /**
   * Convenience getter for retrieving common role values.
   * @return {!Object<string, string>}
   * @readonly
   */
  get role() {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["c" /* role */];
  }

  /**
   * Gets pertinent element info to use for testing against ARIA properties.
   * @param {!Element} element
   * @return {!Object<string, string>}
   * @private
   */
  getElementInfo_(element) {
    const role = element.getAttribute('role');
    const type = element.getAttribute('type');
    const tagName = element.tagName;
    return {role, type, tagName};
  }

  /**
   * Toggles an element's selected state for screen readers.
   * @param {!Element} element
   */
  toggleSelected(element) {
    const {role, type, tagName} = this.getElementInfo_(element);
    const isRadio = tagName === 'INPUT' && type === 'radio';

    let ariaSelectedValue = (element.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].SELECTED) === 'true');
    ariaSelectedValue = (!ariaSelectedValue).toString();

    // Warn a developer if they're not using "aria-selected" w/ a valid role.
    if (!__WEBPACK_IMPORTED_MODULE_0__constants__["e" /* validAriaRoles */].SELECTED.includes(role) || isRadio) {
      console.warn(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].ERROR_MSG_VALID_SELECTED);
    }

    element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].SELECTED, ariaSelectedValue);
  }

  /**
   * Toggles an element's expanded state for screen readers.
   * @param {!Element} element
   * @param {string} controls Denotes which elements in a page an interactive
   *      element or set of elements has control over.
   */
  toggleExpanded(element, controls) {
    let ariaExpandedValue = (element.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].EXPANDED) === 'true');
    ariaExpandedValue = (!ariaExpandedValue).toString();

    // Warn a developer if they're not using valid ID string "aria-controls".
    if (controls !== undefined && typeof controls !== 'string') {
      console.warn(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].ERROR_MSG_CONTROLS_ID);
    } else {
      element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].CONTROLS, controls);
    }

    element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].EXPANDED, ariaExpandedValue);
  }

  /**
   * Toggles an element's checked state for screen readers.
   * @param {!Element} element
   */
  toggleChecked(element) {
    const {role, type, tagName} = this.getElementInfo_(element);
    const isInputCheckbox = tagName !== 'INPUT' && type !== role.CHECKBOX;

    let ariaCheckboxValue = (element.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].CHECKED) === 'true');

    ariaCheckboxValue = (!ariaCheckboxValue).toString();

    // Warn a developer if they're not using "aria-checked" w/ a
    // valid element or role.
    if (!__WEBPACK_IMPORTED_MODULE_0__constants__["e" /* validAriaRoles */].CHECKED.includes(role) || !isInputCheckbox) {
      console.warn(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].ERROR_MSG_VALID_CHECKBOX);
    }

    element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].CHECKED, ariaCheckboxValue);
  }

  /**
   * Toggles an element's visibility state for screen readers.
   * @param {!Element} element
   * @param {boolean=} disableTabbing
   */
  toggleVisibility(element, disableTabbing = false) {
    let ariaHiddenValue = (element.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].HIDDEN) === 'true');

    if (ariaHiddenValue && disableTabbing) {
      this.disableTabbing(element);
    } else if (!ariaHiddenValue && disableTabbing) {
      this.enableTabbing(element);
    }

    ariaHiddenValue = (!ariaHiddenValue).toString();
    element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].HIDDEN, ariaHiddenValue);
  }

  /**
   * Removes an element from the document's tab sequence.
   * @param {!Element} element
   */
  disableTabbing(element) {
    const originalTabIndexValue = element.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].TABINDEX);

    // When there's an explicit `tabindex` value save it a data attribute
    // so it can be swapped back later.
    if (originalTabIndexValue) {
      element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].TABINDEX_DATA_PROP, originalTabIndexValue);
    }

    element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].TABINDEX, __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].DEACTIVATE_TABINDEX);
  }

  /**
   * Adds an element to the document's tab sequence.
   * @param {!Element} element
   */
  enableTabbing(element) {
    // If this element had tabbing disabled and had an original `tabindex`
    // value then it was saved to a data attribute so we could reuse it.
    const originalTabIndexValue =
        element.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].TABINDEX_DATA_PROP);
    const currentTabIndexValue = element.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].TABINDEX);

    // If there's already a positive `tabindex` value then just bail.
    if (parseInt(currentTabIndexValue)>= 0) return;

    if (!originalTabIndexValue) {
      element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].TABINDEX, '0');
    } else {
      const tabIndexValue = parseInt(originalTabIndexValue) >= 0 ?
          originalTabIndexValue.toString() : '0';
      element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].TABINDEX, tabIndexValue);
    }
  }

  /**
   * Enables a page region's updated content to be announced by the
   *    screen reader.
   * NOTE: Some screen readers require this attribute to be present in
   *    the original DOM.
   * @param {!Element} element
   * @param {string} politenes
   * @param {boolean=} announceWholeString
   */
  announceDynamicChanges(element, politeness, announceWholeString = false) {
    if (typeof politeness !== 'string') {
      politeness = __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].LIVE_POLITE_VALUE;
    }

    if (politeness !== __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].LIVE_POLITE_VALUE ||
        politeness !== __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].LIVE_ASSERTIVE_VALUE) {
      console.warn(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].ERROR_MSG_USE_VALID_POLITENESS);
    }

    element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].LIVE, politeness);

    // The screen reader should always present the live region as a whole,
    // even if only part of the region changes.
    if (announceWholeString) {
      element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].ATOMIC, 'true');
    }
  }

  /**
   * Stops a screen reader from announcing content updates.
   * @param {!Element} element
   */
  silenceDynamicChanges(element) {
    const isAtomicActivated = element.getAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].ATOMIC) === 'true';

    if (isAtomicActivated) {
      element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].ATOMIC, 'false');
    }

    element.setAttribute(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].LIVE, __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* aria */].LIVE_OFF_VALUE);
  }

 /**
  * Queries all focusable elements.
  * @param {!Element} entryPoint
  * return {!Array<?Element>}
  */
  gatherFocusableElements(entryPoint) {
    return Array.from(entryPoint.querySelectorAll(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].FOCUSABLE_NODES));
  }

  /**
   * Relinquishes focus state control back to the document.
   * @param {!Element} entryPoint
   */
  disableFocusTrap(entryPoint) {
    if (!this.focusTrapQueue_.has(entryPoint)) return;

    const {keyupHandler,
           currentFocusElement} = this.focusTrapQueue_.get(entryPoint);

    // Return focus back to element that was active before trapping
    // was enabled.
    currentFocusElement && currentFocusElement.focus();

    document.removeEventListener('keydown', keyupHandler);
    this.focusTrapQueue_.delete(entryPoint);
  }

  /**
   * Keeps the focus state trapped within an element's bounds.
   * @param {!Element} entryPoint
   * @param {?Element} focusInitialElement
   */
  enableFocusTrap(entryPoint, focusInitialElement) {
    const tabbableSequence = this.gatherFocusableElements(entryPoint);
    const currentFocusElement = document.activeElement;
    const tabbableSequenceSize = tabbableSequence.length - 1;

    // The current active element in the tabbable sequence.
    let index = 0;

    if (tabbableSequence.length <= 1) {
      console.warn(__WEBPACK_IMPORTED_MODULE_0__constants__["d" /* strings */].ERROR_MSG_NEED_MORE_ELEMENTS);
    }

    const firstTabbableElement = tabbableSequence[0];

    // Keep track of the user's tab direction.
    let tabDirectionBackward = false;

    // When there's no initial focusable element, set the focus state
    // on first the first tabbable element.
    focusInitialElement = focusInitialElement || firstTabbableElement;
    focusInitialElement.focus();

    // Get the index of the active element.
    index = tabbableSequence.findIndex((element) =>
        element.isEqualNode(focusInitialElement));

    const keyupHandler = (event) => {
      const {shiftKey, keyCode} = event;

      if (__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* numbers */].TAB_KEY !== keyCode) return;
      // Relinquish native tab control to our handler.
      event.preventDefault();

      // A user holding down the shift key and tabbing is moving backwards.
      tabDirectionBackward = shiftKey;

      if (tabDirectionBackward) {
        // When the user is tabbing backwards and they hit the first tabbable
        // element shift focus to the last tabbable element.
        index = index === 0 ? tabbableSequenceSize : (index - 1);
      } else {
        // When the user is tabbing forwards and they hit the last tabbable
        // element shift focus to the first tabbable element.
        index = index === tabbableSequenceSize ? 0 : (index + 1);
      }

      tabbableSequence[index].focus();
    };

    const focusTrapData = {
      keyupHandler,
      currentFocusElement,
    };

    document.addEventListener('keydown', keyupHandler);

    // Cache the handler so it can be unbound later.
    this.focusTrapQueue_.set(entryPoint, focusTrapData);
  }
}
/* unused harmony export default */



/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {string} */
const aria = {
  ATOMIC: 'aria-atomic',
  BUSY: 'aria-busy',
  CHECKED: 'aria-checked',
  CONTROLS: 'aria-controls',
  DESCRIBED_BY: 'aria-describedby',
  EXPANDED: 'aria-expanded',
  HIDDEN: 'aria-hidden',
  LABEL: 'aria-label',
  LABELLED_BY: 'aria-labelledby',
  LIVE: 'aria-live',
  MODAL: 'aria-modal',
  PRESSED: 'aria-pressed',
  SELECTED: 'aria-selected',
  VALUE_MAX: 'aria-valuemax',
  VALUE_MIN: 'aria-valuemin',
  VALUE_NOW: 'aria-valuenow',
  // Values for properties

  // Any updates made to this region should only be announced if the user
  // is not currently doing anything. live="polite" should be used in most
  // situations.
  LIVE_POLITE_VALUE: 'polite',

  // Any updates made to this region are important enough to be announced
  // to the user as soon as possible, but it is not necessary to immediately
  // interrupt the user. live="assertive" must be used if there is
  // information that a user must know about right away,
  LIVE_ASSERTIVE_VALUE: 'assertive',

  // Stops screen reader from annoucing updates.
  LIVE_OFF_VALUE: 'off',
};
/* harmony export (immutable) */ __webpack_exports__["a"] = aria;


/** @type {!Objec<string, !Array>} */
const validAriaRoles = {
  CHECKED: [
    'menuitemradio',
    'radio',
    'treeitem',
  ],
  SELECTED: [
    'gridcell',
    'option',
    'row',
    'tab',
  ],
};
/* harmony export (immutable) */ __webpack_exports__["e"] = validAriaRoles;


/** @enum {string} */
const strings = {
  TABINDEX_DATA_PROP: 'data-tabindex',
  TABINDEX: 'tabindex',
  ACTIVATE_TABINDEX: '0',
  DEACTIVATE_TABINDEX: '-1',
  FOCUSABLE_NODES: 'button, [href], input, select,' +
      'textarea, [tabindex]:not([tabindex="-1"])',
  TAB_FORWARD: 'foreward',
  TAB_BACKWARD: 'backward',
  ERROR_MSG_VALID_SELECTED: 'The "aria-selected" attribute should be paired' +
      'with these valid roles: ' + validAriaRoles.SELECTED.join(', '),
  ERROR_MSG_VALID_CHECKBOX: 'The "aria-checked" attribute should be paired' +
      'with a valid checkbox element or these valid roles: ' +
      validAriaRoles.CHECKED.join(', '),
  ERROR_MSG_CONTROLS_ID: 'The "controls" param should be the string' +
      'id of an element.',
  ERROR_MSG_USE_VALID_POLITENESS: 'Please use a valid politeness setting.',
  ERROR_MSG_NEED_MORE_ELEMENTS: 'You need two or more tabble element to' +
      'make the focus trap work.',
};
/* harmony export (immutable) */ __webpack_exports__["d"] = strings;


/** @enum {number} */
const numbers = {
  SHIFT_KEY: 16,
  TAB_KEY: 9,
};
/* harmony export (immutable) */ __webpack_exports__["b"] = numbers;


/** @enum {string} */
const role = {
  BUTTON: 'button',
  CHECKBOX: 'checkbox',
  GRID_CELL: 'gridcell',
  LINK: 'link',
  MENU_ITEM: 'menuitem',
  MENU_ITEM_CHECKBOX: 'menuitemcheckbox',
  MENU_ITEM_RADIO: 'menuitemradio',
  OPTION: 'option',
  PROGRESS_BAR: 'progressbar',
  RADIO: 'radio',
  SCROLLBAR: 'scrollbar',
  SEARCH_BOX: 'searchbox',
  SLIDER: 'slider',
  SPIN_BUTTON: 'spinbutton',
  SWITCH: 'switch',
  TAB: 'tab',
  TAB_PANEL: 'tabpanel',
  TEXT_BOX: 'textbox',
  TREE_ITEM: 'treeitem',
};
/* harmony export (immutable) */ __webpack_exports__["c"] = role;



/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @private @const {string} */
const PREFIX_METRIC = 'metric';

/** @private @const {string} */
const PREFIX_DIMENSION = 'dimension';

/** @private @const {number} */
const MAX_CUSTOM_DATA_POINTS = 9;

/** @private @const {!Array<string>} */
const USE_DATA_KEY = [
    'hitType',
    'hitCallback',
    'eventCategory',
    'eventAction',
    'eventLabel',
    'eventValue',
    'socialNetwork',
    'socialAction',
    'socialTarget',
  ];

/** @private @const {!Object<string, *>} */
const DEFAULT_GA = {
  hitType: 'event',
};

// Set analytics if it's been loaded.
window.ga = window.ga || function() {};

/**
 * Class for sending custom data to Google Analytics
 * @final
 */
class Analytics {
  constructor(scrubReferrer) {
    /** @private {?Object<string, string>} */
    this.dimensions_;

    /** @private {?Object<string, string>} */
    this.metrics_;

    scrubReferrer && this.scrubReferrer();
    this.resetCustomDataStores_();
  }

  /**
   * Sends event data to Google Analytics.
   * @param {string} eventType
   * @param {!Object<string, *>} eventData
   */
  sendEvent(eventType, eventData) {
    const dimension = this.parsePropWhenString_(eventData, PREFIX_DIMENSION);
    const metric = this.parsePropWhenString_(eventData, PREFIX_METRIC);

    const dimensionData = (dimension &&
        this.processCustomData_(PREFIX_DIMENSION, this.dimensions_, dimension));

    const metricData = (metric &&
        this.processCustomData_(PREFIX_METRIC, this.metrics_, metric));

    const eventProps = Object.keys(eventData);

    const dataParcel =
        eventProps.filter((prop) => ~USE_DATA_KEY.indexOf(prop))
        .reduce((parcel, prop) => {
          parcel[prop] = eventData[prop];
          return parcel;
        }, {});

    Object.assign(
        dataParcel,
        (dimensionData && dimensionData),
        (metricData && metricData));

    delete dataParcel.index;

    // Send the event.
    window.ga(eventType, dataParcel);

    this.resetCustomDataStores_();
  }

  /**
   * Sets the GA transport beacon feature.
   * @private
   */
  resetCustomDataStores_() {
    this.metrics_ = this.dimensions_ = {'index': 0};
  }

  /**
   * Removes `document.referrer` info for PII compliance.
   * Reference (Google docs id) 159DDDTtc45rkCoc_4BmtwKOlAGUnTp19EhzmAzMCOpg
   */
  scrubReferrer() {
    window.ga('set', 'referrer', document.referrer.split('?')[0]);
  }

  /**
   * Sets the GA transport beacon feature.
   */
  setTransportBeacon() {
    window.ga('set', 'transport', 'beacon');
  }

  /**
   * Checks if property value is a stringified array
   * and parses valid JSON.
   * @param {!Object<string, *>} data
   * @param {string|Object} prop
   * @return {string|Object}
   * @private
   */
  parsePropWhenString_(data, prop) {
    let propValue = data[prop];

    if (!propValue) {
      return '';
    }

    if (typeof propValue === 'string') {
      try {
        propValue = JSON.parse(propValue);
      } catch (e) {
        propValue = '';
        console.warn(`(LBAnalytics) Sorry, ${propValue} isn't valid JSON.`);
      }
    }

    return propValue;
  }

  /**
   * Checks if the current index is greator or equal to the
   * maximum number of supported custom data points.
   * @param {number} index
   * @return {boolean}
   * @private
   */
  exceedCustomDataLimit_(index) {
    return index >= MAX_CUSTOM_DATA_POINTS;
  }

  /**
   * Copies custom `dimension` or `metric` values into
   * the event data parcel.
   * @param {string} measurement
   * @param {!Object<string, * >} data
   * @param {!Array<string>} customList
   * @return {!Object<string, string>}
   * @private
   */
  processCustomData_(measurement, data, customList) {
    customList.forEach((value) =>
        this.spawnCustomDataEntry_(measurement, data, value));

    return data;
  }

  /**
   * Creates a custom `dimension` or `metric` entry in the
   * event data parcel that gets sent to Google Analytics.
   * @param {string} measurement
   * @param {!Object<string, * >} data
   * @param {string} value
   * @private
   */
  spawnCustomDataEntry_(measurement, data, value) {
    const node = {};
    const prop = (measurement + data.index);

    if (this.exceedCustomDataLimit_(data.index)) {
      return console.warn(
        `(LBAnalytics) You have too many ${measurement} values.`);
    }

    data.index += 1;

    node[prop] = value;
    Object.assign(data, node);
  }
}
/* unused harmony export default */



/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);



const defaultOptions = {
  // Callback to run.
  onActivate: null,
  // Callback to run.
  onProgress: null,
  // Callback to run.
  onDeActivate: null,
  // The amount of the element to be showing to run activate.
  activateThreshold: __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* numbers */].DEFAULT_ACTIVATE_THRESHOLD,
  // The amount of the element to be showing to run deactivate.
  deActivateThreshold: __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* numbers */].DEFAULT_DEACTIVATE_THRESHOLD,
  // Only run the activate callback once.
  activateOnce: false,
  // Only run the deActivate callback once.
  deActivateOnce: false,
  // Higher fidelity results in more progress callbacks.
  ioFidelity: 1001,
  // Specify a different root element than viewport for IntersectionObserver.
  ioRoot: null,
};


/**
 * Initializes an intersection observer on an element and runs callbacks when
 * the element comes into and out of view, according to options.
 */
class ElementObserver {
  /**
   * Creates a new ElementObserver.
   * @param {!Element} element The observed element.
   * @param {!Object} options Configuration options.
   */
  constructor(element, options) {

    /** @type {!Element} */
    this.element_ = element;

    /** @type {boolean} */
    this.activated = false;

    /** @type {Object} */
    this.options_ = Object.assign({}, defaultOptions, options);

    /** @type {!Function} */
    this.activateCallback_ = this.options_.onActivate;

    /** @type {!Function} */
    this.progressCallback_ = this.options_.onProgress;

    /** @type {Function=} */
    this.deActivateCallback_ = this.options_.onDeActivate;

    /** @type {boolean} */
    this.activateHasRun_ = false;

    /** @type {boolean} */
    this.deActivateHasRun_ = false;

    /** @type {number} */
    this.maxPossibleRatio_ = 0;

    if (this.activateCallback_ &&
        this.deActivateCallback_ &&
        this.options_.activateThreshold <=
        this.options_.deActivateThreshold) {
      throw new Error(`ElementObserver: If both activate and deactivate
          callbacks are provided, the activate threshold must be larger
          than the deActivate threshold.`);
    }

    if (!this.activateCallback_) {
      this.activateHasRun_ = true;
    }

    if (!this.deActivateCallback_) {
      this.deActivateHasRun_ = true;
    }

    window.addEventListener('resize',
        Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["d" /* throttle */])(this.resetMaxPossibleRatio_.bind(this), 500));

    this.initIntersectionObserver_(element);
  }

  /**
   * Runs the progress callback.
   * @param {!IntersectionObserverEntry} entry The IntersectionObserver entry.
   */
  progress(entry) {
    if (this.progressCallback_) {
      // The intersection ratio if the element is taller than the viewport
      // and can't reach 1 via IntersectionObserverEntry.intersectionRatio.
      // Ranges from 0-1.
      const overflowRatio =
          this.getRatioOfMaxPossible_(entry.intersectionRatio);
      this.progressCallback_(entry, overflowRatio);
    }
  }

  /**
   * Runs the activate callback.
   * @param {!IntersectionObserverEntry} entry The IntersectionObserver entry.
   */
  activate(entry) {
    if (!this.activateCallback_ ||
        this.activated ||
        this.activateHasRun_ && this.options_.activateOnce) {
      return;
    }
    this.activateCallback_(entry);
    this.activated = true;
    this.activateHasRun_ = true;
  }

  /**
   * Runs the deactivate callback.
   * @param {!IntersectionObserverEntry} entry The IntersectionObserver entry.
   */
  deActivate(entry) {
    if (!this.deActivateCallback_ ||
        !this.activated ||
        this.deActivateHasRun_ && this.options_.deActivateOnce) {
      return;
    }
    this.deActivateCallback_(entry);
    this.activated = false;
    this.deActivateHasRun_ = true;
  }

  /**
   * Unobserves IntersectionObserver instance from given element.
   * @param {!Element} element The element to stop observing.
   */
  unobserve(element = this.element_) {
    this.observer_.unobserve(element);
  }

  /**
   * Determines the maximum possible intersectionRatio value an element can
   * have based on its own height and the height of the viewport.
   * For instance if an element is twice as tall as the viewport, it can only
   * ever reach an intersectionRatio of 0.5.
   * @param {!Element} realRatio The real intersectionRatio.
   * @return {number} The max possible intersection ratio.
   */
  getMaxPossibleRatio_(element) {
    if (!this.maxPossibleRatio_) {
      const viewportBounds = document.documentElement.getBoundingClientRect();
      const elementBounds = element.getBoundingClientRect();
      const realRatio = viewportBounds.height / elementBounds.height;
      this.maxPossibleRatio_ = Math.min(realRatio, 1);
    }

    return this.maxPossibleRatio_;
  }

  /**
   * Gets the current intersection ratio taking into account an element that is
   * taller than the viewport.
   * @param {number} realRatio The real intersectionRatio.
   * @return {number} The max possible intersection ratio.
   */
  getRatioOfMaxPossible_(realRatio) {
    return realRatio / this.getMaxPossibleRatio_(this.element_);
  }

  /**
   * Resets the value of this.maxPossibleRatio_.
   */
  resetMaxPossibleRatio_() {
    this.maxPossibleRatio_ = 0;
  }

  /**
   * Sets up an IntersectionObserver on an element.
   * @param {!Element} element The element to observe.
   */
  initIntersectionObserver_(element) {
    const ioOptions = {
      threshold: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["c" /* getThresholdArray */])(this.options_.ioFidelity),
      root: this.options_.ioRoot,
    };

    this.observer_ = new IntersectionObserver(
      this.intersectionObserverCallback_.bind(this),
      ioOptions);

    this.observer_.observe(element);
  }

  intersectionObserverCallback_(entries, observer) {
    const entry = entries[0];
    const element = entry.target;

    this.progress(entry);

    if (entry.intersectionRatio > this.options_.activateThreshold) {
      this.activate(entry);
    }

    if (entry.intersectionRatio < this.options_.deActivateThreshold) {
      this.deActivate(entry);
    }

    // In this case, no additional callbacks will run, so we can remove the
    // IntersectionObserver.
    if (this.options_.activateOnce &&
        this.activateHasRun_ &&
        this.options_.deActivateOnce &&
        this.deActivateHasRun_ &&
        !this.progressCallback_) {
      this.unobserve(element);
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ElementObserver;



/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {number} */
const numbers = {
  /**
   * The amount a section needs to be intersecting to activate it.
   */
  DEFAULT_ACTIVATE_THRESHOLD: .3,
  /**
   * The amount a section needs to be intersecting to deactivate it.
   */
  DEFAULT_DEACTIVATE_THRESHOLD: .1,
};
/* harmony export (immutable) */ __webpack_exports__["a"] = numbers;



/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__auto_init_auto_init__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);




/**
 * Class to render a Mustache template with data and
 * safely insert it into the DOM.
 * @final
 */
class LBTemplate {
  /**
   * Creates a new LBTemplate instance.
   * @param {string} templateId The id of the template script tag.
   * @param {Array<string>=} customTags Custom Mustache template tags .
   */
  constructor(templateId, customTags) {
    this.template_ = this.getTemplateById_(templateId);

    if (!window.Mustache) {
      throw new Error('The Mustache CDN must be included.');
    }

    if (customTags) {
      this.customizeMustacheTags_(customTags);
    }
  }

  /**
   * Customizes the Mustache template tags.
   * @param {!Array<string>} customTags Custom Mustache template tags to set.
   * @private
   */
  customizeMustacheTags_(customTags) {
    if (window.Mustache && customTags) {
      window.Mustache.tags = customTags;
    }
  }

  /**
   * Renders a Mustache template to the DOM using provided data.
   * @param {!Object} data Data to be rendered.
   * @param {!Element} container The element to insert the rendered template in.
   * @param {boolean=} doEmptyContainer Whether to empty the container first.
   */
  render(data, container, doEmptyContainer = true) {
    // Add a helper function to the data that allows the template to know the
    // index of an item in an array it's iterating on.
    data = this.indexArrays_(data);
    doEmptyContainer && Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* emptyContainer */])(container);
    const rendered = window.Mustache.render(this.template_, data);
    const fragment = document.createRange().createContextualFragment(rendered);
    container.appendChild(fragment);

    // Run lbAutoInit on the container to discover any new components
    // that were added.
    Object(__WEBPACK_IMPORTED_MODULE_0__auto_init_auto_init__["a" /* lbAutoInit */])(container);
  }

  /**
   * Adds keys to an object in an array that represent the object's index.
   * @param {!Object} data The data to add keys to.
   * @return {Object} The same object that was passed as an argument, with any
   *   objects in an array having new keys for their 0 and 1-based indices in
   *   the array.
   */
  indexArrays_(data) {
    if (Array.isArray(data)) {
      // If this is an object directly in an array, give it index properties.
      // 0 and 1-based index properties are given since Mustache can't do math.
      data.forEach((item, index) => {
        if (typeof item === 'object') {
          item.lbIndex0 = index;
          item.lbIndex = index + 1;
          this.indexArrays_(item);
        }
      });
    }

    if (typeof data === 'object') {
      Object.values(data).forEach((value) => {
        this.indexArrays_(value);
      });
    }

    return data;
  }

  /**
   * Gets the contents of a script tag with a template to be rendered.
   * @param {string} id The id of the script tag with a template.
   * @return {string}
   */
  getTemplateById_(id) {
    const template = document.getElementById(id);
    return template ? template.innerText : '';
  }
}
/* unused harmony export default */



/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @type {?Parser} */
let instance = null;

/**
 * Class for conducting tokenization of query string.
 * @final
 */
class Parser {
  /**
   * Create a new parser.
   */
  constructor() {
    // Convert our parser into a singleton.
    if (!instance) {
      instance = this;
    }

    /** @private {number} */
    this.errors_ = 0;

    /** @private {!Object<string, string>} */
    this.tokens_ = {};

    return instance;
  }

  /**
   * Takes key-value object pairs and returns a valid query string.
   * @param {!Object<string, string|number|boolean>} objTokens
   * @return {string}
   */
  assembleSearchString(objTokens) {
    return Object.keys(objTokens).reduce((searchString, key, index) => {
      const value = objTokens[key];
      let searchParam = value ? `${key}=${value}` : key;

      if (index) {
        searchParam = `&${searchParam}`;
      }

      return (searchString += searchParam);
    }, '?');
  }

  /**
   * Splits a query string into chunks of smaller key-value strings.
   * @param {string} string The query string to tokenize.
   * @return {!Array<string>}
   * @private
   */
  separate_(string) {
    return string.slice(1).split('&').map((chunk) => chunk.split('='));
  }

  /**
   * Check for errors and increment counter.
   * @param {!Array<string>} chunk - Key-value array.
   * @param {!RegExp} validationRe
   * @return {boolean}
   * @private
   */
  sanitize_(chunk, validationRe) {
    if (this.validate_(chunk, validationRe)) {
      return true;
    }

    this.errors_ += 1;
    return false;
  }

  /**
   * Validate each key-value pair.
   * @param {!Array<string>} chunk Key-value array.
   * @return {boolean}
   * @private
   */
  validate_(chunk, validationRe) {
    return (chunk[0] && chunk[1]) && validationRe.test(chunk[0]) &&
        validationRe.test(chunk[1]);
  }

  /**
   * Convert key-value chunks into a token map.
   * @param {!Object<string, string>} bundle Token map.
   * @param {!Array<string>} chunk Key-value array.
   * @return {!Object<string, string>}
   * @private
   */
  assemble_(bundle, chunk) {
    bundle[chunk[0]] = chunk[1];
    return bundle;
  }

  /**
   * Reset our `parser` instance.
   */
  dispose() {
    instance = null;
    this.errors_ = 0;
    this.tokens_ = {};
  }

/**
 * Get the number of valid url query tokens.
 * @return {number}
 */
  entriesCount() {
    return Object.keys(this.tokens_).length;
  }

/**
 * Get token map.
 * @return {!Object<string, string>}
 */
  entries() {
    return this.tokens_;
  }

  /**
   * Get erroneous param count.
   * @return {number}
   */
  errors() {
    return this.errors_;
  }

  /**
   * Creates and returns a token dictionary.
   * @param {string} searchString
   * @param {RegExp=} validationRe
   * @return {!Object<string, string>}
   */
  parse(searchString = window.location.search, validationRe) {
    searchString = this.separate_(searchString);

    if (validationRe && (validationRe instanceof RegExp)) {
      searchString =
          searchString.filter((chunk) => this.sanitize_(chunk, validationRe));
    }

    return searchString.reduce(this.assemble_, this.tokens_);
  }
}
/* unused harmony export default */



/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A provider for polyfills. Initialize all polyfills or just one.
 * Demo:
 * import polyfills from '../providers/polyfills/polyfills';
 * polyfills.initAll(); // All polyfills.
 * polyfills.init('closest'); // One polyfill.
 */
const polyfills = {
  /**
   * Initializes one polyfill.
   * @param {string} polyfillName The name of the polyfill to initialize.
   */
  init(polyfillName) {
    polyfillData[polyfillName]();
  },

  /**
   * Initializes all polyfills.
   */
  initAll() {
    Object.keys(polyfillData).forEach((key) => {
      this.init(key);
    });
  },
};

const polyfillData = {
  closest: () => {
    /**
     * Element.closest() polyfill
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill
     */
    if (!Element.prototype.closest) {
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector ||
          Element.prototype.webkitMatchesSelector;
      }
      Element.prototype.closest = function(s) {
        var el = this;
        var ancestor = this;
        if (!document.documentElement.contains(el)) {
          return null;
        }
        do {
          if (ancestor.matches(s)) {
            return ancestor;
          }
          ancestor = ancestor.parentElement;
        } while (ancestor !== null);
        return null;
      };
    }
  },
};

/* unused harmony default export */ var _unused_webpack_default_export = (polyfills);


/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(135);


/**
 * `XMLHttpRequest` wrapper class.
 * @final
 */
class Requestor {
  constructor(options) {
    /** @private @const {!Object<string, *>} */
    this.options_ = Object.assign(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* defaultOptions */], options);

    /** @private {?XMLHttpRequest} */
    this.httpRequest_;

    /** @private {?Promise} */
    this.requestPromise_;
  }

  /**
   * Binds load event listener to request.
   * @param {!Function} handleLoad
   * @private
   */
  attachSuccessListener_(handleLoad) {
    this.httpRequest_.addEventListener('load', handleLoad);
  }

  /**
   * Binds error event listener to request.
   * @param {!Function} handleError
   * @private
   */
  attachFailureListener_(handleError) {
    this.httpRequest_.addEventListener('error', handleError);
  }

  /**
   * Binds state change event listener to request.
   * @param {!Function} handleStateChange
   * @private
   */
  attachStateChangeListener_(handleStateChange) {
    this.httpRequest_.addEventListener('readystatechange', handleStateChange);
  }

  /**
   * Binds timeout event listener to request.
   * @param {!Function} handleTimeout
   * @private
   */
  attachTimeoutListener_(handleTimeout) {
    this.httpRequest_.addEventListener('timeout', handleTimeout);
  }

  /**
   * Gets data from response using request `responseType`.
   * @param {string} responseType
   * @private
   */
  getResponseByType_(responseType) {
    let response = this.httpRequest_[__WEBPACK_IMPORTED_MODULE_0__constants__["c" /* responseModel */][responseType]];

    if (this.isIeCompatibilityMode_(responseType)) {
      response = window.JSON.parse(response);
    }

    return response;
  }

  /**
   * Handles request failures: error, abort and 404.
   * @param {string} failureType
   * @param {!Function} reject
   * @private
   */
  failureCallback_(failureType, reject) {
    if (failureType === __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* failureTypes */].ERROR ||
        failureType === __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* failureTypes */].TIMEOUT ||
        (failureType === __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* failureTypes */].FOUR_HUNDRED_FOUR &&
            this.httpRequest_.status === 404)) {
      reject({
        failureType,
        'status': this.httpRequest_.status,
        'statusText': this.httpRequest_.statusText,
      });
      this.requestPromise_ = null;
    }
  }

  /**
   * Handles request success.
   * @param {string} responseType
   * @param {!Function} resolve
   * @private
   */
  successCallback_(responseType, resolve) {
    const response = this.getResponseByType_(responseType);
    resolve(response);
    this.requestPromise_ = null;
  }

  /**
   * Determines if `Requestor` should be placed in IE compatibility mode.
   * @param {string} responseType
   * @return {boolean}
   * @private
   */
  isIeCompatibilityMode_(responseType) {
    return (responseType === __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* responseTypes */].JSON ||
            responseType === __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* responseTypes */].TEXT) &&
            this.options_.ieCompatibilityMode;
  }

  /**
   * Wraps `XMLHttpRequest` in a promise.
   * @param {string} requestUrl
   * @param {string} responseType
   * @return {!Promise}
   */
  request(requestUrl, responseType = __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* responseTypes */].JSON) {
    responseType = this.isIeCompatibilityMode_(responseType) ?
        __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* responseTypes */].TEXT : responseType;

    if (this.requestPromise_) {
      return this.requestPromise_;
    }

    this.requestPromise_ = new Promise((resolve, reject) => {
      this.httpRequest_ = new XMLHttpRequest();
      this.httpRequest_.responseType = responseType;
      this.httpRequest_.open('GET', requestUrl, true);
      this.httpRequest_.setRequestHeader('Accept', 'application/json');
      this.httpRequest_.timeout = this.options_.timeout;

      // Request listeners.
      this.attachSuccessListener_(
          this.successCallback_.bind(this, responseType, resolve));

      this.attachStateChangeListener_(
          this.failureCallback_.bind(this,
              __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* failureTypes */].FOUR_HUNDRED_FOUR, reject));

      this.attachFailureListener_(
          this.failureCallback_.bind(this, __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* failureTypes */].ERROR, reject));

      this.attachTimeoutListener_(
          this.failureCallback_.bind(this, __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* failureTypes */].TIMEOUT, reject));

      this.httpRequest_.send();
    });

    return this.requestPromise_;
  }
}
/* unused harmony export Requestor */



/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {string} */
const responseTypes = {
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  BLOB: 'blob',
  TEXT: 'text',
  DOCUMENT: 'document',
};
/* harmony export (immutable) */ __webpack_exports__["d"] = responseTypes;


/** @enum {string} */
const failureTypes = {
  ERROR: 'error',
  TIMEOUT: 'timeout',
  FOUR_HUNDRED_FOUR: '404',
};
/* harmony export (immutable) */ __webpack_exports__["b"] = failureTypes;


/** @private @const {!Object<string, string>} */
const responseModel = {
  'arraybuffer': 'response',
  'json': 'response',
  'blob': 'response',
  'text': 'responseText',
  'document': 'responseXML',
};
/* harmony export (immutable) */ __webpack_exports__["c"] = responseModel;


/** @private @const {!Object<string, *>} */
const defaultOptions = {
  ieCompatibilityMode: false,
  timeout: 5000,
};
/* harmony export (immutable) */ __webpack_exports__["a"] = defaultOptions;



/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @typedef {{
 *  'domain': Function,
 *  'range': Function,
 *  'translate': Function,
 * }}
 */
let transformer;

/**
 * Class to simplify working with number ranges - specifically, translating
 * values from one domain to another. This is useful if you want to scale
 * or position an element using a range of values not tied to the
 * viewport number space, or conversely, use the viewport space to
 * translate a different set of number, like font size.
 * e.g
 * const scale = new ScaleProvider().create();
 * scale.domain(0, 1000).range(0, 1);
 * let normalizedValue = scale.translate(401);
 * normalizedValue = 0.401
 * @final
 */
class Scale {
  constructor() {}

  /**
   * Creates an interface for translating values.
   * @return {!transformer}
   */
  create() {
    /** @private {!Array<number>} */
    let domain_ = [0, 1];
    /** @private {!Array<number>} */
    let output_ = [0, 1];

    return {
      /**
       * Determines if a value is a number.
       * @param {*} value The value to test.
       * @return {boolean} Whether or not the value is a number.
       */
      isNumber(value) {
        return typeof(value) === 'number';
      },

      /**
       * Set min and max domain values.
       * The `domain` is a value's origin number space.
       * @param {number} min
       * @param {number} max
       * @return {!Object<string, transformer>}
       */
      domain: function(min, max) {
        if (!this.isNumber(min) || !this.isNumber(max)) {
          throw new Error('Please specify a min/max value for the domain.');
        }
        domain_ = [min, max];
        return this;
      },

      /**
       * Set min and max output values.
       * The `range` is a number space used to inform how the number
       * will be translated.
       * @param {number} min
       * @param {number} max
       * @return {!Object<string, transformer>}
       */
      range: function(min, max) {
        if (!this.isNumber(min) || !this.isNumber(max)) {
          throw new Error('Please specify a min/max value for the range.');
        }
        output_ = [min, max];
        return this;
      },

      /**
       * Calculates the new value based on the domain and range spaces.
       * @param {number} value
       * @return {number}
       */
      translate: function(value) {
        const valDomainMin = (value - domain_[0]);
        const outputMinMax = (output_[1] - output_[0]);
        const domainMinMax = (domain_[1] - domain_[0]);
        return valDomainMin * outputMinMax / domainMinMax + output_[0];
      },
    };
  }
}
/* unused harmony export default */



/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__raf_raf__ = __webpack_require__(65);


/** @type {?Scroll} */
let instance = null;

/**
* Class that governs `window` scroll events.
* @final
*/
class Scroll {
  constructor(options) {
    if (!instance) {
      instance = this;
    }

    /** @private @const {!Raf} - Request Animation Frame service. */
    this.raf_ = new __WEBPACK_IMPORTED_MODULE_0__raf_raf__["a" /* Raf */]();

    /**
     * The last recorded scroll position.
     * @private {number}
     */
    this.lastPosition_ = -1;

    /**
     * A group of callbacks executed during a scroll event.
     * @private {!Array<!Function>}
     */
    this.callbacks_ = [];

    /**
     * Flag for in progress (Raf) scroll event.
     * @private {boolean}
     */
    this.rendering_ = false;

    return instance;
  }

  /**
   * Renders an Raf (scroll event) callback.
   * @private
   */
  render_() {
    // Current offset position.
    const position = this.getPosition();
    // The scroll direction: up|down.
    const delta = this.lastPosition_ - position;

    if (this.callbacks_.length) {
      const event = {
        position,
        delta,
      };

      // Pass event payload to callbacks.
      this.callbacks_.forEach((callback) => callback(event));
    }

    this.rendering_ = false;
    this.raf_.stop();
    // Set the previous scroll position.
    this.lastPosition_ = position;
  }

  /**
   * Synchronizes scroll paints using Raf.
   * @private
   */
  renderer_() {
    if (this.isScrolling() && !this.rendering_) {
      this.rendering_ = true;
      this.raf_.resume();
      this.raf_.ticker(this.render_, this);
    }
  }

  /**
   * Binds the scroll event listener.
   * @param {boolean} immediate - perform pre-scroll calculations.
   */
  listen(immediate = false) {
    window.addEventListener('scroll', this.renderer_.bind(this));

    if (immediate) {
      this.render_();
    }
  }

  /**
   * Checks if the user is scrolling.
   */
  isScrolling() {
    return this.lastPosition_ !== this.getPosition();
  }

  /**
   * Check if there's room to scroll.
   * @return {boolean}
   * @private
   */
  hasSpaceToScroll_() {
    return window.scrollY + window.innerHeight <=
           document.body.clientHeight - this.options_.minScrollDistancePx;
  }

  /**
   * Sets a scroll position.
   * Primarily used with `window.beforeunload`.
   * @param {number} positionX
   * @param {number} positionY
   */
  setPosition(positionX, positionY) {
    window.scrollTo(positionX, positionY);
  }

  /**
   * Gets current page Y offset.
   * @return {number}
   */
  getPosition() {
    return window.pageYOffset;
  }

  /**
   * Resets scroll instance.
   */
  dispose() {
    this.raf_.cancel();
    this.lastPosition_ = -1;
    this.callbacks_ = [];
    instance = null;
  }

  /**
   * Adds subscribers (callbacks) to list that will be executed
   * during scroll event.
   * @param {!Function} callback
   * @return {!Function}
   */
  subscribe(callback) {
    this.callbacks_.push(callback);

    return () => {
      const index = this.callbacks_.indexOf(callback);
      return this.callbacks_.splice(index, 1);
    };
  }
}
/* unused harmony export default */



/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(139);


/** @private {boolean} */
let isClientReady_ = false;

/** @private @const {!Array<?Function>} */
const loadCallbacks_ = [];

/**
 * @typedef {{
 *  'location': string,
 *  'locationRadius': string,
 *  'part': string,
 *  'q': string,
 *  'type': string,
 *  'eventType': string,
 *  'relatedToVideoId': string,
 * }}
 */
let searchInterface;

/**
 * Class for making YouTube API requests.
 * @final
 */
class YTApi {
  static attach(clientId) {
    const scriptPromise = new Promise((resolve, reject) => {
      let script = document.getElementById(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* strings */].SCRIPT_ID);

      if (script) {
        resolve();
      } else {
        script = document.createElement('script');
        script.id = __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* strings */].SCRIPT_ID;
        script.src = __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* strings */].APIS_SOURCE;
        document.head.appendChild(script);
        script.addEventListener('load', resolve);
        script.addEventListener('error', reject);
      }
    });

    return scriptPromise.then(() => new YTApi(clientId));
  }

  constructor(clientId) {
    /** @private @const {string} */
    this.clientId_ = clientId;

    /** @private @const {!Object<string, !Array<!Function>>} */
    this.events_ = Object.create(null);

    /** @private {?window.gapi} */
    this.gapi_;

    /** @private {?Function} */
    this.wireResolve_;
  }

  /**
   * Executes event specific listeners.
   * @param {string} eventName
   * @param {?Object<string, *>} details
   * @private
   */
  emit_(eventName, details) {
    (this.events_[eventName] || [])
        .forEach((listener) => listener(details));
  }

  /**
   * Adds an event specific listener.
   * @param {string} eventName
   * @param {!Function} details
   * @return {!Function}
   */
  listen(eventName, listener) {
    if (!listener || typeof listener !== 'function') {
      throw new Error(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* strings */].ENSURE_LISTENER_DEFNINED_MSG);
    }

    eventName = `${__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* strings */].EVENT_PREFIX}:${eventName}`;
    this.events_[eventName] = (this.events_[eventName] || []);
    this.events_[eventName].push(listener);

    return () => {
      this.events_[eventName] =
          this.events_[eventName].filter((f) => f !== listener);
    };
  }

  /**
   * Gets videos by video id(s), chart name or region code.
   * https://developers.google.com/youtube/v3/docs/videos/list
   * @param {!Object<string, string>} options
   * @return {!Promise}
   */
  videos(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].VIDEOS, options);
  }

  /**
   * Gets subscriptions by channel id.
   * https://developers.google.com/youtube/v3/docs/subscriptions/list
   * @param {!Object<string, string>} options
   * @return {!Promise}
   */
  subs(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].SUBS, options);
  }

  /**
   * Gets video categories by region code.
   * https://developers.google.com/youtube/v3/docs/videoCategories/list
   * @param {!Object<string, string>} options
   * @return {!Promise}
   */
  videoCategories(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].VIDEO_CAT, options);
  }

  /**
   * Gets video captions by video id.
   * https://developers.google.com/youtube/v3/docs/captions/list
   * @param {!Object<string, string>} options
   * @return {!Promise}
   */
  videoCaptions(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].CAPTIONS, options);
  }

  /**
   * Gets channel(s) by id(s).
   * https://developers.google.com/youtube/v3/docs/channels/list
   * @param {!Object<string, string>} options
   * @return {!Promise}
   */
  channels(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].CHANNELS, options);
  }

  /**
   * Gets channel sections by channel id.
   * https://developers.google.com/youtube/v3/docs/channelSections/list
   * @param {!Object<string, string>} options
   * @return {!Promise}
   */
  channelSections(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].CHANNEL_SECTIONS, options);
  }

  /**
   * Gets channel activities by channel id.
   * https://developers.google.com/youtube/v3/docs/activities/list
   * @param {!Object<string, string>} options
   * @return {!Promise}
   */
  channelActivities(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].ACTIVITIES, options);
  }

  /**
   * Gets Playlistby playlist id.
   * https://developers.google.com/youtube/v3/docs/playlists/list
   * @param {!Object<string, string>} options
   * @return {!Promise}
   */
  playlist(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].PLAYLISTS, options);
  }

  /**
   * Gets Playlist items by playlist id.
   * https://developers.google.com/youtube/v3/docs/playlistItems/list
   * @param {!Object<string, string>} options
   * @return {!Promise}
   */
  playlistItems(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].PLAYLIST_ITEMS, options);
  }

  /**
   * Searches YouTube videos using keywords, locations, events, etc.
   * https://developers.google.com/youtube/v3/docs/search/list
   * @param {!searchInterface} options
   * @return {!Promise}
   */
  search(options) {
    return this.executeRequestMechanism_(__WEBPACK_IMPORTED_MODULE_0__constants__["b" /* taxonomies */].SEARCH, options);
  }

  /**
   * Builds and sends API requests. Emits a request specific event.
   * @param {string} taxonomy
   * @param {!Object<string, string>} params
   * @return {!Promise}
   * @private
   */
  executeRequestMechanism_(taxonomy, params) {
    const path = `/youtube/${__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* strings */].API_VERSION}/${taxonomy}`;
    const eventName = `${__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* strings */].EVENT_PREFIX}:${taxonomy}`;
    const method = 'GET';

    const promise = new Promise((resolve, reject) =>
        this.gapi_.client.request({method, path, params}).execute(resolve));

    return promise.then((snapshot) => {
      this.emit_(eventName, snapshot);
      return snapshot;
    });
  }

  /**
   * Loads the YT API lib and updates provider states.
   * @private
   */
  loadClient_() {
    this.gapi_ = window.gapi;
    this.gapi_.client.setApiKey(this.clientId_);
    this.gapi_.client.load('youtube', __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* strings */].API_VERSION, this.wireResolve_);
    this.emit_(__WEBPACK_IMPORTED_MODULE_0__constants__["a" /* strings */].EVENT_LOAD);
    setTimeout(() => {
      this.wireResolve_ = null;
    });
    isClientReady_ = true;
  }

  /**
   * Initializes the API.
   */
  init() {
    if (isClientReady_) {
      return Promise.resolve().then(() => this.loadClient_());
    }

    return new Promise((resolve) => {
      this.wireResolve_ = resolve;
      loadCallbacks_.push(this.loadClient_.bind(this));

      window.onload = () =>
          loadCallbacks_.forEach((callback) => callback());
    });
  }
}
/* unused harmony export default */



/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @enum {string} */
const strings = {
  API_VERSION: 'v3',
  APIS_SOURCE: 'https://apis.google.com/js/client.js',
  ACTIVITIES_TAX: 'activities',
  SCRIPT_ID: 'js-yt-api',
  // Events
  EVENT_LOAD: 'yt-api:load',
  EVENT_PREFIX: 'yt-api',
  // Messages
  NO_LISTENER_MSG: `You haven't registered any listeners for this event.`,
  ENSURE_LISTENER_DEFNINED_MSG: `Please make sure that "listener" is function.`,
};
/* harmony export (immutable) */ __webpack_exports__["a"] = strings;


/** @enum {string} */
const taxonomies = {
  ACTIVITIES: 'activities',
  CAPTIONS: 'captions',
  CHANNELS: 'channels',
  CHANNEL_SECTIONS: 'channelSections',
  COMMENTS: 'comments',
  PLAYLISTS: 'playlists',
  PLAYLIST_ITEMS: 'playlistItems',
  SUBS: 'subscriptions',
  VIDEO_CAT: 'videoCategories',
  VIDEOS: 'videos',
  SEARCH: 'search',
};
/* harmony export (immutable) */ __webpack_exports__["b"] = taxonomies;



/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** @const {string} */
const IFRAME_API_SRC = 'https://www.youtube.com/iframe_api';

/** @const {number} */
const API_REQUEST_TIMEOUT = 10000;


/**
 * Class for loading the YouTube IFrame API.
 * Docs: https://developers.google.com/youtube/iframe_api_reference
 * @final
 */
class YTIframeApiInit {
  /**
   * Creates a new instance of the YTIframeApiInit provider, which is a
   * singleton.
   * @param {number} timeout Time in milliseconds to count before timing out
   *   the API request.
   */
  constructor(timeout = API_REQUEST_TIMEOUT) {
    /** @private {number} */
    this.timeout_ = timeout;

    /** @private {Promise|undefined} */
    this.apiPromise_;
  }

  /**
   * Loads the YouTube iFrame API if it's not already loaded.
   * Registers a callback on YT.ready to notify YTPlayer components.
   * @return {!Promise} A promise for the API being loaded.
   */
  loadApi() {
    if (!this.apiPromise_) {
      this.apiPromise_ = new Promise((resolve, reject) => {
        // Run when the API has loaded.
        const onApiReady = () => {
          clearTimeout(apiRequestTimer);
          resolve();
        };

        // Timeout and reject if the API takes too long to load (unlikely).
        const apiRequestTimer = setTimeout(() => {
          reject('The YouTube iFrame API request timed out.');
        }, this.timeout_);

        if (window.YT) {
          onApiReady();
        }

        // Insert API script with load callback.
        const tag = document.createElement('script');
        const [firstScriptTag] = document.getElementsByTagName('script');

        tag.src = IFRAME_API_SRC;
        tag.addEventListener('load', () => {
          window.YT.ready(onApiReady);
        });
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
      });
    }

    return this.apiPromise_;
  }
}

/* harmony default export */ __webpack_exports__["a"] = (new YTIframeApiInit());


/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = function(config) {
  config.set({
    // Base path that will be used to resolve all patterns (eg. files, exclude)
    // relative to the location of karma.conf.js.
    basePath: '.',

    // Available frameworks: https://npmjs.org/browse/keyword/karma-adapter.
    frameworks: ['jasmine', 'closure'],

    // List of files / patterns to load in the browser.
    files: [
      // Closure stuffs.
      '../node_modules/google-closure-library/closure/goog/base.js',
      {
        pattern: '../node_modules/google-closure-library/closure/goog/deps.js',
        included: false,
        served: false,
      },
      // Library dependencies e.g. Angular, Lodash (none currently)
      // ...
      // The tests themselves.
      '**/*_test.js',
      // JavaScript sources.
      {
        pattern: '**/*.js',
        included: false,
      },
    ],

    // Files to exclude.
    exclude: [
      'static/js/*.min.js',
    ],

    preprocessors: {
      // External deps.
      '../node_modules/google-closure-library/closure/goog/deps.js':
          ['closure-deps'],
      // Source files are preprocessed for dependencies.
      '**/*.js': ['closure'],
    },

    // Test results reporter to use.
    // Possible values: 'dots', 'progress'
    // Available reporters: https://npmjs.org/browse/keyword/karma-reporter
    reporters: ['spec'],

    // Level of logging.
    // Possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG.
    logLevel: config.LOG_ERROR,
    // Web server port.
    port: 9876,
    // Enable / disable colors in the output (reporters and logs).
    colors: true,

    // Continuous Integration mode. Enable / disable watching file and
    // executing tests whenever any file changes.
    singleRun: false,
    autoWatch: true,

    // Start these browsers.
    // Available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: ['Chrome'],

    // Define custom flags.
    customLaunchers: {
      Chrome_without_security: {
        base: 'Chrome',
        flags: ['--disable-web-security'],
      },
    },
  });
};


/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__providers_auth__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_yt_data__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__google_youtube_src_components_global_constants__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__google_youtube_src_providers_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__globals_utils__ = __webpack_require__(4);







/** @private @enum {string} */
const Selectors_ = {
  ACCOUNT_DIALOG: '.ytc-js-account-dialog',
  CHANNEL_IMG: '.ytc-js-auth-channel-img',
  CHANNEL_NAME: '.ytc-js-auth-channel-name',
  EMAIL: '.ytc-js-account-email',
  INFO_BAR: '.ytc-js-auth-info-bar ',
  LOADER: '.ytc-js-loader',
  NAME: '.ytc-js-account-name',
  PROFILE_IMG: '.ytc-js-account-profile-img',
  SIGNIN_BTN: '.ytc-js-auth-signin-btn',
  SIGNOUT_BTN: '.ytc-js-auth-signout-btn',
  SUB_COUNT: '.ytc-js-auth-sub-count',
};

/** @private @enum {string} */
const Classes_ = {
  HIDE: 'yt-hide',
  PROFILE_IMG: 'account__profile-img',
  READY: 'account-ready',
  SIGNIN_BTN: 'ytc-js-auth-signin-btn',
};


/**
 * Populates and manipulates the DOM with user YouTube and Firebase
 * authentication data.
 */
class Account extends __WEBPACK_IMPORTED_MODULE_1__providers_yt_data__["default"] {
  constructor() {
    super();

    /**
     * Any element that should should become a profile image once the user
     * signs in.
     * @private @const {!Array<!Element>}
     */
    this.profileImgs_ =
        [...document.querySelectorAll(Selectors_.PROFILE_IMG)];

    /** @private @const {!Element} */
    this.loader_ = document.querySelector(Selectors_.LOADER);

    /** @private @const {!Element} */
    this.accountDialog_ = document.querySelector(Selectors_.ACCOUNT_DIALOG);

    /** @private @const {!Element} */
    this.name_ = document.querySelector(Selectors_.NAME);

    /** @private @const {!Element} */
    this.email_ = document.querySelector(Selectors_.EMAIL);

    /** @private {!Array<!Element>} */
    this.channelImgs_ =
        [...document.querySelectorAll(Selectors_.CHANNEL_IMG)];

    /** @private {!Array<!Element>} */
    this.channelNames_ =
        [...document.querySelectorAll(Selectors_.CHANNEL_NAME)];

    /** @private {!Array<!Element>} */
    this.subCounts_ =
        [...document.querySelectorAll(Selectors_.SUB_COUNT)];

    /** @private {?Element} */
    this.infoBar_ = document.querySelector(Selectors_.INFO_BAR);

    /** @private {boolean} */
    this.isSignedIn_ = false;

    this.registerEvents_();
  }

  /** @private */
  registerEvents_() {
    Object(__WEBPACK_IMPORTED_MODULE_3__google_youtube_src_providers_utils_utils__["a" /* delegate */])(document, Selectors_.SIGNIN_BTN, 'click',
        __WEBPACK_IMPORTED_MODULE_0__providers_auth__["default"].signIn.bind(__WEBPACK_IMPORTED_MODULE_0__providers_auth__["default"]));
    Object(__WEBPACK_IMPORTED_MODULE_3__google_youtube_src_providers_utils_utils__["a" /* delegate */])(document, Selectors_.SIGNOUT_BTN, 'click',
        __WEBPACK_IMPORTED_MODULE_0__providers_auth__["default"].signOut.bind(__WEBPACK_IMPORTED_MODULE_0__providers_auth__["default"]));
    Object(__WEBPACK_IMPORTED_MODULE_3__google_youtube_src_providers_utils_utils__["a" /* delegate */])(document, Selectors_.PROFILE_IMG, 'click',
        this.toggleAccountDialog_.bind(this));

    window.addEventListener('click', this.hideAccountDialog_.bind(this));
    window.addEventListener('keyup', this.handleEscKey_.bind(this));

    // Shows the loader.
    this.loader_.classList.remove(Classes_.HIDE);
  }

  /**
   * Whether or not the account dialog is visible.
   * @return {boolean}
   * @private
   */
  accountDialogIsVisible_() {
    return !this.accountDialog_.classList.contains(Classes_.HIDE);
  }

  /**
   * Fills in DOM with auth and YouTube data.
   * @param {!Object} user The user data tree given by Firebase when signed in.
   * @param {!Object} data The user's YouTube data tree.
   * @private
   */
  onYTDataReady(user, data) {
    this.isSignedIn_ = true;
    this.fillInAuthDetails_(user);
    this.fillInYTDataDetails_(data.items[0]);
    this.onAccountReady();
  }

  /**
   * Hides the info bar and account dialog and removes access token from session
   * storage.
   */
  onSignOut() {
    this.isSignedIn_ = false;
    this.hideAccountDialog_();
    this.fillInAuthDetails_();
    window.sessionStorage.clear();

    if (this.infoBar_) {
      this.infoBar_.classList.add(Classes_.HIDE);
    }

    this.onAccountSignOut();
  }

  /**
   * Empty method that is called when the account dialog is ready.
   */
  onAccountReady() {}

  /**
   * Empty method that is called when the user signs out.
   */
  onAccountSignOut() {}

  /**
   * Fills in user's name and email in the account dialog elements. Also toggles
   * classes and `backgroundImage` on all `Sign in` CTAs to switch them to
   * profile images and vice versa.
   * @param {?Object} user The user data tree given by Firebase when signed in.
   * @private
   */
  fillInAuthDetails_(user=null) {
    if (user) {
      this.name_.textContent = user.displayName;
      this.email_.textContent = user.email;
    }

    this.profileImgs_.forEach((img) => {
      // Toggles between being a `Sign in` CTA and a profile image.
      img.classList.toggle('mdc-button', !user);
      img.classList.toggle(Classes_.SIGNIN_BTN, !user);
      img.classList.toggle(Classes_.PROFILE_IMG, user);

      // Shows the button.
      img.classList.remove(Classes_.HIDE);

      // Hides the loader.
      this.loader_.classList.add(Classes_.HIDE);

      if (user) {
        // Adds profile image.
        img.style.backgroundImage = `url(${user.photoURL})`;
      } else {
        // Removes profile image.
        img.removeAttribute('style');
      }
    });
  }

  /**
   * Fills in DOM elements with user's YT channel data.
   * @param {!Object} data User's YT Data object.
   * @private
   */
  fillInYTDataDetails_(data) {
    const subCount =
        __WEBPACK_IMPORTED_MODULE_4__globals_utils__["default"].localizeNumber(parseInt(data.statistics.subscriberCount, 10));

    document.body.classList.add(Classes_.READY);

    if (this.infoBar_) {
      this.infoBar_.classList.remove(Classes_.HIDE);
    }

    this.channelImgs_.forEach((img) => {
      img.style.backgroundImage = `url(${data.snippet.thumbnails.default.url})`;
    });

    this.channelNames_.forEach((name) => {
      name.textContent = data.snippet.title;
    });

    this.subCounts_.forEach((count) => {
      count.querySelector('span').textContent = subCount;
    });
  }

  /**
   * Toggles the `hide` class on the account dialog when the user is signed in.
   * @private
   */
  toggleAccountDialog_() {
    if (!this.isSignedIn_) return;

    this.accountDialog_.classList.toggle(
        Classes_.HIDE, this.accountDialogIsVisible_());
  }

  /**
   * Hides the account dialog by adding the `hide` class to it.
   * @param {?Event} e Event object.
   * @private
   */
  hideAccountDialog_(e=undefined) {
    if (!e) {
      // No event, just hide the account dialog.
      this.accountDialog_.classList.add(Classes_.HIDE);
      return;
    }

    if (!this.accountDialog_.contains(e.target) &&
        !e.target.classList.contains(Classes_.PROFILE_IMG)) {
      // User clicked outside the account dialog and not on a the profile image.
      this.accountDialog_.classList.add(Classes_.HIDE);
    }
  }

  /**
   * Hides the account dialog on Escape keyup if it's visible.
   * @param {!Event} e Event object.
   * @private
   */
  handleEscKey_(e) {
    if (e.keyCode === __WEBPACK_IMPORTED_MODULE_2__google_youtube_src_components_global_constants__["a" /* KeyCodes */].ESC && this.accountDialogIsVisible_()) {
      this.hideAccountDialog_();
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = Account;



/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__globals_utils__ = __webpack_require__(4);



/** @private @enum {string} */
const Attrs_ = {
  ANSWER: 'data-nextup-eligibilty-answer',
  NOT_ELIGIBLE_MSG: 'data-nextup-not-eligible-message',
  RESULT: 'data-nextup-result-message',
  SUB_COUNT_ANSWER: 'data-nextup-eligibilty-sub-count-answer',
};

/** @private @enum {string} */
const Selectors_ = {
  ANSWER: `[${Attrs_.ANSWER}]`,
  QUESTION: '.yt-js-nextup-eligibilty-question',
  QUESTIONS_WRAPPER: '.yt-js-nextup-eligibilty-questions',
  MISSING_REQUIREMENTS: '.yt-js-nextup-missing-requirements',
  NOT_ELIGIBLE_MSG: `[${Attrs_.NOT_ELIGIBLE_MSG}]`,
  NOT_ELIGIBLE_MSGS_WRAPPER: '.yt-js-nextup-not-eligible-messages',
  RESET: '.yt-js-nextup-eligibilty-reset',
  RESULT: `[${Attrs_.RESULT}]`,
  RESULTS_WRAPPER: '.yt-js-nextup-results',
  SUB_COUNT_ANSWER: `[${Attrs_.SUB_COUNT_ANSWER}]`,
};

/** @private @enum {string} */
const Classes_ = {
  HIDE: 'yt-hide',
};

/** @private @enum {string} */
const Messages_ = {
  ELIGIBLE: 'eligible',
  NOT_ELIGIBLE: 'not-eligible',
  NOT_ENOUGH_SUBS: 'not-enough-subs',
  TOO_MANY_SUBS: 'too-many-subs',
};


/**
 * Assesses whether a user is eligible to participate in NextUp by recording
 * their answers to a quiz. They must have the appropriate number of
 * subscribers, not too few or too many, and answer `Yes` to all questions. If
 * they are not eligible, then a message with missing requirements is displayed.
 * @final
 */
class NextUpEligibility {
  constructor() {
    /** @private @const {!Element} */
    this.questionsWrapper_ = document.querySelector(
        Selectors_.QUESTIONS_WRAPPER);

    /** @private @const {!Array<!Element>} */
    this.questions_ = [...this.questionsWrapper_.querySelectorAll(
        Selectors_.QUESTION)];

    /** @private @const {!Element} */
    this.notEligibleMsgsWrapper_ = document.querySelector(
        Selectors_.NOT_ELIGIBLE_MSGS_WRAPPER);

    /** @private @const {!Array<!Element>} */
    this.notEligibleMsgs_ = [...this.notEligibleMsgsWrapper_.querySelectorAll(
        Selectors_.NOT_ELIGIBLE_MSG)];

    /** @private @const {!Element} */
    this.resultsWrapper_ = document.querySelector(
        Selectors_.RESULTS_WRAPPER);

    /** @private @const {!Array<!Element>} */
    this.results_ = [...this.resultsWrapper_.querySelectorAll(
        Selectors_.RESULT)];

    /** @private @const {!Element} */
    this.missingRequirementsWrapper_ = document.querySelector(
        Selectors_.MISSING_REQUIREMENTS);

    /** @private @const {!Array<!Element>} */
    this.missingRequirements_ = [...this.missingRequirementsWrapper_.children];

    /** @private {number} */
    this.currentQuestionIndex_ = 0;

    /** @private @const {number} */
    this.eligibleScore_ = this.questions_.length;

    /** @private @const {!Array<string>} */
    this.userAnswers_ = [];

    /** @private {number} */
    this.score_ = 0;

    this.removeMissingRequirements_();
    this.registerEvents_();
  }

  /**
   * Removes the child elements of the `missing requirements` wrapper so that
   * it can be filled in later with only the ones that are appropriate for the
   * chosen answers.
   * @private
   */
  removeMissingRequirements_() {
    while (this.missingRequirementsWrapper_.firstChild) {
      this.missingRequirementsWrapper_.removeChild(
          this.missingRequirementsWrapper_.firstChild);
    }
  }

  /** @private */
  registerEvents_() {
    __WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].ytc.delegate(document, Selectors_.SUB_COUNT_ANSWER, 'click',
        this.checkSubCountAnswer_.bind(this));

    __WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].ytc.delegate(document, Selectors_.ANSWER, 'click',
        this.progress_.bind(this));

    __WEBPACK_IMPORTED_MODULE_0__globals_utils__["default"].ytc.delegate(document, Selectors_.RESET, 'click',
        this.reset_.bind(this));
  }

  /**
   * Shows a specific `not eligible` message or continues on the next question
   * while adding 1 to the user's `score`. What happens depends on the
   * `subscriber count` data attr value of the given target.
   * @param {!Element} target
   * @private
   */
  checkSubCountAnswer_(target) {
    const answer = target.getAttribute(Attrs_.SUB_COUNT_ANSWER);

    switch (answer) {
      case '1':
        // Not enough subscribers.
        this.showNotEligibleMsg_(Messages_.NOT_ENOUGH_SUBS);
        break;
      case '3':
        // Too many subscribers.
        this.showNotEligibleMsg_(Messages_.TOO_MANY_SUBS);
        break;
      default:
        // The right amount of subscribers.
        this.nextQuestion_();
        this.score_++;
    }
  }

  /**
   * Hides the questions and shows the `not eligible` message with the given
   * value in its data attr.
   * @param {string} msgName Value of the `not eligible` message data attr.
   * @private
   */
  showNotEligibleMsg_(msgName) {
    const msg =
        document.querySelector(`[${Attrs_.NOT_ELIGIBLE_MSG}=${msgName}]`);

    msg.classList.remove(Classes_.HIDE);
    this.questionsWrapper_.classList.add(Classes_.HIDE);
    this.notEligibleMsgsWrapper_.classList.remove(Classes_.HIDE);
  }

  /**
   * Stores the user's answer, adds 1 to their `score` if they chose an eligible
   * answer then shows the next question.
   * @param {!Element} target
   * @private
   */
  progress_(target) {
    const answer = target.getAttribute(Attrs_.ANSWER);
    const isEligible = answer === '1';

    this.userAnswers_.push(answer);

    if (isEligible) this.score_++;

    this.nextQuestion_();
  }

  /**
   * Hides the current question then either shows the results, if the user
   * answered the last one, or shows the next one.
   * @private
   */
  nextQuestion_() {
    this.questions_[this.currentQuestionIndex_].classList.add(Classes_.HIDE);

    if (this.currentQuestionIndex_ + 1 === this.eligibleScore_) {
      this.showResults_();
      return;
    }

    this.currentQuestionIndex_++;
    this.questions_[this.currentQuestionIndex_].classList.remove(Classes_.HIDE);
  }

  /**
   * Hides the questions and shows the results.
   * @private
   */
  showResults_() {
    let msg = document.querySelector(
        `[${Attrs_.RESULT}=${Messages_.ELIGIBLE}]`);

    this.questionsWrapper_.classList.add(Classes_.HIDE);
    this.resultsWrapper_.classList.remove(Classes_.HIDE);

    if (this.score_ !== this.eligibleScore_) {
      // User is NOT eligible.
      msg = document.querySelector(
          `[${Attrs_.RESULT}=${Messages_.NOT_ELIGIBLE}]`);

      // Populate the `missing requirements` wrapper with the appropriate,
      // previously stored requirements based on the user's answers.
      this.userAnswers_.forEach((answer, i) => {
        if (answer === '0') {
          this.missingRequirementsWrapper_.appendChild(
            this.missingRequirements_[i]);
        }
      });
    }

    msg.classList.remove(Classes_.HIDE);
  }

  /**
   * Resets the quiz.
   * @private
   */
  reset_() {
    // Hide result messages.
    this.resultsWrapper_.classList.add(Classes_.HIDE);
    this.results_.forEach((result) => result.classList.add(Classes_.HIDE));
    this.removeMissingRequirements_();

    // Hide `Not eligible` messages.
    this.notEligibleMsgsWrapper_.classList.add(Classes_.HIDE);
    this.notEligibleMsgs_.forEach((msg) => msg.classList.add(Classes_.HIDE));

    // Show first question while hiding the rest.
    this.questionsWrapper_.classList.remove(Classes_.HIDE);
    this.questions_.forEach((q) => q.classList.add(Classes_.HIDE));
    this.questions_[0].classList.remove(Classes_.HIDE);

    // Reset the user's answers.
    this.currentQuestionIndex_ = 0;
    this.userAnswers_ = [];
    this.score_ = 0;
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = NextUpEligibility;



/***/ }),
/* 144 */
/***/ (function(module, exports) {

// import Page from '@google/youtube/src/providers/page/page';
// import NextUpEligibility from './eligibility';
// import NextUpRegistration from './registration';
// import utils from '../../globals/utils';
// /** @private @enum {string} */
// const Selectors_ = {
//   ACCORDION: '.ytc-js-accordion',
//   CAMP_DATE: '.yt-js-camp-date',
//   NEXT_ROUND_DATE: '.yt-next-round-date',
//   REGISTRATION_MODAL: '.yt-js-nextup-registration-modal',
// };
// export default class NextUp extends Page {
//   render_(YTCAccordion, Modal, Slideshow, YTCIframeApi) {
//     new Modal;
//     new Slideshow;
//     new YTCIframeApi;
//     new NextUpEligibility;
//     // NextUp Registration modals.
//     const registrationModals =
//         [...document.querySelectorAll(Selectors_.REGISTRATION_MODAL)];
//     registrationModals.forEach((modal) => new NextUpRegistration(modal));
//     // YTC Accordion.
//     const accordionEl = document.querySelector(Selectors_.ACCORDION);
//     if (accordionEl) new YTCAccordion(accordionEl);
//     // Localize camp dates.
//     const dates = [...document.querySelectorAll(Selectors_.CAMP_DATE)];
//     dates.forEach((date) => {
//       date.innerText = utils.localizeDate(date.innerText, 'short', 'UTC');
//     });
//     // Localize next round date.
//     const nextRoundDate = document.querySelector(Selectors_.NEXT_ROUND_DATE);
//     if (nextRoundDate) {
//       const date = nextRoundDate.querySelector('strong');
//       if (date) {
//         date.innerText = utils.localizeDate(date.innerText, 'short', 'UTC');
//       }
//     }
//   }
// }

/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_checkbox__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_form_field__ = __webpack_require__(151);




/** @private @enum {string} */
const Selectors_ = {
  CHECKBOX: '.yt-js-nextup-registration-checkbox',
  ERROR_WRAPPER: '.yt-js-nextup-registration-error-msg',
  PDF_BTN: '.yt-js-nextup-registration-pdf',
  REGISTRATION_LINK: '.yt-js-nextup-registration-link',
};

/** @private @enum {string} */
const Classes_ = {
  HIDE: 'yt-hide',
};


/**
 * Toggles error messages and enables the registration link if the user performs
 * all required actions.
 * @param {!Element} root
 * @final
 */
class NextUpRegistration {
  constructor(root) {
    /** @private @const */
    this.root_ = root;

    /** @private @const {!Element} */
    this.errorsWrapper_ = this.root_.querySelector(Selectors_.ERROR_WRAPPER);

    /** @private @const {!Element} */
    this.errorsList_ = this.errorsWrapper_.querySelector('ul');

    /** @private @const {!Array<!Element>} */
    this.errors_ = [...this.errorsList_.children];

    /** @private @const {!Element} */
    this.pdfError_ = this.errors_[0];

    /** @private @const {!Element} */
    this.checkboxError_ = this.errors_[1];

    /** @private @const {!Element} */
    this.pdfBtn_ = this.root_.querySelector(Selectors_.PDF_BTN);

    /** @private @const {!Element} */
    this.checkbox_ = this.root_.querySelector(Selectors_.CHECKBOX);

    /** @private @const {!Element} */
    this.registrationLink_ = this.root_.querySelector(
        Selectors_.REGISTRATION_LINK);

    /** @private {boolean} */
    this.pdfViewed_ = false;

    // Removes the child elements of the `errors list` so that it can be filled
    // in later with only the ones that are appropriate for the user's actions.
    while (this.errorsList_.firstChild) {
      this.errorsList_.removeChild(this.errorsList_.firstChild);
    }

    // Register events.
    this.pdfBtn_.addEventListener('click', this.handlePDFClick_.bind(this));
    this.checkbox_.addEventListener('change',
        this.handleCheckboxChange_.bind(this));

    this.initMDCCheckbox_();
  }

  /**
   * Removes PDF error and appends the checkbox one if it is not checked.
   * @private
   */
  handlePDFClick_() {
    this.errorsWrapper_.classList.remove(Classes_.HIDE);

    this.pdfViewed_ = true;
    this.pdfError_.remove();

    if (this.checkbox_.checked) {
      // Checkbox checked.
      this.errorsWrapper_.classList.add(Classes_.HIDE);
    } else {
      // Checkbox NOT checked.
      this.errorsList_.appendChild(this.checkboxError_);
    }

    this.toggleRegistraionLink_();
  }

  /**
   * Removes checkbox error and appends the PDF one if it has not been clicked.
   * @private
   */
  handleCheckboxChange_() {
    this.errorsWrapper_.classList.remove(Classes_.HIDE);

    if (this.checkbox_.checked) {
      // Checkbox checked.
      this.checkboxError_.remove();

      if (this.pdfViewed_) {
        // PDF btn clicked.
        this.errorsWrapper_.classList.add(Classes_.HIDE);
      } else {
        // PDF btn NOT clicked.
        this.errorsList_.appendChild(this.pdfError_);
      }
    } else {
      // Checkbox NOT checked.
      this.errorsList_.appendChild(this.checkboxError_);
    }

    this.toggleRegistraionLink_();
  }

  /**
   * Removes `disabled` attribute from registration link if the checkbox is
   * checked and the PDF button has been clicked. It is added, otherwise.
   * @private
   */
  toggleRegistraionLink_() {
    if (this.pdfViewed_ && this.checkbox_.checked) {
      this.registrationLink_.removeAttribute('disabled');
    } else {
      this.registrationLink_.setAttribute('disabled', true);
    }
  }

  /**
   * Creates new instances of MDCFormField and MDCCheckbox to add the Material
   * ripple effect to the `Official Rules` checkbox.
   * @private
   */
  initMDCCheckbox_() {
    const formFieldEl = this.root_.querySelector('.mdc-form-field');
    const checkboxEl = formFieldEl.querySelector('.mdc-checkbox');
    const formField = new __WEBPACK_IMPORTED_MODULE_1__material_form_field__["a" /* MDCFormField */](formFieldEl);
    const checkbox = new __WEBPACK_IMPORTED_MODULE_0__material_checkbox__["a" /* MDCCheckbox */](checkboxEl);

    formField.input = checkbox;
  }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = NextUpRegistration;



/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MDCCheckbox; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_animation_index__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_base_component__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_selection_control_index__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__material_ripple_index__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__material_ripple_util__ = __webpack_require__(22);
/* unused harmony reexport MDCCheckboxFoundation */
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/* eslint-disable no-unused-vars */

/* eslint-enable no-unused-vars */




/**
 * @extends MDCComponent<!MDCCheckboxFoundation>
 * @implements {MDCSelectionControl}
 */
class MDCCheckbox extends __WEBPACK_IMPORTED_MODULE_1__material_base_component__["a" /* default */] {
  static attachTo(root) {
    return new MDCCheckbox(root);
  }

  /**
   * Returns the state of the native control element, or null if the native control element is not present.
   * @return {?MDCSelectionControlState}
   * @private
   */
  get nativeCb_() {
    const {NATIVE_CONTROL_SELECTOR} = __WEBPACK_IMPORTED_MODULE_3__foundation__["a" /* default */].strings;
    const cbEl = /** @type {?MDCSelectionControlState} */ (
      this.root_.querySelector(NATIVE_CONTROL_SELECTOR));
    return cbEl;
  }

  constructor(...args) {
    super(...args);

    /** @private {!MDCRipple} */
    this.ripple_ = this.initRipple_();
    /** @private {!Function} */
    this.handleChange_;
    /** @private {!Function} */
    this.handleAnimationEnd_;
  }

  initialSyncWithDOM() {
    this.handleChange_ = () => this.foundation_.handleChange();
    this.handleAnimationEnd_= () => this.foundation_.handleAnimationEnd();
    this.nativeCb_.addEventListener('change', this.handleChange_);
    this.listen(Object(__WEBPACK_IMPORTED_MODULE_0__material_animation_index__["a" /* getCorrectEventName */])(window, 'animationend'), this.handleAnimationEnd_);
  }

  /**
   * @return {!MDCRipple}
   * @private
   */
  initRipple_() {
    const MATCHES = Object(__WEBPACK_IMPORTED_MODULE_5__material_ripple_util__["b" /* getMatchesProperty */])(HTMLElement.prototype);
    const adapter = Object.assign(__WEBPACK_IMPORTED_MODULE_4__material_ripple_index__["a" /* MDCRipple */].createAdapter(this), {
      isUnbounded: () => true,
      isSurfaceActive: () => this.nativeCb_[MATCHES](':active'),
      registerInteractionHandler: (type, handler) => this.nativeCb_.addEventListener(type, handler),
      deregisterInteractionHandler: (type, handler) => this.nativeCb_.removeEventListener(type, handler),
    });
    const foundation = new __WEBPACK_IMPORTED_MODULE_4__material_ripple_index__["b" /* MDCRippleFoundation */](adapter);
    return new __WEBPACK_IMPORTED_MODULE_4__material_ripple_index__["a" /* MDCRipple */](this.root_, foundation);
  }

  /** @return {!MDCCheckboxFoundation} */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_3__foundation__["a" /* default */]({
      addClass: (className) => this.root_.classList.add(className),
      removeClass: (className) => this.root_.classList.remove(className),
      setNativeControlAttr: (attr, value) => this.nativeCb_.setAttribute(attr, value),
      removeNativeControlAttr: (attr) => this.nativeCb_.removeAttribute(attr),
      getNativeControl: () => this.nativeCb_,
      forceLayout: () => this.root_.offsetWidth,
      isAttachedToDOM: () => Boolean(this.root_.parentNode),
    });
  }

  /** @return {!MDCRipple} */
  get ripple() {
    return this.ripple_;
  }

  /** @return {boolean} */
  get checked() {
    return this.foundation_.isChecked();
  }

  /** @param {boolean} checked */
  set checked(checked) {
    this.foundation_.setChecked(checked);
  }

  /** @return {boolean} */
  get indeterminate() {
    return this.foundation_.isIndeterminate();
  }

  /** @param {boolean} indeterminate */
  set indeterminate(indeterminate) {
    this.foundation_.setIndeterminate(indeterminate);
  }

  /** @return {boolean} */
  get disabled() {
    return this.foundation_.isDisabled();
  }

  /** @param {boolean} disabled */
  set disabled(disabled) {
    this.foundation_.setDisabled(disabled);
  }

  /** @return {?string} */
  get value() {
    return this.foundation_.getValue();
  }

  /** @param {?string} value */
  set value(value) {
    this.foundation_.setValue(value);
  }

  destroy() {
    this.ripple_.destroy();
    this.nativeCb_.removeEventListener('change', this.handleChange_);
    this.unlisten(Object(__WEBPACK_IMPORTED_MODULE_0__material_animation_index__["a" /* getCorrectEventName */])(window, 'animationend'), this.handleAnimationEnd_);
    super.destroy();
  }
}




/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export transformStyleProperties */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getCorrectEventName; });
/* unused harmony export getCorrectPropertyName */
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @typedef {{
 *   noPrefix: string,
 *   webkitPrefix: string,
 *   styleProperty: string
 * }}
 */
let VendorPropertyMapType;

/** @const {Object<string, !VendorPropertyMapType>} */
const eventTypeMap = {
  'animationstart': {
    noPrefix: 'animationstart',
    webkitPrefix: 'webkitAnimationStart',
    styleProperty: 'animation',
  },
  'animationend': {
    noPrefix: 'animationend',
    webkitPrefix: 'webkitAnimationEnd',
    styleProperty: 'animation',
  },
  'animationiteration': {
    noPrefix: 'animationiteration',
    webkitPrefix: 'webkitAnimationIteration',
    styleProperty: 'animation',
  },
  'transitionend': {
    noPrefix: 'transitionend',
    webkitPrefix: 'webkitTransitionEnd',
    styleProperty: 'transition',
  },
};

/** @const {Object<string, !VendorPropertyMapType>} */
const cssPropertyMap = {
  'animation': {
    noPrefix: 'animation',
    webkitPrefix: '-webkit-animation',
  },
  'transform': {
    noPrefix: 'transform',
    webkitPrefix: '-webkit-transform',
  },
  'transition': {
    noPrefix: 'transition',
    webkitPrefix: '-webkit-transition',
  },
};

/**
 * @param {!Object} windowObj
 * @return {boolean}
 */
function hasProperShape(windowObj) {
  return (windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function');
}

/**
 * @param {string} eventType
 * @return {boolean}
 */
function eventFoundInMaps(eventType) {
  return (eventType in eventTypeMap || eventType in cssPropertyMap);
}

/**
 * @param {string} eventType
 * @param {!Object<string, !VendorPropertyMapType>} map
 * @param {!Element} el
 * @return {string}
 */
function getJavaScriptEventName(eventType, map, el) {
  return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
}

/**
 * Helper function to determine browser prefix for CSS3 animation events
 * and property names.
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getAnimationName(windowObj, eventType) {
  if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
    return eventType;
  }

  const map = /** @type {!Object<string, !VendorPropertyMapType>} */ (
    eventType in eventTypeMap ? eventTypeMap : cssPropertyMap
  );
  const el = windowObj['document']['createElement']('div');
  let eventName = '';

  if (map === eventTypeMap) {
    eventName = getJavaScriptEventName(eventType, map, el);
  } else {
    eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  return eventName;
}

// Public functions to access getAnimationName() for JavaScript events or CSS
// property names.

const transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];

/**
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getCorrectEventName(windowObj, eventType) {
  return getAnimationName(windowObj, eventType);
}

/**
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getCorrectPropertyName(windowObj, eventType) {
  return getAnimationName(windowObj, eventType);
}




/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_foundation__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_selection_control_index__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__adapter__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constants__ = __webpack_require__(150);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


/* eslint-disable no-unused-vars */


/* eslint-enable no-unused-vars */


/** @const {!Array<string>} */
const CB_PROTO_PROPS = ['checked', 'indeterminate'];

/**
 * @extends {MDCFoundation<!MDCCheckboxAdapter>}
 */
class MDCCheckboxFoundation extends __WEBPACK_IMPORTED_MODULE_0__material_base_foundation__["a" /* default */] {
  /** @return enum {cssClasses} */
  static get cssClasses() {
    return __WEBPACK_IMPORTED_MODULE_3__constants__["a" /* cssClasses */];
  }

  /** @return enum {strings} */
  static get strings() {
    return __WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */];
  }

  /** @return enum {numbers} */
  static get numbers() {
    return __WEBPACK_IMPORTED_MODULE_3__constants__["b" /* numbers */];
  }

  /** @return {!MDCCheckboxAdapter} */
  static get defaultAdapter() {
    return /** @type {!MDCCheckboxAdapter} */ ({
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      setNativeControlAttr: (/* attr: string, value: string */) => {},
      removeNativeControlAttr: (/* attr: string */) => {},
      getNativeControl: () => /* !MDCSelectionControlState */ {},
      forceLayout: () => {},
      isAttachedToDOM: () => /* boolean */ {},
    });
  }

  constructor(adapter) {
    super(Object.assign(MDCCheckboxFoundation.defaultAdapter, adapter));

    /** @private {string} */
    this.currentCheckState_ = __WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */].TRANSITION_STATE_INIT;

    /** @private {string} */
    this.currentAnimationClass_ = '';

    /** @private {number} */
    this.animEndLatchTimer_ = 0;

    /** @private {boolean} */
    this.enableAnimationEndHandler_ = false;
  }

  /** @override */
  init() {
    this.currentCheckState_ = this.determineCheckState_(this.getNativeControl_());
    this.updateAriaChecked_();
    this.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_3__constants__["a" /* cssClasses */].UPGRADED);
    this.installPropertyChangeHooks_();
  }

  /** @override */
  destroy() {
    this.uninstallPropertyChangeHooks_();
  }

  /** @return {boolean} */
  isChecked() {
    return this.getNativeControl_().checked;
  }

  /** @param {boolean} checked */
  setChecked(checked) {
    this.getNativeControl_().checked = checked;
  }

  /** @return {boolean} */
  isIndeterminate() {
    return this.getNativeControl_().indeterminate;
  }

  /** @param {boolean} indeterminate */
  setIndeterminate(indeterminate) {
    this.getNativeControl_().indeterminate = indeterminate;
  }

  /** @return {boolean} */
  isDisabled() {
    return this.getNativeControl_().disabled;
  }

  /** @param {boolean} disabled */
  setDisabled(disabled) {
    this.getNativeControl_().disabled = disabled;
    if (disabled) {
      this.adapter_.addClass(__WEBPACK_IMPORTED_MODULE_3__constants__["a" /* cssClasses */].DISABLED);
    } else {
      this.adapter_.removeClass(__WEBPACK_IMPORTED_MODULE_3__constants__["a" /* cssClasses */].DISABLED);
    }
  }

  /** @return {?string} */
  getValue() {
    return this.getNativeControl_().value;
  }

  /** @param {?string} value */
  setValue(value) {
    this.getNativeControl_().value = value;
  }

  /**
   * Handles the animationend event for the checkbox
   */
  handleAnimationEnd() {
    if (!this.enableAnimationEndHandler_) return;

    clearTimeout(this.animEndLatchTimer_);

    this.animEndLatchTimer_ = setTimeout(() => {
      this.adapter_.removeClass(this.currentAnimationClass_);
      this.enableAnimationEndHandler_ = false;
    }, __WEBPACK_IMPORTED_MODULE_3__constants__["b" /* numbers */].ANIM_END_LATCH_MS);
  }

  /**
   * Handles the change event for the checkbox
   */
  handleChange() {
    this.transitionCheckState_();
  }

  /** @private */
  installPropertyChangeHooks_() {
    const nativeCb = this.getNativeControl_();
    const cbProto = Object.getPrototypeOf(nativeCb);

    CB_PROTO_PROPS.forEach((controlState) => {
      const desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
      // We have to check for this descriptor, since some browsers (Safari) don't support its return.
      // See: https://bugs.webkit.org/show_bug.cgi?id=49739
      if (validDescriptor(desc)) {
        const nativeCbDesc = /** @type {!ObjectPropertyDescriptor} */ ({
          get: desc.get,
          set: (state) => {
            desc.set.call(nativeCb, state);
            this.transitionCheckState_();
          },
          configurable: desc.configurable,
          enumerable: desc.enumerable,
        });
        Object.defineProperty(nativeCb, controlState, nativeCbDesc);
      }
    });
  }

  /** @private */
  uninstallPropertyChangeHooks_() {
    const nativeCb = this.getNativeControl_();
    const cbProto = Object.getPrototypeOf(nativeCb);

    CB_PROTO_PROPS.forEach((controlState) => {
      const desc = /** @type {!ObjectPropertyDescriptor} */ (
        Object.getOwnPropertyDescriptor(cbProto, controlState));
      if (validDescriptor(desc)) {
        Object.defineProperty(nativeCb, controlState, desc);
      }
    });
  }

  /** @private */
  transitionCheckState_() {
    const nativeCb = this.adapter_.getNativeControl();
    if (!nativeCb) {
      return;
    }
    const oldState = this.currentCheckState_;
    const newState = this.determineCheckState_(nativeCb);
    if (oldState === newState) {
      return;
    }

    this.updateAriaChecked_();

    // Check to ensure that there isn't a previously existing animation class, in case for example
    // the user interacted with the checkbox before the animation was finished.
    if (this.currentAnimationClass_.length > 0) {
      clearTimeout(this.animEndLatchTimer_);
      this.adapter_.forceLayout();
      this.adapter_.removeClass(this.currentAnimationClass_);
    }

    this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
    this.currentCheckState_ = newState;

    // Check for parentNode so that animations are only run when the element is attached
    // to the DOM.
    if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
      this.adapter_.addClass(this.currentAnimationClass_);
      this.enableAnimationEndHandler_ = true;
    }
  }

  /**
   * @param {!MDCSelectionControlState} nativeCb
   * @return {string}
   * @private
   */
  determineCheckState_(nativeCb) {
    const {
      TRANSITION_STATE_INDETERMINATE,
      TRANSITION_STATE_CHECKED,
      TRANSITION_STATE_UNCHECKED,
    } = __WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */];

    if (nativeCb.indeterminate) {
      return TRANSITION_STATE_INDETERMINATE;
    }
    return nativeCb.checked ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
  }

  /**
   * @param {string} oldState
   * @param {string} newState
   * @return {string}
   */
  getTransitionAnimationClass_(oldState, newState) {
    const {
      TRANSITION_STATE_INIT,
      TRANSITION_STATE_CHECKED,
      TRANSITION_STATE_UNCHECKED,
    } = __WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */];

    const {
      ANIM_UNCHECKED_CHECKED,
      ANIM_UNCHECKED_INDETERMINATE,
      ANIM_CHECKED_UNCHECKED,
      ANIM_CHECKED_INDETERMINATE,
      ANIM_INDETERMINATE_CHECKED,
      ANIM_INDETERMINATE_UNCHECKED,
    } = MDCCheckboxFoundation.cssClasses;

    switch (oldState) {
    case TRANSITION_STATE_INIT:
      if (newState === TRANSITION_STATE_UNCHECKED) {
        return '';
      }
    // fallthrough
    case TRANSITION_STATE_UNCHECKED:
      return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
    case TRANSITION_STATE_CHECKED:
      return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
    // TRANSITION_STATE_INDETERMINATE
    default:
      return newState === TRANSITION_STATE_CHECKED ?
        ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
    }
  }

  updateAriaChecked_() {
    // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
    if (this.isIndeterminate()) {
      this.adapter_.setNativeControlAttr(
        __WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */].ARIA_CHECKED_ATTR, __WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */].ARIA_CHECKED_INDETERMINATE_VALUE);
    } else {
      // The on/off state does not need to keep track of aria-checked, since
      // the screenreader uses the checked property on the checkbox element.
      this.adapter_.removeNativeControlAttr(__WEBPACK_IMPORTED_MODULE_3__constants__["c" /* strings */].ARIA_CHECKED_ATTR);
    }
  }

  /**
   * @return {!MDCSelectionControlState}
   * @private
   */
  getNativeControl_() {
    return this.adapter_.getNativeControl() || {
      checked: false,
      indeterminate: false,
      disabled: false,
      value: null,
    };
  }
}

/**
 * @param {ObjectPropertyDescriptor|undefined} inputPropDesc
 * @return {boolean}
 */
function validDescriptor(inputPropDesc) {
  return !!inputPropDesc && typeof inputPropDesc.set === 'function';
}

/* harmony default export */ __webpack_exports__["a"] = (MDCCheckboxFoundation);


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_selection_control_index__ = __webpack_require__(21);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint-disable no-unused-vars */


/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Checkbox. Provides an interface for managing
 * - classes
 * - dom
 * - event handlers
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
class MDCCheckboxAdapter {
  /** @param {string} className */
  addClass(className) {}

  /** @param {string} className */
  removeClass(className) {}

  /**
   * Sets an attribute with a given value on the input element.
   * @param {string} attr
   * @param {string} value
   */
  setNativeControlAttr(attr, value) {}

  /**
   * Removes an attribute from the input element.
   * @param {string} attr
   */
  removeNativeControlAttr(attr) {}

  /** @return {!MDCSelectionControlState} */
  getNativeControl() {}

  forceLayout() {}

  /** @return {boolean} */
  isAttachedToDOM() {}
}

/* unused harmony default export */ var _unused_webpack_default_export = (MDCCheckboxAdapter);


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return strings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return numbers; });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @const {string} */
const ROOT = 'mdc-checkbox';

/** @enum {string} */
const cssClasses = {
  UPGRADED: 'mdc-checkbox--upgraded',
  CHECKED: 'mdc-checkbox--checked',
  INDETERMINATE: 'mdc-checkbox--indeterminate',
  DISABLED: 'mdc-checkbox--disabled',
  ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
  ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
  ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
  ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
  ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
  ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked',
};

/** @enum {string} */
const strings = {
  NATIVE_CONTROL_SELECTOR: `.${ROOT}__native-control`,
  TRANSITION_STATE_INIT: 'init',
  TRANSITION_STATE_CHECKED: 'checked',
  TRANSITION_STATE_UNCHECKED: 'unchecked',
  TRANSITION_STATE_INDETERMINATE: 'indeterminate',
  ARIA_CHECKED_ATTR: 'aria-checked',
  ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed',
};

/** @enum {number} */
const numbers = {
  ANIM_END_LATCH_MS: 250,
};




/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MDCFormField; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_component__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_selection_control_index__ = __webpack_require__(21);
/* unused harmony reexport MDCFormFieldFoundation */
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/* eslint-disable no-unused-vars */

/* eslint-enable no-unused-vars */

/**
 * @extends MDCComponent<!MDCFormFieldFoundation>
 */
class MDCFormField extends __WEBPACK_IMPORTED_MODULE_0__material_base_component__["a" /* default */] {
  static attachTo(root) {
    return new MDCFormField(root);
  }

  /** @param {?MDCSelectionControl} input */
  set input(input) {
    this.input_ = input;
  }

  /** @return {?MDCSelectionControl} */
  get input() {
    return this.input_;
  }

  constructor(...args) {
    super(...args);

    /** @private {?MDCSelectionControl} */
    this.input_;
  }

  /**
   * @return {!Element}
   * @private
   */
  get label_() {
    const {LABEL_SELECTOR} = __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* default */].strings;
    return /** @type {!Element} */ (this.root_.querySelector(LABEL_SELECTOR));
  }

  /** @return {!MDCFormFieldFoundation} */
  getDefaultFoundation() {
    return new __WEBPACK_IMPORTED_MODULE_1__foundation__["a" /* default */]({
      registerInteractionHandler: (type, handler) => this.label_.addEventListener(type, handler),
      deregisterInteractionHandler: (type, handler) => this.label_.removeEventListener(type, handler),
      activateInputRipple: () => {
        if (this.input_ && this.input_.ripple) {
          this.input_.ripple.activate();
        }
      },
      deactivateInputRipple: () => {
        if (this.input_ && this.input_.ripple) {
          this.input_.ripple.deactivate();
        }
      },
    });
  }
}




/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_base_foundation__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adapter__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(154);
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */





/**
 * @extends {MDCFoundation<!MDCFormFieldAdapter>}
 */
class MDCFormFieldFoundation extends __WEBPACK_IMPORTED_MODULE_0__material_base_foundation__["a" /* default */] {
  /** @return enum {cssClasses} */
  static get cssClasses() {
    return __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* cssClasses */];
  }

  /** @return enum {strings} */
  static get strings() {
    return __WEBPACK_IMPORTED_MODULE_2__constants__["b" /* strings */];
  }

  /** @return {!MDCFormFieldAdapter} */
  static get defaultAdapter() {
    return {
      registerInteractionHandler: (/* type: string, handler: EventListener */) => {},
      deregisterInteractionHandler: (/* type: string, handler: EventListener */) => {},
      activateInputRipple: () => {},
      deactivateInputRipple: () => {},
    };
  }

  constructor(adapter) {
    super(Object.assign(MDCFormFieldFoundation.defaultAdapter, adapter));

    /** @private {!EventListener} */
    this.clickHandler_ = /** @type {!EventListener} */ (
      () => this.handleClick_());
  }

  init() {
    this.adapter_.registerInteractionHandler('click', this.clickHandler_);
  }

  destroy() {
    this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
  }

  /** @private */
  handleClick_() {
    this.adapter_.activateInputRipple();
    requestAnimationFrame(() => this.adapter_.deactivateInputRipple());
  }
}

/* harmony default export */ __webpack_exports__["a"] = (MDCFormFieldFoundation);


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Form Field. Provides an interface for managing
 * - event handlers
 * - ripple activation
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
class MDCFormFieldAdapter {
  /**
   * @param {string} type
   * @param {!EventListener} handler
   */
  registerInteractionHandler(type, handler) {}

  /**
   * @param {string} type
   * @param {!EventListener} handler
   */
  deregisterInteractionHandler(type, handler) {}

  activateInputRipple() {}

  deactivateInputRipple() {}
}

/* unused harmony default export */ var _unused_webpack_default_export = (MDCFormFieldAdapter);


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cssClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return strings; });
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses = {
  ROOT: 'mdc-form-field',
};

/** @enum {string} */
const strings = {
  LABEL_SELECTOR: '.mdc-form-field > label',
};




/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXgubWluLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIGEyYWYxNTAwM2VkNjY2NmEwZmM4Iiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vbW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy91dGlscy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvdGlsZW1hcC92aXNpYmlsaXR5LmpzIiwid2VicGFjazovLy8uL2dsb2JhbHMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvbWRjL2ZvdW5kYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL3RpbGVtYXAvaXRlcmFibGV0aWxlbWFwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL21vZGVsZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3BhZ2UtbmF2L3BhZ2UtbmF2LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9nbHVlLWNhcm91c2VsL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2Jhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL2FkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL29wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL3RpbGVtYXAvdGlsZW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvdGlsZW1hcC90aWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9tZGMvY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2hlYWRlci9uYXYvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS91dGlsLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvbW9kYWwvbW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvdmlkZW8taWZyYW1lL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL3ZpZGVvLWlmcmFtZS95dC1wbGF5ZXIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9jYXJvdXNlbC90aWxlbWFwL3RpbGVpdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL2NyZWF0b3JzLWJhbm5lci9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9hdXRvLWluaXQvYXV0by1pbml0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvcHViLXN1Yi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wcm92aWRlcnMvYXV0aC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvYWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWdlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2Jsb2cvYmxvZy5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2hlcm8vc2xpZGVzaG93LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvdHdpdHRlci1mZWVkL3R3aXR0ZXItZmVlZC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3l0LWNoYW5uZWwtc3BvdGxpZ2h0L3l0LWNoYW5uZWwtc3BvdGxpZ2h0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2Jhc2UvbWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vbW9kZWxldmVudGFkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL25hdmlnYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL2Z4L2Vhc2luZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvaW1hZ2UvYWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wYWdlbGlzdC9vcHRpb25zLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL3BhZ2VsaXN0L2FkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL2V2ZW50cy9rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvYmVuZWZpdHMvYnJvbnplL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhZ2VzL2JlbmVmaXRzL2dyYXBoaXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhZ2VzL2JlbmVmaXRzL29wYWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvYmVuZWZpdHMvc2lsdmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhZ2VzL2JlbmVmaXRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhZ2VzL2F3YXJkcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jcmVhdG9ycy1iYW5uZXIvYmFubmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2FjY29yZGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24vY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24tZHJhd2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvYXV0by1zY3JvbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy90aW1lci90aW1lci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvcHJvdmlkZXJzL2Vhc2luZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9nbG9iYWwvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvZGV0ZWN0L2RldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9iYXNlL3BsYWluLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvYnJlYWtwb2ludC1tb25pdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvbG9jYWwtc3RvcmUvbG9jYWwtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9yYWYvcmFmLmpzIiwid2VicGFjazovLy8uL3Byb3ZpZGVycy95dC1kYXRhLmpzIiwid2VicGFjazovLy8uL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9mb3VuZGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RpYWxvZy9mb3VuZGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RpYWxvZy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvdmlkZW8taWZyYW1lL2ZvdW5kYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvdmlkZW8taWZyYW1lL3l0LXBsYXllci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy92aWRlby1pZnJhbWUveXQtcGxheWVyL2ZvdW5kYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvYmFzZS9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvZ2x1ZS1jYXJvdXNlbC9mb3VuZGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2dsdWUtY2Fyb3VzZWwvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9jYXJvdXNlbC9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvZm91bmRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvZG9tL2ZvY3VzX3V0aWwvZm9jdXMtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvc2hpbS9lbGVtZW50bWF0Y2hlcy9lbGVtZW50bWF0Y2hlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvdGlsZW1hcC9jb250YWluZWR0aWxlaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL3RpbGVtYXAvaW5kZXhpdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvdGlsZW1hcC92aXNpYmlsaXR5aXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL2Z4L3R3ZWVuLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9jYXJvdXNlbC9zd2lwZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvZGVib3VuY2UvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2ltYWdlL2ZvdW5kYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL2VsZW1lbnRzdG9nZ2xlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvdG9nZ2xlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvZXZlbnRzL2V2ZW50dGFyZ2V0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi9tcS9yZXNwb25zaXZlbW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9uZXh0L2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9uZXh0L2FkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vbmV4dC9mb3VuZGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL3BhZ2VsaXN0L2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wYWdlbGlzdC9mb3VuZGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL3BhZ2VsaXN0L2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9rZXl1dGlsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi9zaGltL2VsZW1lbnQvY2xvc2VzdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wcmV2aW91cy9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vcHJldmlvdXMvYWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wcmV2aW91cy9mb3VuZGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2FjY29yZGlvbi9mb3VuZGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24tZHJhd2VyL2ZvdW5kYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvYWNjb3JkaW9uL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvYXV0by1zY3JvbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvYXV0by1zY3JvbGwvZm91bmRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9oZWFkZXIvbmF2L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2hlYWRlci9uYXYvZm91bmRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9oZWFkZXIvbW9iaWxlLW5hdi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9oZWFkZXIvbW9iaWxlLW5hdi9mb3VuZGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvZGV0ZWN0L3Rlc3RzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2Jhc2UvcHVic3ViLXNoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9mb290ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9icmVha3BvaW50LW1vbml0b3IvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL3l0LXBsYXllci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy95dC1wbGF5ZXIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9hMTF5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvYTExeS9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9hbmFseXRpY3MvYW5hbHl0aWNzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvZWxlbWVudC1vYnNlcnZlci9lbGVtZW50LW9ic2VydmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvZWxlbWVudC1vYnNlcnZlci9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy90ZW1wbGF0ZS90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvcHJvdmlkZXJzL3VybC1wYXJzZXIvdXJsLXBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvcHJvdmlkZXJzL3BvbHlmaWxscy9wb2x5ZmlsbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9yZXF1ZXN0L3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9yZXF1ZXN0L2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvcHJvdmlkZXJzL3NjYWxlL3NjYWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvc2Nyb2xsL3Njcm9sbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvcHJvdmlkZXJzL3l0LWFwaS95dC1hcGkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy95dC1hcGkvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMveXQtaWZyYW1lLWFwaS1pbml0L3l0LWlmcmFtZS1hcGktaW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9rYXJtYS5jb25mLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYWNjb3VudC9hY2NvdW50LmpzIiwid2VicGFjazovLy8uL3BhZ2VzL25leHR1cC9lbGlnaWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9wYWdlcy9uZXh0dXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvbmV4dHVwL3JlZ2lzdHJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGVja2JveC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGVja2JveC9hZGFwdGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zvcm0tZmllbGQvZm91bmRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2FkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNjcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGEyYWYxNTAwM2VkNjY2NmEwZmM4IiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50JztcblxuZXhwb3J0IHtNRENGb3VuZGF0aW9uLCBNRENDb21wb25lbnR9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG5pbXBvcnQge09wdGlvbnN9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7TW9kZWxFdmVudEFkYXB0ZXJ9IGZyb20gJy4vbW9kZWxldmVudGFkYXB0ZXInO1xuXG4vKipcbiAqIFRoZSBkYXRhIG1vZGVsIHVzZWQgZm9yIFBhZ2luYXRpb24gY29tcG9uZW50cy5cbiAqIFRoZSBvcHRpb25hbCBwcm9wZXJ0aWVzIGFyZSBAZXhwb3J0ZWQgb25seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoXG4gKiB0aGUgbGVnYWN5IEFuZ3VsYXJKUyBwYWdpbmF0aW9uIGRpcmVjdGl2ZXMgYW5kIGFueSBhcHBzIHVzaW5nIHRoZW0sIHRoYXQgbWF5XG4gKiBmb3IgZXhhbXBsZSBhY2Nlc3MgbW9kZWwgcHJvcGVydGllcyBkaXJlY3RseSBmcm9tIGFuIEFuZ3VsYXJKUyB0ZW1wbGF0ZSxcbiAqIGluc3RlYWQgb2Ygd3JhcHBpbmcgdGhlbSBpbiBhY2Nlc3NvcnMgZGVmaW5lZCBpbiB0aGUgY29udHJvbGxlci4gQWxzbyBuZWVkZWRcbiAqIGZvciBwYWdpbmF0aW9uLXN0YXRlIHRoYXQgbG9va3MgdXAgbW9kZWwgcHJvcGVydGllcyBieSB1bm9iZnVzY2F0ZWQgbmFtZS5cbiAqIEB1bnJlc3RyaWN0ZWRcbiAqL1xuY2xhc3MgUGFnaW5hdGlvbk1vZGVsIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUb3RhbCBudW1iZXIgb2YgcGFnZXMuXG4gICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRvdGFsUGFnZXNfID0gb3B0aW9uc1sndG90YWxQYWdlcyddICE9IHVuZGVmaW5lZCA/XG4gICAgICAgIG9wdGlvbnNbJ3RvdGFsUGFnZXMnXSA6IFBhZ2luYXRpb25Nb2RlbC5kZWZhdWx0cy50b3RhbFBhZ2VzO1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgbnVtYmVyIG9mIGl0ZW1zLiBBIHBhZ2UgY2FuIGNvbnRhaW4gbXVsdGlwbGUgaXRlbXMgaWZcbiAgICAgKiB7QGNvZGUgaXRlbXNQZXJQYWdlfSBpcyBiaWdnZXIgdGhhbiAxLlxuICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b3RhbEl0ZW1zXyA9IG9wdGlvbnNbJ3RvdGFsSXRlbXMnXSAhPSB1bmRlZmluZWQgP1xuICAgICAgICBvcHRpb25zWyd0b3RhbEl0ZW1zJ10gOiBQYWdpbmF0aW9uTW9kZWwuZGVmYXVsdHMudG90YWxJdGVtcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBwYWdlLiBTdGFydHMgYXQgMS5cbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFBhZ2VfID0gb3B0aW9uc1snY3VycmVudFBhZ2UnXSAhPSB1bmRlZmluZWQgP1xuICAgICAgICBvcHRpb25zWydjdXJyZW50UGFnZSddIDogUGFnaW5hdGlvbk1vZGVsLmRlZmF1bHRzLmN1cnJlbnRQYWdlO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiB0aXRsZXMgYXNzaWduZWQgdG8gZWFjaCBwYWdlLlxuICAgICAqIEBwcml2YXRlIHshQXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpdGxlc18gPSBvcHRpb25zWyd0aXRsZXMnXSAhPSB1bmRlZmluZWQgP1xuICAgICAgICBvcHRpb25zWyd0aXRsZXMnXSA6IFBhZ2luYXRpb25Nb2RlbC5kZWZhdWx0cy50aXRsZXM7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBwYWdpbmF0aW9uIGNhbiBsb29wIGZyb20gdGhlIGxhc3QgdG8gdGhlIGZpcnN0IHBhZ2UuXG4gICAgICogQGV4cG9ydCB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmN5Y2xpY2FsID0gb3B0aW9uc1snY3ljbGljYWwnXSAhPSB1bmRlZmluZWQgP1xuICAgICAgICBvcHRpb25zWydjeWNsaWNhbCddIDogUGFnaW5hdGlvbk1vZGVsLmRlZmF1bHRzLmN5Y2xpY2FsO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGl0ZW1zIHBlciBwYWdlLlxuICAgICAqIEBleHBvcnQge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLml0ZW1zUGVyUGFnZSA9IG9wdGlvbnNbJ2l0ZW1zUGVyUGFnZSddICE9IHVuZGVmaW5lZCA/XG4gICAgICAgIG9wdGlvbnNbJ2l0ZW1zUGVyUGFnZSddIDogUGFnaW5hdGlvbk1vZGVsLmRlZmF1bHRzLml0ZW1zUGVyUGFnZTtcblxuICAgIGlmICh0aGlzLnRvdGFsUGFnZXNfID09IDApIHtcbiAgICAgIHRoaXMudG90YWxQYWdlc18gPSB0aGlzLmNvdW50VG90YWxQYWdlc18oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b3RhbFBhZ2VzXyA+IDAgJiYgdGhpcy50b3RhbEl0ZW1zXyA9PSAwKSB7XG4gICAgICB0aGlzLnRvdGFsSXRlbXNfID0gdGhpcy50b3RhbFBhZ2VzXztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBidXR0b25zIHRvIGRpc3BsYXkgaW4gdGhlIHBhZ2UgbGlzdCBkaXJlY3RpdmUuXG4gICAgICogQGV4cG9ydCB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4TGVuZ3RoID0gb3B0aW9uc1snbWF4TGVuZ3RoJ10gIT0gdW5kZWZpbmVkID9cbiAgICAgICAgb3B0aW9uc1snbWF4TGVuZ3RoJ10gOiBQYWdpbmF0aW9uTW9kZWwuZGVmYXVsdHMubWF4TGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgICogVGltZSBpbiBtaWxsaXNlY29uZHMgdW50aWwgdHJhbnNpdGlvbmluZyB0byBuZXh0IHBhZ2UuXG4gICAgICogQGV4cG9ydCB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGltZXIgPSBvcHRpb25zWyd0aW1lciddICE9IHVuZGVmaW5lZCA/XG4gICAgICAgIG9wdGlvbnNbJ3RpbWVyJ10gOiBQYWdpbmF0aW9uTW9kZWwuZGVmYXVsdHMudGltZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaWQgb2YgdGhlIGN1cnJlbnQgYWN0aXZlIGVsZW1lbnQuXG4gICAgICogQGV4cG9ydCB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlRWwgPSBvcHRpb25zWydhY3RpdmVFbCddICE9IHVuZGVmaW5lZCA/XG4gICAgICAgIG9wdGlvbnNbJ2FjdGl2ZUVsJ10gOiBQYWdpbmF0aW9uTW9kZWwuZGVmYXVsdHMuYWN0aXZlRWw7XG5cbiAgICAvKipcbiAgICAgKiBLZXkgdmFsdWUgcGFpcnMgb2YgcGFnZSBpZCB0byBlbGVtZW50IGlkcy4gVGhpcyBpcyBuZWVkZWQgZm9yIGdlbmVyYXRpbmdcbiAgICAgKiBhcmlhIHJvbGVzIG5lY2Vzc2FyeSB0byB0aWUgdG9nZXRoZXIgdGFiIGJ1dHRvbnMgYW5kIHRhYiBwYW5lbHMuXG4gICAgICogSW5kZXggYmVnaW5zIHdpdGggMS5cbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudElkcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB0aGUgbW9kZWwgZGVsZWdhdGVzIHRvIHRvIGVtaXQgYW5kIGxpc3RlbiB0byBldmVudHMuIEluIGFcbiAgICAgKiB0eXBpY2FsIE1EQyBtYW5uZXIsIGVhY2ggcGxhdGZvcm0gd2lsbCBpbXBsZW1lbnQgdGhlc2UgbWV0aG9kcyBieVxuICAgICAqIGxldmVyYWdpbmcgdGhlaXIgb3duIGZyYW1ld29yay1zcGVjaWZpYyB3YXkuXG4gICAgICogQHByaXZhdGUge01vZGVsRXZlbnRBZGFwdGVyfVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRBZGFwdGVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB0aW1lciBpcyBjdXJyZW50bHkgcnVubmluZy4gQSBwYXVzZWQgdGltZXIgaXMgY29uc2lkZXJlZCBhc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc1RpbWVyUnVubmluZ18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIHs/bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGltZXJJbnRlcnZhbElkXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB0aW1lciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNUaW1lclBhdXNlZF8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIHtAY29kZSB0aW1lcn0gdmFsdWUgcHJlc2VydmVkIHdoaWxlIHRoZSB0aW1lciBpcyBwYXVzZWQgYW5kIGl0c1xuICAgICAqIHZhbHVlIGlzIHplcm8uXG4gICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBhdXNlZFRpbWVyRHVyYXRpb25fID0gMDtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBvdGhlciBwYWdpbmF0aW9uIGNvbXBvbmVudHMgY2FuIG92ZXJyaWRlIGlmIHRoZXkgd2FudCB0b1xuICAgICAqIGltcGxlbWVudCBob3cgdGhlIG1haW4gY29udGVudCBlbGVtZW50IHNob3VsZCBnZXQga2V5Ym9hcmQgZm9jdXMgZnJvbVxuICAgICAqIG90aGVyIGNvbXBvbmVudHMgbGlrZSB7QGNvZGUgcGFnaW5hdGlvbi1wYWdlLWxpc3R9IG9yXG4gICAgICoge0Bjb2RlIHBhZ2luYXRpb24tdGVsZXBvcnR9LlxuICAgICAqIEBwcml2YXRlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmZvY3VzTWFpbkVsZW1lbnRfID0gbnVsbDtcblxuICAgIHRoaXMuc3RhcnRUaW1lcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgbW9kZWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7IU9wdGlvbnN9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50UGFnZTogMSxcbiAgICAgIHRvdGFsSXRlbXM6IDAsXG4gICAgICBpdGVtc1BlclBhZ2U6IDEsXG4gICAgICB0b3RhbFBhZ2VzOiAwLFxuICAgICAgbWF4TGVuZ3RoOiAwLFxuICAgICAgdGltZXI6IDAsXG4gICAgICBjeWNsaWNhbDogZmFsc2UsXG4gICAgICB0aXRsZXM6IFtdLFxuICAgICAgYWN0aXZlRWw6ICcnLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgc2V0IGN1cnJlbnRQYWdlKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMSkgcmV0dXJuO1xuICAgIC8vIElmIGEgcGFnZSBudW1iZXIgbGltaXQgaXMgZGVmaW5lZCBidXQgdGhlIHNwZWNpZmllZCBpbmRleCB2YWx1ZSBleGNlZWRzXG4gICAgLy8gaXQsIHdlIGRvbid0IGFzc2lnbiBpdFxuICAgIGlmICh0aGlzLnRvdGFsUGFnZXMgPiAwICYmIGluZGV4ID4gdGhpcy50b3RhbFBhZ2VzKSByZXR1cm47XG4gICAgdGhpcy5jdXJyZW50UGFnZV8gPSBpbmRleDtcbiAgICB0aGlzLmVtaXRfKHN0cmluZ3MuQ1VSUkVOVF9QQUdFX0VWRU5UKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgdG90YWxJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbEl0ZW1zXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgc2V0IHRvdGFsSXRlbXMoY291bnQpIHtcbiAgICB0aGlzLnRvdGFsSXRlbXNfID0gY291bnQ7XG4gICAgdGhpcy50b3RhbFBhZ2VzID0gdGhpcy5jb3VudFRvdGFsUGFnZXNfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRvdGFsUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxQYWdlc187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gICAqIEBleHBvcnRcbiAgICovXG4gIHNldCB0b3RhbFBhZ2VzKGNvdW50KSB7XG4gICAgdGhpcy50b3RhbFBhZ2VzXyA9IGNvdW50O1xuICAgIHRoaXMuZW1pdF8oc3RyaW5ncy5UT1RBTF9QQUdFU19FVkVOVCk7XG4gIH1cblxuICAvKipcbiAgICogUGFnaW5hdGVzIHRvIHRoZSBwcmV2aW91cyBwYWdlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1cGRhdGVNb2RlbCBXaGV0aGVyIHRoZSBtb2RlbCBzaG91bGQgYmUgdXBkYXRlZC4gSWYgbm90LFxuICAgKiAgICAgb25seSB0aGUgcGFnaW5hdGlvbiBldmVudCBpcyBmaXJlZCwgYW5kIGl0cyB0aGUgbGlzdGVuZXIncyBqb2IgdG9cbiAgICogICAgIHVwZGF0ZSB0aGUgbW9kZWwgb3Igbm90XG4gICAqIEBleHBvcnRcbiAgICovXG4gIHByZXZpb3VzKHVwZGF0ZU1vZGVsID0gdHJ1ZSkge1xuICAgIGlmICh1cGRhdGVNb2RlbCkge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHRoaXMuZ2V0UHJldmlvdXNQYWdlXygpO1xuICAgIH07XG4gICAgdGhpcy5lbWl0XyhzdHJpbmdzLlBSRVZJT1VTX0VWRU5UKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYWdpbmF0ZXMgdG8gdGhlIG5leHQgcGFnZS5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdXBkYXRlTW9kZWwgV2hldGhlciB0aGUgbW9kZWwgc2hvdWxkIGJlIHVwZGF0ZWQuIElmIG5vdCxcbiAgICogICAgIG9ubHkgdGhlIHBhZ2luYXRpb24gZXZlbnQgaXMgZmlyZWQsIGFuZCBpdHMgdGhlIGxpc3RlbmVyJ3Mgam9iIHRvXG4gICAqICAgICB1cGRhdGUgdGhlIG1vZGVsIG9yIG5vdFxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBuZXh0KHVwZGF0ZU1vZGVsID0gdHJ1ZSkge1xuICAgIGlmICh1cGRhdGVNb2RlbCkge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHRoaXMuZ2V0TmV4dFBhZ2VfKCk7XG4gICAgfTtcbiAgICB0aGlzLmVtaXRfKHN0cmluZ3MuTkVYVF9FVkVOVCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBmb2N1cyBvbiB0aGUgbWFpbiBjb250ZW50IGVsZW1lbnQuXG4gICAqL1xuICBmb2N1c01haW5FbGVtZW50KCkge1xuICAgIHRoaXMuZm9jdXNNYWluRWxlbWVudF8gJiYgdGhpcy5mb2N1c01haW5FbGVtZW50XygpO1xuICB9XG5cbiAgLyoqXG4gICAqIExldHMgYSBwYWdpbmF0aW9uIGNvbXBvbmVudCB0ZWxsIHRoZSBtb2RlbCBpdCB3YW50cyB0byBtb3ZlIGtleWJvYXJkIGZvY3VzXG4gICAqIG9uIG9uZSBvZiBpdHMgRE9NIGVsZW1lbnQgd2hlbiBhbm90aGVyIHBhZ2luYXRpb24gY29tcG9uZW50IHJlbGlucXVpc2hlc1xuICAgKiBmb2N1cywgZm9yIGV4YW1wbGUge0Bjb2RlIHBhZ2luYXRpb24tcGFnZS1saXN0fSBvclxuICAgKiB7QGNvZGUgcGFnaW5hdGlvbi10ZWxlcG9ydH0uXG4gICAqIFR5cGljYWxseSB0aGUgaGFuZGxlciB3aWxsOlxuICAgKiAxLiBwaWNrIHdoaWNoIERPTSBlbGVtZW50IHdpbGwgcmVjZWl2ZSBmb2N1cyxcbiAgICogMi4gZGVsZWdhdGUgdG8gdGhlIGFkYXB0ZXIgaG93IHRvIHNldCBmb2N1cyBvbiB0aGlzIGVsZW1lbnQuXG4gICAqIEZvciBhIGdpdmVuIHBhZ2luYXRpb24gbW9kZWwsIG9ubHkgb25lIHBhZ2luYXRpb24gY29tcG9uZW50IGNhbiBzZXQgdGhpc1xuICAgKiBoYW5kbGVyIGFuZCBkZWNsYXJlIGl0c2VsZiBhcyBhYmxlIHRvIHJlY2VpdmUga2V5Ym9hcmQgZm9jdXMuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBzZXRGb2N1c01haW5FbGVtZW50SGFuZGxlcihoYW5kbGVyKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNNYWluRWxlbWVudF8pIHJldHVybjtcbiAgICB0aGlzLmZvY3VzTWFpbkVsZW1lbnRfID0gaGFuZGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgaGFuZGxlciB0aGF0IHNldCB0aGUgZm9jdXMgdG8gdGhlIG1haW4gY29udGVudCBlbGVtZW50LlxuICAgKiBBIGNvbXBvbmVudCBjYWxsaW5nIHtAY29kZSBzZXRGb2N1c01haW5FbGVtZW50SGFuZGxlcn0gc2hvdWxkIGFsd2F5c1xuICAgKiByZWxlYXNlIHRoaXMgaGFuZGxlciB3aGVuIGl0J3MgZGlzcG9zZWQgdG8gZW5zdXJlIGl0J3MgcHJvcGVybHkgZ2FyYmFnZVxuICAgKiBjb2xsZWN0ZWQuXG4gICAqL1xuICBjbGVhckZvY3VzTWFpbkVsZW1lbnRIYW5kbGVyKCkge1xuICAgIHRoaXMuZm9jdXNNYWluRWxlbWVudF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgcGFnZSBpcyB0aGUgZmlyc3Qgb25lLiBBbHdheXMgZmFsc2UgZm9yIGN5Y2xpY2FsXG4gICAqIHBhZ2luYXRpb25zLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNGaXJzdCgpIHtcbiAgICByZXR1cm4gIXRoaXMuY3ljbGljYWwgJiYgKHRoaXMuY3VycmVudFBhZ2VfID09IDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgcGFnZSBpcyB0aGUgbGFzdCBvbmUuIEFsd2F5cyBmYWxzZSBmb3IgY3ljbGljYWxcbiAgICogcGFnaW5hdGlvbnMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0xhc3QoKSB7XG4gICAgcmV0dXJuICF0aGlzLmN5Y2xpY2FsICYmICh0aGlzLmN1cnJlbnRQYWdlXyA9PSB0aGlzLnRvdGFsUGFnZXNfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSB0aXRsZSBmb3IgYSBwYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICovXG4gIHJlZ2lzdGVyUGFnZVRpdGxlKHRpdGxlKSB7XG4gICAgdGhpcy50aXRsZXNfLnB1c2godGl0bGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBzZXZlcmFsIHRpdGxlcyBmb3IgcGFnZXMuXG4gICAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IHRpdGxlc1xuICAgKi9cbiAgcmVnaXN0ZXJQYWdlVGl0bGVzKHRpdGxlcykge1xuICAgIHRoaXMudGl0bGVzXy5wdXNoKC4uLnRpdGxlcyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGl0bGUgb2YgdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAqL1xuICBnZXRQcmV2aW91c1BhZ2VUaXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50aXRsZXNfW3RoaXMuZ2V0UHJldmlvdXNQYWdlXygpIC0gMV07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGl0bGUgb2YgdGhlIG5leHQgcGFnZS5cbiAgICovXG4gIGdldE5leHRQYWdlVGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGVzX1t0aGlzLmdldE5leHRQYWdlXygpIC0gMV07XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYWRhcHRlciB0aGF0IGNvbnRhaW5zIG1ldGhvZHMgdXNlZCB0byBkZWxlZ2F0ZSBldmVudCBicm9hZGNhc3RpbmdcbiAgICogYW5kIGxpc3RlbmluZy5cbiAgICogQHBhcmFtIHshTW9kZWxFdmVudEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIHNldEV2ZW50QWRhcHRlcihhZGFwdGVyKSB7XG4gICAgdGhpcy5ldmVudEFkYXB0ZXJfID0gYWRhcHRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIGEgcGFnaW5hdGlvbiBldmVudCwgYW5kIGV4ZWN1dGVzIGEgaGFuZGxlciBmdW5jdGlvbiB3aGVuIGl0XG4gICAqIGZpcmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICovXG4gIGxpc3Rlbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuZXZlbnRBZGFwdGVyXyAmJiB0aGlzLmV2ZW50QWRhcHRlcl8ubGlzdGVuKHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBsaXN0ZW5pbmcgdG8gYW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lclxuICAgKi9cbiAgdW5saXN0ZW4odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmV2ZW50QWRhcHRlcl8gJiYgdGhpcy5ldmVudEFkYXB0ZXJfLnVubGlzdGVuKHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHRpbWVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1cGRhdGVNb2RlbCBXaGV0aGVyIHRvIHVwZGF0ZSB0aGUgbW9kZWwsIG9yIG9ubHkgZmlyZVxuICAgKiAgICAgcGFnaW5hdGlvbiBldmVudHMuXG4gICAqL1xuICBzdGFydFRpbWVyKHVwZGF0ZU1vZGVsID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy50aW1lciB8fCB0aGlzLmlzVGltZXJSdW5uaW5nXykgcmV0dXJuO1xuICAgIHRoaXMuaXNUaW1lclJ1bm5pbmdfID0gdHJ1ZTtcbiAgICB0aGlzLnRpbWVySW50ZXJ2YWxJZF8gPVxuICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm5leHQodXBkYXRlTW9kZWwpLCB0aGlzLnRpbWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgdGltZXIuXG4gICAqL1xuICBzdG9wVGltZXIoKSB7XG4gICAgdGhpcy5pc1RpbWVyUnVubmluZ18gPSBmYWxzZTtcbiAgICBjbGVhckludGVydmFsKHRoaXMudGltZXJJbnRlcnZhbElkXyk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2VzIG9yIHJlc3VtZXMgdGhlIHRpbWVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwYXVzZSBXaGV0aGVyIHRvIHBhdXNlIG9yIHJlc3VtZSB0aGUgdGltZXIuXG4gICAqL1xuICBwYXVzZVRpbWVyKHBhdXNlID0gdHJ1ZSkge1xuICAgIGlmIChwYXVzZSAmJiAhdGhpcy5pc1RpbWVyUGF1c2VkXykge1xuICAgICAgdGhpcy5pc1RpbWVyUGF1c2VkXyA9IHRydWU7XG4gICAgICB0aGlzLnBhdXNlZFRpbWVyRHVyYXRpb25fID0gdGhpcy50aW1lcjtcbiAgICAgIHRoaXMudGltZXIgPSAwO1xuICAgICAgdGhpcy5zdG9wVGltZXIoKTtcblxuICAgIH0gZWxzZSBpZiAoIXBhdXNlICYmIHRoaXMuaXNUaW1lclBhdXNlZF8pIHtcbiAgICAgIHRoaXMuaXNUaW1lclBhdXNlZF8gPSBmYWxzZTtcbiAgICAgIHRoaXMudGltZXIgPSB0aGlzLnBhdXNlZFRpbWVyRHVyYXRpb25fO1xuICAgICAgdGhpcy5zdGFydFRpbWVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBjdXJyZW50IHBhZ2UgaGFzIGEgXCJwcmV2aW91c1wiIHBhZ2UuIElmIHtAY29kZSBjeWNsaWNhbH0gaXNcbiAgICoge0Bjb2RlIHRydWV9IHRoaXMgbWV0aG9kIHdpbGwgYWx3YXlzIHJldHVybiB7QGNvZGUgdHJ1ZX0uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNQcmV2aW91cygpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNGaXJzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBjdXJyZW50IHBhZ2UgaGFzIGEgXCJuZXh0XCIgcGFnZS4gSWYge0Bjb2RlIGN5Y2xpY2FsfSBpcyB7QGNvZGUgdHJ1ZX1cbiAgICogdGhpcyBtZXRob2Qgd2lsbCBhbHdheXMgcmV0dXJuIHtAY29kZSB0cnVlfS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc05leHQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzTGFzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHByZXZpb3VzIHBhZ2UgaW5kZXguXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQcmV2aW91c1BhZ2VfKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlXyA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYWdlXyAtIDE7XG4gICAgfVxuICAgIGlmICh0aGlzLmN5Y2xpY2FsKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3RhbFBhZ2VzXztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFBhZ2VfIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZXh0IHBhZ2UgaW5kZXguXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXROZXh0UGFnZV8oKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2VfIDwgdGhpcy50b3RhbFBhZ2VzXykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBhZ2VfICsgMTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3ljbGljYWwpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UGFnZV8gKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgcGFnaW5hdGlvbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRfKGV2dFR5cGUpIHtcbiAgICB0aGlzLmV2ZW50QWRhcHRlcl8gJiYgdGhpcy5ldmVudEFkYXB0ZXJfLmVtaXQoZXZ0VHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQ291bnRzIGhvdyBtYW55IHBhZ2VzIGFyZSBuZWVkZWQgdG8gYWNjb21vZGF0ZSB0aGUgbnVtYmVyIG9mIGl0ZW1zIGFuZFxuICAgKiB0aGUgbnVtYmVyIG9mIGl0ZW1zIHBlciBwYWdlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY291bnRUb3RhbFBhZ2VzXygpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMudG90YWxJdGVtc18gLyB0aGlzLml0ZW1zUGVyUGFnZSk7XG4gIH1cblxufVxuXG5leHBvcnQge1BhZ2luYXRpb25Nb2RlbH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL21vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogUnVucyBhIGNhbGxiYWNrIHRoZSBuZXh0IHRpbWUgYSBwYWdlIHBhaW50IGlzIHJlcXVlc3RlZC5cbiAqIE5vdGU6IGFueSByQUZzIHF1ZXVlZCBpbiBhIHJBRiB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBuZXh0IGZyYW1lLlxuICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5OZXh0UGFpbnQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gY2FsbGJhY2soKSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHZhbHVlIChudW1iZXIgb3IgYm9vbGVhbikgbWFzcXVlcmFkaW5nIGFzIGEgc3RyaW5nIGJhY2sgaW50b1xuICogaXRzIGludGVuZGVkIHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBsZXQgY29lcmNlZFZhbHVlID0gdmFsdWU7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb2VyY2VkVmFsdWUgPVxuICAgICAgWydUcnVlJywgJ0ZhbHNlJ10uaW5jbHVkZXModmFsdWUpID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IHZhbHVlO1xuXG4gIHRyeSB7XG4gICAgY29lcmNlZFZhbHVlID0gSlNPTi5wYXJzZShjb2VyY2VkVmFsdWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTm90IGEgQm9vbGVhbiBvciBOdW1iZXJcbiAgfVxuICByZXR1cm4gY29lcmNlZFZhbHVlO1xufTtcblxuLyoqXG4gKiBDbGFtcHMgYSB2YWx1ZSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHshRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCkge1xuICByZXR1cm4gKHZhbCkgPT4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xufTtcblxuLyoqXG4gKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSBlbGVtZW50IG9mXG4gKiB0aGUgZ2l2ZW4gdHlwZSwgd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gKiBAcGFyYW0geyFPYmplY3R9IGV2dERhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZEJ1YmJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW1pdChlbGVtZW50LCBldnRUeXBlLCBldnREYXRhLCBzaG91bGRCdWJibGUgPSBmYWxzZSkge1xuICBsZXQgZXZ0O1xuICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpO1xuICB9XG5cbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKiBAcGFyYW0geyFFbGVtZW50fCFIVE1MRG9jdW1lbnR9IGVsZW1lbnQgUGFyZW50IGVsZW1lbnQgb3IgZG9jdW1lbnQgdG8gYWRkXG4gKiAgICAgdGhlIGV2ZW50IGxpc3RlbmVyIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFF1ZXJ5IHNlbGVjdG9yIGZvciBjaGlsZHJlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yIChmaXJzdCBhcmd1bWVudCBvZlxuICogICAgIGFkZEV2ZW50TGlzdGVuZXIpLlxuICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdG8gY2FsbC4gUmVjZWl2ZXMgdGhlIGV2ZW50IGFzIGFuXG4gKiAgICAgYXJndW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxlZ2F0ZShlbGVtZW50LCBzZWxlY3RvciwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIChlKSA9PiB7XG4gICAgZGVsZWdhdGVIZWxwZXJfKGUsIGVsZW1lbnQsIHNlbGVjdG9yLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICB9LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKiBAcGFyYW0geyFFbGVtZW50fCFIVE1MRG9jdW1lbnR9IGVsZW1lbnQgUGFyZW50IGVsZW1lbnQgb3IgZG9jdW1lbnQgdG8gYWRkXG4gKiAgICAgdGhlIGV2ZW50IGxpc3RlbmVyIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFF1ZXJ5IHNlbGVjdG9yIGZvciBjaGlsZHJlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yIChmaXJzdCBhcmd1bWVudCBvZlxuICogICAgIGFkZEV2ZW50TGlzdGVuZXIpLlxuICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdG8gY2FsbC4gUmVjZWl2ZXMgdGhlIGV2ZW50IGFzIGFuXG4gKiAgICAgYXJndW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmRlbGVnYXRlKGVsZW1lbnQsIHNlbGVjdG9yLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICBkZWxlZ2F0ZUhlbHBlcl8oZSwgZWxlbWVudCwgc2VsZWN0b3IsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gIH0sIGZhbHNlKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IG1hdGNoZXMgdGhlIGdpdmVuIHF1ZXJ5IHNlbGVjdG9yLlxuICogRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyBvciBvbGRlciBuYXRpdmVcbiAqIDxwcmVmaXg+TWF0Y2hlc1NlbGVjdG9yLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIGlmIChFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4gICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG4gIH1cbn07XG5cbi8qKlxuICogV2FpdHMgdGhlIGdpdmVuIGFtb3VudCBvZiB0aW1lIGJlZm9yZSBhcHBseWluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24uXG4gKiBAcGFyYW0geyFGdW5jdGlvbjw/Pn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYXBwbHkgYWZ0ZXIgdGhlIGdpdmVuIHRpbWUgaGFzXG4gKiAgICAgYmVlbiByZWFjaGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlXG4gKiAgICAgYXBwbHlpbmcgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtib29sZWFufSBleGVjQXNhcCBXaGV0aGVyIHRvIGFwcGx5IHRoZSBjYWxsYmFjayBpbW1lZGlhdGVseSBvciBub3QuXG4gKiBAcmV0dXJuIHshRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgdGhyZXNob2xkLCBleGVjQXNhcCwgLi4udGhlQXJncykge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBvYmogPSB0aGlzO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGVBcmdzO1xuICAgIGNvbnN0IGRlbGF5ZWQgPSAoKSA9PiB7XG4gICAgICBpZiAoIWV4ZWNBc2FwKSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfSBlbHNlIGlmIChleGVjQXNhcCkge1xuICAgICAgY2FsbGJhY2suYXBwbHkob2JqLCBhcmdzKTtcbiAgICB9XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoZGVsYXllZCwgdGhyZXNob2xkIHx8IDEwMCk7XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3RcbiAqIG9uY2UgZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIFVzZWZ1bCBmb3Igd2luZG93IHNjcm9sbCBvclxuICogcmVzaXplIGhhbmRsZXJzIHRoYXQgd2FudCB0byBydW4gY2FsbGJhY2tzIHZlcnkgZnJlcXVlbnRseSwgd2hpY2ggY2FuXG4gKiBoYXJtIHBhZ2UgcGVyZm9ybWFuY2UuIFNvdXJjZSBpbnNwaXJhdGlvbiBjb21lcyBmcm9tIHVuZGVyc2NvcmUuXG4gKiBAcGFyYW0geyFGdW5jdGlvbjw/Pn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYXBwbHkgYWZ0ZXIgdGhlIGdpdmVuIHRpbWUgaGFzXG4gKiAgICAgYmVlbiByZWFjaGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlXG4gKiAgICAgYXBwbHlpbmcgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmdcbiAqICAgZWRnZSwge2xlYWRpbmc6IGZhbHNlfS4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIHVzZVxuICogICB7dHJhaWxpbmc6IGZhbHNlfS5cbiAqIEByZXR1cm4geyFGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCB0aHJlc2hvbGQgPSAxMDAsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgdGltZW91dDtcbiAgbGV0IGNvbnRleHQ7XG4gIGxldCBhcmdzO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgcHJldmlvdXMgPSAwO1xuXG4gIGNvbnN0IGxhdGVyID0gKCkgPT4ge1xuICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiArbmV3IERhdGUoKTtcbiAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICByZXN1bHQgPSBjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdGhyb3R0bGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IG5vdyA9ICtuZXcgRGF0ZSgpO1xuICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkge1xuICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbmluZyA9IHRocmVzaG9sZCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gdGhyZXNob2xkKSB7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICByZXN1bHQgPSBjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdGhyb3R0bGVkLmNhbmNlbCA9ICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgcHJldmlvdXMgPSAwO1xuICAgIHRpbWVvdXQgPSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn07XG5cbi8qKlxuICogQXBwbGllcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGluIHZpZXcgb3IgYWJvdmUgdGhlXG4gKiBzY3JvbGxhYmxlIGFyZWEuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNoZWNrIGlmIGl0IGlzIGluIHZpZXcgb3Igbm90LlxuICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdWNudGlvbi5cbiAqIEBwYXJhbSB7IUVsZW1lbnQ9fSBvcHRfcm9vdCBUaGUgc2Nyb2xsYWJsZSBlbGVtZW50LiBJZiBubyBlbGVtZW50LCBpc1xuICogICAgIGdpdmVuLCB0aGUgd2luZG93IGlzIHVzZWQuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF90aHJlc2hvbGQgVGhlIGZyYWN0aW9uIG9mIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIGJlXG4gKiAgICAgdmlzaWJsZSBiZWZvcmUgcmV0dXJuaW5nIHRydWUuIEJ5IGRlZmF1bHQsIHRoZSB3aG9sZSBlbGVtZW50IG11c3QgYmUgaW5cbiAqICAgICB2aWV3LiBFeGFtcGxlczpcbiAqICAgICAgIDEgPT0gdGhlIHdob2xlIGVsZW1lbnRcbiAqICAgICAgIDIgPT0gaGFsZiBvZiB0aGUgZWxlbWVudFxuICogICAgICAgNCA9PSBhIHF1YXJ0ZXIgb2YgdGhlIGVsZW1lbnRcbiAqIEByZXR1cm4geyFGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudEluVmlldyhcbiAgICBlbGVtZW50LCBjYWxsYmFjaywgb3B0X3Jvb3QsIG9wdF90aHJlc2hvbGQsIC4uLnRoZUFyZ3MpIHtcbiAgY29uc3Qgcm9vdCA9IG9wdF9yb290IHx8IHdpbmRvdztcbiAgY29uc3Qgcm9vdEhlaWdodCA9IHJvb3Qub2Zmc2V0SGVpZ2h0IHx8IHJvb3QuaW5uZXJIZWlnaHQ7XG4gIGNvbnN0IHNjcm9sbFBvc3RpdGlvbiA9IHJvb3Quc2Nyb2xsVG9wIHx8IHJvb3QucGFnZVlPZmZzZXQ7XG4gIGNvbnN0IHRocmVzaG9sZCA9IG9wdF90aHJlc2hvbGQgP1xuICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQgLyBvcHRfdGhyZXNob2xkIDogZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3Qgb2JqID0gdGhpcztcbiAgICBjb25zdCBhcmdzID0gdGhlQXJncztcbiAgICBpZiAocm9vdEhlaWdodCArIHNjcm9sbFBvc3RpdGlvbiA+PSBlbGVtZW50Lm9mZnNldFRvcCArIHRocmVzaG9sZCkge1xuICAgICAgY2FsbGJhY2suYXBwbHkob2JqLCBhcmdzKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW5zaWRlIHBhcmVudCBjb250YWluZXIuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHBlcmNlbnRhZ2Ugb2YgaW1hZ2UgdmlzaWJsZSBpbiB2aWV3cG9ydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNDb250YWluZXIoZWxlbWVudCwgYm91bmRzKSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCByYXRpb1Zpc2libGUgPSAoYm91bmRzIC0gY2xpZW50UmVjdC50b3ApIC8gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIHJldHVybiByYXRpb1Zpc2libGUgPD0gMCA/IDAgOiByYXRpb1Zpc2libGUgID49IDEuMCA/IDEuMCA6IHJhdGlvVmlzaWJsZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgZ2l2ZW4gc2NyaXB0IGhhcyBsb2FkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNjcmlwdCBzb3VyY2UgVVJMLlxuICogQHBhcmFtIHtib29sZWFuPX0gYXV0b0FwcGVuZCBJZiBmYWxzZSwgdGhlIGRldmVsb3BlciBjYW4gZGV0ZXJtaW5lIHdoZXJlIHRvXG4gKiAgICAgcGxhY2UgdGhlIHNjcmlwdCBpbiB0aGUgRE9NLlxuICogQHJldHVybiB7IVByb21pc2V9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQXN5bmNTY3JpcHQoc3JjLCBhdXRvQXBwZW5kID0gdHJ1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZpcnN0U2NyaXB0VGFnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICAgIGNvbnN0IHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gICAgdGFnLnNyYyA9IHNyYztcbiAgICB0YWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSh0YWcpO1xuXG4gICAgaWYgKGF1dG9BcHBlbmQpIHtcbiAgICAgIGZpcnN0U2NyaXB0VGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhZywgZmlyc3RTY3JpcHRUYWcpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGNvcnJlY3QgdGFyZ2V0IGVsZW1lbnQgYmFzZWQgb24gdGhlIGVsZW1lbnQgcHJvdmlkZWQuIFVzZWQgd2hlblxuICogdGhlICd3cm9uZycgKGNoaWxkIGVsZW1lbnQpIHJlY2VpdmVzIGEgY2xpY2sgZXZlbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgZnJvbSB0aGUgY2xpY2sgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIGZvciB0aGUgY29ycmVjdCBlbGVtZW50LlxuICogQHJldHVybiB7RWxlbWVudH0gVGhlIGNvcnJlY3QgdGFyZ2V0IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb3JyZWN0VGFyZ2V0RWwoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikgPyBlbGVtZW50IDogZWxlbWVudC5jbG9zZXN0KHNlbGVjdG9yKTtcbn07XG5cbi8qKlxuICogT3BlbnMgbmV3IHdpbmRvdyB3aXRoIGEgZ2l2ZW4gZGltZW5zaW9ucy4gR29vZCBmb3Igc2hvd2luZyBhIGNvbXBvbmVudCBhdFxuICogZGlmZmVyZW50IHZpZXdwb3J0IHNpemVzLlxuICogRXguIFRvIG9wZW4gYSAzMjB4NjQwIHdpbmRvdyBhdCAvZG9jcy86XG4gKiAgICAgPGJ1dHRvbiBwYXRoPVwiL2RvY3MvXCJcbiAqICAgICAgICAgICAgIHNpemU9XCIzMjA6NjQwXCJcbiAqICAgICAgICAgICAgIGNsYXNzPVwianMtb3Blbi1uZXctd2luZG93XCI+XG4gKiAgICAgPC9idXR0b24+XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCBUaGUgZWxlbWVudCBmcm9tIHRoZSBjbGljayBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGNsaWNrIGV2ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3Blbk5ld1dpbmRvdyh0YXJnZXQsIGUpIHtcbiAgY29uc3QgcGF0aCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ3BhdGgnKTtcbiAgY29uc3Qgc2l6ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ3NpemUnKS5zcGxpdCgnOicpO1xuICBjb25zdCB3aWR0aCA9IHNpemVbMF07XG4gIGNvbnN0IGhlaWdodCA9IHNpemVbMV07XG5cbiAgd2luZG93Lm9wZW4ocGF0aCwgJycsXG4gICAgICBgaGVpZ2h0PSR7aGVpZ2h0fSx3aWR0aD0ke3dpZHRofSxsZWZ0PSR7ZS5zY3JlZW5YfSx0b3A9JHtlLnNjcmVlbll9YCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5leHQgdmFsaWQgaW5kZXggb2YgYSBnaXZlbiBhcnJheS4gRWl0aGVyIGluY3JlbWVudHMgdGhlXG4gKiBjdXJyZW50IGluZGV4IG9yIHJlc2V0cyB0byB6ZXJvLlxuICogQHBhcmFtIHshQXJyYXl8Tm9kZUxpc3R9IGxpc3QgVGhlIGxpc3QgdG8gY3ljbGUgdGhyb3VnaC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggdG8gaW5jcmVtZW50IGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV4dCB2YWxpZCBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRJbmRleChsaXN0LCBjdXJyZW50SW5kZXgpIHtcbiBjb25zdCBpbmNyZW1lbnRlZE5leHQgPSArK2N1cnJlbnRJbmRleDtcbiByZXR1cm4gaW5jcmVtZW50ZWROZXh0IDwgbGlzdC5sZW5ndGggPyBpbmNyZW1lbnRlZE5leHQgOiAwO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBjaGlsZCBlbGVtZW50cyBvZiBhIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgZWxlbWVudCB0byBlbXB0eSBvZiBpdHMgY2hpbGRyZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUNvbnRhaW5lcihjb250YWluZXIpIHtcbiB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgdXNlZCBpbiB0aGUgJ3RocmVzaG9sZCcgYXJndW1lbnQgZm9yIGFuXG4gKiAgIEludGVyc2VjdGlvbiBPYnNlcnZlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWRlbGl0eSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cbiAqICAgVGhpcyBjYW4gYmUgdXNlZCB0byB0ZWxsIGFuIGludGVyc2VjdGlvbiBvYnNlcnZlciBob3cgb2Z0ZW4gdG8gcnVuIGFcbiAqICAgY2FsbGJhY2suIEZvciBpbnN0YW5jZSBhIGZpZGVsaXR5IG9mIDEwIHdpbGwgY3JlYXRlIGFuIGFycmF5IHRoYXQgdGVsbHNcbiAqICAgYW4gaW50ZXJzZWN0aW9uIG9ic2VydmVyIHRvIHJ1biB0aGUgY2FsbGJhY2sgZXZlcnkgdGltZSB0aGUgdmlzaWJsZSBhcmVhXG4gKiAgIG9mIHRoZSBlbGVtZW50IGJlaW5nIG9ic2VydmVkIGNoYW5nZXMgYnkgYXQgbGVhc3QgMTAlLiBBIGhpZ2hlciBmaWRlbGl0eVxuICogICB3aWxsIHJ1biB0aGUgY2FsbGJhY2sgbW9yZSBvZnRlbi5cbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBudW1iZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGhyZXNob2xkQXJyYXkoZmlkZWxpdHkgPSAxMDAxKSB7XG4gY29uc3Qgc3RlcCA9IDEgLyBmaWRlbGl0eTtcbiByZXR1cm4gbmV3IEFycmF5KGZpZGVsaXR5KS5maWxsKDApLm1hcCgoemVybywgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gaW5kZXggKiBzdGVwO1xuICB9KTtcbn07XG5cbi8vIFByaXZhdGUgZnVuY3Rpb25zIHRoYXQgYXJlIHVzZWQgYnkgdXRpbHMsIG5vdCBleHBvcnRlZC5cblxuLyoqXG4gKiBMaXN0ZW5zIGZvciBldmVudHMgb24gYSBwYXJlbnQgdGhhdCBhcmUgYnViYmxlZCB1cCBmcm9tIGNoaWxkcmVuIHRoYXQgbWF0Y2hcbiAqIHRoZSBnaXZlbiBxdWVyeSBzZWxlY3Rvci5cbiAqIEBwYXJhbSB7IUV2ZW50fSBlIEV2ZW50IG9iamVjdC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR8IUhUTUxEb2N1bWVudH0gZWxlbWVudCBQYXJlbnQgZWxlbWVudCBvciBkb2N1bWVudCB0byBhZGRcbiAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXIgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgUXVlcnkgc2VsZWN0b3IgZm9yIGNoaWxkcmVuLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50IHRvIGxpc3RlbiBmb3IgKGZpcnN0IGFyZ3VtZW50IG9mXG4gKiAgICAgYWRkRXZlbnRMaXN0ZW5lcikuXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0byBjYWxsLiBSZWNlaXZlcyB0aGUgZXZlbnQgYXMgYW5cbiAqICAgICBhcmd1bWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlbGVnYXRlSGVscGVyXyhlLCBlbGVtZW50LCBzZWxlY3RvciwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIGlmIChtYXRjaGVzKHRhcmdldCwgc2VsZWN0b3IpKSB7XG4gICAgICBoYW5kbGVyKHRhcmdldCwgZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvdXRpbHMvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cblxuLyoqXG4gKiBUaGUgdmlldyBzdGF0dXMgb2YgYSB0aWxlIGluIGEgZGlzcGxheSBtYXAuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBWaXNpYmlsaXR5ID0ge1xuICBISURERU46IDAsXG4gIFBBUlRJQUxMWTogMSxcbiAgVklTSUJMRTogMixcbn07XG5cbmV4cG9ydCB7VmlzaWJpbGl0eX07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9jYXJvdXNlbC90aWxlbWFwL3Zpc2liaWxpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgdXRpbHMgPSB7XG4gIC8qKiBAY29uc3Qge3N0cmluZ30gKi9cbiAgSVNfREVWOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdlbnYnKSA9PT0gJ2RldicsXG5cbiAgLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuICBMQU5HOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyxcblxuICAvKipcbiAgICogTG9jYWxpemVzIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIERhdGUgdG8gYmUgbG9jYWxpemVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0XG4gICAqICAgICBgc2hvcnRgOiBNb250aCBhbmQgeWVhclxuICAgKiAgICAgYG1lZGl1bWA6IE1vbnRoIHllYXIgYW5kIGRheVxuICAgKiAgICAgYGxvbmdgOiBNb250aCwgeWVhciwgZGF5IGFuZCBhYmJyZXZpYXRlZCB3ZWVrZGF5XG4gICAqIEBwYXJhbSB7P3N0cmluZ30gdHogT3B0aW9uYWwgdGltZXpvbmUuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGxvY2FsaXplRGF0ZTogKGRhdGUsIGZvcm1hdD0nc2hvcnQnLCB0ej11bmRlZmluZWQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbW9udGg6ICdsb25nJyxcbiAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICB9O1xuXG4gICAgaWYgKGZvcm1hdCA9PT0gJ21lZGl1bScgfHwgZm9ybWF0ID09PSAnbG9uZycpIG9wdGlvbnMuZGF5ID0gJ251bWVyaWMnO1xuICAgIGlmIChmb3JtYXQgPT09ICdsb25nJykgb3B0aW9ucy53ZWVrZGF5ID0gJ3Nob3J0JztcbiAgICBpZiAodHopIG9wdGlvbnMudGltZVpvbmUgPSB0ejtcblxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKS50b0xvY2FsZURhdGVTdHJpbmcodXRpbHMuTEFORywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvY2FsaXplcyBnaXZlbiBudW1iZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgTlVtYmVyIHRvIGJlIGxvY2FsaXplZC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgbG9jYWxpemVOdW1iZXI6IChudW1iZXIpID0+IHtcbiAgICByZXR1cm4gbnVtYmVyLnRvTG9jYWxlU3RyaW5nKHV0aWxzLkxBTkcpO1xuICB9LFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCB1dGlscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2xvYmFscy91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICovXG5jbGFzcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gb2YgaXRzIHNlbWFudGljIG51bWJlcnMgYXMgY29uc3RhbnRzLiBlLmcuIHtBTklNQVRJT05fREVMQVlfTVM6IDM1MH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIG1heSBjaG9vc2UgdG8gaW1wbGVtZW50IHRoaXMgZ2V0dGVyIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb252ZW5pZW50XG4gICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFBfSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChyZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyB1c2VkIHRocm91Z2hvdXQgdGhlIHBhZ2luYXRpb24gY29tcG9uZW50cy5cbiAqL1xuXG5cblxuLyoqXG4gKiBUT0RPOiBNb3ZlIGJvb2xlYW4gY2xhc3MgZGVmaW5pdGlvbnMgdG8gY29tbW9uIChTSE9XX1BBR0UsIFBBR0VTX1JFQURZKS5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBCVVRUT046ICdnbHVlLW8tcGFnaW5hdGlvbl9fYnV0dG9uJyxcbiAgQlVUVE9OX0NPTlRBSU5FUjogJ2dsdWUtby1wYWdpbmF0aW9uX19idXR0b24tY29udGFpbmVyJyxcbiAgUEFHSU5BVElPTjogJ2dsdWUtby1wYWdpbmF0aW9uJyxcbn07XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIENVUlJFTlRfUEFHRV9FVkVOVDogJ2dsdWVwYWdpbmF0aW9uY3VycmVudHBhZ2UnLFxuICBUT1RBTF9QQUdFU19FVkVOVDogJ2dsdWVwYWdpbmF0aW9udG90YWxwYWdlcycsXG4gIFBSRVZJT1VTX0VWRU5UOiAnZ2x1ZXBhZ2luYXRpb25wcmV2aW91cycsXG4gIE5FWFRfRVZFTlQ6ICdnbHVlcGFnaW5hdGlvbm5leHQnLFxuICAvLyBGT0NVU19FVkVOVCBpcyBkZXByZWNhdGVkLCB1c2Uge0Bjb2RlIFBhZ2luYXRpb25Nb2RlbC5mb2N1c01haW5FbGVtZW50KCl9XG4gIC8vIGluc3RlYWQuXG4gIEZPQ1VTX0VWRU5UOiAnZ2x1ZXBhZ2luYXRpb25mb2N1cycsXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBhcmVudCBjbGFzcyBmb3IgRm91bmRhdGlvbiBjbGFzc2VzIG9mIGNvbXBvbmVudHMgYnVpbHQgd2l0aCB0aGUgTURDLVdlYiBhcmNoaXRlY3R1cmUuXG4gKiBGb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9wYWNrYWdlcy9tZGMtYmFzZS9mb3VuZGF0aW9uLmpzXG4gKiBNREMtV2ViIGFyY2hpdGVjdHVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXJjaGl0ZWN0dXJlLm1kXG4gKiBBdXRob3JpbmcgY29tcG9uZW50czpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqL1xuXG5cblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmNsYXNzIE1EQ0ZvdW5kYXRpb24ge1xuXG4gIC8qKlxuICAgKiBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuXG4gICAqIG9iamVjdCB3aGljaCBleHBvcnRzIGV2ZXJ5IENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhXG4gICAqIHByb3BlcnR5LlxuICAgKiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZz59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW5cbiAgICogb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsIHNlbWFudGljIHN0cmluZ3MgYXMgY29uc3RhbnRzLlxuICAgKiBlLmcuIHtBUklBX1JPTEU6ICd0YWJsaXN0J31cbiAgICogQHJldHVybiB7IU9iamVjdDxzdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuXG4gICAqIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbCBvZiBpdHMgc2VtYW50aWMgbnVtYmVycyBhcyBjb25zdGFudHMuXG4gICAqIGUuZy4ge0FOSU1BVElPTl9ERUxBWV9NUzogMzUwfVxuICAgKiBAcmV0dXJuIHshT2JqZWN0PG51bWJlcj59XG4gICAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VD19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSB7fSkge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshVH0gKi9cbiAgICB0aGlzLmFkYXB0ZXIgPSAvKiogQHR5cGUgeyFUfSAqLyAoYWRhcHRlcik7XG4gIH1cblxuICAvKipcbiAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiByb3V0aW5lc1xuICAgKiAocmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGluaXQoKSB7fVxuXG4gIC8qKlxuICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGRlLWluaXRpYWxpemF0aW9uXG4gICAqIHJvdXRpbmVzIChkZS1yZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZGVzdHJveSgpIHt9XG5cbn1cblxuZXhwb3J0IHtNRENGb3VuZGF0aW9ufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL21kYy9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7VmlzaWJpbGl0eX0gZnJvbSAnLi92aXNpYmlsaXR5JztcblxuLyoqXG4gKiBAcmVjb3JkXG4gKi9cbmZ1bmN0aW9uIEl0ZXJhYmxlVGlsZU1hcCgpIHt9XG5cbi8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuSXRlcmFibGVUaWxlTWFwLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5JdGVyYWJsZVRpbGVNYXAucHJvdG90eXBlLmlzQ3ljbGljYWwgPSBmdW5jdGlvbigpIHt9O1xuXG4vKiogQHJldHVybiB7bnVtYmVyfSAqL1xuSXRlcmFibGVUaWxlTWFwLnByb3RvdHlwZS5nZXRGcmFtZVggPSBmdW5jdGlvbigpIHt9O1xuXG4vKiogQHJldHVybiB7bnVtYmVyfSAqL1xuSXRlcmFibGVUaWxlTWFwLnByb3RvdHlwZS5nZXRUaWxlc0NvdW50ID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbkl0ZXJhYmxlVGlsZU1hcC5wcm90b3R5cGUuZ2V0QWxsVGlsZXNXaWR0aCA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbGVJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbGVYXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcmFtZVhcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9hcHBseUV4cGFuZFxuICogQHJldHVybiB7IVZpc2liaWxpdHl9XG4gKi9cbkl0ZXJhYmxlVGlsZU1hcC5wcm90b3R5cGUuZ2V0VGlsZVZpc2liaWxpdHkgPVxuICAgIGZ1bmN0aW9uKHRpbGVJbmRleCwgdGlsZVgsIG9wdF9mcmFtZVgsIG9wdF9hcHBseUV4cGFuZCkge307XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuSXRlcmFibGVUaWxlTWFwLnByb3RvdHlwZS5mcmFtZVdpZHRoO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbkl0ZXJhYmxlVGlsZU1hcC5wcm90b3R5cGUuZnJhbWVFeHBhbmQ7XG5cbmV4cG9ydCB7SXRlcmFibGVUaWxlTWFwfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL3RpbGVtYXAvaXRlcmFibGV0aWxlbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG5pbXBvcnQge0V2ZW50VGFyZ2V0fSBmcm9tICcuLi8uLi9ldmVudHMvZXZlbnR0YXJnZXQnO1xuaW1wb3J0IHtQYWdpbmF0aW9uTW9kZWx9IGZyb20gJy4vbW9kZWwnO1xuaW1wb3J0IHtNb2RlbEV2ZW50QWRhcHRlcn0gZnJvbSAnLi9tb2RlbGV2ZW50YWRhcHRlcic7XG5cblxuLyoqXG4gKiBQYWdpbmF0aW9uIG1vZGVsIGZhY3RvcnkuIFVzZWQgb25seSBpbiBWYW5pbGxhIEpTIGFwcGxpY2F0aW9ucyBzaW5jZSBpdCBhbHNvXG4gKiBzZXR1cCBkZWxlZ2F0ZSBtZXRob2RzIHRvIGJyb2FkY2FzdCBwYWdpbmF0aW9uIGV2ZW50cy4gT3RoZXIgcGxhdGZvcm1zXG4gKiBzaG91bGQgaW5zdGVhZCBkZWxlZ2F0ZSB0byB0aGVpciBmcmFtZXdvcmstc3BlY2lmaWMgd2F5IG9mIGJyb2FkY2FzdGluZ1xuICogZXZlbnRzLiBTZWUge0Bjb2RlIGdsdWUubmcudWkucGFnaW5hdGlvbi5QYWdpbmF0aW9uQ3RybH0gZm9yXG4gKiB0aGUgQW5ndWxhckpTIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBNb2RlbEZhY3Rvcnkge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9yIGV4aXN0aW5nIHBhZ2luYXRpb24gbW9kZWwgaW5zdGFuY2UgYmFzZWQgb24gYW4gaWRlbnRpZmllci5cbiAgICogRmFsbHMgYmFjayBvbiBhIGRlZmF1bHQgaW5zdGFuY2UgaWYgbm8gaWQgaXMgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaWRcbiAgICogQHJldHVybiB7IVBhZ2luYXRpb25Nb2RlbH1cbiAgICovXG4gIHN0YXRpYyBnZXQoaWQgPSBNb2RlbEZhY3RvcnkuREVGQVVMVF9JTlNUQU5DRV9JRCkge1xuICAgIGxldCBpbnN0YW5jZSA9IE1vZGVsRmFjdG9yeS5pbnN0YW5jZXNfW2lkXTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZSA9IE1vZGVsRmFjdG9yeS5jcmVhdGVJbnN0YW5jZV8oKTtcbiAgICAgIE1vZGVsRmFjdG9yeS5pbnN0YW5jZXNfW2lkXSA9IGluc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBleGlzdGluZyBwYWdpbmF0aW9uIG1vZGVsIGluc3RhbmNlcy5cbiAgICovXG4gIHN0YXRpYyBjbGVhckFsbCgpIHtcbiAgICBNb2RlbEZhY3RvcnkuaW5zdGFuY2VzXyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcGFnaW5hdGlvbiBtb2RlbCBpbnN0YW5jZS5cbiAgICogQHJldHVybiB7IVBhZ2luYXRpb25Nb2RlbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZV8oKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgUGFnaW5hdGlvbk1vZGVsKCk7XG4gICAgY29uc3QgZXZlbnRUYXJnZXQgPSBuZXcgRXZlbnRUYXJnZXQoKTtcblxuICAgIGNvbnN0IC8qKiAhTW9kZWxFdmVudEFkYXB0ZXIgKi8gYWRhcHRlciA9IHtcbiAgICAgIGVtaXQ6IChldnRUeXBlKSA9PiBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGV2dFR5cGUpLFxuICAgICAgbGlzdGVuOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4gZXZlbnRUYXJnZXQubGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpLFxuICAgICAgdW5saXN0ZW46IChldnRUeXBlLCBoYW5kbGVyKSA9PiBldmVudFRhcmdldC51bmxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSxcbiAgICB9O1xuXG4gICAgaW5zdGFuY2Uuc2V0RXZlbnRBZGFwdGVyKGFkYXB0ZXIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG59XG5cbi8qKlxuICogSW50ZXJuYWwgbGlzdCBvZiBhbGwgcmVnaXN0ZXJlZCBwYWdpbmF0aW9uIG1vZGVsIGluc3RhbmNlcy5cbiAqIEBwcml2YXRlIHshT2JqZWN0PCFQYWdpbmF0aW9uTW9kZWw+fVxuICovXG5Nb2RlbEZhY3RvcnkuaW5zdGFuY2VzXyA9IHt9O1xuXG4vKipcbiAqIFBhZ2luYXRpb24gbW9kZWwga2V5IGZvciB0aGUgZGVmYXVsdCBwYWdpbmF0aW9uIG1vZGVsLlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbk1vZGVsRmFjdG9yeS5ERUZBVUxUX0lOU1RBTkNFX0lEID0gJ19fZGVmYXVsdCc7XG5cbmV4cG9ydCB7TW9kZWxGYWN0b3J5fTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vbW9kZWxmYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAcHJpdmF0ZSBAZW51bSB7c3RyaW5nfSovXG5jb25zdCBTZWxlY3RvcnNfID0ge1xuICBBQ1RJVkVfSVRFTTogJy55dC1qcy1hY3RpdmUtcGFnZS1uYXYnLFxuICBIRUFERVI6ICcubGItaGVhZGVyJyxcbiAgSEVBREVSX05BVl9JVEVNUzogJy5sYi1uYXZfX2l0ZW0sIC5sYi1uYXZfX3N1Yml0ZW0sICcrXG4gICAgICAgICAgICAgICAgICAgICcubGItbW9iaWxlLW5hdl9faXRlbSwgLmxiLW1vYmlsZS1uYXZfX3N1Yml0ZW0nLFxufTtcblxuLyoqIEBwcml2YXRlIEBlbnVtIHtzdHJpbmd9Ki9cbmV4cG9ydCBjb25zdCBDbGFzc2VzXyA9IHtcbiAgSEFTX0FDVElWRV9QQUdFX05BVjogJ2hhcy1hY3RpdmUtcGFnZS1uYXYnLFxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGNvcnJlY3QgYWN0aXZlIHN0YXRlcyBvbiBhbGwgbmF2IGl0ZW1zIHdoZW4gYSB1c2VyIGlzIG9uIGEgcGFnZVxuICogdGhhdCdzIG5vdCBwYXJ0IG9mIHRoZSBtYWluIGhlYWRlciBuYXYuXG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZU5hdiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBhY3RpdmUgcGFnZSBuYXYsIGlmIG9uZSBleGlzdHMuXG4gICAgICogQHByaXZhdGUgez9FbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlSXRlbV8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uQUNUSVZFX0lURU0pO1xuXG4gICAgLy8gTm8gbmVlZCB0byBnbyBmdXJ0aGVyLiBUaGVyZSBpcyBubyBwYWdlIG5hdiBvciB0aGUgdXNlciBpcyBvbiBhblxuICAgIC8vIGBPdmVydmlld2AgcGFnZSBhbmQgdGhlIGhlYWRlciBjb21wb25lbnQgY29ycmVjdGx5IHNldHMgdGhlIGFjdGl2ZSBzdGF0ZXNcbiAgICAvLyBvZiBhbGwgbmF2IGl0ZW1zLlxuICAgIGlmICghdGhpcy5hY3RpdmVJdGVtXyB8fCAhdGhpcy5hY3RpdmVJdGVtXy5kYXRhc2V0LnBhcmVudExpbmtzKSByZXR1cm47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlua3Mgb2YgdGhlIHBhcmVudCBuYXYocykgb2YgdGhlIGFjdGl2ZSBwYWdlIG5hdiBzZXQgaW50byBhIGBkYXRhYFxuICAgICAqIGF0dHJpYnV0ZSBhcyBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgYSBjb21tYS5cbiAgICAgKiBAcHJpdmF0ZSB7IUFycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRMaW5rc18gPSB0aGlzLmFjdGl2ZUl0ZW1fLmRhdGFzZXQucGFyZW50TGlua3Muc3BsaXQoJywnKTtcblxuICAgIC8qKlxuICAgICAqIEFsbCBuYXYgaXRlbXMgdGhhdCBhcmUgcGFydCBvZiB0aGUgbWFpbiBoZWFkZXIgbmF2LiBUaGlzIGV4Y2x1ZGVzIHRoZVxuICAgICAqIHBhZ2UgbmF2IGl0ZW1zLlxuICAgICAqIEBwcml2YXRlIHshQXJyYXk8IUVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMubWFpbk5hdkl0ZW1zXyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uSEVBREVSKVxuICAgICAgICAucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvcnNfLkhFQURFUl9OQVZfSVRFTVMpXTtcblxuICAgIHRoaXMuc2V0QWN0aXZlU3RhdGVzT25QYXJlbnROYXZzXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFBcnJheTwhRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRBY3RpdmVQYXJlbnROYXZzXygpIHtcbiAgICBjb25zdCBhY3RpdmVQYXJlbnROYXZzID0gW107XG5cbiAgICB0aGlzLnBhcmVudExpbmtzXy5mb3JFYWNoKChwYXJlbnRMaW5rKSA9PiB7XG4gICAgICB0aGlzLm1haW5OYXZJdGVtc18uZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtSHJlZiA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cbiAgICAgICAgaWYgKGl0ZW1IcmVmID09PSBwYXJlbnRMaW5rKSB7XG4gICAgICAgICAgYWN0aXZlUGFyZW50TmF2cy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhY3RpdmVQYXJlbnROYXZzO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHNldEFjdGl2ZVN0YXRlc09uUGFyZW50TmF2c18oKSB7XG4gICAgdGhpcy5nZXRBY3RpdmVQYXJlbnROYXZzXygpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChDbGFzc2VzXy5IQVNfQUNUSVZFX1BBR0VfTkFWKTtcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL3BhZ2UtbmF2L3BhZ2UtbmF2LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IE1EQ1JpcHBsZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENSaXBwbGVGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQGV4dGVuZHMgTURDQ29tcG9uZW50PCFNRENSaXBwbGVGb3VuZGF0aW9uPlxuICovXG5jbGFzcyBNRENSaXBwbGUgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKiogQHBhcmFtIHsuLi4/fSBhcmdzICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy51bmJvdW5kZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHt7aXNVbmJvdW5kZWQ6IChib29sZWFufHVuZGVmaW5lZCl9PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHshTURDUmlwcGxlfVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QsIHtpc1VuYm91bmRlZCA9IHVuZGVmaW5lZH0gPSB7fSkge1xuICAgIGNvbnN0IHJpcHBsZSA9IG5ldyBNRENSaXBwbGUocm9vdCk7XG4gICAgLy8gT25seSBvdmVycmlkZSB1bmJvdW5kZWQgYmVoYXZpb3IgaWYgb3B0aW9uIGlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkXG4gICAgaWYgKGlzVW5ib3VuZGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJpcHBsZS51bmJvdW5kZWQgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpc1VuYm91bmRlZCk7XG4gICAgfVxuICAgIHJldHVybiByaXBwbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUmlwcGxlQ2FwYWJsZVN1cmZhY2V9IGluc3RhbmNlXG4gICAqIEByZXR1cm4geyFNRENSaXBwbGVBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFkYXB0ZXIoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBNQVRDSEVTID0gdXRpbC5nZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB1dGlsLnN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvdyksXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gaW5zdGFuY2UudW5ib3VuZGVkLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiBpbnN0YW5jZS5yb290X1tNQVRDSEVTXSgnOmFjdGl2ZScpLFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IGluc3RhbmNlLmRpc2FibGVkLFxuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IGluc3RhbmNlLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiBpbnN0YW5jZS5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiAodGFyZ2V0KSA9PiBpbnN0YW5jZS5yb290Xy5jb250YWlucyh0YXJnZXQpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBpbnN0YW5jZS5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGluc3RhbmNlLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YXJOYW1lLCB2YWx1ZSkgPT4gaW5zdGFuY2Uucm9vdF8uc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpLFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gaW5zdGFuY2Uucm9vdF8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAoe3g6IHdpbmRvdy5wYWdlWE9mZnNldCwgeTogd2luZG93LnBhZ2VZT2Zmc2V0fSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgdW5ib3VuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuYm91bmRlZF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB1bmJvdW5kZWQgKi9cbiAgc2V0IHVuYm91bmRlZCh1bmJvdW5kZWQpIHtcbiAgICB0aGlzLnVuYm91bmRlZF8gPSBCb29sZWFuKHVuYm91bmRlZCk7XG4gICAgdGhpcy5zZXRVbmJvdW5kZWRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc3VyZSBDb21waWxlciB0aHJvd3MgYW4gYWNjZXNzIGNvbnRyb2wgZXJyb3Igd2hlbiBkaXJlY3RseSBhY2Nlc3NpbmcgYVxuICAgKiBwcm90ZWN0ZWQgb3IgcHJpdmF0ZSBwcm9wZXJ0eSBpbnNpZGUgYSBnZXR0ZXIvc2V0dGVyLCBsaWtlIHVuYm91bmRlZCBhYm92ZS5cbiAgICogQnkgYWNjZXNzaW5nIHRoZSBwcm90ZWN0ZWQgcHJvcGVydHkgaW5zaWRlIGEgbWV0aG9kLCB3ZSBzb2x2ZSB0aGF0IHByb2JsZW0uXG4gICAqIFRoYXQncyB3aHkgdGhpcyBmdW5jdGlvbiBleGlzdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRVbmJvdW5kZWRfKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0VW5ib3VuZGVkKHRoaXMudW5ib3VuZGVkXyk7XG4gIH1cblxuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlKCk7XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVhY3RpdmF0ZSgpO1xuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8ubGF5b3V0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1JpcHBsZUZvdW5kYXRpb259XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBNRENSaXBwbGVGb3VuZGF0aW9uKE1EQ1JpcHBsZS5jcmVhdGVBZGFwdGVyKHRoaXMpKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIHRoaXMudW5ib3VuZGVkID0gJ21kY1JpcHBsZUlzVW5ib3VuZGVkJyBpbiB0aGlzLnJvb3RfLmRhdGFzZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTZWUgTWF0ZXJpYWwgRGVzaWduIHNwZWMgZm9yIG1vcmUgZGV0YWlscyBvbiB3aGVuIHRvIHVzZSByaXBwbGVzLlxuICogaHR0cHM6Ly9tYXRlcmlhbC5pby9ndWlkZWxpbmVzL21vdGlvbi9jaG9yZW9ncmFwaHkuaHRtbCNjaG9yZW9ncmFwaHktY3JlYXRpb25cbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgUmlwcGxlQ2FwYWJsZVN1cmZhY2Uge31cblxuLyoqIEBwcm90ZWN0ZWQgeyFFbGVtZW50fSAqL1xuUmlwcGxlQ2FwYWJsZVN1cmZhY2UucHJvdG90eXBlLnJvb3RfO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSByaXBwbGUgYmxlZWRzIG91dCBvZiB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50LlxuICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5SaXBwbGVDYXBhYmxlU3VyZmFjZS5wcm90b3R5cGUudW5ib3VuZGVkO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSByaXBwbGUgaXMgYXR0YWNoZWQgdG8gYSBkaXNhYmxlZCBjb21wb25lbnQuXG4gKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cblJpcHBsZUNhcGFibGVTdXJmYWNlLnByb3RvdHlwZS5kaXNhYmxlZDtcblxuZXhwb3J0IHtNRENSaXBwbGUsIE1EQ1JpcHBsZUZvdW5kYXRpb24sIFJpcHBsZUNhcGFibGVTdXJmYWNlLCB1dGlsfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgRlxuICovXG5jbGFzcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDQ29tcG9uZW50fVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHdoaWNoIGV4dGVuZCBNRENCYXNlIHNob3VsZCBwcm92aWRlIGFuIGF0dGFjaFRvKCkgbWV0aG9kIHRoYXQgdGFrZXMgYSByb290IGVsZW1lbnQgYW5kXG4gICAgLy8gcmV0dXJucyBhbiBpbnN0YW50aWF0ZWQgY29tcG9uZW50IHdpdGggaXRzIHJvb3Qgc2V0IHRvIHRoYXQgZWxlbWVudC4gQWxzbyBub3RlIHRoYXQgaW4gdGhlIGNhc2VzIG9mXG4gICAgLy8gc3ViY2xhc3NlcywgYW4gZXhwbGljaXQgZm91bmRhdGlvbiBjbGFzcyB3aWxsIG5vdCBoYXZlIHRvIGJlIHBhc3NlZCBpbjsgaXQgd2lsbCBzaW1wbHkgYmUgaW5pdGlhbGl6ZWRcbiAgICAvLyBmcm9tIGdldERlZmF1bHRGb3VuZGF0aW9uKCkuXG4gICAgcmV0dXJuIG5ldyBNRENDb21wb25lbnQocm9vdCwgbmV3IE1EQ0ZvdW5kYXRpb24oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge0Y9fSBmb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgZm91bmRhdGlvbiA9IHVuZGVmaW5lZCwgLi4uYXJncykge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshRWxlbWVudH0gKi9cbiAgICB0aGlzLnJvb3RfID0gcm9vdDtcbiAgICB0aGlzLmluaXRpYWxpemUoLi4uYXJncyk7XG4gICAgLy8gTm90ZSB0aGF0IHdlIGluaXRpYWxpemUgZm91bmRhdGlvbiBoZXJlIGFuZCBub3Qgd2l0aGluIHRoZSBjb25zdHJ1Y3RvcidzIGRlZmF1bHQgcGFyYW0gc28gdGhhdFxuICAgIC8vIHRoaXMucm9vdF8gaXMgZGVmaW5lZCBhbmQgY2FuIGJlIHVzZWQgd2l0aGluIHRoZSBmb3VuZGF0aW9uIGNsYXNzLlxuICAgIC8qKiBAcHJvdGVjdGVkIHshRn0gKi9cbiAgICB0aGlzLmZvdW5kYXRpb25fID0gZm91bmRhdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXREZWZhdWx0Rm91bmRhdGlvbigpIDogZm91bmRhdGlvbjtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmluaXQoKTtcbiAgICB0aGlzLmluaXRpYWxTeW5jV2l0aERPTSgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgvKiAuLi5hcmdzICovKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBkbyBhbnkgYWRkaXRpb25hbCBzZXR1cCB3b3JrIHRoYXQgd291bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIGFcbiAgICAvLyBcImNvbnN0cnVjdG9yXCIuIEVzc2VudGlhbGx5LCBpdCBpcyBhIGhvb2sgaW50byB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGJlZm9yZSB0aGUgZm91bmRhdGlvbiBpc1xuICAgIC8vIGluaXRpYWxpemVkLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYmVzaWRlcyByb290IGFuZCBmb3VuZGF0aW9uIHdpbGwgYmUgcGFzc2VkIGluIGhlcmUuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUZ9IGZvdW5kYXRpb25cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkIGZvdW5kYXRpb24gY2xhc3MgZm9yIHRoZVxuICAgIC8vIGNvbXBvbmVudC5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBnZXREZWZhdWx0Rm91bmRhdGlvbiB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkICcgK1xuICAgICAgJ2ZvdW5kYXRpb24gY2xhc3MnKTtcbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IG5lZWQgdG8gcGVyZm9ybSB3b3JrIHRvIHN5bmNocm9uaXplIHdpdGggYSBob3N0IERPTVxuICAgIC8vIG9iamVjdC4gQW4gZXhhbXBsZSBvZiB0aGlzIHdvdWxkIGJlIGEgZm9ybSBjb250cm9sIHdyYXBwZXIgdGhhdCBuZWVkcyB0byBzeW5jaHJvbml6ZSBpdHMgaW50ZXJuYWwgc3RhdGVcbiAgICAvLyB0byBzb21lIHByb3BlcnR5IG9yIGF0dHJpYnV0ZSBvZiB0aGUgaG9zdCBET00uIFBsZWFzZSBub3RlOiB0aGlzIGlzICpub3QqIHRoZSBwbGFjZSB0byBwZXJmb3JtIERPTVxuICAgIC8vIHJlYWRzL3dyaXRlcyB0aGF0IHdvdWxkIGNhdXNlIGxheW91dCAvIHBhaW50LCBhcyB0aGlzIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5IGZyb20gd2l0aGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBtYXkgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJlbGVhc2UgYW55IHJlc291cmNlcyAvIGRlcmVnaXN0ZXIgYW55IGxpc3RlbmVycyB0aGV5IGhhdmVcbiAgICAvLyBhdHRhY2hlZC4gQW4gZXhhbXBsZSBvZiB0aGlzIG1pZ2h0IGJlIGRlcmVnaXN0ZXJpbmcgYSByZXNpemUgZXZlbnQgZnJvbSB0aGUgd2luZG93IG9iamVjdC5cbiAgICB0aGlzLmZvdW5kYXRpb25fLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIGxpc3RlbmluZyBmb3IgY3VzdG9tIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgbWV0aG9kIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LiBUaGlzIGlzIG1vc3QgdXNlZnVsIHdoZW5cbiAgICogdW5saXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICB1bmxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGEgY3Jvc3MtYnJvd3Nlci1jb21wYXRpYmxlIGN1c3RvbSBldmVudCBmcm9tIHRoZSBjb21wb25lbnQgcm9vdCBvZiB0aGUgZ2l2ZW4gdHlwZSxcbiAgICogd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshT2JqZWN0fSBldnREYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZEJ1YmJsZVxuICAgKi9cbiAgZW1pdChldnRUeXBlLCBldnREYXRhLCBzaG91bGRCdWJibGUgPSBmYWxzZSkge1xuICAgIGxldCBldnQ7XG4gICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgICAgZGV0YWlsOiBldnREYXRhLFxuICAgICAgICBidWJibGVzOiBzaG91bGRCdWJibGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMucm9vdF8uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NvbXBvbmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBMQkNvbXBvbmVudCBmcm9tICcuLi9iYXNlL2luZGV4JztcbmltcG9ydCB7TEJHbHVlQ2Fyb3VzZWxGb3VuZGF0aW9ufSBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtzdHJpbmdzLCBsaXN0c30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtDYXJvdXNlbH0gZnJvbSAnQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9jYXJvdXNlbC9jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdpbmF0aW9uTmV4dH0gZnJvbSAnQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL25leHQvY29tcG9uZW50JztcbmltcG9ydCB7TW9kZWxGYWN0b3J5fSBmcm9tICdAZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vbW9kZWxmYWN0b3J5JztcbmltcG9ydCB7UGFnaW5hdGlvblBhZ2VMaXN0fSBmcm9tXG4gICAgJ0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wYWdlbGlzdC9jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdpbmF0aW9uUHJldmlvdXN9IGZyb21cbiAgICAnQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL3ByZXZpb3VzL2NvbXBvbmVudCc7XG5cbi8qKiBAcHJpdmF0ZSBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IHtHTFVFX1BBR0lOQVRJT05fUEFHRV9MSVNUX1NFTEVDVE9SLFxuICAgICAgIEdMVUVfUEFHSU5BVElPTl9QUkVWSU9VU19TRUxFQ1RPUixcbiAgICAgICBHTFVFX1BBR0lOQVRJT05fTkVYVF9TRUxFQ1RPUixcbiAgICAgICBHTFVFX0NBUk9VU0VMX1NFTEVDVE9SLFxuICAgICAgIEdMVUVfUEFHSU5BVElPTl9EQVRBLFxuICAgICAgIE9QVElPTlNfS0VZLFxuICAgICAgIE1PREVMX1BSRUZJWCxcbiAgICAgfSA9IHN0cmluZ3M7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBXcmFwcGVyIGZvciBHbHVlIENhcm91c2VsIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGNhcm91c2VsIGFuZFxuICogaXRzIHJlbGF0ZWQgbmV4dC9wcmV2aW91cy9saXN0IG5hdiBjb21wb25lbnRzLlxuICovXG5cblxuLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG5sZXQgY2Fyb3VzZWxOdW1iZXIgPSAxO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgZGVmaW5lcyBMQkdsdWVDYXJvdXNlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIExCR2x1ZUNhcm91c2VsIGV4dGVuZHMgTEJDb21wb25lbnQge1xuICAvLyBJbnZva2VkIGJ5IGBtZGMuYXV0b0luaXQoKWBcbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICByZXR1cm4gbmV3IExCR2x1ZUNhcm91c2VsKHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIGBwYWdpbmF0aW9uTW9kZWxgIGdldHRlci5cbiAgICovXG4gIGdldCBtb2RlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdpbmF0aW9uTW9kZWxfO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGNvbXBvbmVudCBmb3VuZGF0aW9uIGFuZCBwYXNzIGl0IHRoZSBhZGFwdGVyIGRpY3QuXG4gICAqIEByZXR1cm4ge0xCR2x1ZUNhcm91c2VsRm91bmRhdGlvbn1cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTEJHbHVlQ2Fyb3VzZWxGb3VuZGF0aW9uKHtcbiAgICAgIGdldE9wdGlvbnM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgR2x1ZSBzdWIgY29tcG9uZW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRHbHVlQ29tcG9uZW50c18oKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5nbHVlTW9kdWxlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLmdsdWVNb2R1bGVzW2tleV07XG4gICAgICBjb25zdCBjb21wb25lbnRSb290ID0gdGhpcy5xdWVyeUNvbXBvbmVudFNlbGVjdG9yKG1vZHVsZS5zZWxlY3Rvcik7XG5cbiAgICAgIGlmIChjb21wb25lbnRSb290KSB7XG4gICAgICAgIGNvbXBvbmVudFJvb3Quc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgR0xVRV9QQUdJTkFUSU9OX0RBVEEsIHRoaXMuY2Fyb3VzZWxNb2RlbEluc3RhbmNlXyk7XG5cbiAgICAgICAgbW9kdWxlLmluc3RhbmNlID1cbiAgICAgICAgICAgIG1vZHVsZS5jb21wb25lbnRDdG9yLmF0dGFjaFRvKGNvbXBvbmVudFJvb3QsIG1vZHVsZS5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBjb21wb25lbnQuIFNldHVwIGVsZW1lbnRzIGFuZCBjaGlsZCBjb21wb25lbnRzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLnBhcnNlT3B0aW9uc1N0cmluZyhPUFRJT05TX0tFWSk7XG5cbiAgICBjb25zdCB7Y3ljbGljYWwsIHN0YXJ0UGFnZX0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICo+fSBTZXBlcmF0ZSBHbHVlIHNwZWNpZmljIG9wdGlvbnMuICovXG4gICAgY29uc3QgZ2x1ZU9wdGlvbnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnNfKVxuICAgICAgICAuZmlsdGVyKChvcHQpID0+IChsaXN0cy5JR05PUkVfT1BUSU9OUy5pbmRleE9mKG9wdCkgPT09IC0xKSlcbiAgICAgICAgLnJlZHVjZSgob3B0cywgb3B0KSA9PiB7XG4gICAgICAgICAgb3B0c1tvcHRdID0gdGhpcy5vcHRpb25zX1tvcHRdO1xuICAgICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgICB9LCB7fSk7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHtzdHJpbmd9ICovXG4gICAgdGhpcy5jYXJvdXNlbE1vZGVsSW5zdGFuY2VfID0gYCR7TU9ERUxfUFJFRklYfSR7Y2Fyb3VzZWxOdW1iZXJ9YDtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFQYWdpbmF0aW9uTW9kZWx9ICovXG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfID0gTW9kZWxGYWN0b3J5LmdldCh0aGlzLmNhcm91c2VsTW9kZWxJbnN0YW5jZV8pO1xuXG4gICAgLyoqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICo+fSAqL1xuICAgIHRoaXMuZ2x1ZU1vZHVsZXMgPSB7XG4gICAgICBQYWdpbmF0aW9uUGFnZUxpc3Q6IHtcbiAgICAgICAgJ3NlbGVjdG9yJzogR0xVRV9QQUdJTkFUSU9OX1BBR0VfTElTVF9TRUxFQ1RPUixcbiAgICAgICAgJ2NvbXBvbmVudEN0b3InOiBQYWdpbmF0aW9uUGFnZUxpc3QsXG4gICAgICB9LFxuICAgICAgUGFnaW5hdGlvbk5leHQ6IHtcbiAgICAgICAgJ3NlbGVjdG9yJzogR0xVRV9QQUdJTkFUSU9OX05FWFRfU0VMRUNUT1IsXG4gICAgICAgICdjb21wb25lbnRDdG9yJzogUGFnaW5hdGlvbk5leHQsXG4gICAgICB9LFxuICAgICAgUGFnaW5hdGlvblByZXZpb3VzOiB7XG4gICAgICAgICdzZWxlY3Rvcic6IEdMVUVfUEFHSU5BVElPTl9QUkVWSU9VU19TRUxFQ1RPUixcbiAgICAgICAgJ2NvbXBvbmVudEN0b3InOiBQYWdpbmF0aW9uUHJldmlvdXMsXG4gICAgICB9LFxuICAgICAgQ2Fyb3VzZWw6IHtcbiAgICAgICAgJ3NlbGVjdG9yJzogR0xVRV9DQVJPVVNFTF9TRUxFQ1RPUixcbiAgICAgICAgJ2NvbXBvbmVudEN0b3InOiBDYXJvdXNlbCxcbiAgICAgICAgJ29wdGlvbnMnOiBnbHVlT3B0aW9ucyxcbiAgICAgIH0sXG4gICAgfTtcblxuXG4gICAgaWYgKGN5Y2xpY2FsKSB7XG4gICAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8uY3ljbGljYWwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdGFydFBhZ2UpIHtcbiAgICAgLy8gU3RhcnQgb24gYSBzcGVjaWZpYyBwYWdlLlxuICAgICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLmN1cnJlbnRQYWdlID0gc3RhcnRQYWdlO1xuICAgIH1cblxuICAgIC8vIFRvIGVuc3VyZSBvdXIgR2x1ZSBjb21wb25lbnRzIGFuZCBtb2RlbCBhcmUgcHJvcGVybHkgc3luY2VkIHdhaXQgYW4gZXh0cmFcbiAgICAvLyB0aWNrIHRvIGVuc3VyZSBgTW9kZWxGYWN0b3J5YCBoYXMgZ2VuZXJhdGVkIGEgbmV3IGluc3RhbmNlIGJlZm9yZVxuICAgIC8vIGluaXRpYWxpemF0aW9uLlxuICAgIHNldFRpbWVvdXQodGhpcy5pbml0R2x1ZUNvbXBvbmVudHNfLmJpbmQodGhpcykpO1xuXG4gICAgLy8gSW5jcmVtZW50IGNhcm91c2VsIG51bWJlciB0byBlbmFibGUgbXVsdGlwbGUgY2Fyb3VzZWxzL3BhZ2luYXRpb25cbiAgICAvLyBtb2RlbHMgb24gdGhlIHNhbWUgcGFnZS5cbiAgICBjYXJvdXNlbE51bWJlciArPSAxO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2dsdWUtY2Fyb3VzZWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7bGJDbGFzc01peGlufSBmcm9tICcuL21peGluJztcbmltcG9ydCB7TURDQ29tcG9uZW50fSBmcm9tICdAbWF0ZXJpYWwvYmFzZSc7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBMQkNvbXBvbmVudDpcbiAqIENvbW1vbiBiYXNlIGNvbXBvbmVudCB0aGF0IGluY2x1ZGVzIExCIHNwZWNpZmljIHV0aWxpdHkgbWV0aG9kcyBhbmRcbiAqIHByb3BlcnRpZXMgYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBNREMgQ0FGIGFyY2hpdGVjdHVyZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMQkNvbXBvbmVudCBleHRlbmRzIGxiQ2xhc3NNaXhpbihNRENDb21wb25lbnQpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHshT2JqZWN0fHVuZGVmaW5lZH0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICBzdXBlcihyb290LCBmb3VuZGF0aW9uLCAuLi5hcmdzKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFufG51bWJlcnxzdHJpbmc+fSAqL1xuICAgIHRoaXMub3B0aW9uc18gPSB7fTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9iYXNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtWaXNpYmlsaXR5fSBmcm9tICcuL3RpbGVtYXAvdmlzaWJpbGl0eSc7XG5pbXBvcnQge1BhZ2luYXRpb25Nb2RlbH0gZnJvbSAnLi4vLi4vcGFnaW5hdGlvbi9tb2RlbCc7XG5cbi8qKiBAcmVjb3JkICovXG5jbGFzcyBDYXJvdXNlbEFkYXB0ZXIge1xuXG4gIC8qKlxuICAgKiBIb3cgbWFueSBpdGVtcyBoYXMgdGhlIGNhcm91c2VsLiBVc2VkIHRvIHVwZGF0ZSB0aGUgcGFnaW5hdGlvbiBtb2RlbC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY291bnRJdGVtcygpIHt9XG5cbiAgLyoqIEByZXR1cm4geyFQYWdpbmF0aW9uTW9kZWx9ICovXG4gIGdldFBhZ2luYXRpb25Nb2RlbCgpIHt9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGlsZSBlbGVtZW50cyB2aXNpYmlsaXR5IGJhc2VkIG9uIGEgZGlzcGxheSBtYXAsIHRoZW4gY2FsbHMgYVxuICAgKiBmdW5jdGlvbiBvbmNlIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICogQHBhcmFtIHshQXJyYXk8VmlzaWJpbGl0eT59IGRpc3BsYXlNYXBcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICB0b2dnbGVFbGVtZW50cyhkaXNwbGF5TWFwLCBjYWxsYmFjaykge31cblxuICAvKipcbiAgICogTWFrZXMgYWxsIHRpbGUgZWxlbWVudHMgdmlzaWJsZSwgdGhlbiBjYWxscyBhIGZ1bmN0aW9uIG9uY2UgdGhlIERPTSBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlc2V0RWxlbWVudHMoY2FsbGJhY2spIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzUnRsKCkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXQgZm9jdXMgb24gYSB0aWxlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICAgKi9cbiAgZm9jdXNUaWxlKGVsKSB7fVxuXG4gIC8qKlxuICAgKiBTZXQgYSBDU1Mgc3R5bGUgb24gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRTdHlsZShwcm9wLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogVGhlIHdpZHRoIGluIHBpeGVscyBvZiB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIGNvbnRhaW5lciBET00gZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UGFyZW50RWxlbWVudFdpZHRoKCkge31cblxuICAvKipcbiAgICogVGhlIGNvbnRhaW5lcidzIGNoaWxkIERPTSBlbGVtZW50cy5cbiAgICogQHJldHVybiB7IUFycmF5PCFFbGVtZW50Pn1cbiAgICovXG4gIGdldENoaWxkRWxlbWVudHMoKSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggYW5kIGhlaWdodCBkaW1lbnNpb25zIGluIHBpeGVscyBvZiBhIHRpbGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gICAqIEByZXR1cm4geyFPYmplY3Q8bnVtYmVyPn1cbiAgICovXG4gIGdldFRpbGVEaW1lbnNpb25zKGVsKSB7fVxuXG4gIC8qKlxuICAgKiBTZXQgYSBDU1Mgc3R5bGUgb24gYSB0aWxlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldFRpbGVTdHlsZShlbCwgcHJvcCwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBhdHRyaWJ1dGUgb24gYSB0aWxlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gdmFsdWVcbiAgICovXG4gIHNldFRpbGVBdHRyKGVsLCBhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSBhIHRpbGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICBybVRpbGVBdHRyKGVsLCBhdHRyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlciAqL1xuICByZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJTd2lwZVN0YXJ0KGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJTd2lwZVN0YXJ0KGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyU3dpcGVNb3ZlKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJTd2lwZU1vdmUoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJTd2lwZUVuZChoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyU3dpcGVFbmQoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJTd2lwZUNhbmNlbChoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyU3dpcGVDYW5jZWwoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJNb3VzZUxlYXZlKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJNb3VzZUxlYXZlKGhhbmRsZXIpIHt9XG5cbn1cblxuZXhwb3J0IHtDYXJvdXNlbEFkYXB0ZXJ9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvYWRhcHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cblxuLyoqIEByZWNvcmQgKi9cbmZ1bmN0aW9uIE9wdGlvbnMoKSB7fVxuXG4vKiogQHR5cGUge2Jvb2xlYW59ICovXG5PcHRpb25zLnByb3RvdHlwZS5lbGFzdGljRWRnZTtcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5PcHRpb25zLnByb3RvdHlwZS5lZGdlRnJpY3Rpb247XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKTogbnVtYmVyfSAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZWFzaW5nO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbk9wdGlvbnMucHJvdG90eXBlLnRyYW5zaXRpb25EdXJhdGlvbjtcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5PcHRpb25zLnByb3RvdHlwZS5leHBhbmQ7XG5cbi8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbk9wdGlvbnMucHJvdG90eXBlLmp1bXA7XG5cbi8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbk9wdGlvbnMucHJvdG90eXBlLmNlbnRlcjtcblxuLyoqIEB0eXBlIHtib29sZWFufSAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZ3JvdXA7XG5cbmV4cG9ydCB7T3B0aW9uc307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9jYXJvdXNlbC9vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtDb250YWluZWRUaWxlSXRlcmF0b3J9IGZyb20gJy4vY29udGFpbmVkdGlsZWl0ZXJhdG9yJztcbmltcG9ydCB7SXRlcmFibGVUaWxlTWFwfSBmcm9tICcuL2l0ZXJhYmxldGlsZW1hcCc7XG5pbXBvcnQge1RpbGV9IGZyb20gJy4vdGlsZSc7XG5pbXBvcnQge1RpbGVJdGVyYXRvcn0gZnJvbSAnLi90aWxlaXRlcmF0b3InO1xuaW1wb3J0IHtWaXNpYmlsaXR5fSBmcm9tICcuL3Zpc2liaWxpdHknO1xuaW1wb3J0IHtWaXNpYmlsaXR5SXRlcmF0b3J9IGZyb20gJy4vdmlzaWJpbGl0eWl0ZXJhdG9yJztcblxuXG4vKipcbiAqIEEgb25lLWRpbWVuc2lvbiB0aWxlIG1hcC5cbiAqXG4gKiBJdCBkZWZpbmVzIHRoZSBYIHBvc2l0aW9uIG9mIGEgZnJhbWUgd2hpY2ggZGVsaW1pbmF0ZXMgdGhlIHZpZXcgYXJlYSxcbiAqIHRoZSBmcmFtZSdzIHdpZHRoLCBlYWNoIHRpbGUncyB3aWR0aCwgYW5kIGEgZGlzcGxheSBtYXAgdGhhdCBsaXN0cyB3aGljaFxuICogdGlsZXMgYXJlIGN1cnJlbnRseSB2aXNpYmxlIGluc2lkZSB0aGUgZnJhbWUsIGdpdmVuIGl0cyBwb3NpdGlvbiBvbiB0aGVcbiAqIHRpbGUgY29udGFpbmVyJ3MgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gKlxuICogSXQgaXMgb25seSBkZWZpbmVkIGF0IGEgbWF0aGVtYXRpYyBsZXZlbC4gVGhlIGNvbmNyZXRlIGRpc3BsYXkgb24gdGhlIERPTVxuICogaXMgZGVsZWdhdGVkIHRvIGEgcmVuZGVyZXIuXG4gKlxuICogSW4gdGhlIGNhc2Ugb2YgYSBjeWNsaWNhbCBjYXJvdXNlbCwgYWxsIGF2YWlsYWJsZSB0aWxlcyBjeWNsZSBpbmZpbml0ZWx5XG4gKiBpbiBib3RoIGRpcmVjdGlvbnMsIGxpa2UgdGhlIGV4YW1wbGUgYmVsb3cgd2l0aCA0IGF2YWlsYWJsZSB0aWxlcy5cbiAqXG4gKiAtIC4uLiBbIDEgXVsgMiBdWyAzIF1bIDQgXXxbIDEgXVsgMiBdWyAzIF1bIDQgXVsgMSBdWyAyIF1bIDMgXVsgNCBdIC4uLiArXG4gKlxuICogYHxgIG1hcmtzIHRoZSBvcmlnaW4gKHggPSAwKSBvZiB0aGUgdGlsZSBjb250YWluZXIncyBjb29yZGluYXRlIHN5c3RlbS5cbiAqXG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGVUaWxlTWFwfVxuICovXG5jbGFzcyBUaWxlTWFwIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBjeWNsaWNhbCBXaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBjeWNsaWNhbC4gSW4gYSBjeWNsaWNhbFxuICAgKiAgICAgY2Fyb3VzZWwsIGdvaW5nIGZyb20gdGhlIGZpcnN0IGl0ZW0gdG8gdGhlIGxhc3Qgd2lsbCBtb3ZlIGJhY2t3YXJkLFxuICAgKiAgICAgaW5zdGVhZCBvZiBqdW1waW5nIGZvcndhcmQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9jYW5FeGNlZWRFZGdlcyBXaGV0aGVyIHRoZSBmcmFtZSBjYW4gbW92ZSBiZXlvbmQgdGhlXG4gICAqICAgICBlZGdlcyB3aGVuIHRoZSBjYXJvdXNlbCBpcyBub24tY3ljbGljYWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zbmFwVG9DZW50ZXIgV2hldGhlciB0byBzbmFwIHRvIGNlbnRlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGN5Y2xpY2FsLCBvcHRfY2FuRXhjZWVkRWRnZXMsIG9wdF9zbmFwVG9DZW50ZXIpIHtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5jeWNsaWNhbF8gPSBjeWNsaWNhbDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG4gICAgdGhpcy5jYW5FeGNlZWRFZGdlc18gPSAob3B0X2NhbkV4Y2VlZEVkZ2VzID09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgKG9wdF9jYW5FeGNlZWRFZGdlcyA9PSB0cnVlKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnNuYXBUb0NlbnRlcl8gPSAob3B0X3NuYXBUb0NlbnRlciAhPSBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGxlZnQgYm91bmRhcnkgb2YgdGhlIGZyYW1lIGluIHRoZSB0aWxlIGNvbnRhaW5lcidzXG4gICAgICogY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdW11bGF0aXZlIHdpZHRoIG9mIGFsbCBhdmFpbGFibGUgdGlsZXMgY29tYmluZWQuXG4gICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFsbFRpbGVzV2lkdGhfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFycmF5PG51bWJlcj59IFRoZSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgdGlsZXMnIHdpZHRoLiAqL1xuICAgIHRoaXMudGlsZVdpZHRoc18gPSBbXTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFycmF5PG51bWJlcj59IFRoZSBsaXN0IG9mIGRpc2FibGVkIHRpbGUgaW5kZXhlcy4gKi9cbiAgICB0aGlzLmRpc2FibGVkVGlsZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIHRpbGUgd2l0aCBhIHNpemUgYWJvdmUgMC5cbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFyZVRpbGVzVmFsaWRfID0gZmFsc2U7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBmcmFtZS4gKi9cbiAgICB0aGlzLmZyYW1lV2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQSBwaXhlbCB2YWx1ZSBleHBhbmRpbmcgdGhlIGZyYW1lIG9uIGJvdGggc2lkZXMuIFVzZWQgd2hlbiB0aWxlcyBvdXRzaWRlXG4gICAgICogdGhlIGZyYW1lIGFyZWEgbmVlZCB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lRXhwYW5kID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXNwbGF5IG1hcCBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICogVGhlIHN0cnVjdHVyZSBvZiB0aGUgYXJyYXkgaXMgYmFzZWQgb24gdGhlIG51bWJlciBvZiBhdmFpbGFibGUgaXRlbXMuXG4gICAgICogSWYgdGhlIHBvc2l0aW9uIG9mIHRoZSBmcmFtZSBjYW4gcmV2ZWFsIHRoZSBmaXJzdCBhbmQgbGFzdCB0aWxlcyBvZiB0d29cbiAgICAgKiBkaWZmZXJlbnQgY3ljbGVzLCBvciBpcyBsYXJnZSBlbm91Z2ggdG8gc2hvdyBhbGwgdGlsZXMgc2V2ZXJhbCB0aW1lcyxcbiAgICAgKiB0aGUgYXJyYXkgd2lsbCBiZSBsYXJnZXIgdG8gcmVwcmVzZW50IHRoZW0gYWxsLlxuICAgICAqXG4gICAgICogR2l2ZW4gYSB0aWxlIG1hcCBvZiA0IHRpbGVzLCBoZXJlIGFyZSBzb21lIGV4YW1wbGVzIG9mIHNjZW5hcmlvcyBvZlxuICAgICAqIHZpc2libGUgdGlsZXMgYW5kIHRoZWlyIGVxdWl2YWxlbnQgZGlzcGxheSBtYXAuXG4gICAgICpcbiAgICAgKiBbIDEgXVsgMiBdICAgICAgICAgICAgICAgICAgICAgICAgICA6IFsxLCAxLCAwLCAwXVxuICAgICAqIFsgMSBdWyAyIF1bIDMgXSAgICAgICAgICAgICAgICAgICAgIDogWzEsIDEsIDEsIDBdXG4gICAgICogWyAyIF1bIDMgXVsgNCBdICAgICAgICAgICAgICAgICAgICAgOiBbMCwgMSwgMSwgMV1cbiAgICAgKiBbIDQgXVsgMSBdWyAyIF0gICAgICAgICAgICAgICAgICAgICA6IFswLCAwLCAwLCAxLCAxLCAxXVxuICAgICAqIFsgMyBdWyA0IF1bIDEgXVsgMiBdWyAzIF1bIDQgXVsgMSBdIDogWzAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZSB7IUFycmF5PFZpc2liaWxpdHk+fVxuICAgICAqL1xuICAgIHRoaXMuZGlzcGxheU1hcF8gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aWxlIGN1cnJlbnRseSBzbmFwcGVkLlxuICAgICAqIEBwcml2YXRlIHs/VGlsZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50U25hcHBlZFRpbGVfO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIHRpbGVzJyB3aWR0aC5cbiAgICogQHJldHVybiB7IUFycmF5PG51bWJlcj59XG4gICAqL1xuICBnZXRUaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlV2lkdGhzXztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNldCBhbGwgdGlsZXMgd2lkdGggYXQgb25jZSwgYW5kIGFzIGEgcmVzdWx0IHRoZSBudW1iZXIgb2YgYXZhaWxhYmxlIHRpbGVzLlxuICAgKiBAcGFyYW0geyFBcnJheTxudW1iZXI+fSB3aWR0aHMgVGhlIGxpc3Qgb2YgYWxsIHRpbGVzJyB3aWR0aC5cbiAgICovXG4gIHNldFRpbGVzKHdpZHRocykge1xuICAgIHRoaXMudGlsZVdpZHRoc18gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkod2lkdGhzKTtcbiAgICB0aGlzLmFsbFRpbGVzV2lkdGhfID0gdGhpcy5nZXRBbGxUaWxlc1dpZHRoKCk7XG5cbiAgICB2YXIgaXNCZWxvd1plcm8gPSBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgcmV0dXJuIHdpZHRoIDw9IDA7XG4gICAgfTtcbiAgICAvLyBOZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSB0aWxlIHdpdGggYSB3aWR0aCBncmVhdGVyIHRoYW4gemVybyB0byBiZVxuICAgIC8vIGNvbnNpZGVyZWQgYXMgdmFsaWQuXG4gICAgdGhpcy5hcmVUaWxlc1ZhbGlkXyA9ICF0aGlzLmdldFRpbGVzKCkuZXZlcnkoaXNCZWxvd1plcm8pO1xuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5TWFwXygpO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGF2YWlsYWJsZSB0aWxlcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0VGlsZXNDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlV2lkdGhzXy5sZW5ndGg7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBUaGUgY3VtdWxhdGl2ZSB3aWR0aCBvZiBhbGwgYXZhaWxhYmxlIHRpbGVzIGNvbWJpbmVkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRBbGxUaWxlc1dpZHRoKCkge1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZ2V0VGlsZXNDb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHdpZHRoICs9IHRoaXMuZ2V0VGlsZVdpZHRoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBwcm9wZXJseSBzaXplZCB0byBiZSBjb21wdXRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVXaWR0aCA+IDAgJiYgdGhpcy5hcmVUaWxlc1ZhbGlkXztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIGEgZGVmaW5lZCB0aWxlLCBvciB6ZXJvIGlmIHRoZSB0aWxlIGhhcyBiZWVuIGRpc2FibGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlLiBJdCBjYW4gc2FmZWx5IGV4Y2VlZCB0aGVcbiAgICogICAgbnVtYmVyIG9mIGF2YWlsYWJsZSB0aWxlcywgZWcuIGlmIHRoZXJlIGFyZSA0IHRpbGVzIGF2YWlsYWJsZSxcbiAgICogICAgaW5kZXggPSA2IHdpbGwgZ2V0IHRoZSB3aWR0aCBvZiB0aGUgdGlsZSAjMi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHRpbGUuXG4gICAqL1xuICBnZXRUaWxlV2lkdGgoaW5kZXgpIHtcbiAgICBpbmRleCA9IGluZGV4ICUgdGhpcy5nZXRUaWxlc0NvdW50KCk7XG4gICAgaWYgKHRoaXMuZ2V0RGlzYWJsZWRUaWxlc18oKS5pbmRleE9mKGluZGV4KSA9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMudGlsZVdpZHRoc19baW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhIHdpZHRoIGxhcmdlIGVub3VnaCB0byBjb250YWluIGFsbCB2aXNpYmxlIHRpbGVzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRNYXhXaWR0aCgpIHtcbiAgICAvLyBDb21wdXRlcyBob3cgbGFyZ2UgdGhlIGNvbnRhaW5lciBzaG91bGQgYmUgaWYgaXQgd2FzIGZpbGwgd2l0aCBtdWx0aXBsZVxuICAgIC8vIG9jY3VyZW5jZXMgb2YgdGhlIGxhcmdlc3QgYXZhaWxhYmxlIHRpbGUuXG4gICAgdmFyIGxhcmdlc3RUaWxlV2lkdGggPSBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLnRpbGVXaWR0aHNfKTtcblxuICAgIC8vIEFwcGx5IGV4cGFuZCB2YWx1ZSBvbiBib3RoIHNpZGVzIG9mIHRoZSBmcmFtZSBhcmVhLlxuICAgIHZhciBmcmFtZVdpZHRoID0gdGhpcy5mcmFtZVdpZHRoICsgMiAqIHRoaXMuZnJhbWVFeHBhbmQ7XG4gICAgcmV0dXJuICgyICsgTWF0aC5jZWlsKGZyYW1lV2lkdGggLyBsYXJnZXN0VGlsZVdpZHRoKSkgKiBsYXJnZXN0VGlsZVdpZHRoO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhbWUgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZyYW1lIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0RnJhbWVYKCkge1xuICAgIHJldHVybiB0aGlzLnhfO1xuICB9XG5cblxuICAvKipcbiAgICogU2V0cyB0aGUgZnJhbWUgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7P251bWJlcn0geCBUaGUgZnJhbWUgcG9zaXRpb24uXG4gICAqL1xuICBzZXRGcmFtZVgoeCkge1xuICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgIHggPSAwO1xuICAgIH1cbiAgICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMueF8gPSB4O1xuXG4gICAgaWYgKCF0aGlzLmN5Y2xpY2FsXyAmJiAhdGhpcy5jYW5FeGNlZWRFZGdlc18pIHtcbiAgICAgIHRoaXMueF8gPVxuICAgICAgICAgIE1hdGgubWluKE1hdGgubWF4KHRoaXMueF8sIHRoaXMuZ2V0TWluRnJhbWVYKCkpLCB0aGlzLmdldE1heEZyYW1lWCgpKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXlNYXBfKCk7XG4gICAgdGhpcy5jdXJyZW50U25hcHBlZFRpbGVfID0gdGhpcy5nZXRTbmFwcGVkVGlsZSgpO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgdGlsZSBjdXJyZW50bHkgc25hcHBlZC5cbiAgICogQHJldHVybiB7P1RpbGV8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0Q3VycmVudFNuYXBwZWRUaWxlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTbmFwcGVkVGlsZV87XG4gIH1cblxuXG4gIC8qKlxuICAgKiBUaGUgZnJhbWUncyBtaW5pbXVtIHBvc2l0aW9uIGlmIHRoZSB0aWxlIG1hcCBpcyBub24tY3ljbGljYWwuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldE1pbkZyYW1lWCgpIHtcbiAgICBpZiAodGhpcy5zbmFwVG9DZW50ZXJfKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaWxlV2lkdGgoMCkgLyAyIC0gdGhpcy5mcmFtZVdpZHRoIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogVGhlIGZyYW1lJ3MgbWF4aW11bSBwb3NpdGlvbiBpZiB0aGUgdGlsZSBtYXAgaXMgbm9uLWN5Y2xpY2FsLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRNYXhGcmFtZVgoKSB7XG4gICAgdmFyIGxhc3RUaWxlV2lkdGggPSB0aGlzLmdldFRpbGVXaWR0aCh0aGlzLmdldFRpbGVzQ291bnQoKSAtIDEpO1xuICAgIHZhciBmcmFtZVggPSB0aGlzLmFsbFRpbGVzV2lkdGhfIC0gbGFzdFRpbGVXaWR0aDtcbiAgICBpZiAodGhpcy5zbmFwVG9DZW50ZXJfKSB7XG4gICAgICBmcmFtZVggKz0gbGFzdFRpbGVXaWR0aCAvIDIgLSB0aGlzLmZyYW1lV2lkdGggLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZnJhbWVYO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgZnJhbWUgcG9zaXRpb24gc25hcHBlZCBvbiB0aGUgcHJldmlvdXMgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhbWVYIEEgZnJhbWUgcG9zaXRpb24gdG8gdXNlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnRcbiAgICogICAgIG9uZS5cbiAgICogQHJldHVybiB7P251bWJlcn1cbiAgICovXG4gIGdldFByZXZpb3VzRnJhbWVYKG9wdF9mcmFtZVgpIHtcbiAgICB2YXIgc25hcHBlZFRpbGUgPSB0aGlzLmdldFNuYXBwZWRUaWxlKGZhbHNlLCBvcHRfZnJhbWVYKTtcbiAgICBpZiAoIXNuYXBwZWRUaWxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVGlsZUl0ZXJhdG9yKHRoaXMsIHNuYXBwZWRUaWxlLCBudWxsLCBmYWxzZSk7XG4gICAgaXRlcmF0b3IubmV4dCgpO1xuICAgIHZhciB0aWxlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlIHx8IHNuYXBwZWRUaWxlO1xuICAgIHZhciBmcmFtZVggPSB0aWxlID8gdGlsZS54IDogc25hcHBlZFRpbGUueDtcbiAgICBpZiAodGhpcy5zbmFwVG9DZW50ZXJfKSB7XG4gICAgICBmcmFtZVggKz0gdGlsZS53aWR0aCAvIDIgLSB0aGlzLmZyYW1lV2lkdGggLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZnJhbWVYO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgZnJhbWUgcG9zaXRpb24gc25hcHBlZCBvbiB0aGUgbmV4dCB0aWxlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcmFtZVggQSBmcmFtZSBwb3NpdGlvbiB0byB1c2UgaW5zdGVhZCBvZiB0aGUgY3VycmVudFxuICAgKiAgICAgb25lLlxuICAgKiBAcmV0dXJuIHs/bnVtYmVyfVxuICAgKi9cbiAgZ2V0TmV4dEZyYW1lWChvcHRfZnJhbWVYKSB7XG4gICAgdmFyIHNuYXBwZWRUaWxlID0gdGhpcy5nZXRTbmFwcGVkVGlsZShmYWxzZSwgb3B0X2ZyYW1lWCk7XG4gICAgaWYgKCFzbmFwcGVkVGlsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGl0ZXJhdG9yID0gbmV3IFRpbGVJdGVyYXRvcih0aGlzLCBzbmFwcGVkVGlsZSwgbnVsbCwgdHJ1ZSk7XG4gICAgaXRlcmF0b3IubmV4dCgpO1xuICAgIHZhciB0aWxlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlIHx8IHNuYXBwZWRUaWxlO1xuICAgIHZhciBmcmFtZVggPSB0aWxlID8gdGlsZS54IDogc25hcHBlZFRpbGUueDtcbiAgICBpZiAodGhpcy5zbmFwVG9DZW50ZXJfKSB7XG4gICAgICBmcmFtZVggKz0gdGlsZS53aWR0aCAvIDIgLSB0aGlzLmZyYW1lV2lkdGggLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZnJhbWVYO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgZnJhbWUgcG9zaXRpb24gc25hcHBlZCBvbiB0aGUgcHJldmlvdXMgZ3JvdXAgb2YgdGlsZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2ZyYW1lWCBBIGZyYW1lIHBvc2l0aW9uIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50XG4gICAqICAgICBvbmUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFByZXZpb3VzR3JvdXBGcmFtZVgob3B0X2ZyYW1lWCkge1xuICAgIHZhciBmcmFtZVggPSAob3B0X2ZyYW1lWCAhPSB1bmRlZmluZWQpID8gb3B0X2ZyYW1lWCA6IHRoaXMuZ2V0RnJhbWVYKCk7XG5cbiAgICB2YXIgZ2V0Rmlyc3RUaWxlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IENvbnRhaW5lZFRpbGVJdGVyYXRvcih0aGlzLCBmcmFtZVgpO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgdmFyIGdldEZpcnN0VmlzaWJsZVRpbGUgPSAoZnVuY3Rpb24oZnJhbWVYKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgQ29udGFpbmVkVGlsZUl0ZXJhdG9yKHRoaXMsIGZyYW1lWCk7XG4gICAgICB2YXIgdGlsZTtcbiAgICAgIHdoaWxlICh0aWxlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlKSB7XG4gICAgICAgIHZhciB2c2IgPSB0aGlzLmdldFRpbGVWaXNpYmlsaXR5KHRpbGUuaW5kZXgsIHRpbGUueCwgZnJhbWVYLCBmYWxzZSk7XG4gICAgICAgIGlmICh2c2IgPT0gVmlzaWJpbGl0eS5WSVNJQkxFKSB7XG4gICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAvLyBHZXQgdGhlIGZpcnN0IHRpbGUgaW5zaWRlIHRoZSBjdXJyZW50IGZyYW1lXG4gICAgdmFyIGZpcnN0VGlsZSA9IGdldEZpcnN0VGlsZSgpO1xuXG4gICAgLy8gR2V0IHRoZSB0YXJnZXQgZnJhbWUgcG9zaXRpb25cbiAgICB2YXIgdGFyZ2V0RnJhbWVYO1xuICAgIHZhciB2c2IgPVxuICAgICAgICB0aGlzLmdldFRpbGVWaXNpYmlsaXR5KGZpcnN0VGlsZS5pbmRleCwgZmlyc3RUaWxlLngsIGZyYW1lWCwgZmFsc2UpO1xuXG4gICAgaWYgKHZzYiA9PSBWaXNpYmlsaXR5LlZJU0lCTEUpIHtcbiAgICAgIHRhcmdldEZyYW1lWCA9IGZyYW1lWDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0RnJhbWVYID0gZmlyc3RUaWxlLnggKyBmaXJzdFRpbGUud2lkdGg7XG4gICAgfVxuICAgIHRhcmdldEZyYW1lWCAtPSB0aGlzLmZyYW1lV2lkdGg7XG5cbiAgICAvLyBHZXQgdGhlIGZpcnN0IGZ1bGx5IHZpc2libGUgdGlsZSBpbiB0aGUgdGFyZ2V0IGZyYW1lXG4gICAgdmFyIGZpcnN0VmlzaWJsZVRpbGUgPSBnZXRGaXJzdFZpc2libGVUaWxlKHRhcmdldEZyYW1lWCk7XG5cbiAgICAvLyBSZXR1cm4gaXRzIHBvc2l0aW9uXG4gICAgcmV0dXJuIGZpcnN0VmlzaWJsZVRpbGUgPyBmaXJzdFZpc2libGVUaWxlLnggOiAwO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgZnJhbWUgcG9zaXRpb24gc25hcHBlZCBvbiB0aGUgbmV4dCBncm91cCBvZiB0aWxlcy5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhbWVYIEEgZnJhbWUgcG9zaXRpb24gdG8gdXNlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnRcbiAgICogICAgIG9uZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TmV4dEdyb3VwRnJhbWVYKG9wdF9mcmFtZVgpIHtcbiAgICB2YXIgZnJhbWVYID0gdGhpcy5mcmFtZVdpZHRoO1xuICAgIGZyYW1lWCArPSAob3B0X2ZyYW1lWCAhPSB1bmRlZmluZWQpID8gb3B0X2ZyYW1lWCA6IHRoaXMuZ2V0RnJhbWVYKCk7XG4gICAgdmFyIGl0ZXJhdG9yID0gbmV3IENvbnRhaW5lZFRpbGVJdGVyYXRvcih0aGlzLCBmcmFtZVgpO1xuICAgIHZhciB0aWxlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuXG4gICAgLy8gRXZlbiBpZiB0aGUgY3VycmVudCB0aWxlIGlzIGFsc28gY29udGFpbmVkIGluIHRoZSBuZXh0IGZyYW1lLCBzdGlsbCBtb3ZlXG4gICAgLy8gdG8gdGhlIG5leHQgdGlsZS5cbiAgICBpZiAodGlsZSAmJiB0aGlzLmN1cnJlbnRTbmFwcGVkVGlsZV8gJiZcbiAgICAgICAgdGlsZS54ID09IHRoaXMuY3VycmVudFNuYXBwZWRUaWxlXy54KSB7XG4gICAgICB0aWxlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0aWxlKSB7XG4gICAgICByZXR1cm4gdGlsZS54O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGFzdFRpbGVJbmRleCA9IHRoaXMuZ2V0VGlsZXNDb3VudCgpIC0gMTtcbiAgICAgIHZhciBsYXN0VGlsZVggPSB0aGlzLmFsbFRpbGVzV2lkdGhfIC0gdGhpcy5nZXRUaWxlV2lkdGgobGFzdFRpbGVJbmRleCk7XG4gICAgICByZXR1cm4gbGFzdFRpbGVYO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpc3BsYXkgbWFwIGZvciB0aGUgY3VycmVudCBmcmFtZSBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7IUFycmF5PFZpc2liaWxpdHk+fVxuICAgKi9cbiAgZ2V0RGlzcGxheU1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwbGF5TWFwXztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGN5Y2xpY2FsLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDeWNsaWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jeWNsaWNhbF87XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgdmlzaWJsZSB0aWxlIGluIHRoZSBmcmFtZSdzIGNvb3JkaW5hdGVcbiAgICogc3lzdGVtLiBUaGlzIGNhbiBiZSB1c2VkIGJ5IHRoZSByZW5kZXJlciB0byBzZXQgdGhlIHRyYW5zbGF0ZSBwcm9wZXJ0eSBvZlxuICAgKiB0aGUgdmlzaWJsZSB0aWxlcyBjb250YWluZXIgaW4gdGhlIERPTS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Q29udGFpbmVyWCgpIHtcbiAgICAvLyBDb252ZXJ0IHRvIHRoZSBmcmFtZSdzIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIHZhciB4ID0gLXRoaXMuZ2V0RnJhbWVYKCk7XG5cbiAgICBpZiAodGhpcy5jeWNsaWNhbF8gJiYgdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHdoaWxlICh4ID4gMCkge1xuICAgICAgICB4IC09IHRoaXMuYWxsVGlsZXNXaWR0aF87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZGlzcGxheU1hcF8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB2aXNpYmxlID0gdGhpcy5kaXNwbGF5TWFwX1tpXTtcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCArPSB0aGlzLmdldFRpbGVXaWR0aChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmcmFtZSB3aGVyZSB0aGUgaG9yaXpvbnRhbCBjZW50ZXIgb2YgdGhlXG4gICAqIHNwZWNpZmllZCB0aWxlIGlzIGFsaWduZWQgd2l0aCB0aGUgY2VudGVyIG9mIHRoZSBmcmFtZS4gVGhlIHBvc2l0aW9uIGlzXG4gICAqIGNvbXB1dGF0ZWQgYmFzZWQgb24gdGhlIGN1cnJlbnQgZnJhbWUgcG9zaXRpb24sIHNvIHRoZSByZWxhdGl2ZSBkaXN0YW5jZVxuICAgKiBzaG91bGQgYmUgc2hvcnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgdGlsZSBpbmRleC5cbiAgICogQHBhcmFtIHs/Ym9vbGVhbj19IG9wdF9tb3ZlRm9yd2FyZCBXaGV0aGVyIHRvIG1vdmUgZm9yd2FyZCBmcm9tIHRoZSBjdXJyZW50XG4gICAqICAgICBmcmFtZSBwb3NpdGlvbi4gT25seSB1c2VkIGZvciBjeWNsaWNhbCBjYXJvdXNlbHMuIChEZWZhdWx0OiB0cnVlKVxuICAgKiBAcGFyYW0gez9ib29sZWFuPX0gb3B0X2ZvcmNlU25hcFRvQ2VudGVyIFdoZXRoZXIgdG8gYWx3YXlzIGdldCB0aGUgdGlsZVxuICAgKiAgICAgc25hcHBlZCB0byB0aGUgY2VudGVyIG9mIHRoZSBmcmFtZSwgb3ZlcnJpZGluZyB0aGUgY2Fyb3VzZWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7P251bWJlcn0gVGhlIGZyYW1lIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0RnJhbWVYU25hcHBlZE9uVGlsZShpbmRleCwgb3B0X21vdmVGb3J3YXJkLCBvcHRfZm9yY2VTbmFwVG9DZW50ZXIpIHtcbiAgICAvLyBLZWVwIHRpbGUgaW5kZXggd2l0aGluIGJvdW5kcy5cbiAgICBpbmRleCA9IE1hdGgubWluKE1hdGgubWF4KGluZGV4LCAwKSwgdGhpcy5nZXRUaWxlc0NvdW50KCkgLSAxKTtcblxuICAgIHZhciBpdGVyYXRvcjtcblxuICAgIGlmICh0aGlzLmN5Y2xpY2FsXykge1xuICAgICAgdmFyIHNuYXBwZWRUaWxlID0gdGhpcy5nZXRTbmFwcGVkVGlsZSgpO1xuICAgICAgaWYgKCFzbmFwcGVkVGlsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdG9yID0gbmV3IFRpbGVJdGVyYXRvcih0aGlzLCBzbmFwcGVkVGlsZSwgaW5kZXgsIG9wdF9tb3ZlRm9yd2FyZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdG9yID0gbmV3IFRpbGVJdGVyYXRvcih0aGlzLCAwLCBpbmRleCk7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lWCA9IDA7XG4gICAgdmFyIHRpbGU7XG4gICAgd2hpbGUgKHRpbGUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWUpIHtcbiAgICAgIGZyYW1lWCA9IHRpbGUueDtcbiAgICB9XG5cbiAgICAvLyBDZW50ZXJpbmcgd2l0aGluIGZyYW1lLlxuICAgIGlmICh0aGlzLnNuYXBUb0NlbnRlcl8gfHwgb3B0X2ZvcmNlU25hcFRvQ2VudGVyKSB7XG4gICAgICBmcmFtZVggKz0gdGhpcy5nZXRUaWxlV2lkdGgoaW5kZXgpIC8gMiAtIHRoaXMuZnJhbWVXaWR0aCAvIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lWDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBjdXJyZW50bHkgc25hcHBlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2ZvcmNlU25hcFRvQ2VudGVyIFdoZXRoZXIgdG8gYWx3YXlzIGdldCB0aGUgdGlsZVxuICAgKiAgICAgc25hcHBlZCB0byB0aGUgY2VudGVyIG9mIHRoZSBmcmFtZSwgb3ZlcnJpZGluZyB0aGUgY2Fyb3VzZWwgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhbWVYIEEgZnJhbWUgcG9zaXRpb24gdG8gdXNlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnRcbiAgICogICAgIG9uZS5cbiAgICogQHJldHVybiB7P1RpbGV8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0U25hcHBlZFRpbGUob3B0X2ZvcmNlU25hcFRvQ2VudGVyLCBvcHRfZnJhbWVYKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lWCA9IChvcHRfZnJhbWVYICE9IHVuZGVmaW5lZCkgPyBvcHRfZnJhbWVYIDogdGhpcy5nZXRGcmFtZVgoKTtcblxuICAgIHZhciB0aWxlO1xuICAgIHZhciBpdGVyYXRvciA9IG5ldyBDb250YWluZWRUaWxlSXRlcmF0b3IodGhpcywgMCwgZnJhbWVYKTtcblxuICAgIC8vIElmIHRoZSBmcmFtZSBpcyBvdXQgb2YgYm91bmRzIG9mIGEgbm9uLWN5Y2xpY2FsIGNhcm91c2VsLCByZXR1cm4gZWl0aGVyXG4gICAgLy8gdGhlIGZpcnN0IG9mIHRoZSBsYXN0IHRpbGUuXG4gICAgaWYgKCF0aGlzLmN5Y2xpY2FsXykge1xuICAgICAgaWYgKGZyYW1lWCA8IHRoaXMuZ2V0TWluRnJhbWVYKCkgfHwgZnJhbWVYID4gdGhpcy5nZXRNYXhGcmFtZVgoKSkge1xuICAgICAgICB2YXIgaW5kZXggPSBmcmFtZVggPCB0aGlzLmdldE1pbkZyYW1lWCgpID8gMCA6IHRoaXMuZ2V0VGlsZXNDb3VudCgpIC0gMTtcbiAgICAgICAgaXRlcmF0b3IgPSBuZXcgVGlsZUl0ZXJhdG9yKHRoaXMsIGluZGV4KTtcbiAgICAgICAgdGlsZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgdGlsZS5vZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodGlsZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZSkge1xuICAgICAgdmFyIGlzU25hcHBlZFRpbGU7XG4gICAgICB2YXIgb2Zmc2V0O1xuICAgICAgdmFyIGxlZnRCb3VuZDtcbiAgICAgIHZhciByaWdodEJvdW5kO1xuICAgICAgdmFyIHNuYXBYID0gZnJhbWVYO1xuXG4gICAgICBpZiAodGhpcy5zbmFwVG9DZW50ZXJfIHx8IG9wdF9mb3JjZVNuYXBUb0NlbnRlcikge1xuICAgICAgICBsZWZ0Qm91bmQgPSB0aWxlLng7XG4gICAgICAgIHJpZ2h0Qm91bmQgPSB0aWxlLnggKyB0aWxlLndpZHRoIC0gMTtcbiAgICAgICAgc25hcFggKz0gdGhpcy5mcmFtZVdpZHRoIC8gMjtcbiAgICAgICAgaXNTbmFwcGVkVGlsZSA9IChzbmFwWCA+PSBsZWZ0Qm91bmQgJiYgc25hcFggPCByaWdodEJvdW5kKTtcbiAgICAgICAgb2Zmc2V0ID0gc25hcFggLSBsZWZ0Qm91bmQgLSAoKHJpZ2h0Qm91bmQgLSBsZWZ0Qm91bmQgKyAxKSAvIDIpO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByaWdodEJvdW5kID0gdGlsZS54ICsgdGlsZS53aWR0aCAvIDI7XG4gICAgICAgIGlmIChmcmFtZVggPj0gMCkge1xuICAgICAgICAgIGlzU25hcHBlZFRpbGUgPSBzbmFwWCA8PSByaWdodEJvdW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlZnRCb3VuZCA9IHRpbGUueCAtIHRpbGUubmV4dFdpZHRoIC8gMjtcbiAgICAgICAgICBpc1NuYXBwZWRUaWxlID0gKHNuYXBYID49IGxlZnRCb3VuZCAmJiBzbmFwWCA8IHJpZ2h0Qm91bmQpO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IHNuYXBYIC0gdGlsZS54O1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTbmFwcGVkVGlsZSkge1xuICAgICAgICB0aWxlLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGZyYW1lIHBvc2l0aW9uIGJhY2sgYmV0d2VlbiAwIGFuZCB0aGUgY3VtdWxhdGl2ZSB3aWR0aCBvZiBhbGxcbiAgICogYXZhaWxhYmxlIHRpbGVzLiBUaGlzIGlzIG9ubHkgdG8gbWFrZSBzdXJlIHRoZSBmcmFtZSBwb3NpdGlvbiBzdGF5cyB3aXRoaW5cbiAgICogcmVhc29uYWJsZSBib3VuZGFyaWVzLCBldmVuIHRob3VnaCB0aGUgdmlzaWJsZSBwb3NpdGlvbiBhbmQgdGlsZXMgd2lsbFxuICAgKiBzdGF5IGlkZW50aWNhbC5cbiAgICogVGhhdCBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IHdoZW4gdGhlIGNhcm91c2VsIGlzIG5vdCBhbmltYXRpbmcsIHRvXG4gICAqIHByZXZlbnQgYW55IHVud2FudGVkIGFuaW1hdGlvbnMgd2hlcmUgdGhlIGNhcm91c2VsIHdvdWxkIGp1bXAgdG8gdGhlIHNhbWVcbiAgICogdmlzaWJsZSBwb3NpdGlvbiBidXQgb25lIGN5Y2xlIGFoZWFkLlxuICAgKi9cbiAgYWRqdXN0RnJhbWVYKCkge1xuICAgIHZhciBjb3JyZWN0ZWRYID0gdGhpcy5nZXRGcmFtZVgoKSAlIHRoaXMuYWxsVGlsZXNXaWR0aF87XG4gICAgdGhpcy5zZXRGcmFtZVgoY29ycmVjdGVkWCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGEgZnJhbWUgcG9zaXRpb24gd291bGQgZXhjZWVkIHRoZSBib3VuZHMgb2YgYSBub24tY3ljbGljYWxcbiAgICogY2Fyb3VzZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IEEgZnJhbWUgcG9zaXRpb24gdG8gdGVzdCBhZ2FpbnN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNGcmFtZVhFeGNlZWRpbmdCb3VuZHMoeCkge1xuICAgIGlmICh0aGlzLmN5Y2xpY2FsXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBtaW4gPSB0aGlzLmdldE1pbkZyYW1lWCgpO1xuICAgIHZhciBtYXggPSB0aGlzLmdldE1heEZyYW1lWCgpO1xuICAgIHJldHVybiB4IDwgbWluIHx8IHggPiBtYXg7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIHRpbGUgYW1vbmcgdGhlIHZpc2libGUgb25lcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSB0aWxlIGluZGV4LlxuICAgKiBAcmV0dXJuIHs/bnVtYmVyfSBUaGUgdmlzaWJsZSBpbmRleCwgb3IgbnVsbCBpZiB0aGUgdGlsZSBpcyBub3QgdmlzaWJsZS5cbiAgICovXG4gIGdldFZpc2libGVJbmRleChpbmRleCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmaXJzdFZpc2libGVUaWxlID0gbnVsbDtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHZpc2libGUgdGlsZSBpbiB0aGUgY3VycmVudCBkaXNwbGF5IG1hcFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmRpc3BsYXlNYXBfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5kaXNwbGF5TWFwX1tpXSA9PSBWaXNpYmlsaXR5LkhJRERFTikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZmlyc3RWaXNpYmxlVGlsZSA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB3aGlsZSAoaW5kZXggPCBmaXJzdFZpc2libGVUaWxlKSB7XG4gICAgICBpbmRleCArPSB0aGlzLnRpbGVXaWR0aHNfLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgdmlzaWJpbGl0eSA9IHRoaXMuZGlzcGxheU1hcF9baW5kZXhdO1xuICAgIGlmICh2aXNpYmlsaXR5ICE9IFZpc2liaWxpdHkuSElEREVOICYmIHZpc2liaWxpdHkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaW5kZXggLSBmaXJzdFZpc2libGVUaWxlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0cyBhIHRpbGUncyB2aXNpYmlsaXR5IHN0YXR1cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbGVJbmRleCBUaGUgdGlsZSBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbGVYIFRoZSB0aWxlIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcmFtZVggQSBmcmFtZSBwb3NpdGlvbiB0byB1c2UgaW5zdGVhZCBvZiB0aGUgY3VycmVudFxuICAgKiAgICAgb25lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfYXBwbHlFeHBhbmQgV2hldGhlciB0byBjaGVjayB2aXNpYmlsaXR5IGluc2lkZSB0aGVcbiAgICogICAgIGV4cGFuZGVkIGZyYW1lIGFyZWEuXG4gICAqIEByZXR1cm4geyFWaXNpYmlsaXR5fVxuICAgKi9cbiAgZ2V0VGlsZVZpc2liaWxpdHkodGlsZUluZGV4LCB0aWxlWCwgb3B0X2ZyYW1lWCwgb3B0X2FwcGx5RXhwYW5kKSB7XG4gICAgdmFyIGZyYW1lWCA9IChvcHRfZnJhbWVYICE9IHVuZGVmaW5lZCkgPyBvcHRfZnJhbWVYIDogdGhpcy5nZXRGcmFtZVgoKTtcbiAgICB2YXIgdGlsZVdpZHRoID0gdGhpcy5nZXRUaWxlV2lkdGgodGlsZUluZGV4KTtcbiAgICBpZiAodGlsZVdpZHRoID09IDApIHtcbiAgICAgIHJldHVybiBWaXNpYmlsaXR5LkhJRERFTjtcbiAgICB9XG5cbiAgICB2YXIgdGlsZUxlZnRYID0gdGlsZVg7XG4gICAgdmFyIHRpbGVSaWdodFggPSB0aWxlTGVmdFggKyB0aWxlV2lkdGggLSAxO1xuICAgIHZhciBmcmFtZUV4cGFuZCA9IChvcHRfYXBwbHlFeHBhbmQgIT0gZmFsc2UpID8gdGhpcy5mcmFtZUV4cGFuZCA6IDA7XG4gICAgdmFyIGZyYW1lTGVmdFggPSBmcmFtZVggLSBmcmFtZUV4cGFuZDtcbiAgICB2YXIgZnJhbWVSaWdodFggPSBmcmFtZVggKyB0aGlzLmZyYW1lV2lkdGggKyBmcmFtZUV4cGFuZDtcblxuICAgIHZhciBmdWxseVZpc2libGUgPSAodGlsZUxlZnRYID49IGZyYW1lTGVmdFgpICYmICh0aWxlUmlnaHRYIDwgZnJhbWVSaWdodFgpO1xuICAgIGlmIChmdWxseVZpc2libGUpIHtcbiAgICAgIHJldHVybiBWaXNpYmlsaXR5LlZJU0lCTEU7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWxseVZpc2libGUgPVxuICAgICAgICAodGlsZUxlZnRYID49IGZyYW1lTGVmdFggJiYgdGlsZUxlZnRYIDwgZnJhbWVSaWdodFgpIHx8XG4gICAgICAgICh0aWxlUmlnaHRYID49IGZyYW1lTGVmdFggJiYgdGlsZVJpZ2h0WCA8IGZyYW1lUmlnaHRYKSB8fFxuICAgICAgICAodGlsZUxlZnRYIDw9IGZyYW1lTGVmdFggJiYgdGlsZVJpZ2h0WCA+PSBmcmFtZVJpZ2h0WCk7XG5cbiAgICByZXR1cm4gcGFydGlhbGx5VmlzaWJsZSA/IFZpc2liaWxpdHkuUEFSVElBTExZIDogVmlzaWJpbGl0eS5ISURERU47XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZS1lbmFibGVzIHByZXZpb3VzbHkgZGlzYWJsZWQgdGlsZXMuXG4gICAqL1xuICBlbmFibGVIaWRkZW5UaWxlcygpIHtcbiAgICBpZiAoIXRoaXMuZ2V0RGlzYWJsZWRUaWxlc18oKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc25hcHBlZFRpbGUgPSB0aGlzLmdldFNuYXBwZWRUaWxlKHRydWUpO1xuICAgIGlmICghc25hcHBlZFRpbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldERpc2FibGVkVGlsZXNfKFtdKTtcblxuICAgIC8vIFJlcGxhY2UgY2Fyb3VzZWwgYXQgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgc2FtZSBmb2N1c2VkIHRpbGU7XG4gICAgdmFyIGZyYW1lWCA9IHRoaXMuZ2V0RnJhbWVYU25hcHBlZE9uVGlsZShzbmFwcGVkVGlsZS5pbmRleCwgbnVsbCwgdHJ1ZSkgK1xuICAgICAgICBzbmFwcGVkVGlsZS5vZmZzZXQ7XG4gICAgdGhpcy5zZXRGcmFtZVgoZnJhbWVYKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIERpc2FibGVzIGFsbCB0aWxlcyBwbGFjZWQgY29udGFpbmVkIGJldHdlZW4gdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudFxuICAgKiBmcmFtZSBhbmQgYW5vdGhlciBvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcmFtZVggVGhlIHBvc2l0aW9uIG9mIHRoZSBvdGhlciBmcmFtZS5cbiAgICovXG4gIGRpc2FibGVIaWRkZW5UaWxlcyhmcmFtZVgpIHtcbiAgICBpZiAoZnJhbWVYID09IHRoaXMuZ2V0RnJhbWVYKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc25hcHBlZFRpbGUgPSB0aGlzLmdldFNuYXBwZWRUaWxlKCk7XG4gICAgaWYgKCFzbmFwcGVkVGlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoaWRkZW5UaWxlcyA9IHRoaXMuZ2V0SGlkZGVuVGlsZXNfKHRoaXMuZ2V0RnJhbWVYKCksIGZyYW1lWCk7XG4gICAgaWYgKCFoaWRkZW5UaWxlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldERpc2FibGVkVGlsZXNfKGhpZGRlblRpbGVzKTtcblxuICAgIC8vIFJlcGxhY2UgY2Fyb3VzZWwgYXQgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgc2FtZSBmb2N1c2VkIHRpbGVcbiAgICBmcmFtZVggPSB0aGlzLmdldEZyYW1lWFNuYXBwZWRPblRpbGUoc25hcHBlZFRpbGUuaW5kZXgpICtcbiAgICAgICAgc25hcHBlZFRpbGUub2Zmc2V0O1xuICAgIHRoaXMuc2V0RnJhbWVYKGZyYW1lWCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCB0aWxlcyBjb250YWluZWQgYmV0d2VlbiB0d28gZnJhbWUgYm91bmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUZyYW1lWCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGZyYW1lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9GcmFtZVggVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgZnJhbWUuXG4gICAqIEByZXR1cm4geyFBcnJheTxudW1iZXI+fSBBIGxpc3Qgb2YgdGlsZSBpbmRleGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SGlkZGVuVGlsZXNfKGZyb21GcmFtZVgsIHRvRnJhbWVYKSB7XG4gICAgdmFyIHRpbGVzID0gW107XG4gICAgdmFyIGl0ZXJhdG9yID0gbmV3IENvbnRhaW5lZFRpbGVJdGVyYXRvcih0aGlzLCBmcm9tRnJhbWVYLCB0b0ZyYW1lWCk7XG4gICAgdmFyIHRpbGU7XG4gICAgd2hpbGUgKHRpbGUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWUpIHtcbiAgICAgIHZhciB2c2IxID0gdGhpcy5nZXRUaWxlVmlzaWJpbGl0eSh0aWxlLmluZGV4LCB0aWxlLngsIGZyb21GcmFtZVgpO1xuICAgICAgdmFyIHZzYjIgPSB0aGlzLmdldFRpbGVWaXNpYmlsaXR5KHRpbGUuaW5kZXgsIHRpbGUueCwgdG9GcmFtZVgpO1xuICAgICAgaWYgKHZzYjEgPT0gVmlzaWJpbGl0eS5ISURERU4gJiYgdnNiMiA9PSBWaXNpYmlsaXR5LkhJRERFTikge1xuICAgICAgICB0aWxlcy5wdXNoKHRpbGUuaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB3aGljaCB0aWxlcyBhcmUgdmlzaWJsZSBpbiB0aGUgZnJhbWUgYW5kIGNyZWF0ZXMgdGhlIGVxdWl2YWxlbnRcbiAgICogZGlzcGxheSBtYXAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVEaXNwbGF5TWFwXygpIHtcbiAgICB0aGlzLmRpc3BsYXlNYXBfLmxlbmd0aCA9IDA7XG4gICAgdmFyIGl0ZXJhdG9yID0gbmV3IFZpc2liaWxpdHlJdGVyYXRvcih0aGlzKTtcbiAgICB2YXIgdGlsZTtcbiAgICB3aGlsZSAodGlsZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZSkge1xuICAgICAgdGhpcy5kaXNwbGF5TWFwXy5wdXNoKHRpbGUudnNiKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsaXN0IG9mIGRpc2FibGVkIHRpbGVzLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8bnVtYmVyPn0gQSBsaXN0IG9mIHRpbGUgaW5kZXhlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERpc2FibGVkVGlsZXNfKCkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkVGlsZXNfO1xuICB9XG5cblxuICAvKipcbiAgICogRGlzYWJsZXMgYSBzZXQgb2YgdGlsZXMuXG4gICAqIEBwYXJhbSB7IUFycmF5PG51bWJlcj59IHRpbGVzIEEgbGlzdCBvZiB0aWxlIGluZGV4ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXREaXNhYmxlZFRpbGVzXyh0aWxlcykge1xuICAgIHRoaXMuZGlzYWJsZWRUaWxlc18gPSB0aWxlcztcbiAgICB0aGlzLmFsbFRpbGVzV2lkdGhfID0gdGhpcy5nZXRBbGxUaWxlc1dpZHRoKCk7XG4gIH1cblxufVxuXG5leHBvcnQge1RpbGVNYXB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvdGlsZW1hcC90aWxlbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtWaXNpYmlsaXR5fSBmcm9tICcuL3Zpc2liaWxpdHknO1xuXG4vKiogQHJlY29yZCAqL1xuZnVuY3Rpb24gVGlsZSgpIHt9XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuVGlsZS5wcm90b3R5cGUuaW5kZXg7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuVGlsZS5wcm90b3R5cGUueDtcblxuLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuVGlsZS5wcm90b3R5cGUud2lkdGg7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cblRpbGUucHJvdG90eXBlLm5leHRXaWR0aDtcblxuLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuVGlsZS5wcm90b3R5cGUub2Zmc2V0O1xuXG4vKiogQHR5cGUge1Zpc2liaWxpdHl8dW5kZWZpbmVkfSAqL1xuVGlsZS5wcm90b3R5cGUudnNiO1xuXG5leHBvcnQge1RpbGV9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvdGlsZW1hcC90aWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUGFyZW50IGNsYXNzIGZvciBWYW5pbGxhIGNvbXBvbmVudHMgYnVpbHQgd2l0aCB0aGUgTURDLVdlYiBhcmNoaXRlY3R1cmUuXG4gKiBGb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9wYWNrYWdlcy9tZGMtYmFzZS9jb21wb25lbnQuanNcbiAqIE1EQy1XZWIgYXJjaGl0ZWN0dXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hcmNoaXRlY3R1cmUubWRcbiAqIEF1dGhvcmluZyBjb21wb25lbnRzOlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICovXG5cblxuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge1Q9fSBmb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgZm91bmRhdGlvbiA9IHVuZGVmaW5lZCwgLi4uYXJncykge1xuICAgIC8qKiBAcHJvdGVjdGVkIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuXG4gICAgLy8gTm90ZSB0aGF0IHdlIGluaXRpYWxpemUgZm91bmRhdGlvbiBoZXJlIGFuZCBub3Qgd2l0aGluIHRoZSBjb25zdHJ1Y3RvcidzXG4gICAgLy8gZGVmYXVsdCBwYXJhbSBzbyB0aGF0XG4gICAgLy8gdGhpcy5yb290XyBpcyBkZWZpbmVkIGFuZCBjYW4gYmUgdXNlZCB3aXRoaW4gdGhlIGZvdW5kYXRpb24gY2xhc3MuXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG5cbiAgICB0aGlzLmZvdW5kYXRpb25fLmluaXQoKTtcbiAgICB0aGlzLmluaXRpYWxTeW5jV2l0aERPTSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlXG4gICAqIGNvbnNpZGVyZWQgcGFydCBvZiBhIFwiY29uc3RydWN0b3JcIi4gRXNzZW50aWFsbHksIGl0IGlzIGEgaG9vayBpbnRvIHRoZVxuICAgKiBwYXJlbnQgY29uc3RydWN0b3IgYmVmb3JlIHRoZSBmb3VuZGF0aW9uIGlzIGluaXRpYWxpemVkLiBBbnkgYWRkaXRpb25hbFxuICAgKiBhcmd1bWVudHMgYmVzaWRlcyByb290IGFuZCBmb3VuZGF0aW9uIHdpbGwgYmUgcGFzc2VkIGluIGhlcmUuXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgaW5pdGlhbGl6ZSguLi5hcmdzKSB7fVxuXG4gIC8qKlxuICAgKiBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZFxuICAgKiBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGUgY29tcG9uZW50LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7VH1cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge31cblxuICAvKipcbiAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0b1xuICAgKiBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET00gb2JqZWN0LiBBbiBleGFtcGxlIG9mIHRoaXMgd291bGQgYmUgYSBmb3JtXG4gICAqIGNvbnRyb2wgd3JhcHBlciB0aGF0IG5lZWRzIHRvIHN5bmNocm9uaXplIGl0cyBpbnRlcm5hbCBzdGF0ZSB0byBzb21lXG4gICAqIHByb3BlcnR5IG9yIGF0dHJpYnV0ZSBvZiB0aGUgaG9zdCBET00uIFBsZWFzZSBub3RlOiB0aGlzIGlzICpub3QqIHRoZVxuICAgKiBwbGFjZSB0byBwZXJmb3JtIERPTSByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpc1xuICAgKiBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuICBpbml0aWFsU3luY1dpdGhET00oKSB7fVxuXG4gIC8qKlxuICAgKiBTdWJjbGFzc2VzIG1heSBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmVsZWFzZSBhbnkgcmVzb3VyY2VzIC8gZGVyZWdpc3RlclxuICAgKiBhbnkgbGlzdGVuZXJzIHRoZXkgaGF2ZSBhdHRhY2hlZC4gQW4gZXhhbXBsZSBvZiB0aGlzIG1pZ2h0IGJlXG4gICAqIGRlcmVnaXN0ZXJpbmcgYSByZXNpemUgZXZlbnQgZnJvbSB0aGUgd2luZG93IG9iamVjdC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuXG4gICAqIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlbiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC5cbiAgICogVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2ZcbiAgICogdGhlIGdpdmVuIHR5cGUsIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7TURDQ29tcG9uZW50fTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL21kYy9jb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7S2V5Q29kZXN9IGZyb20gJy4uLy4uL2dsb2JhbC9jb25zdGFudHMnO1xuXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IFNlbGVjdG9ycyA9IHtcbiAgQUNUSVZFX01PQklMRV9TVUJOQVZfSVRFTTogJy5sYi1tb2JpbGUtbmF2X19zdWJpdGVtLS1hY3RpdmUnLFxuICBBQ1RJVkVfU1VCTkFWX0lURU06ICcubGItbmF2X19zdWJpdGVtLS1hY3RpdmUnLFxuICBIQVNIX0xJTktTOiAnLmxiLWpzLWhhc2gtbGluaycsXG4gIE1FTlVfQlROOiAnLmxiLWpzLW1lbnUtYnRuJyxcbiAgTU9CSUxFX05BVjogJy5sYi1qcy1tb2JpbGUtbmF2JyxcbiAgTU9CSUxFX05BVl9UT0dHTEU6ICcubGItanMtbW9iaWxlLW5hdi10b2dnbGUnLFxuICBOQVZfSVRFTV9XUkFQUEVSOiAnLmxiLWpzLWRlc2t0b3AtbmF2LWl0ZW0td3JhcHBlcicsXG4gIE5BVl9JVEVNUzogJy5sYi1qcy1uYXYtaXRlbScsXG4gIFNVQk5BVjogJy5sYi1qcy1zdWJuYXYnLFxuICBUQUJBQkxFX0VMUzogJ2EsIGJ1dHRvbicsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBDbGFzc2VzID0ge1xuICBBQ1RJVkVfTU9CSUxFX05BVl9JVEVNOiAnbGItbW9iaWxlLW5hdl9faXRlbS0tYWN0aXZlJyxcbiAgQUNUSVZFX05BVl9JVEVNOiAnbGItbmF2X19pdGVtLS1hY3RpdmUnLFxuICBBQ1RJVkVfTU9CSUxFX1NVQk5BVl9JVEVNOiAnbGItbW9iaWxlLW5hdl9fc3ViaXRlbS0tYWN0aXZlJyxcbiAgQUNUSVZFX1NVQk5BVl9JVEVNOiAnbGItbmF2X19zdWJpdGVtLS1hY3RpdmUnLFxuICBIQVNfQUNUSVZFX01PQklMRV9TVUJOQVY6ICdsYi1tb2JpbGUtbmF2X19pdGVtLS1zdWJuYXYtYWN0aXZlJyxcbiAgSEFTX0FDVElWRV9TVUJOQVY6ICdsYi1uYXZfX2l0ZW0tLXN1Ym5hdi1hY3RpdmUnLFxuICBNT0JJTEVfTkFWX0lURU06ICdsYi1tb2JpbGUtbmF2X19pdGVtJyxcbiAgTU9CSUxFX1NVQk5BVl9JVEVNOiAnbGItbW9iaWxlLW5hdl9fc3ViaXRlbScsXG4gIE5BVl9JVEVNOiAnbGItbmF2X19pdGVtJyxcbiAgTkFWX0lURU1fV1JBUFBFUjogJ2xiLW5hdl9faXRlbS13cmFwcGVyJyxcbiAgTkFWX0lURU1fV1JBUFBFUl9GT0NVU0VEOiAnbGItbmF2X19pdGVtLXdyYXBwZXItLWZvY3VzZWQnLFxuICBOT19TQ1JPTEw6ICduby1zY3JvbGwnLFxuICBPUEVORURfTU9CSUxFX05BVjogJ2xiLW1vYmlsZS1uYXYtLW9wZW5lZCcsXG4gIFNVQk5BVl9JVEVNOiAnbGItbmF2X19zdWJpdGVtJyxcbiAgU1VCTkFWX09WRVJGTE9XSU5HX0xFRlQ6ICdsYi1uYXZfX3N1Ym5hdi0tb3ZlcmZsb3dpbmctbGVmdCcsXG4gIFNVQk5BVl9PVkVSRkxPV0lOR19SSUdIVDogJ2xiLW5hdl9fc3VibmF2LS1vdmVyZmxvd2luZy1yaWdodCcsXG4gIFNUSUNLWTogJ2xiLWhlYWRlci0tc3RpY2t5JyxcbiAgU0xJREVfQVdBWTogJ2xiLWhlYWRlci0tc2xpZGUtYXdheScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBBdHRycyA9IHtcbiAgQVJJQV9ISURERU46ICdhcmlhLWhpZGRlbicsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBFdmVudHMgPSB7XG4gIC8vIEV2ZW50cy5cbiAgS0VZVVA6ICdrZXl1cCcsXG4gIE1PVVNFRU5URVI6ICdtb3VzZWVudGVyJyxcbiAgTU9VU0VMRUFWRTogJ21vdXNlbGVhdmUnLFxuICBSRVNJWkU6ICdyZXNpemUnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgS2V5cyA9IEtleUNvZGVzO1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmV4cG9ydCBjb25zdCBOdW1iZXJzID0ge1xuICAvLyBUaGUgYW1vdW50IG9mIHBpeGVscyBhIHVzZXIgbmVlZHMgdG8gc2Nyb2xsIHRvIG1ha2UgdGhlIGhlYWRlciBzaG93L2hpZGUuXG4gIFNMSURFX0FXQVlfU0NST0xMX1RIUkVTSE9MRDogMTAsXG4gIC8vIFRoZSBhbW91bnQgb2YgcGl4ZWxzIGEgdXNlciBuZWVkcyB0byBtb3VzZW1vdmUgdG8gbWFrZSB0aGUgaGVhZGVyIHNob3cuXG4gIFNMSURFX0FXQVlfTU9VU0VNT1ZFX1RIUkVTSE9MRDogMTAwLFxuICAvLyBUaGUgYW1vdW50IG9mIHRpbWUgdG8gbWVhc3VyZSBpZiBhIHVzZXIncyBtb3VzZW1vdmUgcmVhY2hlcyB0aGUgZGlzdGFuY2VcbiAgLy8gZGVmaW5lZCBpbiBTTElERV9BV0FZX01PVVNFTU9WRV9USFJFU0hPTEQgYmVmb3JlIHJlc2V0dGluZy5cbiAgU0xJREVfQVdBWV9NT1VTRU1PVkVfUkVTRVRfVElNRTogNzUwLFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvaGVhZGVyL25hdi9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENSaXBwbGV9IGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUvaW5kZXgnO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGNoZWNrZWQ6IGJvb2xlYW4sXG4gKiAgIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4sXG4gKiAgIGRpc2FibGVkOiBib29sZWFuLFxuICogICB2YWx1ZTogP3N0cmluZ1xuICogfX1cbiAqL1xubGV0IE1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZTtcblxuLyoqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1NlbGVjdGlvbkNvbnRyb2wge1xuICAvKiogQHJldHVybiB7P01EQ1JpcHBsZX0gKi9cbiAgZ2V0IHJpcHBsZSgpIHt9XG59XG5cbmV4cG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlLCBNRENTZWxlY3Rpb25Db250cm9sfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgQ1NTIGN1c3RvbSB2YXJpYWJsZSBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBhcHBseVBhc3NpdmUgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG8gZGV0ZWN0IHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgc3VwcG9ydC5cbiAqIEBwcml2YXRlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8qKlxuICogQHBhcmFtIHshV2luZG93fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRldGVjdEVkZ2VQc2V1ZG9WYXJCdWcod2luZG93T2JqKSB7XG4gIC8vIERldGVjdCB2ZXJzaW9ucyBvZiBFZGdlIHdpdGggYnVnZ3kgdmFyKCkgc3VwcG9ydFxuICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzExNDk1NDQ4L1xuICBjb25zdCBkb2N1bWVudCA9IHdpbmRvd09iai5kb2N1bWVudDtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBub2RlLmNsYXNzTmFtZSA9ICdtZGMtcmlwcGxlLXN1cmZhY2UtLXRlc3QtZWRnZS12YXItYnVnJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAvLyBUaGUgYnVnIGV4aXN0cyBpZiA6OmJlZm9yZSBzdHlsZSBlbmRzIHVwIHByb3BhZ2F0aW5nIHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgLy8gQWRkaXRpb25hbGx5LCBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgbnVsbCBpbiBpZnJhbWVzIHdpdGggZGlzcGxheTogXCJub25lXCIgaW4gRmlyZWZveCxcbiAgLy8gYnV0IEZpcmVmb3ggaXMga25vd24gdG8gc3VwcG9ydCBDU1MgY3VzdG9tIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93T2JqLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGNvbnN0IGhhc1BzZXVkb1ZhckJ1ZyA9IGNvbXB1dGVkU3R5bGUgIT09IG51bGwgJiYgY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BTdHlsZSA9PT0gJ3NvbGlkJztcbiAgbm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIGhhc1BzZXVkb1ZhckJ1Zztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3dPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG5cbiAgY29uc3Qgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSB3aW5kb3dPYmouQ1NTICYmIHR5cGVvZiB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NDY2OVxuICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICBjb25zdCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSAhZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcztcbn1cblxuLy9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbiAqIEBwYXJhbSB7IVdpbmRvdz19IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHtwYXNzaXZlOiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSBIVE1MRWxlbWVudFByb3RvdHlwZVxuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudFByb3RvdHlwZSkge1xuICByZXR1cm4gW1xuICAgICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnbWF0Y2hlcycsXG4gIF0uZmlsdGVyKChwKSA9PiBwIGluIEhUTUxFbGVtZW50UHJvdG90eXBlKS5wb3AoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFFdmVudH0gZXZcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcGFnZU9mZnNldFxuICogQHBhcmFtIHshQ2xpZW50UmVjdH0gY2xpZW50UmVjdFxuICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKGV2LCBwYWdlT2Zmc2V0LCBjbGllbnRSZWN0KSB7XG4gIGNvbnN0IHt4LCB5fSA9IHBhZ2VPZmZzZXQ7XG4gIGNvbnN0IGRvY3VtZW50WCA9IHggKyBjbGllbnRSZWN0LmxlZnQ7XG4gIGNvbnN0IGRvY3VtZW50WSA9IHkgKyBjbGllbnRSZWN0LnRvcDtcblxuICBsZXQgbm9ybWFsaXplZFg7XG4gIGxldCBub3JtYWxpemVkWTtcbiAgLy8gRGV0ZXJtaW5lIHRvdWNoIHBvaW50IHJlbGF0aXZlIHRvIHRoZSByaXBwbGUgY29udGFpbmVyLlxuICBpZiAoZXYudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9IGVsc2Uge1xuICAgIG5vcm1hbGl6ZWRYID0gZXYucGFnZVggLSBkb2N1bWVudFg7XG4gICAgbm9ybWFsaXplZFkgPSBldi5wYWdlWSAtIGRvY3VtZW50WTtcbiAgfVxuXG4gIHJldHVybiB7eDogbm9ybWFsaXplZFgsIHk6IG5vcm1hbGl6ZWRZfTtcbn1cblxuZXhwb3J0IHtzdXBwb3J0c0Nzc1ZhcmlhYmxlcywgYXBwbHlQYXNzaXZlLCBnZXRNYXRjaGVzUHJvcGVydHksIGdldE5vcm1hbGl6ZWRFdmVudENvb3Jkc307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge01EQ0RpYWxvZ30gZnJvbSAnQG1hdGVyaWFsL2RpYWxvZyc7XG5pbXBvcnQge2RlbGVnYXRlfSBmcm9tICdAZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy91dGlscy91dGlscyc7XG5cblxuLyoqXG4gKiBSZXZlYWxzIGFuIE1EQ0RpYWxvZy5cbiAqIEBmaW5hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAcHJpdmF0ZSB7IUFycmF5PCFFbGVtZW50Pn0gKi9cbiAgICB0aGlzLm1vZGFsRWxzXyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tb2RhbF0nKV07XG5cbiAgICAvKiogQHByaXZhdGUgeyFPYmplY3Q8c3RyaW5nLCAhTURDRGlhbG9nPn0gKi9cbiAgICB0aGlzLm1vZGFsc18gPSB7fTtcblxuICAgIC8vIE1ha2VzIGEgbmV3IGluc3RhbmNlIG9mIE1EQ0RpYWxvZyBmb3IgZWFjaCBkZXNpZ25hdGVkIGVsZW1lbnQgYW5kIHNldHNcbiAgICAvLyB0aGVtIGludG8gYW4gb2JqZWN0LlxuICAgIHRoaXMubW9kYWxFbHNfLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICB0aGlzLm1vZGFsc19bZWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsJyldID0gbmV3IE1EQ0RpYWxvZyhlbCk7XG4gICAgfSk7XG5cbiAgICAvLyBTaG93cyB0aGUgdmlkZW8gZGlhbG9nIG9uIGNsaWNrLlxuICAgIGRlbGVnYXRlKGRvY3VtZW50LFxuICAgICAgICAnW2RhdGEtbW9kYWwtdHJpZ2dlcl0nLCAnY2xpY2snLCB0aGlzLnNob3dNb2RhbF8uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gdGFyZ2V0IFRoZSBkaWFsb2cgdHJpZ2dlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNob3dNb2RhbF8odGFyZ2V0KSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzLm1vZGFsc19bdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RhbC10cmlnZ2VyJyldO1xuXG4gICAgbW9kYWwubGFzdEZvY3VzZWRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgbW9kYWwuc2hvdygpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvbW9kYWwvbW9kYWwuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7TURDQ29tcG9uZW50fSBmcm9tICdAbWF0ZXJpYWwvYmFzZSc7XG5pbXBvcnQge0lGUkFNRV9BUElfU1JDLCBTZWxlY3RvcnN9IGZyb20gJy4veXQtcGxheWVyL2NvbnN0YW50cyc7XG5pbXBvcnQge0xCSWZyYW1lQXBpRm91bmRhdGlvbn0gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCB7WVRQbGF5ZXJ9IGZyb20gJy4veXQtcGxheWVyL2luZGV4JztcblxuXG4vKipcbiAqIFBhcmVudCBjbGFzcyB0aGF0IGxvYWRzIHRoZSBZVCBJZnJhbWUgQVBJIGZvciBZVFBsYXllciBjb21wb25lbnRzLlxuICovXG5leHBvcnQgY2xhc3MgTEJJZnJhbWVBcGkgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgWVRJZnJhbWVBcGkuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcm9vdCBUaGUgc2VsZWN0b3Igb2YgdGhlIHBhcmVudCBlbGVtZW50LiBUaGUgcm9vdCB3aWxsIGJlXG4gICAqICAgIHRoZSBkb2N1bWVudCdzIGJvZHkgaWYgbm8gc2VsZWN0b3IgaXMgZ2l2ZW4uXG4gICAqIEByZXR1cm4geyFMQklmcmFtZUFwaX1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290PSdib2R5Jykge1xuICAgIHJldHVybiBuZXcgTEJJZnJhbWVBcGkocm9vdCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUxCSWZyYW1lQXBpRm91bmRhdGlvbn1cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTEJJZnJhbWVBcGlGb3VuZGF0aW9uKHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayBvbiBvbllvdVR1YmVJZnJhbWVBUElSZWFkeSB0byBpbml0aWFsaXplIGEgdmlkZW9cbiAgICogcGxheWVyIGZvciBlYWNoIGNvbXBvbmVudCBwbGF5ZXIgZWxlbWVudC4gT3B0aW9uYWxseSBsb2FkcyB0aGUgWVQgSWZyYW1lXG4gICAqIEFQSSBpZiBpdCdzIG5vdCBhbHJlYWR5IGxvYWRlZC5cbiAgICovXG4gIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCF3aW5kb3cub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHkpIHtcbiAgICAgIHdpbmRvdy5vbllvdVR1YmVJZnJhbWVBUElSZWFkeSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHBsYXllckVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3JzLlBMQVlFUik7XG4gICAgICAgIHBsYXllckVscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBsYXllckVscyk7XG5cbiAgICAgICAgcGxheWVyRWxzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgWVRQbGF5ZXIuYXR0YWNoVG8oZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF3aW5kb3cuWVQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgY29uc3QgZmlyc3RTY3JpcHRUYWcgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG5cbiAgICAgIHRhZy5zcmMgPSBJRlJBTUVfQVBJX1NSQztcbiAgICAgIGZpcnN0U2NyaXB0VGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhZywgZmlyc3RTY3JpcHRUYWcpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy92aWRlby1pZnJhbWUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBJRlJBTUVfQVBJX1NSQyA9ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS9pZnJhbWVfYXBpJztcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5leHBvcnQgY29uc3QgQXR0cnMgPSB7XG4gIEVWRU5UOiAnbGItcGxheWVyLWV2ZW50JyxcbiAgU0VUVElOR1M6ICdsYi1wbGF5ZXItc2V0dGluZ3MnLFxuICBWSURFT19JRDogJ2xiLXZpZGVvLWlkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IFNlbGVjdG9ycyA9IHtcbiAgRVZFTlQ6IGBbJHtBdHRycy5FVkVOVH1dYCxcbiAgUExBWUVSOiAnLmxiLWpzLXZpZGVvLWlmcmFtZScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBKc29uS2V5cyA9IHtcbiAgQ1VFX0lEOiAnY3VlX2lkJyxcbiAgRVZFTlRfVFlQRTogJ2V2ZW50JyxcbiAgUExBWUVSX0lEOiAncGxheWVyX2lkJyxcbn07XG5cbi8qKiBAZW51bSB7IVlULlBsYXllcn0gKi9cbmV4cG9ydCBjb25zdCBZVFBsYXllcnMgPSB7fTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUyA9IHtcbiAgZW5hYmxlanNhcGk6IDEsXG4gIG1vZGVzdGJyYW5kaW5nOiAxLFxuICByZWw6IDAsXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy92aWRlby1pZnJhbWUveXQtcGxheWVyL2NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbmltcG9ydCB7SW5kZXhJdGVyYXRvcn0gZnJvbSAnLi9pbmRleGl0ZXJhdG9yJztcbmltcG9ydCB7SXRlcmFibGVUaWxlTWFwfSBmcm9tICcuL2l0ZXJhYmxldGlsZW1hcCc7XG5pbXBvcnQge1RpbGV9IGZyb20gJy4vdGlsZSc7XG5cblxuLyoqXG4gKiBJdGVyYXRlcyB0aWxlcyBmcm9tIGEgc3RhcnRpbmcgdGlsZSwgZnJvbSBlaXRoZXIgYSB0aWxlIGluZGV4IG9yIHBvc2l0aW9uLFxuICogdXAgdG8gYSBzcGVjaWZpZWQgdGlsZSBpbmRleCBvciBmb3JldmVyLCBpbiBhIGdpdmVuIGRpcmVjdGlvbi5cbiAqL1xuY2xhc3MgVGlsZUl0ZXJhdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHshSXRlcmFibGVUaWxlTWFwfSB0aWxlTWFwIEEgdGlsZSBtYXAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFUaWxlfSBmcm9tVGlsZSBBIHRpbGUgaW5kZXggb3IgYVxuICAgKiAgICAgdGlsZSBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9udW1iZXI9fSBvcHRfdG9UaWxlSW5kZXggVGhlIHRpbGUgaW5kZXggdG8gaXRlcmF0ZSB0by5cbiAgICogQHBhcmFtIHs/Ym9vbGVhbj19IG9wdF9tb3ZlRm9yd2FyZCBXaGV0aGVyIHRvIGl0ZXJhdGUgZm9yd2FyZC5cbiAgICogICAgIChEZWZhdWx0OiB0cnVlKVxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZU1hcCwgZnJvbVRpbGUsIG9wdF90b1RpbGVJbmRleCwgb3B0X21vdmVGb3J3YXJkKSB7XG4gICAgLyoqIEBwcml2YXRlIHshSXRlcmFibGVUaWxlTWFwfSAqL1xuICAgIHRoaXMudGlsZU1hcF8gPSB0aWxlTWFwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSBXaGV0aGVyIHRvIGl0ZXJhdGUgdGlsZXMgZm9yd2FyZC4gKi9cbiAgICB0aGlzLm1vdmVGb3J3YXJkXyA9IChvcHRfbW92ZUZvcndhcmQgIT0gZmFsc2UpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9IFRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCB0aWxlLiAqL1xuICAgIHRoaXMueF8gPSAwO1xuXG4gICAgdmFyIGZyb21UaWxlSW5kZXg7XG4gICAgaWYgKGZyb21UaWxlLnggIT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tVGlsZUluZGV4ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovKGZyb21UaWxlLmluZGV4KTtcbiAgICAgIHRoaXMueF8gPSBmcm9tVGlsZS54O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tVGlsZUluZGV4ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovKGZyb21UaWxlKTtcbiAgICAgIHRoaXMueF8gPSB0aGlzLmdldFN0YXJ0VGlsZVhfKGZyb21UaWxlSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRpbGUgaW5kZXggaXRlcmF0b3IuXG4gICAgICogQHByaXZhdGUgeyFJbmRleEl0ZXJhdG9yfVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhJdGVyYXRvcl8gPSBuZXcgSW5kZXhJdGVyYXRvcihcbiAgICAgICAgdGhpcy50aWxlTWFwXywgZnJvbVRpbGVJbmRleCwgb3B0X3RvVGlsZUluZGV4LCBvcHRfbW92ZUZvcndhcmQpO1xuXG4gICAgLyoqXG4gICAgICogQW5vdGhlciBpbmRleCBpdGVyYXRvciBvbmUgc3RlcCBhaGVhZCBvZiB7QGNvZGUgaW5kZXhJdGVyYXRvcl99LCB1c2VkIHRvXG4gICAgICogYWxzbyBwcm92aWRlIHRoZSB3aWR0aCBvZiB0aGUgbmV4dCB0aWxlLlxuICAgICAqIEBwcml2YXRlIHshSW5kZXhJdGVyYXRvcn1cbiAgICAgKi9cbiAgICB0aGlzLm5leHRJbmRleEl0ZXJhdG9yXyA9IG5ldyBJbmRleEl0ZXJhdG9yKFxuICAgICAgICB0aGlzLnRpbGVNYXBfLCBmcm9tVGlsZUluZGV4LCBvcHRfdG9UaWxlSW5kZXgsIG9wdF9tb3ZlRm9yd2FyZCk7XG5cbiAgICB0aGlzLm5leHRJbmRleEl0ZXJhdG9yXy5uZXh0KCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgaXRlcmF0b3IgdG8gdGhlIG5leHQgdGlsZS5cbiAgICogQHJldHVybiB7IUl0ZXJhdG9yT2JqZWN0fVxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4SXRlcmF0b3JfLm5leHQoKS52YWx1ZTtcbiAgICB2YXIgbmV4dEluZGV4ID0gdGhpcy5uZXh0SW5kZXhJdGVyYXRvcl8ubmV4dCgpLnZhbHVlO1xuICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMudGlsZU1hcF8uZ2V0VGlsZVdpZHRoKGluZGV4KTtcbiAgICAgIHZhciBuZXh0V2lkdGggPSAobmV4dEluZGV4ICE9IHVuZGVmaW5lZCkgP1xuICAgICAgICAgIHRoaXMudGlsZU1hcF8uZ2V0VGlsZVdpZHRoKG5leHRJbmRleCkgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgeCA9IHRoaXMueF87XG4gICAgICB0aGlzLnhfICs9IHRoaXMubW92ZUZvcndhcmRfID8gd2lkdGggOiAtbmV4dFdpZHRoO1xuXG4gICAgICBjb25zdCAvKiogIVRpbGUgKi8gdmFsdWUgPSB7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBuZXh0V2lkdGg6IG5leHRXaWR0aCxcbiAgICAgICAgeDogeCxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlyc3QgdGlsZSBwb3NpdGlvbiB0byBpdGVyYXRlIGZyb20uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgdGlsZSBpbmRleCB0byBzdGFydCBmcm9tLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRTdGFydFRpbGVYXyhpbmRleCkge1xuICAgIHZhciB4O1xuICAgIHZhciB0aWxlTWFwID0gdGhpcy50aWxlTWFwXztcbiAgICBpZiAodGlsZU1hcC5pc0N5Y2xpY2FsKCkpIHtcbiAgICAgIHZhciBjeWNsZXMgPSBNYXRoLmZsb29yKHRpbGVNYXAuZ2V0RnJhbWVYKCkgLyB0aWxlTWFwLmdldEFsbFRpbGVzV2lkdGgoKSk7XG4gICAgICB4ID0gY3ljbGVzICogdGlsZU1hcC5nZXRBbGxUaWxlc1dpZHRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgeCArPSB0aWxlTWFwLmdldFRpbGVXaWR0aChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG4gIH1cblxufVxuXG5cbi8qKlxuICogSXRlcmF0b3Igb2JqZWN0LlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIHZhbHVlOiAoVGlsZXx1bmRlZmluZWQpLFxuICogICBkb25lOiBib29sZWFuXG4gKiB9fVxuICovXG5sZXQgSXRlcmF0b3JPYmplY3Q7XG5cbmV4cG9ydCB7VGlsZUl0ZXJhdG9yfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL3RpbGVtYXAvdGlsZWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBNRUFTVVJJTkc6ICdnbHVlLWlzLW1lYXN1cmluZycsXG4gIFJFQURZOiAnZ2x1ZS1pcy1yZWFkeScsXG4gIFNXSVBJTkc6ICdnbHVlLWlzLXN3aXBpbmcnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBSRVNJWkVfREVMQVk6IDI1MCxcbn07XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3Qgc3dpcGVEaXJlY3Rpb24gPSB7XG4gIFNXSVBFX1JJR0hUOiAnUklHSFQnLFxuICBTV0lQRV9MRUZUOiAnTEVGVCcsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIG51bWJlcnMsIHN3aXBlRGlyZWN0aW9ufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL2NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgQkFOTkVSOiAnLmxiLWJhbm5lcicsXG4gIENMT1NFX0JUTjogJy5sYi1iYW5uZXJfX2Nsb3NlJyxcbiAgU0hPV19FTEVNRU5UOiAnbGItYmFubmVyLS1zaG93Jyxcbn07XG5cbi8qKlxuICogTG9jYWwgc3RvcmFnZSBrZXkgcmVxdWlyZWQgZm9yIGJhbm5lciBvbiB0aGUgc2l0ZS5cbiAqIEBUeXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBsb2NhbFN0b3JhZ2VCYW5uZXJLZXkgPSAnY3JlYXRvcnMtYmFubmVyJztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRvcnMtYmFubmVyL2NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IExCUGxhaW5Db21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9iYXNlL3BsYWluJztcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBEQVRBX1BSRUZJWDogJ2RhdGEtJyxcbiAgU1RPUkVfUkVHSVNURVJfQVRUUjogJ2xiLWF1dG8taW5pdCcsXG59O1xuXG5jb25zdCBsYkF0dHIgPSBgJHtzdHJpbmdzLlNUT1JFX1JFR0lTVEVSX0FUVFJ9YDtcbmNvbnN0IGxiRGF0YUF0dHIgPSBgJHtzdHJpbmdzLkRBVEFfUFJFRklYfSR7c3RyaW5ncy5TVE9SRV9SRUdJU1RFUl9BVFRSfWA7XG5cbi8qKiBAcHJpdmF0ZSBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCBGdW5jdGlvbj59ICovXG5jb25zdCByZWdpc3RyeSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8qKiBAcHJpdmF0ZSBAY29uc3QgeyFXZWFrTWFwfSAqL1xuY29uc3QgY29tcG9uZW50SW5zdGFuY2VzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGNvbXBvbmVudCBuYW1lIGxvb2sgdXAgaW4gdGhlIHJlZ2lzdHJ5IGFuZCBpbnN0YW50aWF0ZXMgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsYXNzLlxuICogQHBhcmFtIHshRWxlbWVudH0gbm9kZVxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNvbXBvbmVudChub2RlKSB7XG4gIC8vIEd1YXJkIGFnYWluc3QgZHVwbGljYXRlIGNvbXBvbmVudCBDdG9yIGluc3RhbnRpYXRpb25zLlxuICAvLyBUT0RPKGNsYXl0b25taXN1cmFAKSBGaW5kIGEgY2xlYW5lciB3YXkgdG8gZG8gdGhpcy5cbiAgaWYgKGNvbXBvbmVudEluc3RhbmNlcy5oYXMobm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGN0b3JOYW1lcyA9IG5vZGUuZ2V0QXR0cmlidXRlKGxiQXR0cikgfHwgbm9kZS5nZXRBdHRyaWJ1dGUobGJEYXRhQXR0cik7XG4gIGlmICghY3Rvck5hbWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAobGItYXV0by1pbml0KSBOb2RlIGRvZXNuJ3QgaGF2ZSBhIHZhbGlkIGF0dHJpYnV0ZSBrZXkuYCk7XG4gIH1cbiAgY3Rvck5hbWVzID0gY3Rvck5hbWVzLnNwbGl0KCcsJyk7XG4gIGlmICghY3Rvck5hbWVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYChsYi1hdXRvLWluaXQpIE5vZGUgZG9lc24ndCBoYXZlIGEgdmFsaWQgYXR0cmlidXRlIHZhbHVlLmApO1xuICB9XG4gIC8vIFRoZSBcImxiLWF1dG8taW5pdFwiIGF0dHJpYnV0ZSB2YWx1ZSBjYW4gaW5jbHVkZWQgTiBudW1iZXIgb2YgY29tbWFcbiAgLy8gc2VwZXJhdGVkIGNvbXBvbmVudCBuYW1lcy0gaW5pdGlhbGl6ZSBlYWNoIG9uZS5cbiAgZm9yIChsZXQgY3Rvck5hbWUgb2YgY3Rvck5hbWVzKSB7XG4gICAgY3Rvck5hbWUgPSBjdG9yTmFtZS50cmltKCk7XG4gICAgaWYgKCFyZWdpc3RyeVtjdG9yTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgKGxiLWF1dG8taW5pdCkgQ291bGQgbm90IGZpbmQgY29uc3RydWN0b3IgaW4gcmVnaXN0cnkgYCArXG4gICAgICAgICAgYGZvciAke2N0b3JOYW1lfWApO1xuICAgIH1cblxuICAgIGxldCBjb21wb25lbnQ7XG4gICAgbGV0IHtDdG9yLCBkZXBzfSA9IHJlZ2lzdHJ5W2N0b3JOYW1lXTtcbiAgICAvLyBTYWZlZ3VhcmQgYWdhaW5zdCBjb21wb25lbnRzIHRoYXQgZG9uJ3QgaGF2ZSBhIHN0YXRpYyBgYXR0YWNoVG9gXG4gICAgLy8gbWV0aG9kIGJ5IGluc3RhbnRpYXRpbmcgdGhlIGNvbnN0cnVjdG9yIGFuZCBjYWxsaW5nIGBuZXdgLlxuICAgIGlmICgnYXR0YWNoVG8nIGluIEN0b3IpIHtcbiAgICAgIGNvbXBvbmVudCA9IEN0b3IuYXR0YWNoVG8obm9kZSwgLi4uZGVwcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudCA9IG5ldyBDdG9yKG5vZGUsIHVuZGVmaW5lZCwgLi4uZGVwcyk7XG4gICAgfVxuXG4gICAgLy8gVG8gZW5zdXJlIGNsYXNzIHByb3BlcnRpZXMgYXNzaWduZWQgaW4gc3ViIGNsYXNzZXMgYXJlbid0IHVuZGVmaW5lZCxcbiAgICAvLyB3ZSdsbCBjYWxsIGBpbml0aWFsaXplYCBhZnRlciB0aGUgY29tcG9uZW50IGNsYXNzIGhhcyBiZWVuIGluc3RhbnRpYXRlZC5cbiAgICBpZiAoY29tcG9uZW50IGluc3RhbmNlb2YgTEJQbGFpbkNvbXBvbmVudCkge1xuICAgICAgY29tcG9uZW50LmluaXRpYWxpemUgJiYgY29tcG9uZW50LmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICBsZXQgaW5zdGFuY2VPYmogPSBjb21wb25lbnRJbnN0YW5jZXMuZ2V0KG5vZGUpIHx8IHt9O1xuICAgIGluc3RhbmNlT2JqW2N0b3JOYW1lXSA9IGNvbXBvbmVudDtcbiAgICBjb21wb25lbnRJbnN0YW5jZXMuc2V0KG5vZGUsIGluc3RhbmNlT2JqKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGNvbXBvbmVudCBjb25zdHJ1Y3RvcnMgZm91bmQgaW4gcmVnaXN0cnkuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudE5vZGUgVGhlIHBhcmVudCBub2RlIHRvIHNlYXJjaCB3aXRoaW4uXG4gKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgIUZ1bmN0aW9uPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGxiQXV0b0luaXQgPSAocGFyZW50Tm9kZSA9IGRvY3VtZW50KSA9PiB7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgKGxiLWF1dG8taW5pdCkgVGhlIHNwZWNpZmllZCBwYXJlbnROb2RlIGRvZXMgbm90IGV4aXN0LmApO1xuICB9O1xuXG4gIGNvbnN0IG5vZGVzID1cbiAgICAgIFsuLi5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoYFske2xiQXR0cn1dYCksXG4gICAgICAuLi5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoYFske2xiRGF0YUF0dHJ9XWApXTtcblxuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBpbnN0YW50aWF0ZUNvbXBvbmVudChub2RlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0Q29tcG9uZW50OiBsYkF1dG9Jbml0LmdldENvbXBvbmVudCxcbiAgICBkZWxldGVJbnN0YW5jZTogbGJBdXRvSW5pdC5kZWxldGVJbnN0YW5jZSxcbiAgICB1bnJlZ2lzdGVyQ29tcG9uZW50OiBsYkF1dG9Jbml0LmRlbGV0ZUluc3RhbmNlLFxuICB9O1xufTtcblxuLyoqXG4gKiBBZGRzIG5ldyBjb21wb25lbnQgd2l0aCBkZXBlbmRlbmNpZXMgdG8gdGhlIHJlZ2lzdHJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBDdG9yXG4gKiBAcGFyYW0gey4uLip9IGRlcHNcbiAqL1xubGJBdXRvSW5pdC5yZWdpc3RlciA9IChuYW1lLCBDdG9yLCAuLi5kZXBzKSA9PiB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAobGItYXV0by1pbml0KSBDb21wb25lbnRzIG11c3QgaGF2ZSBhIG5hbWUgdG8gYmUgcmVnaXN0ZXJlZC5gKTtcbiAgfVxuICByZWdpc3RyeVtuYW1lXSA9IHtDdG9yLCBkZXBzfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVnaXN0cnkuXG4gKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgRnVuY3Rpb24+fVxuICovXG5sYkF1dG9Jbml0LmdldFJlZ2lzdHJ5ID0gKCkgPT4ge1xuICByZXR1cm4gcmVnaXN0cnk7XG59O1xuXG4vKipcbiAqIFVzZXMgYSBET00gZWxlbWVudCB0byByZXRyaWV2ZSBhIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHs/c3RyaW5nfSBjb21wb25lbnROYW1lXG4gKiBAcmV0dXJuIHtMQkNvbXBvbmVudHxudWxsfVxuICovXG5sYkF1dG9Jbml0LmdldENvbXBvbmVudCA9IChlbGVtZW50LCBjb21wb25lbnROYW1lKSA9PiB7XG4gIGlmICghY29tcG9uZW50SW5zdGFuY2VzLmhhcyhlbGVtZW50KSkge1xuICAgIHRyeSB7XG4gICAgICBpbnN0YW50aWF0ZUNvbXBvbmVudChlbGVtZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBjb25zdCBlbGVtZW50RW50cnkgPSBjb21wb25lbnRJbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICAvLyBJZiBhIGNvbXBvbmVudCBuYW1lIHdhcyBwcm92aWRlZCwgcmV0dXJuIHRoYXQgaW5zdGFuY2UuXG4gIC8vIElmIG5vIGNvbXBvbmVudCBuYW1lIHdhcyBwcm92aWRlZCwgcmV0dXJuIHRoZSBmaXJzdCBpbnN0YW5jZS5cbiAgY29uc3QgY29tcG9uZW50RW50cnkgPVxuICAgICAgY29tcG9uZW50TmFtZSA/XG4gICAgICBlbGVtZW50RW50cnlbY29tcG9uZW50TmFtZV0gOlxuICAgICAgZWxlbWVudEVudHJ5W09iamVjdC5rZXlzKGVsZW1lbnRFbnRyeSlbMF1dO1xuXG4gIHJldHVybiBjb21wb25lbnRFbnRyeTtcbn07XG5cbi8qKlxuICogVXNlcyBhIERPTSBlbGVtZW50IHRvIHJldHJpZXZlIGFuIG9iamVjdCBvZiBjb3JyZXNwb25kaW5nIGNvbXBvbmVudCBpbnN0YW5jZXMuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/TEJDb21wb25lbnR9XG4gKi9cbmxiQXV0b0luaXQuZ2V0Q29tcG9uZW50cyA9IChlbGVtZW50KSA9PiB7XG4gIGlmIChjb21wb25lbnRJbnN0YW5jZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpbnN0YW5jZSBmcm9tIHRoZSBjb21wb25lbnQgc3RvcmUgYW5kIGNhbGxzIGBkZXN0cm95YCBtZXRob2RcbiAqIG9uIHRoZSBkZWxldGVkIGluc3RhbmNlLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICovXG5sYkF1dG9Jbml0LmRlbGV0ZUluc3RhbmNlID0gKGVsZW1lbnQpID0+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSBsYkF1dG9Jbml0LmdldENvbXBvbmVudChlbGVtZW50KTtcbiAgY29tcG9uZW50SW5zdGFuY2VzLmRlbGV0ZShlbGVtZW50KTtcbiAgKCdkZXN0cm95JyBpbiBpbnN0YW5jZSkgJiYgaW5zdGFuY2UuZGVzdHJveSgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9hdXRvLWluaXQvYXV0by1pbml0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBQdWJTdWIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshT2JqZWN0PHN0cmluZywgP0FycmF5PD9GdW5jdGlvbj4+fSAqL1xuICAgIHRoaXMuc3Vic2NyaWJlcnNfID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCcm9hZGNhc3RzIGFuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWMgVGhlIHRvcGljIG5hbWUgdG8gYnJvYWRjYXN0LlxuICAgKiBAcGFyYW0geyp9IGRldGFpbCBUaGUgZGV0YWlscyBvZiB0aGUgYnJvYWRjYXN0LlxuICAgKi9cbiAgYnJvYWRjYXN0KHRvcGljLCBkZXRhaWwpIHtcbiAgICBpZiAoIXRoaXMuc3Vic2NyaWJlcnNfW3RvcGljXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3Vic2NyaWJlcnNfW3RvcGljXS5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKGRldGFpbCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzdWJzY3JpYmVyIGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWMgVGhlIHRvcGljIG5hbWUgdG8gYnJvYWRjYXN0LlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gc3Vic2NyaWJlciBUaGUgY2FsbGJhY2sgdG8gdW5yZWdpc3Rlci5cbiAgICovXG4gIHVuc3Vic2NyaWJlKHRvcGljLCBzdWJzY3JpYmVyKSB7XG4gICAgc3Vic2NyaWJlciA9IHN1YnNjcmliZXIudG9TdHJpbmcoKTtcbiAgICB0aGlzLnN1YnNjcmliZXJzX1t0b3BpY10gPVxuICAgICAgICB0aGlzLnN1YnNjcmliZXJzX1t0b3BpY10uZmlsdGVyKChzdWIpID0+IHN1Yi50b1N0cmluZygpICE9PSBzdWJzY3JpYmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3Vic2NyaWJlciB0byB0aGUgcmVnaXN0cnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpYyBUaGUgdG9waWMgbmFtZSB0byBicm9hZGNhc3QuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBzdWJzY3JpYmVyIFRoZSBjYWxsYmFjayB0byB1bnJlZ2lzdGVyLlxuICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gcnVuIHRoZSBzdWJzY3JpYmVyIGNhbGxiYWNrIGluLlxuICAgKi9cbiAgc3Vic2NyaWJlKHRvcGljLCBzdWJzY3JpYmVyLCBjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiB0b3BpYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHRvcGljYCBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIH1cblxuICAgIHRoaXMuc3Vic2NyaWJlcnNfW3RvcGljXSA9IHRoaXMuc3Vic2NyaWJlcnNfW3RvcGljXSB8fCBbXTtcbiAgICB0aGlzLnN1YnNjcmliZXJzX1t0b3BpY10ucHVzaChzdWJzY3JpYmVyLmJpbmQoY29udGV4dCB8fCBzdWJzY3JpYmVyKSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9wdWItc3ViL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQHByaXZhdGUgQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBZVF9PQVVUSF9TQ09QRV8gPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC95b3V0dWJlLnJlYWRvbmx5JztcblxuXG4vKipcbiAqIEdvb2dsZSBzaWduIGluIHdpdGggRmlyZWJhc2UgQXV0aGVudGljYXRpb24gYW5kIFlvdVRVYmUgT2F1dGggcHJvdmlkZXIuIEl0XG4gKiBleHBvc2VzIGNhbGxiYWNrIG1ldGhvZHMgZm9yIGJvdGggc2lnbmluZyBpbiBhbmQgc2lnbmluZyBvdXQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBTZXRzIHVwIFlUIG9hdXRoIHdpdGggRmlyZWJhc2UgbG9naW4uXG4gICAgQXV0aC5GQl9QUk9WSURFUi5hZGRTY29wZShZVF9PQVVUSF9TQ09QRV8pO1xuXG4gICAgLy8gU2V0cyBsYW5ndWFnZSBvZiBvYXV0aCBzY3JlZW4uXG4gICAgQXV0aC5GQl9BVVRILmxhbmd1YWdlQ29kZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nO1xuXG4gICAgdGhpcy5jaGVja0xvZ2luU3RhdHVzXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtcHR5IG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBvbiBzaWduIGluIGFuZCBzaG91bGQgYmUgcmVwbGFjZWQgaW4gYWxsIHBhZ2VzXG4gICAqIHRoYXQgZXh0ZW5kIHRoaXMgY2xhc3MuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gdXNlciBUaGUgdXNlciBkYXRhIHRyZWUgZ2l2ZW4gYnkgRmlyZWJhc2Ugd2hlbiBzaWduZWQgaW4uXG4gICAqL1xuICBvblNpZ25Jbih1c2VyKSB7fVxuXG4gIC8qKlxuICAgKiBFbXB0eSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgb24gc2lnbiBvdXQgYW5kIHNob3VsZCBiZSByZXBsYWNlZCBpbiBhbGwgcGFnZXNcbiAgICogdGhhdCBleHRlbmQgdGhpcyBjbGFzcy5cbiAgICovXG4gIG9uU2lnbk91dCgpIHt9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHVzZXIgaXMgc2lnbmVkIGluIG9yIG5vdCB0aGVuIGZpcmVzIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFjay5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoZWNrTG9naW5TdGF0dXNfKCkge1xuICAgIEF1dGguRkJfQVVUSC5vbkF1dGhTdGF0ZUNoYW5nZWQoKHVzZXIpID0+IHtcbiAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgIHRoaXMub25TaWduSW4odXNlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uU2lnbk91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmlmICh3aW5kb3cuZmlyZWJhc2UpIHtcbiAgLyoqIEBjb25zdCB7IWZpcmViYXNlLmF1dGguQXV0aFByb3ZpZGVyfSAqL1xuICBBdXRoLkZCX1BST1ZJREVSID0gbmV3IHdpbmRvdy5maXJlYmFzZS5hdXRoLkdvb2dsZUF1dGhQcm92aWRlcigpO1xuXG4gIC8qKiBAY29uc3QgeyFmaXJlYmFzZS5hdXRoLkF1dGh9ICovXG4gIEF1dGguRkJfQVVUSCA9IHdpbmRvdy5maXJlYmFzZS5hdXRoKCk7XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSB1c2VyIGluLlxuICAgKi9cbiAgQXV0aC5zaWduSW4gPSAoKSA9PiB7XG4gICAgQXV0aC5GQl9BVVRILnNpZ25JbldpdGhSZWRpcmVjdChBdXRoLkZCX1BST1ZJREVSKTtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhlIHVzZXIgb3V0LlxuICAgKi9cbiAgQXV0aC5zaWduT3V0ID0gKCkgPT4ge1xuICAgIEF1dGguRkJfQVVUSC5zaWduT3V0KCk7XG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Byb3ZpZGVycy9hdXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJpcHBsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBDU1MgdmFyaWFibGVzXG4gKiAtIHBvc2l0aW9uXG4gKiAtIGRpbWVuc2lvbnNcbiAqIC0gc2Nyb2xsIHBvc2l0aW9uXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHVuYm91bmRlZCwgYWN0aXZlIGFuZCBkaXNhYmxlZCBzdGF0ZXNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUFkYXB0ZXIge1xuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzVW5ib3VuZGVkKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlQWN0aXZlKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlRGlzYWJsZWQoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXQgKi9cbiAgY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJOYW1lXG4gICAqIEBwYXJhbSB7P251bWJlcnxzdHJpbmd9IHZhbHVlXG4gICAqL1xuICB1cGRhdGVDc3NWYXJpYWJsZSh2YXJOYW1lLCB2YWx1ZSkge31cblxuICAvKiogQHJldHVybiB7IUNsaWVudFJlY3R9ICovXG4gIGNvbXB1dGVCb3VuZGluZ1JlY3QoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSAqL1xuICBnZXRXaW5kb3dQYWdlT2Zmc2V0KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlQWRhcHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2FkYXB0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB1dGlscyBmcm9tICcuLi9nbG9iYWxzL3V0aWxzJztcbmltcG9ydCBCbG9nIGZyb20gJy4uL2NvbXBvbmVudHMvYmxvZy9ibG9nJztcbmltcG9ydCBNb2RhbCBmcm9tICcuLi9jb21wb25lbnRzL21vZGFsL21vZGFsJztcbmltcG9ydCBTbGlkZXNob3cgZnJvbSAnLi4vY29tcG9uZW50cy9oZXJvL3NsaWRlc2hvdyc7XG5pbXBvcnQgVHdpdHRlckZlZWQgZnJvbSAnLi4vY29tcG9uZW50cy90d2l0dGVyLWZlZWQvdHdpdHRlci1mZWVkJztcbmltcG9ydCBZVENoYW5uZWxTcG90bGlnaHQgZnJvbVxuICAgICcuLi9jb21wb25lbnRzL3l0LWNoYW5uZWwtc3BvdGxpZ2h0L3l0LWNoYW5uZWwtc3BvdGxpZ2h0JztcbmltcG9ydCB7TEJJZnJhbWVBcGl9IGZyb20gJ0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy92aWRlby1pZnJhbWUnO1xuaW1wb3J0IHtMQkdsdWVDYXJvdXNlbH0gZnJvbSAnQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2dsdWUtY2Fyb3VzZWwnO1xuXG5cbi8qKiBAcHJpdmF0ZSBAY29uc3Qge3N0cmluZ30qL1xuY29uc3QgU2VsZWN0b3JzXyA9IHtcbiAgQkxPRzogJy55dC1qcy1ibG9nJyxcbiAgVFdJVFRFUl9GRUVEOiAnLnl0LWpzLXR3aXR0ZXItZmVlZCcsXG4gIFlUX0NIQU5ORUxfQ0FST1VTRUw6ICcubGItanMtY2Fyb3VzZWwnLFxuICBZVF9DSEFOTkVMX1NQT1RMSUdIVDogJy55dC1qcy1jaGFubmVsLXNwb3RsaWdodCcsXG59O1xuXG5cbi8qKlxuICogQ2xhc3MgZm9yIEluZGV4IHBhZ2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4UGFnZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEluaXRpYWxpemUgcGFnZSBjb21wb25lbnRzLlxuICAgIG5ldyBNb2RhbDtcbiAgICBuZXcgU2xpZGVzaG93O1xuICAgIG5ldyBMQklmcmFtZUFwaTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3Qgez9FbGVtZW50fSovXG4gICAgdGhpcy50d2l0dGVyRmVlZEVsXyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3JzXy5UV0lUVEVSX0ZFRUQpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgICB0aGlzLm5vU29jaWFsTG9jYWxlc18gPSBbXTtcblxuICAgIGlmICh0aGlzLnR3aXR0ZXJGZWVkRWxfKSB7XG4gICAgICB0aGlzLm5vU29jaWFsTG9jYWxlc18gPVxuICAgICAgICAgIHRoaXMudHdpdHRlckZlZWRFbF8uZGF0YXNldC5ub1NvY2lhbExvY2FsZXMuc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHs/RWxlbWVudH0qL1xuICAgIHRoaXMuYmxvZ0VsXyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3JzXy5CTE9HKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFFbGVtZW50fSovXG4gICAgdGhpcy55dENoYW5uZWxDYXJvdXNlbF8gPVxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uWVRfQ0hBTk5FTF9DQVJPVVNFTCk7XG5cbiAgICB0aGlzLnl0Q2hhbm5lbFNwb3RsaWdodHNfID1cbiAgICAgICAgWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3JzXy5ZVF9DSEFOTkVMX1NQT1RMSUdIVCldO1xuXG4gICAgLy8gVHdpdHRlciBhbmQgYmxvZyBmZWVkcy5cbiAgICBpZiAodGhpcy50d2l0dGVyRmVlZEVsXyAmJlxuICAgICAgICB0aGlzLm5vU29jaWFsTG9jYWxlc18uaW5kZXhPZih1dGlscy5MQU5HKSA8IDApIHtcbiAgICAgIG5ldyBMQkdsdWVDYXJvdXNlbCh0aGlzLnR3aXR0ZXJGZWVkRWxfKTtcbiAgICAgIG5ldyBUd2l0dGVyRmVlZCh0aGlzLnR3aXR0ZXJGZWVkRWxfKTtcbiAgICAgIG5ldyBCbG9nKHRoaXMuYmxvZ0VsXyk7XG4gICAgfVxuXG4gICAgLy8gWVQgQ2hhbm5lbCBzcG9ydGxpZ2h0LlxuICAgIHRoaXMueXRDaGFubmVsU3BvdGxpZ2h0c18uZm9yRWFjaCgoc3BvdGxpZ2h0KSA9PiB7XG4gICAgICBuZXcgWVRDaGFubmVsU3BvdGxpZ2h0KHNwb3RsaWdodCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy55dENoYW5uZWxTcG90bGlnaHRzXy5sZW5ndGggPiAxKSB7XG4gICAgICBuZXcgTEJHbHVlQ2Fyb3VzZWwodGhpcy55dENoYW5uZWxDYXJvdXNlbF8pO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWdlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4uLy4uL2dsb2JhbHMvdXRpbHMnO1xuXG5cbi8qKiBAcHJpdmF0ZSBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgU2VsZWN0b3JzXyA9IHtcbiAgQ09QWV9FTDogJy55dC1qcy1ibG9nLWNvcHknLFxuICBDVEE6ICcueXQtanMtYmxvZy1jdGEnLFxuICBEQVRFX0VMOiAnLnl0LWpzLWJsb2ctZGF0ZScsXG4gIExJTktfRUw6ICcueXQtanMtYmxvZy1saW5rJyxcbiAgTU9EQUxfQ09QWV9FTDogJy55dC1qcy1ibG9nLW1vZGFsLWNvcHknLFxuICBUSVRMRV9FTDogJy55dC1qcy1ibG9nLXRpdGxlJyxcbn07XG5cbi8qKiBAcHJpdmF0ZSBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgQ2xhc3Nlc18gPSB7XG4gIEhJREU6ICd5dC1oaWRlJyxcbn07XG5cblxuLyoqXG4gKiBHZXRzIGEgYmxvZyBwb3N0IHZpYSBCbG9nZ2VyIEFQSSBhbmQgcG9wdWxhdGVzIERPTSB3aXRoIGEgcG9zdC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAqIEBmaW5hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbG9nIHtcbiAgY29uc3RydWN0b3Iocm9vdCkge1xuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3Qge3N0cmluZ30gKi9cbiAgICB0aGlzLmlkXyA9IHJvb3QuZGF0YXNldC5ibG9nSWQ7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHtzdHJpbmd9ICovXG4gICAgdGhpcy5lbmRwb2ludF8gPVxuICAgICAgICAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYmxvZ2dlci92My9ibG9ncy8nICsgdGhpcy5pZF8gK1xuICAgICAgICAnL3Bvc3RzP2tleT1BSXphU3lBbGxMbUlMVy1pM3NUZVRlaU0wSGU2SGd3YktKNFRYYlkmbWF4UmVzdWx0cz0xJztcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMubGlua0VsXyA9IHJvb3QucXVlcnlTZWxlY3RvcihTZWxlY3RvcnNfLkxJTktfRUwpO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUFycmF5PCFFbGVtZW50Pn0gKi9cbiAgICB0aGlzLnRpdGxlRWxzXyA9IFsuLi5yb290LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3JzXy5USVRMRV9FTCldO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5kYXRlRWxfID0gcm9vdC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uREFURV9FTCk7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmNvcHlFbF8gPSByb290LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3JzXy5DT1BZX0VMKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMubW9kYWxDb3B5RWxfID0gcm9vdC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uTU9EQUxfQ09QWV9FTCk7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmN0YV8gPSByb290LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3JzXy5DVEEpO1xuXG4gICAgdGhpcy5nZXRQb3N0XygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGFuIEhUVFAgcmVxdWVzdCB0byBnZXQgYmxvZyBwb3N0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBvc3RfKCkge1xuICAgIGNvbnN0IGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKGh0dHAucmVhZHlTdGF0ZSA9PSA0ICYmIGh0dHAuc3RhdHVzID09IDIwMCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IEpTT04ucGFyc2UoaHR0cC5yZXNwb25zZVRleHQpO1xuXG4gICAgICAgIC8vIFNldCBsaW5rIHRvIGJsb2cgcG9zdCBvbiBoYW5kbGUuXG4gICAgICAgIHRoaXMubGlua0VsXy5ocmVmID0gcmVzcG9uc2UuaXRlbXNbMF0udXJsO1xuXG4gICAgICAgIC8vIFNob3cgQ1RBLlxuICAgICAgICB0aGlzLmN0YV8uY2xhc3NMaXN0LnJlbW92ZShDbGFzc2VzXy5ISURFKTtcblxuICAgICAgICAvLyBGaWxsIGluIERPTSBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kYXRlXyhyZXNwb25zZSk7XG4gICAgICAgIHRoaXMudGl0bGVfKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5jb3B5XyhyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGh0dHAub3BlbignR0VUJywgdGhpcy5lbmRwb2ludF8sIHRydWUpO1xuICAgIGh0dHAuc2VuZCgpO1xuICB9XG5cbiAgLyoqXG4gICogUmV0dXJucyBhIHN1YnN0cmluZyBvZiB0aGUgZ2l2ZW4gc3RyaW5nIHdpdGggYW5kIGVsbGlwc2lzIGFwcGVuZGVkIHRvIGl0LlxuICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgKiBAcGFyYW0ge251bWJlcn0gY2hhckNvdW50XG4gICogQHJldHVybiB7c3RyaW5nfVxuICAqIEBwcml2YXRlXG4gICovXG4gIGdldFN1YnN0cmluZ18oc3RyLCBjaGFyQ291bnQpIHtcbiAgIGNvbnN0IHN1YnN0cmluZyA9IHN0ci5zdWJzdHJpbmcoMCwgY2hhckNvdW50KTtcblxuICAgaWYgKHN1YnN0cmluZ1tzdWJzdHJpbmcubGVuZ3RoIC0gMV0gPT0gJyAnKSB7XG4gICAgIGNoYXJDb3VudCA9IGNoYXJDb3VudCAtIDE7XG4gICB9XG5cbiAgIHJldHVybiBgJHtzdHIuc3Vic3RyaW5nKDAsIGNoYXJDb3VudCl9Li4uYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaWxscyBpbiBkYXRlIGVsZW1lbnQgd2l0aCBsb2NhbGl6ZWQgZGF0ZS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSByZXNwb25zZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0ZV8ocmVzcG9uc2UpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUocmVzcG9uc2UuaXRlbXNbMF0ucHVibGlzaGVkKTtcblxuICAgIFsuLi50aGlzLmRhdGVFbF8uY2hpbGRyZW5dLmZvckVhY2goKGNoaWxkKSA9PiBjaGlsZC5yZW1vdmUoKSk7XG4gICAgdGhpcy5kYXRlRWxfLmlubmVyVGV4dCA9IHV0aWxzLmxvY2FsaXplRGF0ZShkYXRlLCAnbG9uZycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbGxzIGluIHRpdGxlIGVsZW1lbnRzIHdpdGggYmxvZyBwb3N0IHRpdGxlLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IHJlc3BvbnNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aXRsZV8ocmVzcG9uc2UpIHtcbiAgICBjb25zdCB0aXRsZSA9IHJlc3BvbnNlLml0ZW1zWzBdLnRpdGxlO1xuXG4gICAgdGhpcy50aXRsZUVsc18uZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIFsuLi5lbC5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnJlbW92ZSgpKTtcbiAgICAgIGVsLmlubmVyVGV4dCA9IHRpdGxlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbGxzIGluIGNvcHkgZWxlbWVudHMgd2l0aCBibG9nIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gcmVzcG9uc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvcHlfKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgY29weSA9IHJlc3BvbnNlLml0ZW1zWzBdLmNvbnRlbnQ7XG4gICAgY29uc3QgZnVsbFBvc3QgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChjb3B5KTtcbiAgICBjb25zdCBzaG9ydFBvc3QgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChcbiAgICAgICAgdGhpcy5nZXRTdWJzdHJpbmdfKGNvcHksIDkwMCkpO1xuXG4gICAgWy4uLnRoaXMuY29weUVsXy5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnJlbW92ZSgpKTtcblxuICAgIHRoaXMuY29weUVsXy5hcHBlbmRDaGlsZChzaG9ydFBvc3QpO1xuICAgIHRoaXMubW9kYWxDb3B5RWxfLmFwcGVuZENoaWxkKGZ1bGxQb3N0KTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2Jsb2cvYmxvZy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtkZWxlZ2F0ZX0gZnJvbSAnQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvdXRpbHMvdXRpbHMnO1xuXG5cbi8qKiBAcHJpdmF0ZSBAY29uc3Qge251bWJlcn0gKi9cbmNvbnN0IFNlbGVjdG9yc18gPSB7XG4gIFJBRElPOiAnLnl0LWpzLXNsaWRlc2hvdy1yYWRpbycsXG4gIFNMSURFOiAnLnl0LWpzLXNsaWRlc2hvdy1zbGlkZScsXG4gIFNMSURFU0hPVzogJy55dC1qcy1zbGlkZXNob3cnLFxufTtcblxuLyoqIEBwcml2YXRlIEBjb25zdCB7bnVtYmVyfSAqL1xuY29uc3QgQ2xhc3Nlc18gPSB7XG4gIEFDVElWRV9SQURJTzogJ3NsaWRlc2hvd19fcmFkaW8tLWFjdGl2ZScsXG4gIEFDVElWRV9TTElERTogJ3NsaWRlc2hvd19fc2xpZGUtLWFjdGl2ZScsXG59O1xuXG4vKiogQHByaXZhdGUgQGNvbnN0IHtudW1iZXJ9ICovXG5jb25zdCBUSU1JTkdfID0gNjAwMDtcblxuXG4vKipcbiAqIFV0aWxpemVzIHNldEludGVydmFsKCkgdG8gYWRkIGFuIGBhY3RpdmVgIGNsYXNzIHRvIG9uZSBlbGVtZW50IGluIGEgbGlzdCBhdCBhXG4gKiB0aW1lLiBUaGlzIGFsbG93cyBkZXZlbG9wZXJzIHRvIHN0eWxlIHRoZXNlIGVsZW1lbnRzIGluIGEgbWFubmVyIHRoYXRcbiAqIHZpc3VhbGx5IHJlc2VtYmxlcyBhIHNsaWRlc2hvdy4gVGhlIHVzZXIgY2FuIHN0b3AgdGhlIHNldEludGVydmFsKCkgYnlcbiAqIGNsaWNraW5nIGFueXdoZXJlIGluIHRoZSByb290IGVsZW1lbnQuIEl0IHJlc3VtZXMgb25jZSB0aGUgbW91c2UgbGVhdmVzIHRoZVxuICogcm9vdC5cbiAqIEBmaW5hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGlkZXNob3cge1xuICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3JzXy5TTElERVNIT1cpO1xuXG4gICAgLyoqXG4gICAgICogc2V0SW50ZXJ2YWwuXG4gICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGlvbl8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogRWFjaCBzbGlkZSBjb250YWlucyBhIGhlcm8gY29tcG9uZW50LlxuICAgICAqIEBwcml2YXRlIEBjb25zdCB7IUFycmF5PCFFbGVtZW50Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNsaWRlc18gPSBbLi4udGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yc18uU0xJREUpXTtcblxuICAgIC8qKlxuICAgICAqIFBhZ2luYXRpb24gcmFkaW8gYnV0dG9ucy5cbiAgICAgKiBAcHJpdmF0ZSBAY29uc3QgeyFBcnJheTwhRWxlbWVudD59XG4gICAgICovXG4gICAgdGhpcy5yYWRpb3NfID0gWy4uLnRoaXMucm9vdF8ucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvcnNfLlJBRElPKV07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmlzaWJsZSBzbGlkZSdzIGluZGV4LlxuICAgICAqIEBwcml2YXRlIHshQXJyYXk8IUVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlU2xpZGVJbmRleF8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzc18gPSBmYWxzZTtcblxuICAgIHRoaXMuaW5pdEFuaW1hdGlvbl8oKTtcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnRzXygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlZ2lzdGVyRXZlbnRzXygpIHtcbiAgICAvLyBQYXVzZXMgYW5pbWF0aW9uIG9uIGNsaWNrLlxuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmRlc3Ryb3lfLmJpbmQodGhpcykpO1xuXG4gICAgLy8gUmVzdW1lcyBhbmltYXRpb24gb24gbW91c2VsZWF2ZS5cbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLmluaXRBbmltYXRpb25fLmJpbmQodGhpcykpO1xuXG4gICAgLy8gSGFuZGxlcyBwYWdpbmF0aW9uLlxuICAgIGRlbGVnYXRlKHRoaXMucm9vdF8sXG4gICAgICAgIFNlbGVjdG9yc18uUkFESU8sICdjbGljaycsIHRoaXMuaGFuZGxlUGFnaW5hdGlvbl8uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIHNldEludGVydmFsKCkgYW5pbWF0aW9uLlxuICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgKi9cbiAgaW5pdEFuaW1hdGlvbl8oKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzc18pIHJldHVybjtcblxuICAgIHRoaXMuYW5pbWF0aW9uXyA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZVNsaWRlSW5kZXhfICsgMSA9PT0gdGhpcy5zbGlkZXNfLmxlbmd0aCkge1xuICAgICAgICAvLyBMYXN0IHNsaWRlIGlzIGFjdGl2ZSwgc3RhcnQgc2xpZGVzaG93IGZyb20gYmVnaW5uaW5nLlxuICAgICAgICB0aGlzLmFjdGl2ZVNsaWRlSW5kZXhfID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhdmUgbm90IHlldCByZWFjaGVkIGxhc3Qgc2xpZGUsIHNvIGdvIHRvIG5leHQgb25lLlxuICAgICAgICB0aGlzLmFjdGl2ZVNsaWRlSW5kZXhfKys7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0QWN0aXZlU2xpZGVfKHRoaXMuYWN0aXZlU2xpZGVJbmRleF8pO1xuICAgIH0sIFRJTUlOR18pO1xuXG4gICAgdGhpcy5hbmltYXRpb25JblByb2dyZXNzXyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgc2V0SW50ZXJ2YWwoKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlc3Ryb3lfKCkge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25JblByb2dyZXNzXykgcmV0dXJuO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hbmltYXRpb25fKTtcbiAgICB0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3NfID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgYGFjdGl2ZWAgY2xhc3MgZnJvbSBhbGwgc2xpZGVzIGFuZCBwYWdpbmF0aW9uIHJhZGlvIGJ1dHRvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldEFsbFNsaWRlc18oKSB7XG4gICAgdGhpcy5zbGlkZXNfLmZvckVhY2goKHNsaWRlLCBpKSA9PiB7XG4gICAgICBzbGlkZS5jbGFzc0xpc3QucmVtb3ZlKENsYXNzZXNfLkFDVElWRV9TTElERSk7XG4gICAgICB0aGlzLnJhZGlvc19baV0uY2xhc3NMaXN0LnJlbW92ZShDbGFzc2VzXy5BQ1RJVkVfUkFESU8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGBhY3RpdmVgIGNsYXNzIGZyb20gdGhlIHByZXZpdXMgc2xpZGUgYW5kIHJhZGlvIGFuZCBhZGRzIGl0IHRvXG4gICAqIHRoZSBuZXh0IG9uZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRBY3RpdmVTbGlkZV8oKSB7XG4gICAgdGhpcy5yZXNldEFsbFNsaWRlc18oKTtcblxuICAgIHRoaXMucmFkaW9zX1t0aGlzLmFjdGl2ZVNsaWRlSW5kZXhfXS5jbGFzc0xpc3QuYWRkKENsYXNzZXNfLkFDVElWRV9SQURJTyk7XG4gICAgdGhpcy5zbGlkZXNfW3RoaXMuYWN0aXZlU2xpZGVJbmRleF9dLmNsYXNzTGlzdC5hZGQoQ2xhc3Nlc18uQUNUSVZFX1NMSURFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzd2l0Y2hldHMgdGhlIGFjdGl2ZSBzbGlkZSBpbmRleCB0byB0aGUgdGFyZ2V0J3MgYGRhdGEtaW5kZXhgIGJlZm9yZVxuICAgKiBzZXR0aW5nIHRoZSBhY3RpdmUgc2xpZGUuXG4gICAqIEByZXR1cm4geyFFbGVtZW50fSB0YXJnZXQgVGhlIGNsaWNrZWQgcmFkaW8gYnV0dG9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUGFnaW5hdGlvbl8odGFyZ2V0KSB7XG4gICAgdGhpcy5hY3RpdmVTbGlkZUluZGV4XyA9IHBhcnNlSW50KHRhcmdldC5kYXRhc2V0LmluZGV4LCAxMCk7XG4gICAgdGhpcy5zZXRBY3RpdmVTbGlkZV8oKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2hlcm8vc2xpZGVzaG93LmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vLi4vZ2xvYmFscy91dGlscyc7XG5cblxuLyoqIEBwcml2YXRlIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBTZWxlY3RvcnNfID0ge1xuICBDT1BZX0VMUzogJy55dC1qcy10d2l0dGVyLWZlZWQtY29weScsXG4gIERBVEVfRUxTOiAnLnl0LWpzLXR3aXR0ZXItZmVlZC1wb3N0LWRhdGUnLFxuICBJTUdfRUxTOiAnLnl0LWpzLXR3aXR0ZXItZmVlZC1pbWcnLFxufTtcblxuLyoqIEBwcml2YXRlIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgVEVTVF9GRUVEXyA9ICcvY3JlYXRvcnMvc3RhdGljL2pzb24vdGVzdHMvdHdpdHRlci1mZWVkLXRlc3QuanNvbic7XG5cbi8qKiBAcHJpdmF0ZSBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IFBBVEhfVE9fRkVFRFNfID1cbiAgICAnaHR0cHM6Ly93d3cuZ3N0YXRpYy5jb20vZ29vZ2xlX3NvY2lhbF9mZWVkcy95dF9jcmVhdG9ycy8nO1xuXG4vKiogQHByaXZhdGUgQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IExvY2FsZVNwZWNpZmljTWFwXyA9IHtcbiAgJ2FyJzogJ2FyX2FsbC5qc29uJyxcbiAgJ2RlJzogJ2RlX2FsbC5qc29uJyxcbiAgJ2VuJzogJ2VuX3VzLmpzb24nLFxuICAnZXMnOiAnZXNfYWxsLmpzb24nLFxuICAnZXMtNDE5JzogJ2VzX2FsbC5qc29uJyxcbiAgJ2ZyJzogJ2ZyX2FsbC5qc29uJyxcbiAgJ2l0JzogJ2l0X2FsbC5qc29uJyxcbiAgJ2phJzogJ2phX2FsbC5qc29uJyxcbiAgJ3B0LUJSJzogJ3B0X2FsbC5qc29uJyxcbiAgJ3B0LVBUJzogJ3B0X2FsbC5qc29uJyxcbn07XG5cbi8qKlxuICogUmVnZXhlcyB1c2VkIHRvIHBhcnNlIHRoZSBmZWVkIHJlc3VsdHMuXG4gKiBAcHJpdmF0ZSBAZW51bSB7UmVnRXhwfVxuICovXG5jb25zdCBSZWdleF8gPSB7XG4gIC8vIEhBU0hUQUcgcmVnZXggaGFzIGEgbWF0Y2ggZm9yICcmJyBhcyBhIHN1cnJvZ2F0ZSBmb3IgbmVnYXRpdmUgbG9va2JlaGluZC5cbiAgLy8gRml4ZXMgYW4gaXNzdWUgd2hlcmUgZW5jb2RlZCBjaGFyYWN0ZXJzIGdvdCBtYXRjaGVkIGFzIGhhc2h0YWdzIGVnLiAmIzEyMztcbiAgSEFTSFRBRzogLygmKT8jKFxcdyspL2csXG4gIExJTks6IC9odHRwczpcXC9cXC90LmNvXFwvPyhcXHcrKS9nLFxuICBVU0VSOiAvQChcXHcrKS9nLFxufTtcblxuLyoqIEBwcml2YXRlIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBMaW5rc18gPSB7XG4gIEhBU0hUQUc6ICc8YSBocmVmPVwiaHR0cHM6Ly90d2l0dGVyLmNvbS9oYXNodGFnLyQyXCIgdGFyZ2V0PVwiX2JsYW5rXCIgJyArXG4gICAgICAgICAgICdyZWw9XCJub3JlZmVycmVyIG5vb3BlbmVyIG5vZm9sbG93XCI+IyQyPC9hPicsXG4gIExJTks6ICc8YSBocmVmPVwiaHR0cHM6Ly90LmNvLyQxXCIgdGFyZ2V0PVwiX2JsYW5rXCIgJyArXG4gICAgICAgICdyZWw9XCJub3JlZmVycmVyIG5vb3BlbmVyIG5vZm9sbG93XCI+aHR0cHM6Ly90LmNvLyQxPC9hPjxicj4nLFxuICBVU0VSOiAnPGEgaHJlZj1cImh0dHBzOi8vdHdpdHRlci5jb20vJDFcIiB0YXJnZXQ9XCJfYmxhbmtcIiAnICtcbiAgICAgICAgJ3JlbD1cInJlbD1cIm5vcmVmZXJyZXIgbm9vcGVuZXIgbm9mb2xsb3dcIj5AJDE8L2E+Jyxcbn07XG5cblxuLyoqXG4gKiBQdWxscyBZb3VUdWJlIENyZWF0b3JzIFR3aXR0ZXIgZmVlZHMgZnJvbSBCcmFuZCBTdHVkaW8ncyBzb2NpYWwgYWdncmVnYXRvclxuICogYW5kIHBvcHVsYXRlcyB0aGUgRE9NIHdpdGggdGhlIHJlc3BvbnNlLlxuICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3aXR0ZXJGZWVkIHtcbiAgY29uc3RydWN0b3Iocm9vdCkge1xuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgKi9cbiAgICB0aGlzLmNhcm91c2VsXyA9IHJvb3Q7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshSUFycmF5TGlrZTwhRWxlbWVudD59ICovXG4gICAgdGhpcy5kYXRlRWxzXyA9IFsuLi50aGlzLmNhcm91c2VsXy5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yc18uREFURV9FTFMpXTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFJQXJyYXlMaWtlPCFFbGVtZW50Pn0gKi9cbiAgICB0aGlzLmltZ0Vsc18gPSBbLi4udGhpcy5jYXJvdXNlbF8ucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvcnNfLklNR19FTFMpXTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFJQXJyYXlMaWtlPCFFbGVtZW50Pn0gKi9cbiAgICB0aGlzLmNvcHlFbHNfID0gWy4uLnRoaXMuY2Fyb3VzZWxfLnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3JzXy5DT1BZX0VMUyldO1xuXG4gICAgdGhpcy5nZXRQb3N0c18oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhbiBIVFRQIHJlcXVlc3QgdG8gdGhlIHNvY2lhbC1mZWVkLWFnZ3JlZ2F0b3ItZ2VuZXJhdGVkIFR3aXR0ZXIgSlNPTlxuICAgKiBmaWxlIGhvc3RlZCBvbiBnc3RhdGljLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UG9zdHNfKCkge1xuICAgIGNvbnN0IGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBsZXQganNvblRleHQ7XG4gICAgbGV0IGVuZHBvaW50O1xuXG4gICAgaHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoaHR0cC5yZWFkeVN0YXRlID09IDQgJiYgaHR0cC5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgIC8vIEV4Y2x1ZGVzIEpTT05QIGNhbGxiYWNrIGNoYXJhY3RlcyBhdCBiZWdpbm5pbmcgb2YgcmVzcG9uc2VUZXh0LlxuICAgICAgICBqc29uVGV4dCA9IGh0dHAucmVzcG9uc2VUZXh0LnN1YnN0cmluZyg2LCBodHRwLnJlc3BvbnNlVGV4dC5sZW5ndGgpO1xuXG4gICAgICAgIEpTT04ucGFyc2UoanNvblRleHQpLmZlZWRzWzBdLnBvc3RzLmZvckVhY2goKHBvc3QsIGkpID0+IHtcbiAgICAgICAgICB0aGlzLmRhdGVfKHBvc3QsIGkpO1xuICAgICAgICAgIHRoaXMuY29weV8ocG9zdCwgaSk7XG4gICAgICAgICAgdGhpcy5pbWdfKHBvc3QsIGkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZW5kcG9pbnQgPSBURVNUX0ZFRURfO1xuXG4gICAgaWYgKCF1dGlscy5JU19ERVYpIHtcbiAgICAgIC8vIElzIHByb2R1Y3Rpb24sIHNvIHVzZSByZWFsIGVuZHBvaW50LlxuICAgICAgZW5kcG9pbnQgPSBgJHtQQVRIX1RPX0ZFRURTX30ke0xvY2FsZVNwZWNpZmljTWFwX1t1dGlscy5MQU5HXX1gO1xuXG4gICAgICBpZiAoIUxvY2FsZVNwZWNpZmljTWFwX1t1dGlscy5MQU5HXSkge1xuICAgICAgICBlbmRwb2ludCA9IGAke1BBVEhfVE9fRkVFRFNffSR7TG9jYWxlU3BlY2lmaWNNYXBfLmVufWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaHR0cC5vcGVuKCdHRVQnLCBlbmRwb2ludCwgdHJ1ZSk7XG4gICAgaHR0cC5zZW5kKCk7XG4gIH1cblxuICAvKipcbiAgICogRmlsbHMgaW4gZGF0ZSBlbGVtZW50cyB3aXRoIGxvY2FsaXplZCBkYXRlLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IHBvc3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGVfKHBvc3QsIGkpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUocGFyc2VJbnQocG9zdC5jcmVhdGVkX2F0LCAxMCkpLnRvU3RyaW5nKCk7XG5cbiAgICBbLi4udGhpcy5kYXRlRWxzX1tpXS5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnJlbW92ZSgpKTtcbiAgICB0aGlzLmRhdGVFbHNfW2ldLmlubmVyVGV4dCA9IHV0aWxzLmxvY2FsaXplRGF0ZShkYXRlLCAnbG9uZycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbGxzIGluIGNvcHkgZWxlbWVudHMgd2l0aCBwYXJzZWQgY29udGVudC5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBwb3N0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb3B5Xyhwb3N0LCBpKSB7XG4gICAgY29uc3QgcGFyc2VkQ29weSA9IHRoaXMucGFyc2VDb3B5Xyhwb3N0LmNvbnRlbnQpO1xuICAgIGNvbnN0IHRleHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQocGFyc2VkQ29weSk7XG5cbiAgICB0ZXh0RWwuYXBwZW5kQ2hpbGQodGV4dCk7XG5cbiAgICBbLi4udGhpcy5jb3B5RWxzX1tpXS5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnJlbW92ZSgpKTtcbiAgICB0aGlzLmNvcHlFbHNfW2ldLmFwcGVuZENoaWxkKHRleHRFbCk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIHdpdGggdGhlIGFwcHJvcHJpYXRlIGFuY2hvciB0YWdcbiAgICogYmFzZWQgb24gdGhlIGdpdmVuIHJlZ2V4IGJlZm9yZSByZXR1cm5pbmcgdGhlIG5ldyBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IFBvc3QgY29weS5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcGFyc2VDb3B5Xyhjb3B5KSB7XG4gICAgY29uc3Qgd2l0aFVzZXJMaW5rcyA9IGNvcHkucmVwbGFjZShSZWdleF8uVVNFUiwgTGlua3NfLlVTRVIpO1xuICAgIGNvbnN0IHdpdGhMaW5rcyA9IHdpdGhVc2VyTGlua3MucmVwbGFjZShSZWdleF8uTElOSywgTGlua3NfLkxJTkspO1xuICAgIGNvbnN0IHdpdGhIYXNodGFnc0xpbmtzID0gd2l0aExpbmtzLnJlcGxhY2UoUmVnZXhfLkhBU0hUQUcsIExpbmtzXy5IQVNIVEFHKTtcbiAgICByZXR1cm4gd2l0aEhhc2h0YWdzTGlua3M7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBiYWNrZ3JvdW5kIGltYWdlIG9mIGltYWdlIGVsZW1lbnRzIHdpdGggdGhlIHBvc3RzJyBpbWFnZXMuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gcG9zdFxuICAgKiBAcGFyYW0ge251bWJlcn0gaVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW1nXyhwb3N0LCBpKSB7XG4gICAgdGhpcy5pbWdFbHNfW2ldLmhyZWYgPSBwb3N0LnVybDtcblxuICAgIGlmIChwb3N0Lm1lZGlhICYmIHBvc3QubWVkaWEuaW1hZ2VzKSB7XG4gICAgICBjb25zdCBpbWFnVXJsID0gcG9zdC5tZWRpYS5pbWFnZXNbMF0udXJsO1xuICAgICAgdGhpcy5pbWdFbHNfW2ldLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJyArIGltYWdVcmwgKyAnKSc7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvdHdpdHRlci1mZWVkL3R3aXR0ZXItZmVlZC5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4uLy4uL2dsb2JhbHMvdXRpbHMnO1xuXG5cbi8qKiBAcHJpdmF0ZSBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgU2VsZWN0b3JzXyA9IHtcbiAgQ0hBTk5FTF9USVRMRV9FTDogJy55dC1qcy1jaGFubmVsLXRpdGxlJyxcbiAgQ09QWV9FTDogJy55dC1qcy1jaGFubmVsLWNvcHknLFxuICBEQVRFX0VMOiAnLnl0LWpzLWNoYW5uZWwtZGF0ZScsXG4gIFZJREVPX0lGUkFNRTogJy55dC1qcy1jaGFubmVsLXZpZGVvJyxcbiAgVklERU9fVElUTEVfRUw6ICcueXQtanMtY2hhbm5lbC1oZWFkbGluZScsXG59O1xuXG4vKiogQHByaXZhdGUgQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBZVF9EQVRBX0VORFBPSU5UXyA9XG4gICAgJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL3lvdXR1YmUvdjMvYWN0aXZpdGllcycgK1xuICAgICc/a2V5PUFJemFTeUFsbExtSUxXLWkzc1RlVGVpTTBIZTZIZ3diS0o0VFhiWScgK1xuICAgICcmcGFydD1zbmlwcGV0LGNvbnRlbnREZXRhaWxzJyArXG4gICAgJyZtYXhSZXN1bHRzPTEnICtcbiAgICAnJmNoYW5uZWxJZD0nO1xuXG5cbi8qKlxuICogR2V0cyB0aGUgbW9zdCByZWNlbnQgWW91VHViZSB2aWRlbyBmcm9tIGEgY2hhbm5lbCBhbmQgZGlzcGxheXMgaXQgb24gdGhlIERPTS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAqIEBmaW5hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBZVENoYW5uZWxTcG90bGlnaHQge1xuICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7c3RyaW5nfSAqL1xuICAgIHRoaXMuY2hhbm5lbElEXyA9IHJvb3QuZGF0YXNldC5jaGFubmVsSWQ7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmNoYW5uZWxUaXRsZUVsXyA9IHJvb3QucXVlcnlTZWxlY3RvcihTZWxlY3RvcnNfLkNIQU5ORUxfVElUTEVfRUwpO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5jb3B5RWxfID0gcm9vdC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uQ09QWV9FTCk7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmRhdGVFbF8gPSByb290LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3JzXy5EQVRFX0VMKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMudmlkZW9JZnJhbWVfID0gcm9vdC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uVklERU9fSUZSQU1FKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMudmlkZW9UaXRsZUVsXyA9IHJvb3QucXVlcnlTZWxlY3RvcihTZWxlY3RvcnNfLlZJREVPX1RJVExFX0VMKTtcblxuICAgIHRoaXMuZ2V0Q2hhbm5lbERhdGFfKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjaGFubmVsIGRhdGEgdmlhIFlUIERhdGEgQVBJLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q2hhbm5lbERhdGFfKCkge1xuICAgIGNvbnN0IGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChodHRwLnJlYWR5U3RhdGUgPT0gNCAmJiBodHRwLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBKU09OLnBhcnNlKGh0dHAucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgY29uc3Qgc25pcHBldCA9IHJlc3BvbnNlLml0ZW1zWzBdLnNuaXBwZXQ7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSByZXNwb25zZS5pdGVtc1swXS5jb250ZW50RGV0YWlscztcblxuICAgICAgICBpZiAocmVzcG9uc2UuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgdmlkZW9JRCA9IGRldGFpbHMudXBsb2FkID8gZGV0YWlscy51cGxvYWQudmlkZW9JZCA6XG4gICAgICAgICAgICAgIGRldGFpbHMucGxheWxpc3RJdGVtLnJlc291cmNlSWQudmlkZW9JZDtcblxuICAgICAgICAgIHRoaXMudmlkZW9fKHZpZGVvSUQpO1xuICAgICAgICAgIHRoaXMuY2hhbm5lbFRpdGxlXyhzbmlwcGV0LmNoYW5uZWxUaXRsZSk7XG4gICAgICAgICAgdGhpcy5kYXRlXyhzbmlwcGV0LnB1Ymxpc2hlZEF0KTtcbiAgICAgICAgICB0aGlzLnZpZGVvVGl0bGVfKHNuaXBwZXQudGl0bGUpO1xuICAgICAgICAgIHRoaXMuY29weV8oc25pcHBldC5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGh0dHAub3BlbignR0VUJywgWVRfREFUQV9FTkRQT0lOVF8gKyB0aGlzLmNoYW5uZWxJRF8sIHRydWUpO1xuICAgIGh0dHAuc2VuZCgpO1xuICB9XG5cbiAgLyoqXG4gICogUmV0dXJucyBhIHN1YnN0cmluZyBvZiB0aGUgZ2l2ZW4gc3RyaW5nIHdpdGggYW5kIGVsbGlwc2lzIGFwcGVuZGVkIHRvIGl0LlxuICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgKiBAcGFyYW0ge251bWJlcn0gY2hhckNvdW50XG4gICogQHJldHVybiB7c3RyaW5nfVxuICAqIEBwcml2YXRlXG4gICovXG4gIGdldFN1YnN0cmluZ18oc3RyLCBjaGFyQ291bnQpIHtcbiAgIGNvbnN0IHN1YnN0cmluZyA9IHN0ci5zdWJzdHJpbmcoMCwgY2hhckNvdW50KTtcblxuICAgaWYgKHN1YnN0cmluZ1tzdWJzdHJpbmcubGVuZ3RoIC0gMV0gPT0gJyAnKSB7XG4gICAgIGNoYXJDb3VudCA9IGNoYXJDb3VudCAtIDE7XG4gICB9XG5cbiAgIHJldHVybiBgJHtzdHIuc3Vic3RyaW5nKDAsIGNoYXJDb3VudCl9Li4uYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIFlvdVR1YmUgdmlkZW8gaWZyYW1lIHdpdGggdGhlIGdpdmVuIElEIGFuZCBhcHBlbmRzIGl0IHRvIHRoZVxuICAgKiB2aWRlbyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9JRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmlkZW9fKHZpZGVvSUQpIHtcbiAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblxuICAgIGlmcmFtZS5jbGFzc0xpc3QuYWRkKCdsYi1wbGF5ZXJfX3ZpZGVvJyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnZnJhbWVib3JkZXInLCAnMCcpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FsbG93ZnVsbHNjcmVlbicsIHRydWUpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ1lUIFBsYXllciBJZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWZyYW1lLnNyYyA9IGBodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8ke3ZpZGVvSUR9L2A7XG5cbiAgICB0aGlzLnZpZGVvSWZyYW1lXy5xdWVyeVNlbGVjdG9yKCdpZnJhbWUnKS5yZW1vdmUoKTtcbiAgICB0aGlzLnZpZGVvSWZyYW1lXy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbGxzIGluIHRoZSBjaGFubmVsIHRpdGxlIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFRpdGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjaGFubmVsVGl0bGVfKGNoYW5uZWxUaXRsZSkge1xuICAgIFsuLi50aGlzLmNoYW5uZWxUaXRsZUVsXy5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnJlbW92ZSgpKTtcbiAgICB0aGlzLmNoYW5uZWxUaXRsZUVsXy5pbm5lclRleHQgPSBjaGFubmVsVGl0bGU7XG4gICAgdGhpcy5jaGFubmVsVGl0bGVFbF8uaHJlZiA9XG4gICAgICAgIGBodHRwczovL3d3dy55b3V0dWJlLmNvbS9jaGFubmVsLyR7dGhpcy5jaGFubmVsSURffS9gO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbGxzIGluIGRhdGUgZWxlbWVudCB3aXRoIGxvY2FsaXplZCBkYXRlLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IHJlc3BvbnNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkYXRlXyhwdWJEYXRlKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHB1YkRhdGUpO1xuXG4gICAgWy4uLnRoaXMuZGF0ZUVsXy5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnJlbW92ZSgpKTtcbiAgICB0aGlzLmRhdGVFbF8uaW5uZXJUZXh0ID0gdXRpbHMubG9jYWxpemVEYXRlKGRhdGUsICdsb25nJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlsbHMgaW4gdGhlIHZpZGVvIHRpdGxlIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9UaXRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmlkZW9UaXRsZV8odmlkZW9UaXRsZSkge1xuICAgIFsuLi50aGlzLnZpZGVvVGl0bGVFbF8uY2hpbGRyZW5dLmZvckVhY2goKGNoaWxkKSA9PiBjaGlsZC5yZW1vdmUoKSk7XG4gICAgdGhpcy52aWRlb1RpdGxlRWxfLmlubmVyVGV4dCA9IHZpZGVvVGl0bGU7XG4gIH1cblxuICAvKipcbiAgICogRmlsbHMgaW4gdGhlIGNvcHkgZWxlbWVudCB3aXRoIGEgc3Vic3RyaW5nIG9mIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb3B5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb3B5Xyhjb3B5KSB7XG4gICAgWy4uLnRoaXMuY29weUVsXy5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnJlbW92ZSgpKTtcbiAgICB0aGlzLmNvcHlFbF8uaW5uZXJUZXh0ID0gdGhpcy5nZXRTdWJzdHJpbmdfKGNvcHksIDE1MCk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy95dC1jaGFubmVsLXNwb3RsaWdodC95dC1jaGFubmVsLXNwb3RsaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtsaXN0cywgc3RyaW5ncywgcmV9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHN1cGVyY2xhc3MgYW5kIGNyZWF0ZXMgYSBuZXcgc3ViY2xhc3MgZnJvbSBpdC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gc3VwZXJDbGFzc1xuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGxiQ2xhc3NNaXhpbiA9IChzdXBlckNsYXNzKSA9PiB7XG4gIHJldHVybiBjbGFzcyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc3R5bGUgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHRyYW5zZm9ybSBzdHlsZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgKj59IHN0eWxlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjc3NTdHlsZXNDb250YWluVHJhbnNmb3JtXyhzdHlsZSkge1xuICAgICAgcmV0dXJuIChsaXN0cy5UUkFOU0ZPUk1TLmluZGV4T2Yoc3R5bGUpICE9PSAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgdHJhbnNmb3JtIHZhbHVlIGNodW5rcyBpbnRvIGEgdmFsaWQgQ1NTIHRyYW5zZm9ybSB2YWx1ZVxuICAgICAqIGFuZCBhcHBlbmRzIHRoZW0gaW50byBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAqPn0gc3R5bGVzXG4gICAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gdHJhbnNmb3Jtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgY29tYmluZVRyYW5zZm9ybVZhbHVlc18oc3R5bGVzLCB0cmFuc2Zvcm1zLCBzdHlsZSkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtU3RyaW5nID0gYCR7c3R5bGV9KCR7c3R5bGVzW3N0eWxlXX0pYDtcbiAgICAgIHRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm1TdHJpbmcpO1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGFueSB0cmFuc2Zvcm0gdmFsdWVzIGludG8gYSB2YWxpZCB0cmFuc2Zvcm0gc3RyaW5nLlxuICAgICAqIGUuZyBgc2NhbGVZOiAuNWAsIGB0cmFuc2xhdGVYOiA1MHB4YCBpbnRvXG4gICAgICogYHRyYW5zZm9ybTogc2NhbGVZKC41KSB0cmFuc2xhdGVYKDUwcHgpYFxuICAgICAqIGFuZCBhcHBlbmRzIHRoZW0gaW50byBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAqPn0gc3R5bGVzXG4gICAgICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsICo+fVxuICAgICAqL1xuICAgIGZsYXR0ZW5UcmFuc2Zvcm1TdHlsZXNfKHN0eWxlcykge1xuICAgICAgLy8gRmluZCBhbGwgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgaW4gb3VyIHN0eWxlcyBvYmplY3QuXG4gICAgICBjb25zdCB0cmFuc2Zvcm1TdHlsZXMgPSBPYmplY3Qua2V5cyhzdHlsZXMpXG4gICAgICAgICAgLmZpbHRlcih0aGlzLmNzc1N0eWxlc0NvbnRhaW5UcmFuc2Zvcm1fLmJpbmQodGhpcykpO1xuXG4gICAgICBjb25zdCB0cmFuc2Zvcm1TdHlsZVN0cmluZyA9IHRyYW5zZm9ybVN0eWxlc1xuICAgICAgICAgIC5yZWR1Y2UodGhpcy5jb21iaW5lVHJhbnNmb3JtVmFsdWVzXy5iaW5kKHRoaXMsIHN0eWxlcyksIFtdKVxuICAgICAgICAgIC5qb2luKCcgJyk7XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgdHJhbnNmb3JtIHZhbHVlcyBzbyB0aGV5IGRvbid0IGdldCB3cml0dGVuXG4gICAgICAvLyB0byB0aGUgRE9NIHR3aWNlLlxuICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgICB0aGlzLmNzc1N0eWxlc0NvbnRhaW5UcmFuc2Zvcm1fKHN0eWxlKSAmJiAoZGVsZXRlIHN0eWxlc1tzdHlsZV0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRyYW5zZm9ybVN0eWxlU3RyaW5nO1xuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGVzLCB7dHJhbnNmb3JtfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfVxuXG4gICAvKipcbiAgICAgKiBQYXJzZSByb290IGVsZW1lbnQncyBgZGF0YS1sYi08Y29tcG9uZW50Pi1vcHRpb25zYCBvclxuICAgICAqICAgYGxiLTxjb21wb25lbnQ+LW9wdGlvbnNgIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZGVmYXVsdE9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgKj59XG4gICAgICovXG4gICAgcGFyc2VPcHRpb25zU3RyaW5nKGNvbXBvbmVudE5hbWUsIGRlZmF1bHRPcHRpb25zID0ge30pIHtcbiAgICAgIGNvbnN0IG5hbWVkT3B0aW9uc0tleSA9IGBkYXRhLWxiLSR7Y29tcG9uZW50TmFtZX0tb3B0aW9uc2A7XG4gICAgICBjb25zdCBuYW1lZE9wdGlvbnNLZXlMYiA9IGBsYi0ke2NvbXBvbmVudE5hbWV9LW9wdGlvbnNgO1xuICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLnJvb3RfLmdldEF0dHJpYnV0ZShuYW1lZE9wdGlvbnNLZXkpIHx8XG4gICAgICAgICAgdGhpcy5yb290Xy5nZXRBdHRyaWJ1dGUobmFtZWRPcHRpb25zS2V5TGIpIHx8XG4gICAgICAgICAgdGhpcy5yb290Xy5nZXRBdHRyaWJ1dGUoc3RyaW5ncy5ERUZBVUxUX09QVElPTlNfS0VZKSB8fFxuICAgICAgICAgIHRoaXMucm9vdF8uZ2V0QXR0cmlidXRlKHN0cmluZ3MuREVGQVVMVF9PUFRJT05TX0tFWV9MQik7XG5cbiAgICAgIC8vIFRvIGVuc3VyZSB3ZSBhbHdheXMgcmV0dXJuIGEgdmFsaWQgb3B0aW9ucyBvYmplY3QsIGFzc2lnbiBkZWZhdWx0c1xuICAgICAgLy8gdG8gYHRoaXMub3B0aW9uc19gLlxuICAgICAgdGhpcy5vcHRpb25zXyA9IGRlZmF1bHRPcHRpb25zO1xuXG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gICAgICB9XG5cbiAgICAgIC8vIFdyYXBwaW5nIGFuIEhUTUwgYXR0cmlidXRlIHZhbHVlIGluIGRvdWJsZSBxdW90ZXMgaXMgYSBtb3JlXG4gICAgICAvLyBjb21tb24gcGF0dGVybi4gVG8gYXZvaWQgY2hva2luZyB0aGUgSlNPTiBwYXJzZXIsIHdlIG5lZWQgdG9cbiAgICAgIC8vIHN3YXAgc2luZ2xlIGZvciBkb3VibGUgcXVvdGVzLlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHNwZWNpYWwgY2hhcmFjdGVycywgaW5jbHVkaW5nIEhUTUwgZW50aXRpZXMgYW5kXG4gICAgICAgIC8vIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAgICAgICAgY29uc3QgaGFuZGxlUmVwbGFjZSA9IChjaGFyKSA9PiB7XG4gICAgICAgICAgLy8gV2hlbiB0aGVyZSdzIGFuIGVzY2FwZWQgc2luZ2xlIHF1b3RlLlxuICAgICAgICAgIC8vIGUuZy4gJ0xldFxcJ3MgbWFrZSBpdCBvdXJzZWx2ZXMuJ1xuICAgICAgICAgIGlmIChjaGFyLm1hdGNoKHJlLlNJTkdMRV9RVU9URV9TTEFTSCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZS5TSU5HTEVfUVVPVEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdoZW4gdGhlcmUncyBzaW5nbGUgcXVvdGUgc3Vycm91bmRlZCBieSBsZXR0ZXJzIG9yIG51bWJlcnNcbiAgICAgICAgICAvLyBlLmcuIFwiTGV0J3MgbWFrZSBpdCBvdXJzZWx2ZXMuXCJcbiAgICAgICAgICBpZiAoY2hhci5tYXRjaChyZS5TSU5HTEVfUVVPVEVfV0lUSF9BTFBIQV9OVU0pKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhci5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAocmUuU0lOR0xFX1FVT1RFLCAnZycpLCByZS5TSU5HTEVfUVVPVEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBxdW90ZVJlID0gbmV3IFJlZ0V4cChPYmplY3QudmFsdWVzKHJlKS5qb2luKCd8JyksICdnaScpO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5yZXBsYWNlKHF1b3RlUmUsIGhhbmRsZVJlcGxhY2UpO1xuICAgICAgICB0aGlzLm9wdGlvbnNfID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIEpTT04ucGFyc2Uob3B0aW9ucykpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgKExhenkgQm9uZXMgRXJyb3IpIFRoZXJlJ3MgYSBwcm9ibGVtIHBhcnNpbmcgdGhlIG9wdGlvbnMgYCArXG4gICAgICAgICAgICBgc3RyaW5nOiAke2Vycm9yfS4gXFxuYCArXG4gICAgICAgICAgICBgKENvbXBvbmVudCBOYW1lKSAke2NvbXBvbmVudE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBvciBjcmVhdGVzIGVsZW1lbnQgc3R5bGVzLlxuICAgICAqIEUuZyB0aGlzLnNldFN0eWxlKHt0cmFuc2xhdGVYOiAxMDB9KTtcbiAgICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAqPn0gc3R5bGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBlbGVtZW50XG4gICAgICovXG4gICAgc2V0U3R5bGUoc3R5bGUsIGVsZW1lbnQgPSB0aGlzLnJvb3RfKSB7XG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ0Vuc3VyZSB0aGF0IGBlbGVtZW50YCBpcyBhIERPTSBFbGVtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmxhdHRlblRyYW5zZm9ybVN0eWxlc18oc3R5bGUpO1xuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHZhbHVlIG9mIGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJLZXlcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEF0dHIoYXR0cktleSwgZWxlbWVudCA9IHRoaXMucm9vdF8pIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyS2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBhdHRyaWJ1dGUgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cktleVxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgcmVtb3ZlQXR0cihhdHRyS2V5LCBlbGVtZW50ID0gdGhpcy5yb290Xykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJLZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50J3MgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyS2V5XG4gICAgICogQHBhcmFtIHsqfSBhdHRyVmFsXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gZWxlbWVudFxuICAgICAqL1xuICAgIHNldEF0dHIoYXR0cktleSwgYXR0clZhbCwgZWxlbWVudCA9IHRoaXMucm9vdF8pIHtcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBHZXQgdGhlIHByZXZpb3VzIHZhbHVlLiAqL1xuICAgICAgY29uc3QgbGFzdFZhbCA9IHRoaXMuZ2V0QXR0cihhdHRyS2V5KTtcblxuICAgICAgLy8gU2V0IHRoZSBrZXkgYW5kIHZhbHVlIG9uIHRoZSBlbGVtZW50LlxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cktleSwgYXR0clZhbCk7XG5cbiAgICAgIGlmIChsYXN0VmFsICE9PSBhdHRyVmFsKSB7XG4gICAgICAgIC8vIFRoZW4gcnVuIGNoYW5nZSBjYWxsYmFjay5cbiAgICAgICAgdGhpcy5hdHRyQ2hhbmdlQ2FsbGJhY2tfKGxhc3RWYWwsIGF0dHJWYWwsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIG9mIGNvbXBvbmVudCByb290IG9yIHJvb3QgY2hpbGQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0geyFFbGVtZW50PX0gZWxlbWVudFxuICAgICAqL1xuICAgIGVtcHR5Q29tcG9uZW50RWxlbWVudHMoZWxlbWVudCA9IHRoaXMucm9vdF8pIHtcbiAgICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgY29tcG9uZW50IGNoaWxkIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P0VsZW1lbnR9XG4gICAgICovXG4gICAgcXVlcnlDb21wb25lbnRTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyBjb21wb25lbnQgY2hpbGQgc2VsZWN0b3JcbiAgICAgKiBhbmQgY29udmVydHMgdG8gbmF0aXZlIGBBcnJheWBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHshQXJyYXk8P0VsZW1lbnQ+fVxuICAgICAqL1xuICAgIHF1ZXJ5Q29tcG9uZW50U2VsZWN0b3JBbGwoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBbLi4udGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdGhhdCBnZXRzIG92ZXJ3cml0dGVuIGluIGEgY29tcG9uZW50IHRoYXQgZXh0ZW5kcyBgTEJDb21wb25lbnRgLlxuICAgICAqIFJ1bnMgYWZ0ZXIgYXR0cmlidXRlIHZhbHVlcyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFzdFZhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50VmFsXG4gICAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXR0ckNoYW5nZUNhbGxiYWNrXyhsYXN0VmFsLCBjdXJyZW50VmFsLCBlbGVtZW50KSB7fVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZ2l2ZW4gY2xhc3MgbmFtZSBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtib29sfSBhZGRDbGFzc1xuICAgICAqIEBwYXJhbSB7IUVsZW1lbnQ9fSBlbGVtZW50XG4gICAgICovXG4gICAgdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lLCBhZGRDbGFzcywgZWxlbWVudCA9IHRoaXMucm9vdF8pIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUsIGFkZENsYXNzKTtcbiAgICB9XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9iYXNlL21peGluLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuXG4vKiogQHJlY29yZCAqL1xuY2xhc3MgTW9kZWxFdmVudEFkYXB0ZXIge1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSkge31cblxuICAvKipcbiAgICogTGlzdGVucyB0byBhbiBldmVudCwgYW5kIGV4ZWN1dGVzIGEgaGFuZGxlciBmdW5jdGlvbiB3aGVuIGl0IGZpcmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgbGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGxpc3RlbmluZyB0byBhbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHVubGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbn1cblxuZXhwb3J0IHtNb2RlbEV2ZW50QWRhcHRlcn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL21vZGVsZXZlbnRhZGFwdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtPcHRpb25zfSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9yZW5kZXJlcic7XG5pbXBvcnQge1RpbGVNYXB9IGZyb20gJy4vdGlsZW1hcC90aWxlbWFwJztcbmltcG9ydCB7VHdlZW59IGZyb20gJy4uLy4uLy4uL2Z4L3R3ZWVuJztcblxuXG4vKipcbiAqIFByb3ZpZGVzIGFsbCBwb3NzaWJsZSB3YXlzIHRvIG1vdmUgdGhlIGNhcm91c2VsIHRvIGEgdGlsZSwgYSBncm91cCBvZlxuICogdGlsZXMsIG9yIGEgc3BlY2lmaWMgcG9zaXRpb24sIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24uXG4gKi9cbmNsYXNzIE5hdmlnYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVRpbGVNYXB9IHRpbGVNYXAgVGhlIHRpbGUgbWFwIGRlZmluaXRpb24uXG4gICAqIEBwYXJhbSB7IVJlbmRlcmVyfSByZW5kZXJlciBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7IU9wdGlvbnN9IG9wdGlvbnMgVGhlIGNhcm91c2VsIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aWxlTWFwLCByZW5kZXJlciwgb3B0aW9ucykge1xuICAgIC8qKiBAcHJpdmF0ZSB7IVRpbGVNYXB9ICovXG4gICAgdGhpcy50aWxlTWFwXyA9IHRpbGVNYXA7XG5cbiAgICAvKiogQHByaXZhdGUgeyFSZW5kZXJlcn0gKi9cbiAgICB0aGlzLnJlbmRlcmVyXyA9IHJlbmRlcmVyO1xuXG4gICAgLyoqIEBwcml2YXRlIHshT2JqZWN0fSAqL1xuICAgIHRoaXMub3B0aW9uc18gPSBvcHRpb25zO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXI/fSBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBzbmFwcGVkIHRpbGUuICovXG4gICAgdGhpcy5zbmFwcGVkVGlsZUluZGV4XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IGZyYW1lIHBvc2l0aW9uLiBEdXJpbmcgcHJldmlvdXMvbmV4dCBwYWdpbmF0aW9ucywgdXNlZCB0b1xuICAgICAqIHN0YXJ0IHRoZSB0cmFuc2l0aW9uIGZyb20gdGhlIHRhcmdldCBwb3NpdGlvbiBvZiBhbnkgb25nb2luZyBhbmltYXRpb24sXG4gICAgICogaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0RnJhbWVYXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byBhIHR3ZWVuIGFuaW1hdGlvbi5cbiAgICAgKiBAcHJpdmF0ZSB7VHdlZW59XG4gICAgICovXG4gICAgdGhpcy50d2Vlbl8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgdGFyZ2V0RnJhbWVYX1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgY3VycmVudEZyYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldEZyYW1lWF87XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGNhcm91c2VsIHRvIHRoZSBzcGVjaWZpZWQgdGlsZSBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSB0aWxlIGluZGV4IHRvIG1vdmUgdG8uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9hbmltYXRlIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgdHJhbnNpdGlvbi5cbiAgICovXG4gIHNlbGVjdFRpbGUoaW5kZXgsIG9wdF9hbmltYXRlKSB7XG4gICAgdGhpcy50aWxlTWFwXy5lbmFibGVIaWRkZW5UaWxlcygpO1xuXG4gICAgdmFyIHNuYXBwZWRUaWxlID0gdGhpcy50aWxlTWFwXy5nZXRTbmFwcGVkVGlsZSgpO1xuICAgIGlmICghc25hcHBlZFRpbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBjeWNsZSB0byB0aGUgbmV4dCBzZXQgb2YgdGlsZXMsIHN0YXkgd2l0aGluIHRoZSBjdXJyZW50IG9uZS5cbiAgICB2YXIgbW92ZUZvcndhcmQgPSBpbmRleCA+IHNuYXBwZWRUaWxlLmluZGV4O1xuICAgIHZhciBmcmFtZVggPSB0aGlzLnRpbGVNYXBfLmdldEZyYW1lWFNuYXBwZWRPblRpbGUoaW5kZXgsIG1vdmVGb3J3YXJkKTtcblxuICAgIGlmICghaXNGaW5pdGUoZnJhbWVYKSB8fCBmcmFtZVggPT0gbnVsbCkge1xuICAgICAgLy8gQ2Fubm90IG1vdmUgdG8gdGhhdCBwb3NpdGlvbi5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdF9hbmltYXRlKSB7XG4gICAgICB0aGlzLnNldEZyYW1lUG9zaXRpb24oZnJhbWVYKTtcbiAgICAgIHRoaXMudGlsZU1hcF8uYWRqdXN0RnJhbWVYKCk7XG4gICAgICB0aGlzLnRhcmdldEZyYW1lWF8gPSB0aGlzLnRpbGVNYXBfLmdldEZyYW1lWCgpO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnNfLmp1bXApIHtcbiAgICAgIC8vIFJlY2FsY3VsYXRlIHRoZSB0YXJnZXQgZnJhbWUgcG9zaXRpb24gYWZ0ZXIgdGVtcG9yYXJpbHkgZGlzYWJsaW5nXG4gICAgICAvLyBoaWRkZW4gdGlsZXMuXG4gICAgICB0aGlzLnRpbGVNYXBfLmRpc2FibGVIaWRkZW5UaWxlcyhmcmFtZVgpO1xuXG4gICAgICB2YXIgdGVtcEZyYW1lWCA9IHRoaXMudGlsZU1hcF8uZ2V0RnJhbWVYU25hcHBlZE9uVGlsZShpbmRleCwgbW92ZUZvcndhcmQpO1xuICAgICAgaWYgKHRlbXBGcmFtZVggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8qKiBAdGhpcyB7TmF2aWdhdG9yfSAqL1xuICAgICAgdmFyIGFuaW1Db21wbGV0ZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUmUtZW5hYmxlIGhpZGRlbiB0aWxlcyBhbmQgbW92ZSB0byBhY3R1YWwgdGFyZ2V0IGZyYW1lIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLnRpbGVNYXBfLmVuYWJsZUhpZGRlblRpbGVzKCk7XG4gICAgICAgIHRoaXMuc2V0RnJhbWVQb3NpdGlvbigvKiogQHR5cGUgeyFudW1iZXJ9ICovIChmcmFtZVgpKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYW5pbWF0ZUZyYW1lUG9zaXRpb24odGVtcEZyYW1lWCwgbnVsbCxcbiAgICAgICAgICBhbmltQ29tcGxldGVIYW5kbGVyLmJpbmQodGhpcykpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYW5pbWF0ZUZyYW1lUG9zaXRpb24oZnJhbWVYKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgY2Fyb3VzZWwgdG8gdGhlIHByZXZpb3VzIHRpbGUgb3IgZ3JvdXAgb2YgdGlsZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfdXBkYXRlSGFuZGxlciBBIGNhbGxiYWNrIGV4ZWN1dGVkIGFmdGVyIGVhY2hcbiAgICogICAgIGFuaW1hdGlvbiB1cGRhdGUuXG4gICAqIEBwYXJhbSB7P251bWJlcj19IG9wdF9mcmFtZVggVGhlIGZyYW1lIHBvc2l0aW9uIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uXG4gICAqICAgICBmcm9tLlxuICAgKi9cbiAgc2VsZWN0UHJldmlvdXMob3B0X3VwZGF0ZUhhbmRsZXIsIG9wdF9mcmFtZVgpIHtcbiAgICB0aGlzLnBhZ2luYXRlXyhmYWxzZSwgb3B0X3VwZGF0ZUhhbmRsZXIsIG9wdF9mcmFtZVgpO1xuICB9XG5cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGNhcm91c2VsIHRvIHRoZSBuZXh0IHRpbGUgb3IgZ3JvdXAgb2YgdGlsZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfdXBkYXRlSGFuZGxlciBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSB7P251bWJlcj19IG9wdF9mcmFtZVggVGhlIGZyYW1lIHBvc2l0aW9uIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uXG4gICAqICAgICBmcm9tLlxuICAgKi9cbiAgc2VsZWN0TmV4dChvcHRfdXBkYXRlSGFuZGxlciwgb3B0X2ZyYW1lWCkge1xuICAgIHRoaXMucGFnaW5hdGVfKHRydWUsIG9wdF91cGRhdGVIYW5kbGVyLCBvcHRfZnJhbWVYKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBjYXJvdXNlbCBmcmFtZSB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgdGFyZ2V0IGZyYW1lIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfdXBkYXRlVGFyZ2V0IFdoZXRoZXIgdG8gcmVnaXN0ZXIgdGhlIHNwZWNpZmllZCBmcmFtZVxuICAgKiAgICAgcG9zaXRpb24gdG8gYmUgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIGFueSBuZXh0IHRyYW5zaXRpb24uXG4gICAqL1xuICBzZXRGcmFtZVBvc2l0aW9uKHgsIG9wdF91cGRhdGVUYXJnZXQpIHtcbiAgICB0aGlzLnRpbGVNYXBfLnNldEZyYW1lWCh4KTtcbiAgICB0aGlzLnJlbmRlcmVyXy5kcmF3KCk7XG5cbiAgICB2YXIgc25hcHBlZFRpbGUgPSB0aGlzLnRpbGVNYXBfLmdldEN1cnJlbnRTbmFwcGVkVGlsZSgpO1xuICAgIGlmIChzbmFwcGVkVGlsZSkge1xuICAgICAgdGhpcy5zbmFwcGVkVGlsZUluZGV4XyA9IHNuYXBwZWRUaWxlLmluZGV4O1xuICAgIH1cblxuICAgIGlmIChvcHRfdXBkYXRlVGFyZ2V0KSB7XG4gICAgICB0aGlzLnRhcmdldEZyYW1lWF8gPSB4O1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFuaW1hdGVzIHRoZSBjYXJvdXNlbCBmcmFtZSB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgZnJhbWUgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfdXBkYXRlSGFuZGxlciBBIGNhbGxiYWNrIGV4ZWN1dGVkIGFmdGVyIGVhY2hcbiAgICogICAgIGFuaW1hdGlvbiB1cGRhdGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfY29tcGxldGVIYW5kbGVyIEEgY2FsbGJhY2sgZXhlY3V0ZWQgb25jZSB0aGVcbiAgICogICAgIGFuaW1hdGlvbiBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBhbmltYXRlRnJhbWVQb3NpdGlvbih4LCBvcHRfdXBkYXRlSGFuZGxlciwgb3B0X2NvbXBsZXRlSGFuZGxlcikge1xuICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuXG4gICAgaWYgKHggPT0gdGhpcy50aWxlTWFwXy5nZXRGcmFtZVgoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0RnJhbWVYXyA9IHg7XG5cbiAgICB2YXIgcG9zaXRpb25Ud2VlbiA9IHt4OiB0aGlzLnRpbGVNYXBfLmdldEZyYW1lWCgpfTtcbiAgICAvKiogQHRoaXMge05hdmlnYXRvcn0gKi9cbiAgICB2YXIgdXBkYXRlSGFuZGxlciA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgdGhpcy5zZXRGcmFtZVBvc2l0aW9uKHBhcmFtcy54KTtcbiAgICAgIG9wdF91cGRhdGVIYW5kbGVyICYmIG9wdF91cGRhdGVIYW5kbGVyKCk7XG4gICAgfTtcbiAgICAvKiogQHRoaXMge05hdmlnYXRvcn0gKi9cbiAgICB2YXIgY29tcGxldGVIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBvcHRfY29tcGxldGVIYW5kbGVyICYmIG9wdF9jb21wbGV0ZUhhbmRsZXIoKTtcbiAgICAgIHRoaXMudGlsZU1hcF8uYWRqdXN0RnJhbWVYKCk7XG4gICAgICB0aGlzLnRhcmdldEZyYW1lWF8gPSB0aGlzLnRpbGVNYXBfLmdldEZyYW1lWCgpO1xuICAgIH07XG5cbiAgICB2YXIgYW5pbU9wdGlvbnMgPSB7XG4gICAgICAneCc6IHgsXG4gICAgICAnZWFzZSc6IHRoaXMub3B0aW9uc18uZWFzaW5nLFxuICAgICAgJ29uVXBkYXRlUGFyYW1zJzogW3Bvc2l0aW9uVHdlZW5dLFxuICAgICAgJ29uVXBkYXRlJzogdXBkYXRlSGFuZGxlci5iaW5kKHRoaXMpLFxuICAgICAgJ29uQ29tcGxldGUnOiBjb21wbGV0ZUhhbmRsZXIuYmluZCh0aGlzKSxcbiAgICB9O1xuXG4gICAgdGhpcy50d2Vlbl8gPSBUd2Vlbi50byhcbiAgICAgICAgcG9zaXRpb25Ud2VlbiwgdGhpcy5vcHRpb25zXy50cmFuc2l0aW9uRHVyYXRpb24sIGFuaW1PcHRpb25zKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFN0b3BzIGFueSBvbmdvaW5nIGFuaW1hdGlvbi5cbiAgICovXG4gIHN0b3BBbmltYXRpb24oKSB7XG4gICAgdGhpcy50d2Vlbl8gJiYgdGhpcy50d2Vlbl8ua2lsbCgpO1xuICB9XG5cblxuICAvKipcbiAgICogV2hldGhlciB0byBwYWdpbmF0ZSB0aWxlcyBieSBncm91cCBpbnN0ZWFkIG9mIG9uZSBieSBvbmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1BhZ2luYXRpbmdHcm91cHMoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5vcHRpb25zXy5ncm91cDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFuaW1hdGVzIHRoZSBjYXJvdXNlbCB0byBhIHRpbGUgb3IgYSBncm91cCBvZiB0aWxlcyBpbiB0aGUgc3BlY2lmaWVkXG4gICAqIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBtb3ZlRm9yd2FyZCBXaGV0aGVyIHRvIG1vdmUgdGhlIGNhcm91c2VsIGZvcndhcmQuXG4gICAqIEBwYXJhbSB7P0Z1bmN0aW9uPX0gb3B0X3VwZGF0ZUhhbmRsZXIgQSBjYWxsYmFjayBleGVjdXRlZCBhZnRlciBlYWNoXG4gICAqICAgICBhbmltYXRpb24gdXBkYXRlLlxuICAgKiBAcGFyYW0gez9udW1iZXI9fSBvcHRfZnJhbWVYIFRoZSBmcmFtZSBwb3NpdGlvbiB0byBzdGFydCB0aGUgdHJhbnNpdGlvblxuICAgKiAgICAgZnJvbS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBhZ2luYXRlXyhtb3ZlRm9yd2FyZCwgb3B0X3VwZGF0ZUhhbmRsZXIsIG9wdF9mcmFtZVgpIHtcbiAgICAvLyBQYWdpbmF0ZSBmcm9tIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBkZXN0aW5hdGlvbiBieSBkZWZhdWx0LlxuICAgIHZhciBmcm9tRnJhbWVYID1cbiAgICAgICAgKG9wdF9mcmFtZVggIT0gdW5kZWZpbmVkKSA/IG9wdF9mcmFtZVggOiB0aGlzLnRhcmdldEZyYW1lWF87XG5cbiAgICB2YXIgdG9GcmFtZVggPSAwO1xuICAgIGlmIChtb3ZlRm9yd2FyZCAmJiB0aGlzLm9wdGlvbnNfLmdyb3VwKSB7XG4gICAgICB0b0ZyYW1lWCA9IHRoaXMudGlsZU1hcF8uZ2V0TmV4dEdyb3VwRnJhbWVYKGZyb21GcmFtZVgpO1xuXG4gICAgfSBlbHNlIGlmIChtb3ZlRm9yd2FyZCkge1xuICAgICAgdG9GcmFtZVggPSB0aGlzLnRpbGVNYXBfLmdldE5leHRGcmFtZVgoZnJvbUZyYW1lWCk7XG5cbiAgICB9IGVsc2UgaWYgKCFtb3ZlRm9yd2FyZCAmJiB0aGlzLm9wdGlvbnNfLmdyb3VwKSB7XG4gICAgICB0b0ZyYW1lWCA9IHRoaXMudGlsZU1hcF8uZ2V0UHJldmlvdXNHcm91cEZyYW1lWChmcm9tRnJhbWVYKTtcblxuICAgIH0gZWxzZSBpZiAoIW1vdmVGb3J3YXJkKSB7XG4gICAgICB0b0ZyYW1lWCA9IHRoaXMudGlsZU1hcF8uZ2V0UHJldmlvdXNGcmFtZVgoZnJvbUZyYW1lWCk7XG4gICAgfVxuXG4gICAgaWYgKHRvRnJhbWVYICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZUZyYW1lUG9zaXRpb24odG9GcmFtZVgsIG9wdF91cGRhdGVIYW5kbGVyKTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQge05hdmlnYXRvcn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9jYXJvdXNlbC9uYXZpZ2F0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG5pbXBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UX1NFTEVDVE9SU30gZnJvbSAnLi4vLi4vLi4vZG9tL2ZvY3VzX3V0aWwvZm9jdXMtdXRpbCc7XG5pbXBvcnQge0Nhcm91c2VsQWRhcHRlcn0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7VGlsZU1hcH0gZnJvbSAnLi90aWxlbWFwL3RpbGVtYXAnO1xuaW1wb3J0IHtWaXNpYmlsaXR5fSBmcm9tICcuL3RpbGVtYXAvdmlzaWJpbGl0eSc7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIFJlbmRlcnMgYSB0aWxlIG1hcCBvbiB0aGUgRE9NLCB3aGVyZSBlYWNoIGNoaWxkIG9mIGEgY29udGFpbmVyIGVsZW1lbnQgaXNcbiAqIGEgdGlsZSBpdGVtLiBQb3NpdGlvbnMgdGhlIGNvbnRhaW5lciBlbGVtZW50LCBtZWFzdXJlcyBhbmQgdXBkYXRlcyBlbGVtZW50XG4gKiBzaXplcy5cbiAqL1xuY2xhc3MgUmVuZGVyZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFUaWxlTWFwfSB0aWxlTWFwIFRoZSB0aWxlIG1hcCBkZWZpbml0aW9uLlxuICAgKiBAcGFyYW0geyFDYXJvdXNlbEFkYXB0ZXJ9IGFkYXB0ZXIgVGhlIGFkYXB0ZXIgaW50ZXJmYWNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtdWx0aXBsZVZpc2libGVUaWxlcyBXaGV0aGVyIGFsbCB0aWxlcyBmdWxseSBkaXNwbGF5ZWRcbiAgICogICAgIHdpdGhpbiB0aGUgZnJhbWUgc2hvdWxkIGJlIHZpc2libGUgdG8gc2NyZWVuIHJlYWRlcnMuIEJ5IGRlZmF1bHQsIG9ubHlcbiAgICogICAgIHRoZSBjdXJyZW50bHkgc25hcHBlZCB0aWxlIGlzIG1hcmtlZCBhcyB2aXNpYmxlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZU1hcCwgYWRhcHRlciwgbXVsdGlwbGVWaXNpYmxlVGlsZXMgPSBmYWxzZSkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMudGlsZU1hcF8gPSB0aWxlTWFwO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5hZGFwdGVyXyA9IGFkYXB0ZXI7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc1J0bF8gPSB0aGlzLmFkYXB0ZXJfLmlzUnRsKCk7XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLm11bHRpcGxlVmlzaWJsZVRpbGVzXyA9IG11bHRpcGxlVmlzaWJsZVRpbGVzO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9IFRoZSB0YWxsZXN0IGVsZW1lbnQgaGVpZ2h0LiAqL1xuICAgIHRoaXMubWF4SGVpZ2h0XyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUgeyFBcnJheTxFbGVtZW50Pn0gVGhlIGxpc3Qgb2YgY3VycmVudGx5IGRpc3BsYXllZCBlbGVtZW50cy4gKi9cbiAgICB0aGlzLmVsZW1lbnRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCB3ZXJlIGluamVjdGVkIGluIHRoZSBET00gZHVyaW5nIHRoZSBsYXN0IGRyYXdcbiAgICAgKiBjeWNsZS5cbiAgICAgKiBAcHJpdmF0ZSB7IUFycmF5PEVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMuYWRkZWRFbGVtZW50c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuc25hcHBlZFRpbGVFbGVtZW50XyA9IG51bGw7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDb3VudHMgbnVtYmVyIG9mIGNoaWxkcmVuIGVsZW1lbnRzLCBtZWFzdXJlcyB0aGVpciB3aWR0aCBhbmQgdGhlaXJcbiAgICogY29udGFpbmVyIHdpZHRoIGFuZCB1cGRhdGVzIHRoZSB0aWxlIG1hcCBhY2NvcmRpbmdseS5cbiAgICogQHBhcmFtIHshRnVuY3Rpb249fSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSB0aGUgbWFya3VwIGhhcyBiZWVuXG4gICAqICAgICByZW5kZXJlZC5cbiAgICovXG4gIGluaXQoY2FsbGJhY2sgPSAoKSA9PiB7fSkge1xuICAgIHRoaXMucmVzZXRFbGVtZW50cygoKSA9PiB7XG4gICAgICB0aGlzLm1lYXN1cmVFbGVtZW50c18oKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjYXJvdXNlbCB2aWV3LlxuICAgKi9cbiAgZHJhdygpIHtcbiAgICAvLyBBZGQvcmVtb3ZlIGl0ZW1zIHRvIERPTVxuICAgIGNvbnN0IG5ld01hcCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLnRpbGVNYXBfLmdldERpc3BsYXlNYXAoKSk7XG4gICAgdGhpcy5hZGFwdGVyXy50b2dnbGVFbGVtZW50cyhuZXdNYXAsICgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlc18oKTtcbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyVHJhbnNsYXRpb25fKCk7XG4gICAgICB0aGlzLmluZGV4VmlzaWJsZUVsZW1lbnRzXygpO1xuICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGNvbnRhaW5lciBhbmQgaXRzIGNoaWxkcmVuIHRvIHRoZWlyIGluaXRpYWwgc3RhdGUuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9uPX0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgdGhlIG1hcmt1cCBoYXMgYmVlblxuICAgKiAgICAgcmVuZGVyZWQuXG4gICAqL1xuICByZXNldEVsZW1lbnRzKGNhbGxiYWNrID0gKCkgPT4ge30pIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKCd3aWR0aCcsICdhdXRvJyk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZSgndHJhbnNmb3JtJywgJ25vbmUnKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlc2V0RWxlbWVudHMoKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldEF0dHJpYnV0ZXNfKCk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCB3ZXJlIGluamVjdGVkIGluIHRoZSBET00gZHVyaW5nIHRoZSBsYXN0IGRyYXdcbiAgICogY3ljbGUuXG4gICAqIEByZXR1cm4geyFBcnJheTxFbGVtZW50Pn1cbiAgICovXG4gIGdldEFkZGVkRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkZWRFbGVtZW50c187XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0U25hcHBlZFRpbGVFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnNuYXBwZWRUaWxlRWxlbWVudF87XG4gIH1cblxuXG4gIC8qKlxuICAgKiBNZWFzdXJlcyB0aGUgY29udGFpbmVyIGFuZCB0aGUgdGlsZSBlbGVtZW50cywgdXBkYXRlIHRoZSB0aWxlIG1hcFxuICAgKiBwcm9wZXJ0aWVzIGFjY29yZGluZ2x5IGFuZCBsb2NrcyB0aGVpciBzaXplLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWVhc3VyZUVsZW1lbnRzXygpIHtcbiAgICBjb25zdCB7TUVBU1VSSU5HfSA9IGNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRUFTVVJJTkcpO1xuICAgIHRoaXMudGlsZU1hcF8uZnJhbWVXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0UGFyZW50RWxlbWVudFdpZHRoKCk7XG5cbiAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICBjb25zdCBlbHMgPSB0aGlzLmFkYXB0ZXJfLmdldENoaWxkRWxlbWVudHMoKTtcbiAgICB0aGlzLm1heEhlaWdodF8gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGVsOyBlbCA9IGVsc1tpXTsgaSsrKSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLmFkYXB0ZXJfLmdldFRpbGVEaW1lbnNpb25zKGVsKTtcbiAgICAgIC8vIExvY2sgZWxlbWVudCdzIHdpZHRoXG4gICAgICAvLyBOZWVkZWQgd2hlbiB0aGUgd2lkdGggaXMgYSBwZXJjZW50YWdlIG9mIHRoZSB2aWV3cG9ydCAoZmx1aWQgbW9kZSlcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGlsZVN0eWxlKGVsLCAnd2lkdGgnLCBgJHt3aWR0aH1weGApO1xuXG4gICAgICAvLyBVcGRhdGUgY2FjaGVkIHBhZ2Ugd2lkdGhzXG4gICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG5cbiAgICAgIHRoaXMubWF4SGVpZ2h0XyA9IE1hdGgubWF4KHRoaXMubWF4SGVpZ2h0XywgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1FQVNVUklORyk7XG5cbiAgICAvLyBBcHBseSBtYXggaGVpZ2h0IHRvIGFsbCBlbGVtZW50c1xuICAgIHRoaXMubWF4SGVpZ2h0XyA9IE1hdGgucm91bmQodGhpcy5tYXhIZWlnaHRfKTtcbiAgICBmb3IgKGxldCBpID0gMCwgZWw7IGVsID0gZWxzW2ldOyBpKyspIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGlsZVN0eWxlKGVsLCAnbWluSGVpZ2h0JywgYCR7dGhpcy5tYXhIZWlnaHRffXB4YCk7XG4gICAgfVxuXG4gICAgdGhpcy50aWxlTWFwXy5zZXRUaWxlcyh3aWR0aHMpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGUoJ3dpZHRoJywgYCR7dGhpcy50aWxlTWFwXy5nZXRNYXhXaWR0aCgpfXB4YCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBlbGVtZW50cycgc2l6ZXMgYW5kIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZXNfKCkge1xuICAgIGNvbnN0IGVscyA9IHRoaXMuYWRhcHRlcl8uZ2V0Q2hpbGRFbGVtZW50cygpO1xuICAgIGNvbnN0IGRpc3BsYXlNYXAgPSB0aGlzLnRpbGVNYXBfLmdldERpc3BsYXlNYXAoKTtcbiAgICBjb25zdCBzbmFwcGVkVGlsZSA9IHRoaXMudGlsZU1hcF8uZ2V0Q3VycmVudFNuYXBwZWRUaWxlKCk7XG4gICAgaWYgKCFzbmFwcGVkVGlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHZpc2libGVJbmRleCA9IHRoaXMudGlsZU1hcF8uZ2V0VmlzaWJsZUluZGV4KHNuYXBwZWRUaWxlLmluZGV4KTtcbiAgICB0aGlzLnNuYXBwZWRUaWxlRWxlbWVudF8gPVxuICAgICAgICAodmlzaWJsZUluZGV4ICE9IG51bGwpID8gZWxzW3Zpc2libGVJbmRleF0gOiBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBsZW4gPSBkaXNwbGF5TWFwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB2aXNpYmxlID0gZGlzcGxheU1hcFtpXTtcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZWxzW2orK107XG4gICAgICAgIGlmICghZWwpIHJldHVybjtcblxuICAgICAgICAvLyBTZXQgdGlsZSBlbGVtZW50J3Mgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMudGlsZU1hcF8uZ2V0VGlsZVdpZHRoKGkpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldFRpbGVTdHlsZShlbCwgJ3dpZHRoJywgYCR7d2lkdGh9cHhgKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUaWxlU3R5bGUoZWwsICdtaW5IZWlnaHQnLCBgJHt0aGlzLm1heEhlaWdodF99cHhgKTtcblxuICAgICAgICBjb25zdCBtYXJrQXNWaXNpYmxlID1cbiAgICAgICAgICAgICh0aGlzLm11bHRpcGxlVmlzaWJsZVRpbGVzXyAmJiB2aXNpYmxlID09IFZpc2liaWxpdHkuVklTSUJMRSkgfHxcbiAgICAgICAgICAgICghdGhpcy5tdWx0aXBsZVZpc2libGVUaWxlc18gJiYgZWwgPT0gdGhpcy5zbmFwcGVkVGlsZUVsZW1lbnRfKTtcblxuICAgICAgICAvLyBBcHBseSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXMgb24gdGlsZSBlbGVtZW50c1xuICAgICAgICBpZiAobWFya0FzVmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8ucm1UaWxlQXR0cihlbCwgJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUaWxlQXR0cihlbCwgJ3RhYmluZGV4JywgLTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGlsZUF0dHIoZWwsICdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8ucm1UaWxlQXR0cihlbCwgJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXMgb24gdGlsZXMnIGNoaWxkIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gRk9DVVNBQkxFX0VMRU1FTlRfU0VMRUNUT1JTLmpvaW4oJywnKTtcbiAgICAgICAgY29uc3QgZm9jdXNhYmxlcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZm9jdXNhYmxlRWw7IGZvY3VzYWJsZUVsID0gZm9jdXNhYmxlc1tpXTsgaSsrKSB7XG4gICAgICAgICAgaWYgKG1hcmtBc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlcl8ucm1UaWxlQXR0cihmb2N1c2FibGVFbCwgJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGlsZUF0dHIoZm9jdXNhYmxlRWwsICd0YWJpbmRleCcsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0cmFuc2xhdGUzZCBwcm9wZXJ0eSBvZiB0aGUgY2Fyb3VzZWwgY29udGFpbmVyIGVsZW1lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRDb250YWluZXJUcmFuc2xhdGlvbl8oKSB7XG4gICAgbGV0IHRyYW5zbGF0ZVggPSBNYXRoLnJvdW5kKHRoaXMudGlsZU1hcF8uZ2V0Q29udGFpbmVyWCgpKTtcbiAgICB0cmFuc2xhdGVYICo9IHRoaXMuaXNSdGxfID8gLTEgOiAxO1xuICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlWH1weCwgMCwgMClgO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGUoJ3RyYW5zZm9ybScsIHRyYW5zbGF0aW9uKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgZGlmZiBvZiBlbGVtZW50cyB0aGF0IHdlcmUganVzdCBhZGRlZCB0byB0aGUgRE9NLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5kZXhWaXNpYmxlRWxlbWVudHNfKCkge1xuICAgIHRoaXMuYWRkZWRFbGVtZW50c18gPSBbXTtcbiAgICBjb25zdCBlbHMgPSB0aGlzLmFkYXB0ZXJfLmdldENoaWxkRWxlbWVudHMoKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBlbDsgZWwgPSBlbHNbaV07IGkrKykge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNfLmluZGV4T2YoZWwpID09IC0xKSB7XG4gICAgICAgIHRoaXMuYWRkZWRFbGVtZW50c18ucHVzaChlbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50c18gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWxzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc2l6ZSBhdHRyaWJ1dGVzIGZyb20gdGlsZSBlbGVtZW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlc2V0QXR0cmlidXRlc18oKSB7XG4gICAgY29uc3QgZWxzID0gdGhpcy5hZGFwdGVyXy5nZXRDaGlsZEVsZW1lbnRzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgZWwgPSBlbHNbaV07XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUaWxlU3R5bGUoZWwsICd3aWR0aCcsICcnKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUaWxlU3R5bGUoZWwsICdtaW5IZWlnaHQnLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuXG5leHBvcnQge1JlbmRlcmVyfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL3JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSBzZXJpZXMgb2YgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHVzZSBpbiBpbXBsZW1lbnRpbmcgZWFzaW5nIGluXG4gKiBqYXZhc2NyaXB0IGFuaW1hdGlvbnMuXG4gKlxuICogQ2xvc3VyZSBwcm92aWRlcyB0aHJlZSBlYXNpbmcgZnVuY3Rpb25zIChnb29nLmZ4LmVhc2luZy5lYXNlSW4sXG4gKiBnb29nLmZ4LmVhc2luZy5lYXNlT3V0LCBnb29nLmZ4LmVhc2luZy5pbkFuZE91dCksIGJ1dCBhcyB0aGF0IGlzIGEgd29lZnVsbHlcbiAqIGluYWRlcXVhdGUgbGlicmFyeSBmb3IgYnJvYWQgYW5pbWF0aW9uIHVzZSwgdGhpcyBzZXJpZXMgb2YgZnVuY3Rpb25zIGFkZHNcbiAqIG1hbnkgbW9yZSBvcHRpb25zIHRvIGJlIHVzZWQgaW4gYSBzaW1pbGFyIHdheS4gRWFzaW5nIGZ1bmN0aW9ucyBhcmUgdXNlZnVsXG4gKiBmb3IgYWRkaW5nIGEgbmF0dXJhbCBmZWVsIHRvIHdoYXQgd291bGQgb3RoZXJ3aXNlIGJlIHVucmVhbGlzdGljLCBsaW5lYXJcbiAqIGFuaW1hdGlvbnMuXG4gKlxuICogRXhhbXBsZSB1c2FnZTogU2F5IHlvdSBoYXZlIGEgRE9NIGVsZW1lbnQgdGhhdCB5b3Ugd2FudCB0byBhbmltYXRlIGJ5IG1vdmluZ1xuICogaXQgYmV0d2VlbiB0d28gYXJiaXRyYXJ5IGxvY2F0aW9ucyBpbiBhIHBhZ2UsIG92ZXIgMiBzZWNvbmRzLiBOb3JtYWxseSB5b3UnZFxuICogZGV0ZXJtaW5lIGl0cyBzdGFydGluZyBwb3NpdGlvbiwgaXRzIGVuZGluZyBwb3NpdGlvbiwgc2V0IHVwIGFuIGludGVydmFsLFxuICogdGhlbiB3aXRoIGVhY2ggaXRlcmF0aW9uLCBkZXRlcm1pbmUgdGhlIHBvc2l0aW9uIHlvdSBzaG91bGQgbW92ZSBpdCB0byBiYXNlZFxuICogb24gaXRzIGluaXRpYWwgYW5kIGVuZGluZyBwb3NpdGlvbiB2YWx1ZXMgYW5kIGEgcGVyY2VudGFnZSB0aGF0IHJlcHJlc2VudHNcbiAqIGl0cyBwcm9ncmVzcyBmcm9tIHN0YXJ0IHRvIGZpbmlzaCwgYmFzZWQgb24gdGhlIDIgc2Vjb25kIGR1cmF0aW9uLiBDYWxsIHRoYXRcbiAqIHBlcmNlbnRhZ2UgVC4gSW4gb3JkZXIgdG8gaW1wbGVtZW50IGFuIGVhc2luZyBtZXRob2QgdXNpbmcgZ2x1ZS5meC5lYXNpbmcsXG4gKiBzaW1wbHkgcGFzcyBUIHRocm91Z2ggeW91ciBkZXNpcmVkIGVhc2luZyBtZXRob2QsIGFuZCB0aGUgcmV0dXJuZWQgdmFsdWUgaXNcbiAqIGFuIFwiZWFzZWRcIiB2YWx1ZSBvZiBULiBVc2luZyB0aGF0IG5ldyBULCB5b3Ugc2V0IHRoZSBlbGVtZW50J3MgcG9zaXRpb24sXG4gKiBhbmQgdGhlIHJlc3VsdGluZyBhbmltYXRpb24gd2lsbCBoYXZlIGEgc21vb3RoIGVhc2UgdG8gaXQsIGluc3RlYWQgb2YgaXRzXG4gKiBvcmlnaW5hbCwgamFycmluZyBsaW5lYXIgbW92ZW1lbnQuIEl0J3MgaGFyZCB0byB1bmRlcnN0YW5kIHRoaXMgd2l0aG91dFxuICogc2VlaW5nIGl0IGluIGFjdGlvbiwgc28gdmlzaXQgdGhlIGV4YW1wbGUgbGluayBiZWxvdyBmb3Igc29tZSBsaXZlIGFuaW1hdGlvblxuICogdXRpbGl6aW5nIGFsbCBvZiB0aGUgZWFzaW5nIGZ1bmN0aW9ucyBwcm92aWRlZCBpbiB0aGlzIGxpYnJhcnkuXG4gKlxuICogSWYgeW91IGFyZSBtb3JlIGZhbWlsaWFyIHdpdGggalF1ZXJ5J3Mgc3R5bGUgb2YgZWFzaW5nIG1ldGhvZHMgd2hpY2ggZXhwZWN0XG4gKiBmb3VyIGFyZ3VtZW50cyAodCwgYiwgYywgZCksIHlvdSBjYW4gdXNlIGdsdWUuZnguZWFzaW5nLmVhc2UoKSwgcGFzc2luZyBpblxuICogdGhvc2UgZm91ciBhcmd1bWVudHMgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBlYXNpbmcgbWV0aG9kIHlvdSdkIGxpa2UgdG8gdXNlLlxuICogV2hldGhlciB5b3Ugc2hvdWxkIHVzZSB0aGlzLCBvciBkaXJlY3RseSBjYWxsIG9uZSBvZiB0aGUgc2luZ2xlLWFyZ3VtZW50XG4gKiBtZXRob2RzLCBpcyB1cCB0byB0aGUgZGV2ZWxvcGVyLCBhbmQgbGFyZ2VseSBkZXBlbmRzIG9uIGNpcmN1bXN0YW5jZS5cbiAqXG4gKiBOb3RlOiBGcmVxdWVudGx5LCB5b3Ugd2lsbCBoYXZlIHRoZSBlYXNpbmcgbWV0aG9kIGJ5IG5hbWUgaW4gc3RyaW5nIGZvcm0gKGFzXG4gKiB3aGVuIGNvbnRhaW5lZCBpbiBzb21lIEpTT04gY29uZmlndXJhdGlvbiBkYXRhKSwgc28geW91IGNhbiBhbHNvIGNhbGwgaXRcbiAqIGxpa2U6IGdsdWUuZnguZWFzaW5nW21ldGhvZE5hbWVdKHBlcmNlbnRhZ2UpO1xuICpcbiAqIEZvciBleGFtcGxlcywgc2VlOlxuICogaHR0cHM6Ly9nbHVlLWRvY3MuYXBwc3BvdC5jb20vZG9jcy9jb21wb25lbnRzL3Jhdy9meC1lYXNpbmdcbiAqL1xuXG5cblxuLyoqXG4gKiBBIG5hbWVzcGFjZSBmb3IgdGhlIGVhc2luZyBmdW5jdGlvbnMuIFRoaXMgaXMgYmVpbmcgY3JlYXRlZCBhbmQgZXhwb3J0ZWRcbiAqIGJlY2F1c2Ugd2Ugd2lsbCBvZnRlbiBoYXZlIHRoZSBuYW1lIG9mIG91ciBkZXNpcmVkIGVhc2luZyBtZXRob2QgYnkgc3RyaW5nXG4gKiBvbmx5LCBzbyB3ZSdsbCBuZWVkIHRvIHRlc3QgdG8gc2VlIGlmIGdsdWUuZnguZWFzaW5nIGNvbnRhaW5zIGEgcHJvcGVydHlcbiAqIChmdW5jdGlvbikgd2l0aCB0aGF0IG5hbWUsIGFuZCB0aGVuIGNhbGwgaXQgbGlrZSBzbzpcbiAqIGdsdWUuZnguZWFzaW5nW21ldGhvZE5hbWVdKHBlcmNlbnRhZ2UpO1xuICovXG5cblxuLyoqXG4gKiBFYXNlcyB2YWx1ZXMgYmFzZWQgb24gdGhlIHR5cGljYWwgZm91ci1hcmd1bWVudCBlYXNpbmcgbWV0aG9kIHN0cnVjdHVyZSB1c2VkXG4gKiBieSBwb3B1bGFyIGxpYnJhcmllcyBsaWtlIGpRdWVyeS4gVGhpcyBpcyBhbiBhZGFwdGVyIHRvIGludGVyZmFjZSB3aXRoIHRoZVxuICogc2luZ2xlLWFyZ3VtZW50IGVhc2luZyBtZXRob2RzIGluIHRoaXMgY2xhc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBDdXJyZW50IHRpbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiIEJlZ2lubmluZyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgZWFzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gYyBUb3RhbCBjaGFuZ2UgaW4gdGhlIHByb3BlcnR5IHZhbHVlIGFjcm9zcyB0aGlzIGFuaW1hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkIFRvdGFsIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpOiBudW1iZXJ9IGZ1bmMgVGhlIGVhc2luZyBtZXRob2QgdG8gY2FsbC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZpbmFsIGVhc2VkIHZhbHVlLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlKHQsIGIsIGMsIGQsIGZ1bmMpIHtcbiAgcmV0dXJuIGIgKyBjICogZnVuYyh0IC8gZCk7XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYSBTaW5lIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlSW5TaW5lKHQpIHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiAxIC0gTWF0aC5jb3ModCAqIChNYXRoLlBJIC8gMikpO1xufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBvdXQgd2l0aCBhIFNpbmUgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VPdXRTaW5lKHQpIHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiBNYXRoLnNpbih0ICogKE1hdGguUEkgLyAyKSk7XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhIFNpbmUgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VJbk91dFNpbmUodCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMSk7XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYSBxdWFkcmF0aWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VJblF1YWQodCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IHQgKiB0O1xufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBvdXQgd2l0aCBhIHF1YWRyYXRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZU91dFF1YWQodCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IHQgKiAoMiAtIHQpO1xufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiBhbmQgb3V0IHdpdGggYSBxdWFkcmF0aWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICBpZiAodCA9PSAwIHx8IHQgPT0gMSkge1xuICAgIHJldHVybiB0O1xuICB9IGVsc2UgaWYgKHQgPCAuNSkge1xuICAgIHJldHVybiAyICogdCAqIHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xICsgKDQgLSAyICogdCkgKiB0O1xuICB9XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYSBjdWJpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZUluQ3ViaWModCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBjdWJpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZU91dEN1YmljKHQpIHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiAoLS10KSAqIHQgKiB0ICsgMTtcbn1cblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gYW5kIG91dCB3aXRoIGEgY3ViaWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQpIHtcbiAgaWYgKHQgPT0gMCB8fCB0ID09IDEpIHtcbiAgICByZXR1cm4gdDtcbiAgfSBlbHNlIGlmICh0IDwgLjUpIHtcbiAgICByZXR1cm4gNCAqIHQgKiB0ICogdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xuICB9XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYSBxdWFydGljIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlSW5RdWFydCh0KSB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgPyB0IDogdCAqIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBxdWFydGljIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlT3V0UXVhcnQodCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IDEgLSAoLS10KSAqIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gYW5kIG91dCB3aXRoIGEgcXVhcnRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZUluT3V0UXVhcnQodCkge1xuICBpZiAodCA9PSAwIHx8IHQgPT0gMSkge1xuICAgIHJldHVybiB0O1xuICB9IGVsc2UgaWYgKHQgPCAuNSkge1xuICAgIHJldHVybiA4ICogdCAqIHQgKiB0ICogdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMSAtIDggKiAoLS10KSAqIHQgKiB0ICogdDtcbiAgfVxufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiB3aXRoIGEgcXVpbnRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZUluUXVpbnQodCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IHQgKiB0ICogdCAqIHQgKiB0O1xufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBvdXQgd2l0aCBhIHF1aW50aWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VPdXRRdWludCh0KSB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgPyB0IDogMSArICgtLXQpICogdCAqIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gYW5kIG91dCB3aXRoIGEgcXVpbnRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IHQgPCAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKlxuICAgICAgKC0tdCkgKiB0ICogdCAqIHQgKiB0O1xufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiB3aXRoIGFuIGV4cG9uZW50aWFsIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlSW5FeHBvKHQpIHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBvdXQgd2l0aCBhbiBleHBvbmVudGlhbCBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZU91dEV4cG8odCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6ICgxIC0gTWF0aC5wb3coMiwgLTEwICogdCkpO1xufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiBhbmQgb3V0IHdpdGggYW4gZXhwb25lbnRpYWwgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VJbk91dEV4cG8odCkge1xuICBpZiAodCA9PSAwIHx8IHQgPT0gMSkge1xuICAgIHJldHVybiB0O1xuICB9IGVsc2UgaWYgKHQgPCAuNSkge1xuICAgIHJldHVybiAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgKiAyIC0gMSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiB3aXRoIGEgY2lyY3VsYXIgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VJbkNpcmModCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IDEgLSBNYXRoLnNxcnQoMSAtICh0ICogdCkpO1xufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBvdXQgd2l0aCBhIGNpcmN1bGFyIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlT3V0Q2lyYyh0KSB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgPyB0IDogTWF0aC5zcXJ0KDEgLSAodCAtIDEpICogKHQgLSAxKSk7XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhIGNpcmN1bGFyIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlSW5PdXRDaXJjKHQpIHtcbiAgaWYgKHQgPT0gMCB8fCB0ID09IDEpIHtcbiAgICByZXR1cm4gdDtcbiAgfSBlbHNlIGlmICh0IDwgLjUpIHtcbiAgICByZXR1cm4gLS41ICogKE1hdGguc3FydCgxIC0gdCAqIHQgKiA0KSAtIDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAuNSAqIChNYXRoLnNxcnQoMSAtIDQgKiAodCAtIDEpICogKHQgLSAxKSkgKyAxKTtcbiAgfVxufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiBhZnRlciBib3VuZGluZyBiYWNrd2FyZHMgYXQgdGhlIGJlZ2lubmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZUluQmFjayh0KSB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgPyB0IDogdCAqIHQgKiAoMi43MDE1OCAqIHQgLSAxLjcwMTU4KTtcbn1cblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgb3V0IGFmdGVyIGJvdW5kaW5nIHBhc3QgdGhlIGVuZCBwb2ludCBhbmQgYmFjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZU91dEJhY2sodCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID9cbiAgICAgIHQgOlxuICAgICAgKHQgLSAxKSAqICh0IC0gMSkgKiAoMi43MDE1OCAqICh0IC0gMSkgKyAxLjcwMTU4KSArIDE7XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhbiBpbml0aWFsIGFuZCBlbmRpbmcgbW92ZW1lbnQgYmV5b25kIHRoZVxuICogZnVsbCByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gZWFzZUluT3V0QmFjayh0KSB7XG4gIGlmICh0ID09IDAgfHwgdCA9PSAxKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0gZWxzZSBpZiAodCA8IC41KSB7XG4gICAgcmV0dXJuIC41ICogKHQgKiAyKSAqICh0ICogMikgKiAoMy41OTQ5MDk1ICogKHQgKiAyKSAtIDIuNTk0OTA5NSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC41ICogKCh0ICogMiAtIDIpICogKHQgKiAyIC0gMikgKlxuICAgICAgICAoMy41OTQ5MDk1ICogKHQgKiAyIC0gMikgKyAyLjU5NDkwOTUpICsgMik7XG4gIH1cbn1cblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gd2l0aCBhbiBlbGFzdGljIHNwcmluZ3kgbW90aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlSW5FbGFzdGljKHQpIHtcbiAgaWYgKHQgPT0gMCB8fCB0ID09IDEpIHtcbiAgICByZXR1cm4gdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLTEgKiAoXG4gICAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKlxuICAgICAgICBNYXRoLnNpbigodCAtIDEuMDc1KSAqICgyICogTWF0aC5QSSkgLyAuMylcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIG91dCB3aXRoIGFuIGVsYXN0aWMgc3ByaW5neSBtb3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VPdXRFbGFzdGljKHQpIHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqXG4gICAgICBNYXRoLnNpbigodCAtIC4wNzUpICogKDIgKiBNYXRoLlBJKSAvIC4zKSArIDE7XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhbiBlbGFzdGljIHNwcmluZ3kgbW90aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlSW5PdXRFbGFzdGljKHQpIHtcbiAgaWYgKHQgPT0gMCB8fCB0ID09IDEpIHtcbiAgICByZXR1cm4gdDtcbiAgfSBlbHNlIGlmICh0IDwgLjUpIHtcbiAgICByZXR1cm4gLS41ICogKE1hdGgucG93KDIsIDEwICogKCh0ICogMikgLSAxKSkgKlxuICAgICAgICBNYXRoLnNpbigodCAqIDIgLSAxLjExMjUpICogMiAqIE1hdGguUEkgLyAuNDUpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLjUgKiBNYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKlxuICAgICAgICBNYXRoLnNpbigodCAqIDIgLSAxLjExMjUpICogMiAqIE1hdGguUEkgLyAuNDUpICsgMTtcbiAgfVxufVxuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiB3aXRoIGEgc2ltcGxlIHBoeXNpY3MgYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBlYXNlSW5Cb3VuY2UodCkge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IDEgLSBlYXNlT3V0Qm91bmNlKDEgLSB0KTtcbn1cblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBzaW1wbGUgcGh5c2ljcyBib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UodCkge1xuICBpZiAodCA9PSAwIHx8IHQgPT0gMSkge1xuICAgIHJldHVybiB0O1xuICB9IGVsc2UgaWYgKHQgPCAxIC8gMi43NSkge1xuICAgIHJldHVybiA3LjU2MjUgKiB0ICogdDtcbiAgfSBlbHNlIGlmICh0IDwgMiAvIDIuNzUpIHtcbiAgICByZXR1cm4gNy41NjI1ICogKHQgLSAxLjUgLyAyLjc1KSAqICh0IC0gMS41IC8gMi43NSkgKyAuNzU7XG4gIH0gZWxzZSBpZiAodCA8IDIuNSAvIDIuNzUpIHtcbiAgICByZXR1cm4gNy41NjI1ICogKHQgLSAyLjI1IC8gMi43NSkgKiAodCAtIDIuMjUgLyAyLjc1KSArIC45Mzc1O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiA3LjU2MjUgKiAodCAtIDIuNjI1IC8gMi43NSkgKiAodCAtIDIuNjI1IC8gMi43NSkgKyAuOTg0Mzc1O1xuICB9XG59XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBzdGFydGluZyBhbmQgZW5kaW5nIGJvdW5jZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGVhc2VJbk91dEJvdW5jZSh0KSB7XG4gIGlmICh0ID09IDAgfHwgdCA9PSAxKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0gZWxzZSBpZiAodCA8IC41KSB7XG4gICAgcmV0dXJuIGVhc2VJbkJvdW5jZSh0ICogMikgKiAuNTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogLjUgKyAuNTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIHdpdGhvdXQgYW55IGVhc2luZy4gVGhpcyBpcyBvbmx5IHVzZWZ1bCBpZiBhIHNjcmlwdCBpc1xuICogZXhwZWN0aW5nIGFuIGVhc2luZyBtZXRob2QsIGJ1dCBvbmUgaXNuJ3QgbmVlZGVkIGluIHRoYXQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gIHJldHVybiB0O1xufVxuXG4vKipcbiAqIEEgbWFwIGZvciBlYXNpbmcgZnVuY3Rpb25zLlxuICogV2UgbmVlZCB0aGlzIG1hcCB0byByZWZlcmVuY2UgZWFzaW5nIGZ1bmN0aW9uIGJhc2VkIG9uIG5hbWUuXG4gKiBJdCBpcyB1c2VmdWwgd2hlbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGlzIGRlZmluZWQgaW4gcnVuLXRpbWUuXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IGVhc2luZ0Z1bmNNYXAgPSBuZXcgTWFwKFtcbiAgWydlYXNlJywgZWFzZV0sXG4gIFsnZWFzZUluU2luZScsIGVhc2VJblNpbmVdLFxuICBbJ2Vhc2VPdXRTaW5lJywgZWFzZU91dFNpbmVdLFxuICBbJ2Vhc2VJbk91dFNpbmUnLCBlYXNlSW5PdXRTaW5lXSxcbiAgWydlYXNlSW5RdWFkJywgZWFzZUluUXVhZF0sXG4gIFsnZWFzZU91dFF1YWQnLCBlYXNlT3V0UXVhZF0sXG4gIFsnZWFzZUluT3V0UXVhZCcsIGVhc2VJbk91dFF1YWRdLFxuICBbJ2Vhc2VJbkN1YmljJywgZWFzZUluQ3ViaWNdLFxuICBbJ2Vhc2VPdXRDdWJpYycsIGVhc2VPdXRDdWJpY10sXG4gIFsnZWFzZUluT3V0Q3ViaWMnLCBlYXNlSW5PdXRDdWJpY10sXG4gIFsnZWFzZUluUXVhcnQnLCBlYXNlSW5RdWFydF0sXG4gIFsnZWFzZU91dFF1YXJ0JywgZWFzZU91dFF1YXJ0XSxcbiAgWydlYXNlSW5PdXRRdWFydCcsIGVhc2VJbk91dFF1YXJ0XSxcbiAgWydlYXNlSW5RdWludCcsIGVhc2VJblF1aW50XSxcbiAgWydlYXNlT3V0UXVpbnQnLCBlYXNlT3V0UXVpbnRdLFxuICBbJ2Vhc2VJbk91dFF1aW50JywgZWFzZUluT3V0UXVpbnRdLFxuICBbJ2Vhc2VJbkV4cG8nLCBlYXNlSW5FeHBvXSxcbiAgWydlYXNlT3V0RXhwbycsIGVhc2VPdXRFeHBvXSxcbiAgWydlYXNlSW5PdXRFeHBvJywgZWFzZUluT3V0RXhwb10sXG4gIFsnZWFzZUluQ2lyYycsIGVhc2VJbkNpcmNdLFxuICBbJ2Vhc2VPdXRDaXJjJywgZWFzZU91dENpcmNdLFxuICBbJ2Vhc2VJbk91dENpcmMnLCBlYXNlSW5PdXRDaXJjXSxcbiAgWydlYXNlSW5CYWNrJywgZWFzZUluQmFja10sXG4gIFsnZWFzZU91dEJhY2snLCBlYXNlT3V0QmFja10sXG4gIFsnZWFzZUluT3V0QmFjaycsIGVhc2VJbk91dEJhY2tdLFxuICBbJ2Vhc2VJbkVsYXN0aWMnLCBlYXNlSW5FbGFzdGljXSxcbiAgWydlYXNlT3V0RWxhc3RpYycsIGVhc2VPdXRFbGFzdGljXSxcbiAgWydlYXNlSW5PdXRFbGFzdGljJywgZWFzZUluT3V0RWxhc3RpY10sXG4gIFsnZWFzZUluQm91bmNlJywgZWFzZUluQm91bmNlXSxcbiAgWydlYXNlT3V0Qm91bmNlJywgZWFzZU91dEJvdW5jZV0sXG4gIFsnZWFzZUluT3V0Qm91bmNlJywgZWFzZUluT3V0Qm91bmNlXSxcbiAgWydsaW5lYXInLCBsaW5lYXJdLFxuXSk7XG5cbmV4cG9ydCB7XG4gIGVhc2luZ0Z1bmNNYXAsXG4gIGVhc2UsXG4gIGVhc2VJblNpbmUsIGVhc2VPdXRTaW5lLCBlYXNlSW5PdXRTaW5lLFxuICBlYXNlSW5RdWFkLCBlYXNlT3V0UXVhZCwgZWFzZUluT3V0UXVhZCxcbiAgZWFzZUluQ3ViaWMsIGVhc2VPdXRDdWJpYywgZWFzZUluT3V0Q3ViaWMsXG4gIGVhc2VJblF1YXJ0LCBlYXNlT3V0UXVhcnQsIGVhc2VJbk91dFF1YXJ0LFxuICBlYXNlSW5RdWludCwgZWFzZU91dFF1aW50LCBlYXNlSW5PdXRRdWludCxcbiAgZWFzZUluRXhwbywgZWFzZU91dEV4cG8sIGVhc2VJbk91dEV4cG8sXG4gIGVhc2VJbkNpcmMsIGVhc2VPdXRDaXJjLCBlYXNlSW5PdXRDaXJjLFxuICBlYXNlSW5CYWNrLCBlYXNlT3V0QmFjaywgZWFzZUluT3V0QmFjayxcbiAgZWFzZUluRWxhc3RpYywgZWFzZU91dEVsYXN0aWMsIGVhc2VJbk91dEVsYXN0aWMsXG4gIGVhc2VJbkJvdW5jZSwgZWFzZU91dEJvdW5jZSwgZWFzZUluT3V0Qm91bmNlLFxuICBsaW5lYXIsXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvZngvZWFzaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuXG4vKiogQHJlY29yZCAqL1xuY2xhc3MgQ2Fyb3VzZWxJbWFnZUFkYXB0ZXIge1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEhlaWdodCgpIHt9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0ZldGNoaW5nQ29tcGxldGUoKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlciAqL1xuICByZWdpc3RlckxvYWRIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJMb2FkSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIG5vdGlmeUxvYWQoKSB7fVxuXG59XG5cbmV4cG9ydCB7Q2Fyb3VzZWxJbWFnZUFkYXB0ZXJ9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvaW1hZ2UvYWRhcHRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cblxuLyoqIEByZWNvcmQgKi9cbmZ1bmN0aW9uIE9wdGlvbnMoKSB7fVxuXG4vKiogQHR5cGUge3N0cmluZ30gKi9cbk9wdGlvbnMucHJvdG90eXBlLnNraXBMYWJlbDtcblxuZXhwb3J0IHtPcHRpb25zfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vcGFnZWxpc3Qvb3B0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbmltcG9ydCB7UGFnaW5hdGlvbk1vZGVsfSBmcm9tICcuLi9tb2RlbCc7XG5cbi8qKiBAcmVjb3JkICovXG5jbGFzcyBQYWdlTGlzdEFkYXB0ZXIge1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshUGFnaW5hdGlvbk1vZGVsfVxuICAgKi9cbiAgZ2V0UGFnaW5hdGlvbk1vZGVsKCkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgYGFyaWEtc2VsZWN0ZWRgIGF0dHJpYnV0ZSBvbiBhbGwgYnV0dG9uIGVsZW1lbnRzIHN1Y2ggdGhhdCB0aGVcbiAgICogYWN0aXZlIGJ1dHRvbiBpcyBgdHJ1ZWAgd2hpbGUgYWxsIG90aGVycyBhcmUgYGZhbHNlYC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50bHkgYWN0aXZlIHBhZ2UgKHN0YXJ0aW5nIGZyb20gMSkuXG4gICAqL1xuICBzZXRBcmlhU2VsZWN0ZWQoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgc2V0QWN0aXZlQnV0dG9uKGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBmb3IgYWxsIGJ1dHRvbnMgaW4gdGhlIGNvbXBvbmVudCwgc2V0dGluZ1xuICAgKiBvbmx5IHRoZSBhY3RpdmUgYnV0dG9uIHRvIGJlIGZvY3VzYWJsZSAoYHRhYmluZGV4PVwiMFwiYCkgd2hpbGUgb3RoZXIgYnV0dG9uc1xuICAgKiBhcmUgc2V0IHRvIG5vdCBmb2N1c2FibGUgKGB0YWJpbmRleD1cIi0xXCJgKS5cbiAgICogU2VlIGIvNjg4MjE0MDUgZm9yIHJhdGlvbmFsZSBvbiB0aGlzIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgY3VycmVudGx5IGFjdGl2ZSBwYWdlIChzdGFydGluZyBmcm9tIDEpLlxuICAgKi9cbiAgc2V0VGFiSW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRBcmlhTGFiZWwoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcbiAgICovXG4gIHNldEFyaWFMYWJlbChpbmRleCwgbGFiZWwpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckNsaWNrSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckNsaWNrSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBoYW5kbGVyIHRvIGJlIHVzZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGtleXMgb24gdGhlIGtleWJvYXJkXG4gICAqIHdoZW4gZm9jdXNlZCBvbiBidXR0b25zIHdpdGhpbiB0aGUgY29tcG9uZW50LiBUaGlzIGlzIHVzZWQgdG8gbmF2aWdhdGVcbiAgICogdGhlIGNvbXBvbmVudCB0byB0aGUgbmV4dC9wcmV2aW91cyBwYWdlIHdoZW4gcmlnaHQvbGVmdCBhcnJvd3MgYXJlIHByZXNzZWQuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlcktleUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlcktleUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyRm9jdXNIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRm9jdXNIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckJsdXJIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyQmx1ckhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRoZSBjb21wb25lbnQgY3VycmVudGx5IGhhcyBhIGNoaWxkIHdpdGggZm9jdXMgb3Igbm90LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZFxuICAgKi9cbiAgc2V0SGFzRm9jdXMoaXNGb2N1c2VkKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGtleWJvYXJkIGZvY3VzIHRvIHRoZSBidXR0b24gc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIHBhZ2UgbnVtYmVyIChzdGFydGluZyBmcm9tIDEpLlxuICAgKi9cbiAgZm9jdXMoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBpcyBhIHJpZ2h0IHRvIGxlZnQgbGFuZ3VhZ2UgYmxvY2suXG4gICAqL1xuICBpc1J0bCgpIHt9XG59XG5cbmV4cG9ydCB7UGFnZUxpc3RBZGFwdGVyfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vcGFnZWxpc3QvYWRhcHRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyB1c2VkIHdoZW4gd29ya2luZyB3aXRoIGtleSBldmVudHMuXG4gKi9cblxuXG5cbi8qKlxuICogUG9zc2libGUgdmFsdWVzIGZvciBgRXZlbnQua2V5YC4gU3BlYyBpcyBzdGlsbCBpbiBkcmFmdCBmb3JtLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgS2V5ID0ge1xuICBFTlRFUjogJ0VudGVyJyxcbiAgU1BBQ0U6ICcgJyxcbiAgVEFCOiAnVGFiJyxcbiAgRVNDOiAnRXNjYXBlJyxcbiAgLy8gVGhlc2Ugb25seSB0cmlnZ2VyIHdpdGggYGtleWRvd25gIG5vdCBga2V5cHJlc3NgIG9uIENocm9tZS5cbiAgTEVGVDogJ0Fycm93TGVmdCcsXG4gIFVQOiAnQXJyb3dVcCcsXG4gIFJJR0hUOiAnQXJyb3dSaWdodCcsXG4gIERPV046ICdBcnJvd0Rvd24nLFxufTtcblxuXG4vKipcbiAqIEtleWNvZGVzIHNlbnQgd2l0aCBgRXZlbnQua2V5Q29kZWAgYW5kIGBFdmVudC53aGljaGAuXG4gKiBOb3RlIHRoYXQgYGtleUNvZGVgIGFuZCBgd2hpY2hgIGFyZSBkZXByZWNhdGVkIGluIGJyb3dzZXJzIGJ1dCBga2V5YCBpc1xuICogc3RpbGwgaW4gZHJhZnQgZm9ybSBhbmQgbm90IGZ1bGx5IHN1cHBvcnRlZCB5ZXQuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBLZXlDb2RlID0ge1xuICBFTlRFUjogMTMsXG4gIFNQQUNFOiAzMixcbiAgVEFCOiA5LFxuICBFU0M6IDI3LFxuICBMRUZUOiAzNywgICAgICAgLy8gYWxzbyBOVU1fV0VTVFxuICBVUDogMzgsICAgICAgICAgLy8gYWxzbyBOVU1fTk9SVEhcbiAgUklHSFQ6IDM5LCAgICAgIC8vIGFsc28gTlVNX0VBU1RcbiAgRE9XTjogNDAsICAgICAgIC8vIGFsc28gTlVNX1NPVVRIXG59O1xuXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG1hcHBpbmcgb2YgS2V5Q29kZSB0byBLZXkuIFRoaXMgaXMgdXNlZnVsIGZvciB0ZXN0aW5nIGZvclxuICogc2V0dGluZyBib3RoIGBrZXlgIGFuZCBga2V5Q29kZWAgY29uc2lzdGVudGx5LlxuICogQHJldHVybiB7IU1hcDxudW1iZXIsc3RyaW5nPn1cbiAqL1xuY29uc3QgY3JlYXRlS2V5Q29kZVRvS2V5TWFwID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGtleUNvZGVNYXAgPSBuZXcgTWFwKCk7XG4gIE9iamVjdC5rZXlzKEtleUNvZGUpLmZvckVhY2goKGtleU5hbWUpID0+IHtcbiAgICBrZXlDb2RlTWFwLnNldChLZXlDb2RlW2tleU5hbWVdLCBLZXlba2V5TmFtZV0pO1xuICB9KTtcbiAgcmV0dXJuIGtleUNvZGVNYXA7XG59O1xuXG4vKiogQGNvbnN0IHshTWFwPG51bWJlcixzdHJpbmc+fSAqL1xuY29uc3QgS0VZX0NPREVfTUFQID0gY3JlYXRlS2V5Q29kZVRvS2V5TWFwKCk7XG5cbmV4cG9ydCB7S2V5LCBLZXlDb2RlLCBLRVlfQ09ERV9NQVB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvZXZlbnRzL2tleS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFBhZ2VOYXYgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9wYWdlLW5hdi9wYWdlLW5hdic7XG5pbXBvcnQge0xCR2x1ZUNhcm91c2VsfSBmcm9tICdAZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvZ2x1ZS1jYXJvdXNlbCc7XG5cblxuLyoqIEBwcml2YXRlIEBjb25zdCB7c3RyaW5nfSovXG5jb25zdCBTZWxlY3RvcnNfID0ge1xuICBDQVJPVVNFTDogJy5sYi1qcy1jYXJvdXNlbCcsXG59O1xuXG4vKipcbiAqIENsYXNzIGZvciBCcm9uemUgcGFnZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvbnplIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbmV3IFBhZ2VOYXY7XG4gICAgbmV3IExCR2x1ZUNhcm91c2VsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3JzXy5DQVJPVVNFTCkpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhZ2VzL2JlbmVmaXRzL2Jyb256ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFBhZ2VOYXYgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9wYWdlLW5hdi9wYWdlLW5hdic7XG5pbXBvcnQge0xCR2x1ZUNhcm91c2VsfSBmcm9tICdAZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvZ2x1ZS1jYXJvdXNlbCc7XG5cblxuLyoqIEBwcml2YXRlIEBjb25zdCB7c3RyaW5nfSovXG5jb25zdCBTZWxlY3RvcnNfID0ge1xuICBDQVJPVVNFTDogJy5sYi1qcy1jYXJvdXNlbCcsXG59O1xuXG4vKipcbiAqIENsYXNzIGZvciBHcmFwaGl0ZSBwYWdlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaGl0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIG5ldyBQYWdlTmF2O1xuICAgIG5ldyBMQkdsdWVDYXJvdXNlbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uQ0FST1VTRUwpKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWdlcy9iZW5lZml0cy9ncmFwaGl0ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFBhZ2VOYXYgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9wYWdlLW5hdi9wYWdlLW5hdic7XG5pbXBvcnQge0xCR2x1ZUNhcm91c2VsfSBmcm9tICdAZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvZ2x1ZS1jYXJvdXNlbCc7XG5cblxuLyoqIEBwcml2YXRlIEBjb25zdCB7c3RyaW5nfSovXG5jb25zdCBTZWxlY3RvcnNfID0ge1xuICBDQVJPVVNFTDogJy5sYi1qcy1jYXJvdXNlbCcsXG59O1xuXG4vKipcbiAqIENsYXNzIGZvciBPcGFsIHBhZ2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wYWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBuZXcgUGFnZU5hdjtcbiAgICBuZXcgTEJHbHVlQ2Fyb3VzZWwoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3RvcnNfLkNBUk9VU0VMKSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFnZXMvYmVuZWZpdHMvb3BhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFBhZ2VOYXYgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9wYWdlLW5hdi9wYWdlLW5hdic7XG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgU2lsdmVyIHBhZ2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbHZlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIG5ldyBQYWdlTmF2O1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhZ2VzL2JlbmVmaXRzL3NpbHZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IE1vZGFsIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbW9kYWwvbW9kYWwnO1xuaW1wb3J0IHtMQklmcmFtZUFwaX0gZnJvbSAnQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL3ZpZGVvLWlmcmFtZSc7XG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgQmVuZWZpdHMgcGFnZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmVuZWZpdHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBuZXcgTW9kYWw7XG4gICAgbmV3IExCSWZyYW1lQXBpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhZ2VzL2JlbmVmaXRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge0xCSWZyYW1lQXBpfSBmcm9tICdAZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvdmlkZW8taWZyYW1lJztcblxuXG4vKipcbiAqIENsYXNzIGZvciBBd2FyZHMgcGFnZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXdhcmRzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbmV3IExCSWZyYW1lQXBpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhZ2VzL2F3YXJkcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgQ3JlYXRvcnMgQmFubmVyLlxuICogQHBhcmFtIHtMb2NhbFN0b3JlfSBBIG5ldyBMb2NhbFN0b3JlIGluc3RhbmNlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyZWF0b3JzQmFubmVyIHtcbiAgY29uc3RydWN0b3IobG9jYWxTdG9yZSkge1xuICAgIHRoaXMuYmFubmVyRWxfID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzdHJpbmdzLkJBTk5FUik7XG5cbiAgICB0aGlzLmNsb3NlQnRuXyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3RyaW5ncy5DTE9TRV9CVE4pO1xuXG4gICAgaWYgKHRoaXMuY2xvc2VCdG5fKSB7XG4gICAgICB0aGlzLmNsb3NlQnRuXy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuaGFuZGxlQ2xpY2tfKCkpO1xuICAgIH1cblxuICAgIHRoaXMubG9jYWxTdG9yZSA9IGxvY2FsU3RvcmU7XG5cbiAgICBpZiAodGhpcy5iYW5uZXJFbF8pIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZV8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGJhbm5lci5cbiAgICovXG4gIGluaXRpYWxpemVfKCkge1xuICAgIGNvbnN0IGlzQmFubmVyQ2xvc2VkID0gdGhpcy5sb2NhbFN0b3JlLnJlZGVlbSgnaXNCYW5uZXJDbG9zZWQnKTtcblxuICAgIHRoaXMuYmFubmVyRWxfLmNsYXNzTGlzdC50b2dnbGUoc3RyaW5ncy5TSE9XX0VMRU1FTlQsICFpc0Jhbm5lckNsb3NlZCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgY2xpY2sgb24gY2xvc2UgYnV0dGlvbi4gQ2xvc2VzIHRoZSBiYW5uZXJcbiAgICogYW5kIGluc2VydHMgdmFsdWUgaW4gbG9jYWxzdG9yZS5cbiAgICovXG4gIGhhbmRsZUNsaWNrXygpIHtcbiAgICB0aGlzLmJhbm5lckVsXy5jbGFzc0xpc3QucmVtb3ZlKHN0cmluZ3MuU0hPV19FTEVNRU5UKTtcblxuICAgIHRoaXMubG9jYWxTdG9yZS5pbnNlcnQoe1xuICAgICAgJ2lzQmFubmVyQ2xvc2VkJzogdHJ1ZSxcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jcmVhdG9ycy1iYW5uZXIvYmFubmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge01EQ0NvbXBvbmVudH0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UnO1xuaW1wb3J0IHtMQkFjY29yZGlvbkZvdW5kYXRpb259IGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQge0xCQWNjb3JkaW9uRHJhd2VyfSBmcm9tICcuL2FjY29yZGlvbi1kcmF3ZXIvaW5kZXgnO1xuXG5cbi8qKiBAY29uc3Qge3N0cmluZ30gLSBjb21wb25lbnQgY2xhc3NlcyAqL1xuY29uc3Qge1xuICBEUkFXRVJTX1RPR0dMRV9CVE5fQ0xBU1MsXG4gIFZJU0lCTEVfQ0xBU1N9ID0gTEJBY2NvcmRpb25Gb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG5cblxuLyoqIEBjb25zdCB7c3RyaW5nfSAtIGNvbXBvbmVudCBzdHJpbmdzICovXG5jb25zdCB7XG4gICAgT1BUSU9OU19LRVksXG4gICAgRFJBV0VSX0lOREVYX0tFWSxcbiAgICBEUkFXRVJTX1NFTEVDVE9SLFxuICAgIERSQVdFUlNfVE9HR0xFX0JUTl9TRUxFQ1RPUixcbiAgICBEUkFXRVJfSEVBRF9TRUxFQ1RPUixcbiAgICBEUkFXRVJfU0VMRUNUT1IsXG4gICAgSElEREVOX0FSSUEsXG4gICAgT1BFTl9BTExfRkFRX1RFWFQsXG4gICAgU0hVVF9BTExfRkFRX1RFWFR9ID0gTEJBY2NvcmRpb25Gb3VuZGF0aW9uLnN0cmluZ3M7XG5cblxuLyoqIEBjb25zdCB7c3RyaW5nfSAtIGNvbXBvbmVudCBldmVudHMgKi9cbmNvbnN0IHtSRUZSRVNIfSA9IExCQWNjb3JkaW9uRm91bmRhdGlvbi5ldmVudHM7XG4vKipcbiAqIENsYXNzIHRoYXQgZGVmaW5lcyBMQkFjY29yZGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIExCQWNjb3JkaW9uIGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLy8gSW52b2tlZCBieSBgbWRjLmF1dG9Jbml0KClgXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBMQkFjY29yZGlvbihyb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBjb21wb25lbnQgZm91bmRhdGlvbiBhbmQgcGFzcyBpdCB0aGUgYWRhcHRlciBkaWN0LlxuICAgKiBAcmV0dXJuIHtMQkFjY29yZGlvbkZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IExCQWNjb3JkaW9uRm91bmRhdGlvbih7XG4gICAgICBnZXRSb290OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfO1xuICAgICAgfSxcbiAgICAgIGdldE9wdGlvbnM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gICAgICB9LFxuICAgICAgZ2V0RHJhd2VyczogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXJzXztcbiAgICAgIH0sXG4gICAgICBnZXREcmF3ZXJJbmRleEZyb21FdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGRyYXdlckluZGV4ID1cbiAgICAgICAgICAgIChldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKERSQVdFUl9JTkRFWF9LRVkpIHx8ICctMScpO1xuICAgICAgICByZXR1cm4gTnVtYmVyKGRyYXdlckluZGV4KTtcbiAgICAgIH0sXG4gICAgICBzZXRUb2dnbGVCdXR0b25BdHRyOiAoYXR0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnRvZ2dsZUJ0bl8pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvZ2dsZUJ0bl8uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBldmVudFN0b3BQcm9wYWdhdGlvbjogKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSxcbiAgICAgIGV2ZW50UHJldmVudERlZmF1bHQ6IChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSxcbiAgICAgIG5vZGVFcXVhbHNUb2dnbGVCdXR0b246IChldmVudCkgPT4ge1xuICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKERSQVdFUlNfVE9HR0xFX0JUTl9DTEFTUyk7XG4gICAgICB9LFxuICAgICAgc2V0RHJhd2VyU3R5bGVzOiAoc3R5bGVzKSA9PiB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5kcmF3ZXJzUGFyZW50Xy5zdHlsZSwgc3R5bGVzKTtcbiAgICAgIH0sXG4gICAgICBlbmFibGVEcmF3ZXJzVGFiU3RhdGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5lbmFibGVEcmF3ZXJzVGFiU3RhdGVfKCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3NEcmF3ZXJzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd2Vyc1BhcmVudF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfSxcbiAgICAgIGFwcGVuZENsYXNzRHJhd2VyczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdlcnNQYXJlbnRfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0sXG4gICAgICBkcmF3ZXJzSGF2ZU1hdGVyaWFsaXplZDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXJzUGFyZW50Xy5jbGFzc0xpc3QuY29udGFpbnMoVklTSUJMRV9DTEFTUyk7XG4gICAgICB9LFxuICAgICAgYXBwZW5kQ2xhc3NUb2dnbGVCdXR0b246IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnRvZ2dsZUJ0bl8pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2dnbGVCdG5fLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzc1RvZ2dsZUJ1dHRvbjogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMudG9nZ2xlQnRuXykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvZ2dsZUJ0bl8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfSxcbiAgICAgIGF0dGFjaEludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIGRldGFjaEludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIGF0dGFjaFJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIC8vIFRPRE8oY2xheXRvbm1pc3VyYUApOiBSZXBsYWNlIHdpdGggUmFmIHJlc2l6ZS5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIGRldGFjaFJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIHJvb3QgZWxlbWVudCdzIGBkYXRhLWxiLW9wdGlvbnM9YCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqIEByZXR1cm4gez9PYmplY3Q8c3RyaW5nLCAqPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBhcnNlT3B0aW9uc1N0cmluZ18oKSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBkZWZhdWx0SGlkZUFjY29yZGlvbjogZmFsc2UsXG4gICAgICAvLyBBcmlhIFN0cmluZ3NcbiAgICAgIG9wZW5BbGxGYXFUZXh0OiBPUEVOX0FMTF9GQVFfVEVYVCxcbiAgICAgIHNodXRBbGxGYXFUZXh0OiBTSFVUX0FMTF9GQVFfVEVYVCxcbiAgICB9O1xuXG4gICAgY29uc3QgcGFyc2VkSlNPTiA9IEpTT04ucGFyc2UoXG4gICAgICAgIHRoaXMucm9vdF8uZ2V0QXR0cmlidXRlKE9QVElPTlNfS0VZKVxuICAgICAgKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBuZXcgT2JqZWN0KHBhcnNlZEpTT04pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1vYmplY3RcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb21wdXRlcyB0aGUgaGVpZ2h0IG9mIGVhY2ggYWNjb3JkaW9uIGRyYXdlci5cbiAgICovXG4gIGNvbXB1dGVEcmF3ZXJIZWlnaHRBbGwoKSB7XG4gICAgdGhpcy5kcmF3ZXJzXy5mb3JFYWNoKChkcmF3ZXIpID0+IGRyYXdlci5jb21wdXRlRHJhd2VySGVpZ2h0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgZHJhd2VyL2RyYXdlciBjb250ZW50IGNhbiBiZSBhY2Nlc3NlZCBieVxuICAgKiBzY3JlZW4gcmVhZGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5hYmxlRHJhd2Vyc1RhYlN0YXRlXygpIHtcbiAgICB0aGlzLmRyYXdlcnNQYXJlbnRfLnNldEF0dHJpYnV0ZShISURERU5fQVJJQSwgJ2ZhbHNlJyk7XG4gICAgdGhpcy5kcmF3ZXJzXy5mb3JFYWNoKChkcmF3ZXIpID0+IGRyYXdlci5lbmFibGVEcmF3ZXJIZWFkVGFiU3RhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyBoaWRkZW4gZHJhd2VyL2RyYXdlciBjb250ZW50IGNhbid0IGJlIGFjY2Vzc2VkIGJ5XG4gICAqIHNjcmVlbiByZWFkZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzYWJsZURyYXdlcnNUYWJTdGF0ZV8oKSB7XG4gICAgdGhpcy5kcmF3ZXJzUGFyZW50Xy5zZXRBdHRyaWJ1dGUoSElEREVOX0FSSUEsICd0cnVlJyk7XG4gICAgdGhpcy5kcmF3ZXJzXy5mb3JFYWNoKChkcmF3ZXIpID0+IGRyYXdlci5kaXNhYmxlRHJhd2VySGVhZFRhYlN0YXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlYXJzIGRvd24gY29tcG9uZW50IHN0eWxlcywgcmVtb3ZlcyBhdHRyaWJ1dGVzIGFuZCB1bmJpbmRzXG4gICAqIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5saXN0ZW4oUkVGUkVTSCwgdGhpcy5yZWZyZXNoQ2FsbGJhY2tfKTtcbiAgICB0aGlzLmRyYXdlcnNQYXJlbnRfLnJlbW92ZUF0dHJpYnV0ZShISURERU5fQVJJQSk7XG4gICAgdGhpcy5kcmF3ZXJzXy5mb3JFYWNoKChkcmF3ZXIpID0+IGRyYXdlci5kZXN0cm95KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGNvbXBvbmVudC4gU2V0dXAgZWxlbWVudHMgYW5kIGNoaWxkIGNvbXBvbmVudHMuXG4gICAqL1xuICBpbml0aWFsaXplKCkge1xuICAgIC8qKiBAcHJpdmF0ZSB7P09iamVjdH0gKi9cbiAgICB0aGlzLm9wdGlvbnNfID0gdGhpcy5wYXJzZU9wdGlvbnNTdHJpbmdfKCk7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLnRvZ2dsZUJ0bl8gPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoRFJBV0VSU19UT0dHTEVfQlROX1NFTEVDVE9SKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMuZHJhd2Vyc1BhcmVudF8gPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoRFJBV0VSU19TRUxFQ1RPUik7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshQXJyYXk8IUxCQWNjb3JkaW9uRHJhd2VyPn0gKi9cbiAgICB0aGlzLmRyYXdlcnNfID0gdGhpcy5xdWVyeUVuY2Fwc3VsYXRlZF8oRFJBV0VSX1NFTEVDVE9SKVxuICAgICAgICAubWFwKHRoaXMuZ2F0aGVyRHJhd2Vyc18pO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMucmVmcmVzaENhbGxiYWNrXyA9IHRoaXMuY29tcHV0ZURyYXdlckhlaWdodEFsbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5kcmF3ZXJzUGFyZW50Xy5zZXRBdHRyaWJ1dGUoSElEREVOX0FSSUEsICd0cnVlJyk7XG4gICAgdGhpcy5saXN0ZW4oUkVGUkVTSCwgdGhpcy5yZWZyZXNoQ2FsbGJhY2tfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGNoaWxkIGRyYXdlciBjb21wb25lbnQgZnJvbSBET00gbm9kZS5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gZHJhd2VyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHshQXJyYXk8IUxCQWNjb3JkaW9uRHJhd2VyPn1cbiAgICovXG4gIGdhdGhlckRyYXdlcnNfKGRyYXdlciwgaW5kZXgpIHtcbiAgICBjb25zdCBkcmF3ZXJIZWFkID0gZHJhd2VyLnF1ZXJ5U2VsZWN0b3IoRFJBV0VSX0hFQURfU0VMRUNUT1IpO1xuICAgIGRyYXdlckhlYWQuc2V0QXR0cmlidXRlKERSQVdFUl9JTkRFWF9LRVksIGluZGV4KTtcbiAgICByZXR1cm4gbmV3IExCQWNjb3JkaW9uRHJhd2VyKGRyYXdlcik7XG4gIH1cblxuICAvKipcbiAgICogUXVlcmllcyBjaGlsZCBzZWxlY3RvciBhbmQgY29lcmNlIERPTSBsaXN0IHRvIG5hdGl2ZSBBcnJheS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4geyFBcnJheTwhRWxlbWVudD59XG4gICAqL1xuICBxdWVyeUVuY2Fwc3VsYXRlZF8oc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgICAgdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxuICAgICAgKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIE9QRU5fQ0xBU1M6ICdpcy1vcGVuJyxcbiAgQUNUSVZFX0NMQVNTOiAnaXMtYWN0aXZlJyxcbiAgRFJBV0VSU19UT0dHTEVfQlROX0NMQVNTOiAnbGItanMtYWNjb3JkaW9uLXRvZ2dsZS1kcmF3ZXJzJyxcbiAgUk9PVF9DTEFTUzogJ2xiLWpzLWFjY29yZGlvbicsXG4gIFZJU0lCTEVfQ0xBU1M6ICdpcy12aXNpYmxlJyxcbiAgSEFTX1RPR0dMRURfQ0xBU1M6ICdoYXMtdG9nZ2xlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBST09UX1NFTEVDVE9SOiAnLmxiLWpzLWFjY29yZGlvbicsXG4gIERSQVdFUlNfU0VMRUNUT1I6ICcubGItanMtYWNjb3JkaW9uLWRyYXdlcnMnLFxuICBEUkFXRVJTX1RPR0dMRV9CVE5fU0VMRUNUT1I6ICcubGItanMtYWNjb3JkaW9uLXRvZ2dsZS1kcmF3ZXJzJyxcbiAgRFJBV0VSX1NFTEVDVE9SOiAnLmxiLWpzLWFjY29yZGlvbi1kcmF3ZXInLFxuICBEUkFXRVJfSEVBRF9TRUxFQ1RPUjogJy5sYi1qcy1hY2NvcmRpb24tZHJhd2VyLWhlYWQnLFxuICBEUkFXRVJfQk9EWV9TRUxFQ1RPUjogJy5sYi1qcy1hY2NvcmRpb24tZHJhd2VyLWJvZHknLFxuICBEUkFXRVJfSU5ERVhfS0VZOiAnZGF0YS1pbmRleCcsXG4gIE9QVElPTlNfS0VZOiAnZGF0YS1sYi1hY2NvcmRpb24tb3B0aW9ucycsXG4gIElEOiAnaWQnLFxuICBJRF9QUkVGSVg6ICdpZC1kcmF3ZXItaW5kZXgtJyxcbiAgSElEREVOX0FSSUE6ICdhcmlhLWhpZGRlbicsXG4gIENPTlRST0xTX0FSSUE6ICdhcmlhLWNvbnRyb2xzJyxcbiAgRVhQQU5ERURfQVJJQTogJ2FyaWEtZXhwYW5kZWQnLFxuICBMQUJFTF9BUklBOiAnYXJpYS1sYWJlbCcsXG4gIE9QRU5fVFJBTlNJVElPTjogJ3dpbGwtb3BlbicsXG4gIFNIVVRfVFJBTlNJVElPTjogJ3dpbGwtc2h1dCcsXG4gIFNIT1dfRkFRX1RFWFQ6ICdDbGljayB0byBzaG93IEZBUXMnLFxuICBPUEVOX0FMTF9GQVFfVEVYVDogJ0NsaWNrIHRvIG9wZW4gYWxsIEZBUXMnLFxuICBTSFVUX0FMTF9GQVFfVEVYVDogJ0NsaWNrIHRvIGNsb3NlIGFsbCBGQVFzJyxcbiAgRk9DVVNBQkxFX0VMRU1FTlRTOiAnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCAnICtcbiAgICAgICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksICcgK1xuICAgICAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgW3RhYmluZGV4XSwgJyArXG4gICAgICAnW2NvbnRlbnRlZGl0YWJsZV0nLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgbnVtYmVycyA9IHtcbiAgVEFCX0tFWTogOSxcbiAgRVNDQVBFX0tFWTogMjcsXG4gIEVOVEVSX0tFWTogMTMsXG4gIFdBSVRfVU5USUxfVklTSUJMRV9USU1FOiAyNTAsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBldmVudHMgPSB7XG4gIE9QRU5fRFJBV0VSOiAnbGItYWNjb3JkaW9uLW9wZW4tZHJhd2VyJyxcbiAgQ0xPU0VfRFJBV0VSOiAnbGItYWNjb3JkaW9uLWNsb3NlLWRyYXdlcicsXG4gIFRPR0dMRV9EUkFXRVI6ICdsYi1hY2NvcmRpb24tdG9nZ2xlLWRyYXdlcicsXG4gIFJFRlJFU0g6ICdsYi1hY2NvcmRpb24tcmVmcmVzaCcsXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24vY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge01EQ0NvbXBvbmVudH0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UnO1xuaW1wb3J0IHtMQkFjY29yZGlvbkRyYXdlckZvdW5kYXRpb259IGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQge1xuICBzZXRBdHRyLFxuICBzYXZlRWxlbWVudFRhYlN0YXRlLFxuICByZXN0b3JlRWxlbWVudFRhYlN0YXRlLFxuICB0cmF2ZXJzZURPTUZvclBhcmVudEVsZW1lbnR9IGZyb20gJy4uL3V0aWwnO1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9IC0gY29tcG9uZW50IGNsYXNzZXMgKi9cbmNvbnN0IHtST09UX0NMQVNTfSA9IExCQWNjb3JkaW9uRHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9IC0gY29tcG9uZW50IHN0cmluZ3MgKi9cbmNvbnN0IHtcbiAgRk9DVVNBQkxFX0VMRU1FTlRTLFxuICBEUkFXRVJfSEVBRF9TRUxFQ1RPUixcbiAgRFJBV0VSX0JPRFlfU0VMRUNUT1IsXG4gIERSQVdFUl9JTkRFWF9LRVl9ID0gTEJBY2NvcmRpb25EcmF3ZXJGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCBkZWZpbmVzIGFuIEFjY29yZGlvbiBkcmF3ZXIgY29tcG9uZW50LlxuICovXG5leHBvcnQgY2xhc3MgTEJBY2NvcmRpb25EcmF3ZXIgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBMQkFjY29yZGlvbkRyYXdlcihyb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBjb21wb25lbnQgZm91bmRhdGlvbiBhbmQgcGFzcyBpdCB0aGUgYWRhcHRlciBkaWN0LlxuICAgKiBAcmV0dXJuIHtMQkFjY29yZGlvbkRyYXdlckZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IExCQWNjb3JkaW9uRHJhd2VyRm91bmRhdGlvbih7XG4gICAgICBnZXREcmF3ZXJSb290OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfO1xuICAgICAgfSxcbiAgICAgIGdldERyYXdlckJvZHk6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyQm9keV87XG4gICAgICB9LFxuICAgICAgZ2V0RHJhd2VySGVhZDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXJIZWFkXztcbiAgICAgIH0sXG4gICAgICBnZXREcmF3ZXJJbmRleDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gTnVtYmVyKFxuICAgICAgICAgICAgdGhpcy5kcmF3ZXJIZWFkXy5nZXRBdHRyaWJ1dGUoRFJBV0VSX0lOREVYX0tFWSlcbiAgICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNldERyYXdlckJvZHlBdHRyOiAoYXR0ck5hbWUsIGF0dHJEYXRhKSA9PiB7XG4gICAgICAgIHNldEF0dHIodGhpcy5kcmF3ZXJCb2R5XywgYXR0ck5hbWUsIGF0dHJEYXRhKTtcbiAgICAgIH0sXG4gICAgICBzZXREcmF3ZXJIZWFkQXR0cjogKGF0dHJOYW1lLCBhdHRyRGF0YSkgPT4ge1xuICAgICAgICBzZXRBdHRyKHRoaXMuZHJhd2VySGVhZF8sIGF0dHJOYW1lLCBhdHRyRGF0YSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlRHJhd2VyQm9keUF0dHI6IChhdHRyTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdlckJvZHlfLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlRHJhd2VySGVhZEF0dHI6IChhdHRyTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdlckhlYWRfLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICB9LFxuICAgICAgZ2V0RHJhd2VyQm9keUF0dHI6IChhdHRyTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREcmF3ZXJCb2R5KCkuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgIH0sXG4gICAgICBnZXREcmF3ZXJIZWFkQXR0cjogKGF0dHJOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdlckhlYWRfLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICB9LFxuICAgICAgc2V0RHJhd2VyQm9keVN0eWxlOiAocHJvcGVydHlOYW1lcykgPT4ge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZHJhd2VyQm9keV8uc3R5bGUsIHByb3BlcnR5TmFtZXMpO1xuICAgICAgfSxcbiAgICAgIGdldERyYXdlckJvZHlIZWlnaHQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyQm9keV8uc2Nyb2xsSGVpZ2h0O1xuICAgICAgfSxcbiAgICAgIGFwcGVuZENsYXNzRHJhd2VyQm9keTogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdlckJvZHlfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzc0RyYXdlckJvZHk6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3ZXJCb2R5Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3NEcmF3ZXJSb290OiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMucm9vdF8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfSxcbiAgICAgIGFwcGVuZENsYXNzRHJhd2VyUm9vdDogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0sXG4gICAgICBwcm9iZURPTUZvckNvbnRyb2xsZXI6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlRE9NRm9yUGFyZW50RWxlbWVudCh0aGlzLnJvb3RfLCAocGFyZW50Tm9kZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucyhST09UX0NMQVNTKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgbmFtZUVxdWFsc0V2ZW50UHJvcGVydHk6IChldmVudCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBldmVudC5wcm9wZXJ0eU5hbWUgPT09IHByb3BlcnR5TmFtZTtcbiAgICAgIH0sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4ge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgICAgICAgIHRoaXMuZHJhd2VyQm9keV8ucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpXG4gICAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzYXZlRWxlbWVudFRhYlN0YXRlOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICBzYXZlRWxlbWVudFRhYlN0YXRlKGVsZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGU6IChlbGVtZW50KSA9PiB7XG4gICAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWxlbWVudCk7XG4gICAgICB9LFxuICAgICAgcHJldmVudEVsZW1lbnRUYWI6IChlbGVtZW50KSA9PiB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgfSxcbiAgICAgIGV2ZW50U3RvcFByb3BhZ2F0aW9uOiAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LFxuICAgICAgZHJhd2VySGVhZEF0dGFjaEludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3ZXJIZWFkXy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIGRyYXdlckhlYWREZXRhY2hJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd2VySGVhZF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBhdHRhY2hJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXRhY2hJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgY29tcG9uZW50LiBTZXR1cCBlbGVtZW50cyBhbmQgY2hpbGQgY29tcG9uZW50cy5cbiAgICovXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5kcmF3ZXJCb2R5XyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihEUkFXRVJfQk9EWV9TRUxFQ1RPUik7XG4gICAgdGhpcy5kcmF3ZXJIZWFkXyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihEUkFXRVJfSEVBRF9TRUxFQ1RPUik7XG4gIH1cblxuICAvKipcbiAgICogUHJveHkgZm91bmRhdGlvbiB0byBkZXN0cm95IGRyYXdlci5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgcG9zdCBET00gaW50ZXJhY3RpdmUuXG4gICAqL1xuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgdGhpcy5jb21wdXRlRHJhd2VySGVpZ2h0KCk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyBkcmF3ZXIvZHJhd2VyIGNvbnRlbnQgdGFiYmFibGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbmFibGVEcmF3ZXJIZWFkVGFiU3RhdGUoKSB7XG4gICAgdGhpcy5kcmF3ZXJIZWFkXy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIGhpZGRlbiBkcmF3ZXIvZHJhd2VyIGNvbnRlbnQgaXMgdW50YWJiYWJsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc2FibGVEcmF3ZXJIZWFkVGFiU3RhdGUoKSB7XG4gICAgdGhpcy5kcmF3ZXJIZWFkXy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIH1cblxuICAvKipcbiAgICogUHJveHkgZm91bmRhdGlvbiB0byBjb21wdXRlIGRyYXdlciBoZWlnaHQuXG4gICAqIFhYWChjbGF5dG9ubWlzdXJhQCk6IElzIHRoaXMgbmVjZXNzYXJ5P1xuICAgKi9cbiAgY29tcHV0ZURyYXdlckhlaWdodCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmNvbXB1dGVIZWlnaHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm94eSBmb3VuZGF0aW9uIHRvIHNldCBkcmF3ZXIgc3RhdGUgdG8gc2h1dC5cbiAgICovXG4gIHNodXREcmF3ZXIoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zaHV0RHJhd2VyKCk7XG4gIH1cblxuICAvKipcbiAgICogUHJveHkgZm91bmRhdGlvbiB0byBzZXQgZHJhd2VyIHN0YXRlIHRvIG9wZW4uXG4gICAqL1xuICBvcGVuRHJhd2VyKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8ub3BlbkRyYXdlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3h5IGZvdW5kYXRpb24gdG8gdG9nZ2xlIGRyYXdlciBzdGF0ZS5cbiAgICovXG4gIG9wZW5TaHV0RHJhd2VyKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8ub3BlblNodXREcmF3ZXIoKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24vYWNjb3JkaW9uLWRyYXdlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFRpbWVyIGZyb20gJy4uL3RpbWVyL3RpbWVyJztcbmltcG9ydCB7ZWFzZUluT3V0UXVhZH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL2Vhc2luZyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAneCc6IG51bWJlcixcbiAqICAneSc6IG51bWJlcixcbiAqIH19XG4gKi9cbmxldCBFbGVtZW50UG9zaXRpb247XG5cbi8qKlxuICogRGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbmFsIHNldHRpbmdzLlxuICogQHByaXZhdGUgQGVudW0geyFudW1iZXJ9XG4gKi9cbmNvbnN0IE9QVElPTl9ERUZBVUxUU18gPSB7XG4gIGR1cmF0aW9uOiA1MDAsXG4gIG9mZnNldDoge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgfSxcbiAgY29udGFpbmVyU2VsZWN0b3I6IG51bGwsXG4gIGNvbnRhaW5lcjogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICBlYXNpbmc6IGVhc2VJbk91dFF1YWQsXG59O1xuXG5cbi8qKlxuKiBDbGFzcyB0aGF0IHNjcm9sbHMgYSBjb250YWluZXIgdG8gYSBuZXcgcG9zaXRpb24uXG4qIEBmaW5hbFxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9TY3JvbGwge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAvKiogQHByaXZhdGUgeyFPYmplY3R9ICovXG4gICAgdGhpcy5vcHRpb25zXyA9IE9iamVjdC5hc3NpZ24oe30sIE9QVElPTl9ERUZBVUxUU18sIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9uc18ub2Zmc2V0ID0gdGhpcy50cmFuc2Zvcm1PZmZzZXRPcHRpb25zXyh0aGlzLm9wdGlvbnNfLm9mZnNldCk7XG4gICAgdGhpcy5vcHRpb25zXy5jb250YWluZXIgPSB0aGlzLnNldENvbnRhaW5lcl8odGhpcy5vcHRpb25zXyk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBlbGVtZW50L3Bvc2l0aW9uIG9iamVjdHMuXG4gICAgICogVE9ETyhtb3NuZXkpOiBDaGFuZ2UgdGhpcyB0byBhIFdlYWtNYXA/XG4gICAgICogQHByaXZhdGUgeyFBcnJheTxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudFBvc2l0aW9uQ2FjaGVfID0gW107XG5cbiAgICAvLyBJbnZhbGlkYXRlIHRoZSBlbGVtZW50IHBvc2l0aW9uIGNhY2hlIGFmdGVyIHdpbmRvdyByZXNpemUuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICAgIHRoaXMuZWxlbWVudFBvc2l0aW9uQ2FjaGVfID0gW107XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBkZWZhdWx0IG9wdGlvbnMgb24gdGhlIG9mZnNldCBrZXkgb2Ygb3B0aW9ucywgd2hpY2ggT2JqZWN0LmFzc2lnbixcbiAgICogdXNlZCBpbiBzZXR0aW5nIGRlZmF1bHRzLCBjYW5ub3QgZG8uXG4gICAqIEBwYXJhbSB7RWxlbWVudFBvc2l0aW9ufG51bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgb3B0aW9ucywgZWl0aGVyIGFuXG4gICAqIG9iamVjdCB3aXRoIHgveSBrZXlzLCBvciBhIG51bWJlciwgcmVwcmVzZW50aW5nIHRoZSB5IG9mZnNldC5cbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgYWRqdXN0ZWQgb3B0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyYW5zZm9ybU9mZnNldE9wdGlvbnNfKG9mZnNldCkge1xuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgb2Zmc2V0ID0ge1xuICAgICAgICB5OiBvZmZzZXQsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldC54ICE9PSAnbnVtYmVyJykge1xuICAgICAgb2Zmc2V0LnggPSBPUFRJT05fREVGQVVMVFNfLm9mZnNldC54O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldC55ICE9PSAnbnVtYmVyJykge1xuICAgICAgb2Zmc2V0LnkgPSBPUFRJT05fREVGQVVMVFNfLm9mZnNldC55O1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRhaW5lciB0byBzY3JvbGwuIElmIHRoZSB1c2VyIHNldCBhICdjb250YWluZXJTZWxlY3Rvcicgb3B0aW9uLFxuICAgKiBmaW5kIHRoYXQgZWxlbWVudCBhbmQgc2V0ICdjb250YWluZXInIHRvIGl0LiBPdGhlcndpc2UgdXNlIHRoZSBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGFpbmVyU2VsZWN0b3IgQSBET00gcXVlcnlTZWxlY3Rvci5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgVGhlIGRlZmF1bHQgc2Nyb2xsIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIGNvbnRhaW5lciBlbGVtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0Q29udGFpbmVyXyh7Y29udGFpbmVyU2VsZWN0b3IsIGNvbnRhaW5lcn0pIHtcbiAgICBpZiAoY29udGFpbmVyU2VsZWN0b3IpIHtcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyU2VsZWN0b3IpO1xuICAgIH1cblxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYChMQiBBdXRvU2Nyb2xsKSBObyB2YWxpZCBzY3JvbGxhYmxlIGNvbnRhaW5lciBmb3VuZC5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHgveSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBkZWZpbmVkIHNjcm9sbFxuICAgKiBjb250YWluZXIuIENoZWNrcyBmb3IgdGhlIGVsZW1lbnQgaW4gYSBjYWNoZSBvciBpbnZhbGlkYXRlcyB0aGUgY2FjaGUgYW5kXG4gICAqIHJlYWRzIHRoZSBwb3NpdGlvbiBkaXJlY3RseS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGdldCB0aGUgcG9zaXRpb24gb2YuXG4gICAqIEByZXR1cm4ge0VsZW1lbnRQb3NpdGlvbn0gVGhlIHgveSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAgICovXG4gIGdldFBvc2l0aW9uXyhlbGVtZW50KSB7XG4gICAgY29uc3QgY2FjaGVkRWxlbWVudCA9IHRoaXMuZWxlbWVudFBvc2l0aW9uQ2FjaGVfLmZpbmQoKGNhY2hlSXRlbSkgPT4ge1xuICAgICAgcmV0dXJuIGNhY2hlSXRlbS5lbGVtZW50ID09PSBlbGVtZW50O1xuICAgIH0pO1xuXG4gICAgaWYgKGNhY2hlZEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb250YWluZXJSZWN0ID0gdGhpcy5vcHRpb25zXy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGNvbnRhaW5lclNjcm9sbCA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnNfLmNvbnRhaW5lciAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBjb250YWluZXJTY3JvbGwgPSB7XG4gICAgICAgIHRvcDogdGhpcy5vcHRpb25zXy5jb250YWluZXIuc2Nyb2xsVG9wLFxuICAgICAgICBsZWZ0OiB0aGlzLm9wdGlvbnNfLmNvbnRhaW5lci5zY3JvbGxMZWZ0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50UG9zaXRpb24gPSB7XG4gICAgICBlbGVtZW50LFxuICAgICAgeTogZWxlbWVudFJlY3QudG9wIC0gY29udGFpbmVyUmVjdC50b3AgKyBjb250YWluZXJTY3JvbGwudG9wLFxuICAgICAgeDogZWxlbWVudFJlY3QubGVmdCAtIGNvbnRhaW5lclJlY3QubGVmdCArIGNvbnRhaW5lclNjcm9sbC5sZWZ0LFxuICAgIH07XG5cbiAgICByZXR1cm4gZWxlbWVudFBvc2l0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHNjcm9sbGVkIGFtb3VudCBvZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge0VsZW1lbnRQb3NpdGlvbn0gVGhlIGN1cnJlbnQgeC95IHNjcm9sbCBhbW91bnQsIGUuZy4ge3g6MTAsIHk6MjB9LlxuICAgKi9cbiAgZ2V0Q29udGFpbmVyU2Nyb2xsXygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5vcHRpb25zXy5jb250YWluZXIuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHRoaXMub3B0aW9uc18uY29udGFpbmVyLnNjcm9sbFRvcCxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGVzIGFuZCBkaXNhYmxlcyBhIGhhbmRsZXIgdG8gY2FwdHVyZSBhbmQgcHJldmVudERlZmF1bHQgb24gc2Nyb2xsXG4gICAqIGV2ZW50cyAoaS5lLiBzY3JvbGxpbmcgdGhlIHBhZ2UpIGR1cmluZyBhbiBhdXRvLXNjcm9sbC5cbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGUgV2hldGhlciB0byBlbmFibGUgdGhlIHNjcm9sbCBjYXB0dXJlLlxuICAgKi9cbiAgdG9nZ2xlU2Nyb2xsSGFuZGxlcl8oZW5hYmxlID0gdHJ1ZSkge1xuICAgIGlmIChlbmFibGUpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjcm9sbHMgdGhlIGNvbnRhaW5lciB0byBhIGdpdmVuIGVsZW1lbnQgaW4gYSBwcm9taXNlLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHNjcm9sbCB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2Nyb2xsLlxuICAgKiBAcGFyYW0ge0VsZW1lbnRQb3NpdGlvbn0gb2Zmc2V0IFBpeGVsIG9mZnNldCB0byBhcHBseSB0b1xuICAgKiBzbW9vdGhTY3JvbGxUb18uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBzY3JvbGwgY29tcGxldGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2Nyb2xsVG9FbGVtZW50KGVsZW1lbnQsXG4gICAgICBkdXJhdGlvbiA9IHRoaXMub3B0aW9uc18uZHVyYXRpb24sXG4gICAgICBvZmZzZXQgPSB0aGlzLm9wdGlvbnNfLm9mZnNldCkge1xuICAgIGNvbnN0IHNjcm9sbFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudFBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbl8oZWxlbWVudCk7XG4gICAgICBjb25zdCBlbGVtZW50T2Zmc2V0UG9zaXRpb24gPSB7XG4gICAgICAgIHg6IGVsZW1lbnRQb3NpdGlvbi54ICsgb2Zmc2V0LngsXG4gICAgICAgIHk6IGVsZW1lbnRQb3NpdGlvbi55ICsgb2Zmc2V0LnksXG4gICAgICB9O1xuICAgICAgdGhpcy5zbW9vdGhTY3JvbGxUb18oXG4gICAgICAgICAgZWxlbWVudE9mZnNldFBvc2l0aW9uLFxuICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgIHJlc29sdmUpO1xuICAgIH0pO1xuICAgIHJldHVybiBzY3JvbGxQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuaW1hdGVzIGEgY29udGFpbmVyJ3Mgc2Nyb2xsIHRvIGEgZ2l2ZW4geC95IHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge0VsZW1lbnRQb3NpdGlvbn0gdG8gVGhlIHgveSBwb3NpdGlvbiB0byBzY3JvbGwgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHNjcm9sbC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGNhbGxiYWNrIHRvIHJ1biBhZnRlciB0aGUgYW5pbWF0aW9uIGVuZHMuXG4gICAqL1xuICBzbW9vdGhTY3JvbGxUb18oXG4gICAgICB0byxcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5vcHRpb25zXy5kdXJhdGlvbixcbiAgICAgIHJlc29sdmUpIHtcblxuICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLmdldENvbnRhaW5lclNjcm9sbF8oKTtcbiAgICBjb25zdCBuZXRDaGFuZ2UgPSB7XG4gICAgICB4OiB0by54IC0gc3RhcnRQb3NpdGlvbi54LFxuICAgICAgeTogdG8ueSAtIHN0YXJ0UG9zaXRpb24ueSxcbiAgICB9O1xuXG4gICAgY29uc3QgYW5pbWF0ZVNjcm9sbCA9IChwcm9ncmVzcykgPT4ge1xuICAgICAgY29uc3QgZWFzZWRQcm9ncmVzcyA9IHRoaXMub3B0aW9uc18uZWFzaW5nKHByb2dyZXNzKTtcbiAgICAgIGNvbnN0IGVhc2VkUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IGVhc2VkUHJvZ3Jlc3MgKiBuZXRDaGFuZ2UueCxcbiAgICAgICAgeTogZWFzZWRQcm9ncmVzcyAqIG5ldENoYW5nZS55LFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjcm9sbFRvUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHN0YXJ0UG9zaXRpb24ueCArIGVhc2VkUG9zaXRpb24ueCxcbiAgICAgICAgeTogc3RhcnRQb3NpdGlvbi55ICsgZWFzZWRQb3NpdGlvbi55LFxuICAgICAgfTtcbiAgICAgIHRoaXMub3B0aW9uc18uY29udGFpbmVyLnNjcm9sbChzY3JvbGxUb1Bvc2l0aW9uLngsIHNjcm9sbFRvUG9zaXRpb24ueSk7XG4gICAgfTtcblxuICAgIHRoaXMudGltZXJfID0gbmV3IFRpbWVyKGFuaW1hdGVTY3JvbGwsICgpID0+IHtcbiAgICAgIHRoaXMudG9nZ2xlU2Nyb2xsSGFuZGxlcl8oZmFsc2UpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIGR1cmF0aW9uKTtcblxuICAgIC8vIFN0YXJ0IHRoZSBzY3JvbGwuXG4gICAgdGhpcy50b2dnbGVTY3JvbGxIYW5kbGVyXygpO1xuICAgIHRoaXMudGltZXJfLnN0YXJ0KCk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9hdXRvLXNjcm9sbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBjb25zdCB7bnVtYmVyfSAqL1xuY29uc3QgREVGQVVMVF9EVVJBVElPTiA9IDMwMDA7XG5cbi8qKiBAY29uc3Qge0Z1bmN0aW9ufSAqL1xuY29uc3QgTk9PUCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcnVucyBhIHRpbWVyIHVzaW5nIFJlcXVlc3QgQW5pbWF0aW9uIEZyYW1lLlxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcbiAgY29uc3RydWN0b3IocHJvZ3Jlc3NDYWxsYmFjayA9IE5PT1AsXG4gICAgICBjb21wbGV0ZUNhbGxiYWNrID0gTk9PUCxcbiAgICAgIGR1cmF0aW9uID0gREVGQVVMVF9EVVJBVElPTikge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIHshRnVuY3Rpb259IC0gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZWFjaCBsb29wLlxuICAgICAqL1xuICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFja18gPSBwcm9ncmVzc0NhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIHshRnVuY3Rpb259IC0gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgdGltZXIgaGFzXG4gICAgICogY29tcGxldGVkLlxuICAgICAqL1xuICAgIHRoaXMuY29tcGxldGVDYWxsYmFja18gPSBjb21wbGV0ZUNhbGxiYWNrO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgdGltZXIgaW4gbWlsbGlzZWNvbmRzLiAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gZHVyYXRpb247XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9IC0gVGhlIHByb2dyZXNzIG9mIHRoZSB0aW1lciBvdmVyIHRpbWUsIGZyb20gMC0xLiAqL1xuICAgIHRoaXMucHJvZ3Jlc3NfID0gMDtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gLSBUaGUgY3VycmVudCByQUYgaWRlbnRpZmllci4gKi9cbiAgICB0aGlzLnJhZklkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9IC0gVGhlIHRpbWVzdGFtcCBmb3Igd2hlbiB0aGUgdGltZXIgc3RhcnRlZC4gKi9cbiAgICB0aGlzLnN0YXJ0VGltZV87XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSB0aW1lci5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMucmFmSWRfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RlcF8uYmluZCh0aGlzKSk7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAvLyBJZiB0aGlzLnN0YXJ0VGltZV8gaGFzIGEgdmFsdWUsIHRoZSB0aW1lciBpcyBzdGFydGluZyBmcm9tIGEgcGF1c2VkXG4gICAgLy8gc3RhdGUuIEluIHRoYXQgY2FzZSB3ZSByZXNldCBpdCB0byBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSB0aW1lciBkdXJhdGlvbiBpcyAxMCBzZWNvbmRzIGFuZCB0aGUgdGltZXIgd2FzXG4gICAgLy8gcGF1c2VkIGF0IDIgc2Vjb25kcywgdGhpcy5wcm9ncmVzc18gd291bGQgYmUgLjIgb3IgMiBzZWNvbmRzLiBXZSBzZXRcbiAgICAvLyB0aGlzLnN0YXJ0VGltZV8gdG8gMiBzZWNvbmRzIGJlZm9yZSBub3cgdG8gcmVmbGVjdCB0aGUgcHJvZ3Jlc3MuXG4gICAgaWYgKCF0aGlzLnN0YXJ0VGltZV8pIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydFRpbWVfID0gbm93IC0gKHRoaXMuZHVyYXRpb25fICogdGhpcy5wcm9ncmVzc18pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZXMgdGhlIHRpbWVyLiBJdCBjYW4gYmUgcmVzdGFydGVkIGFnYWluIGF0IHRoZSBzYW1lIHBvaW50IHdpdGggc3RhcnQoKS5cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgdGltZXIuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWRfKTtcbiAgICB0aGlzLnByb2dyZXNzXyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogUnVucyBwZXJpb2RpY2FsbHkgdG8gYXNzZXNzIHRoZSB0aW1lciBwcm9ncmVzcyBhbmQgcnVuIGNhbGxiYWNrcy5cbiAgICovXG4gIHN0ZXBfKCkge1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHJlbGF0aXZlVGltZSA9IG5vdyAtIHRoaXMuc3RhcnRUaW1lXztcbiAgICB0aGlzLnByb2dyZXNzXyA9IHJlbGF0aXZlVGltZSAvIHRoaXMuZHVyYXRpb25fO1xuXG4gICAgdGhpcy5wcm9ncmVzc18gPSBNYXRoLm1pbih0aGlzLnByb2dyZXNzXywgMSk7XG4gICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrXyh0aGlzLnByb2dyZXNzXyk7XG5cbiAgICBpZiAodGhpcy5wcm9ncmVzc18gPT09IDEpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgdGhpcy5jb21wbGV0ZUNhbGxiYWNrXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmFmSWRfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RlcF8uYmluZCh0aGlzKSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy90aW1lci90aW1lci5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEEgc2VyaWVzIG9mIHV0aWxpdHkgZnVuY3Rpb25zIGZvciB1c2UgaW4gaW1wbGVtZW50aW5nIGVhc2luZyBpblxuICogamF2YXNjcmlwdCBhbmltYXRpb25zLiBDb3BpZWQgZnJvbSBHbHVlLlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6IFNheSB5b3UgaGF2ZSBhIERPTSBlbGVtZW50IHRoYXQgeW91IHdhbnQgdG8gYW5pbWF0ZSBieSBtb3ZpbmdcbiAqIGl0IGJldHdlZW4gdHdvIGFyYml0cmFyeSBsb2NhdGlvbnMgaW4gYSBwYWdlLCBvdmVyIDIgc2Vjb25kcy4gTm9ybWFsbHkgeW91J2RcbiAqIGRldGVybWluZSBpdHMgc3RhcnRpbmcgcG9zaXRpb24sIGl0cyBlbmRpbmcgcG9zaXRpb24sIHNldCB1cCBhbiBpbnRlcnZhbCxcbiAqIHRoZW4gd2l0aCBlYWNoIGl0ZXJhdGlvbiwgZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiB5b3Ugc2hvdWxkIG1vdmUgaXQgdG8gYmFzZWRcbiAqIG9uIGl0cyBpbml0aWFsIGFuZCBlbmRpbmcgcG9zaXRpb24gdmFsdWVzIGFuZCBhIHBlcmNlbnRhZ2UgdGhhdCByZXByZXNlbnRzXG4gKiBpdHMgcHJvZ3Jlc3MgZnJvbSBzdGFydCB0byBmaW5pc2gsIGJhc2VkIG9uIHRoZSAyIHNlY29uZCBkdXJhdGlvbi4gQ2FsbCB0aGF0XG4gKiBwZXJjZW50YWdlIFQuIEluIG9yZGVyIHRvIGltcGxlbWVudCBhbiBlYXNpbmcgbWV0aG9kIHVzaW5nIGdsdWUuZnguZWFzaW5nLFxuICogc2ltcGx5IHBhc3MgVCB0aHJvdWdoIHlvdXIgZGVzaXJlZCBlYXNpbmcgbWV0aG9kLCBhbmQgdGhlIHJldHVybmVkIHZhbHVlIGlzXG4gKiBhbiBcImVhc2VkXCIgdmFsdWUgb2YgVC4gVXNpbmcgdGhhdCBuZXcgVCwgeW91IHNldCB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLFxuICogYW5kIHRoZSByZXN1bHRpbmcgYW5pbWF0aW9uIHdpbGwgaGF2ZSBhIHNtb290aCBlYXNlIHRvIGl0LCBpbnN0ZWFkIG9mIGl0c1xuICogb3JpZ2luYWwsIGphcnJpbmcgbGluZWFyIG1vdmVtZW50LiBJdCdzIGhhcmQgdG8gdW5kZXJzdGFuZCB0aGlzIHdpdGhvdXRcbiAqIHNlZWluZyBpdCBpbiBhY3Rpb24sIHNvIHZpc2l0IHRoZSBleGFtcGxlIGxpbmsgYmVsb3cgZm9yIHNvbWUgbGl2ZSBhbmltYXRpb25cbiAqIHV0aWxpemluZyBhbGwgb2YgdGhlIGVhc2luZyBmdW5jdGlvbnMgcHJvdmlkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuICpcbiAqIElmIHlvdSBhcmUgbW9yZSBmYW1pbGlhciB3aXRoIGpRdWVyeSdzIHN0eWxlIG9mIGVhc2luZyBtZXRob2RzIHdoaWNoIGV4cGVjdFxuICogZm91ciBhcmd1bWVudHMgKHQsIGIsIGMsIGQpLCB5b3UgY2FuIHVzZSBnbHVlLmZ4LmVhc2luZy5lYXNlKCksIHBhc3NpbmcgaW5cbiAqIHRob3NlIGZvdXIgYXJndW1lbnRzIGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgZWFzaW5nIG1ldGhvZCB5b3UnZCBsaWtlIHRvIHVzZS5cbiAqIFdoZXRoZXIgeW91IHNob3VsZCB1c2UgdGhpcywgb3IgZGlyZWN0bHkgY2FsbCBvbmUgb2YgdGhlIHNpbmdsZS1hcmd1bWVudFxuICogbWV0aG9kcywgaXMgdXAgdG8gdGhlIGRldmVsb3BlciwgYW5kIGxhcmdlbHkgZGVwZW5kcyBvbiBjaXJjdW1zdGFuY2UuXG4gKlxuICogTm90ZTogRnJlcXVlbnRseSwgeW91IHdpbGwgaGF2ZSB0aGUgZWFzaW5nIG1ldGhvZCBieSBuYW1lIGluIHN0cmluZyBmb3JtIChhc1xuICogd2hlbiBjb250YWluZWQgaW4gc29tZSBKU09OIGNvbmZpZ3VyYXRpb24gZGF0YSksIHNvIHlvdSBjYW4gYWxzbyBjYWxsIGl0XG4gKiBsaWtlOiBnbHVlLmZ4LmVhc2luZ1ttZXRob2ROYW1lXShwZXJjZW50YWdlKTtcbiAqXG4gKiBGb3IgZXhhbXBsZXMsIHNlZTpcbiAqIGh0dHBzOi8vZ2x1ZS1kb2NzLmFwcHNwb3QuY29tL2RvY3MvY29tcG9uZW50cy9yYXcvZngtZWFzaW5nXG4gKi9cblxuLyoqXG4gKiBFYXNlcyB2YWx1ZXMgYmFzZWQgb24gdGhlIHR5cGljYWwgZm91ci1hcmd1bWVudCBlYXNpbmcgbWV0aG9kIHN0cnVjdHVyZSB1c2VkXG4gKiBieSBwb3B1bGFyIGxpYnJhcmllcyBsaWtlIGpRdWVyeS4gVGhpcyBpcyBhbiBhZGFwdGVyIHRvIGludGVyZmFjZSB3aXRoIHRoZVxuICogc2luZ2xlLWFyZ3VtZW50IGVhc2luZyBtZXRob2RzIGluIHRoaXMgY2xhc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBDdXJyZW50IHRpbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiIEJlZ2lubmluZyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgZWFzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gYyBUb3RhbCBjaGFuZ2UgaW4gdGhlIHByb3BlcnR5IHZhbHVlIGFjcm9zcyB0aGlzIGFuaW1hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkIFRvdGFsIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpOiBudW1iZXJ9IGZ1bmMgVGhlIGVhc2luZyBtZXRob2QgdG8gY2FsbC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZpbmFsIGVhc2VkIHZhbHVlLlxuICovXG5leHBvcnQgY29uc3QgZWFzZSA9ICh0LCBiLCBjLCBkLCBmdW5jKSA9PiB7XG4gIHJldHVybiBiICsgYyAqIGZ1bmModCAvIGQpO1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gd2l0aCBhIFNpbmUgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5TaW5lID0gKHQpID0+IHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiAxIC0gTWF0aC5jb3ModCAqIChNYXRoLlBJIC8gMikpO1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBTaW5lIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5leHBvcnQgY29uc3QgZWFzZU91dFNpbmUgPSAodCkgPT4ge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IE1hdGguc2luKHQgKiAoTWF0aC5QSSAvIDIpKTtcbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhIFNpbmUgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5PdXRTaW5lID0gKHQpID0+IHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gd2l0aCBhIHF1YWRyYXRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVhc2VJblF1YWQgPSAodCkgPT4ge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IHQgKiB0O1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBxdWFkcmF0aWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlT3V0UXVhZCA9ICh0KSA9PiB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgPyB0IDogdCAqICgyIC0gdCk7XG59O1xuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiBhbmQgb3V0IHdpdGggYSBxdWFkcmF0aWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5PdXRRdWFkID0gKHQpID0+IHtcbiAgaWYgKHQgPT0gMCB8fCB0ID09IDEpIHtcbiAgICByZXR1cm4gdDtcbiAgfSBlbHNlIGlmICh0IDwgLjUpIHtcbiAgICByZXR1cm4gMiAqIHQgKiB0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtMSArICg0IC0gMiAqIHQpICogdDtcbiAgfVxufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gd2l0aCBhIGN1YmljIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5leHBvcnQgY29uc3QgZWFzZUluQ3ViaWMgPSAodCkgPT4ge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IHQgKiB0ICogdDtcbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIG91dCB3aXRoIGEgY3ViaWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlT3V0Q3ViaWMgPSAodCkgPT4ge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6ICgtLXQpICogdCAqIHQgKyAxO1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gYW5kIG91dCB3aXRoIGEgY3ViaWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5PdXRDdWJpYyA9ICh0KSA9PiB7XG4gIGlmICh0ID09IDAgfHwgdCA9PSAxKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0gZWxzZSBpZiAodCA8IC41KSB7XG4gICAgcmV0dXJuIDQgKiB0ICogdCAqIHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcbiAgfVxufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gd2l0aCBhIHF1YXJ0aWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5RdWFydCA9ICh0KSA9PiB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgPyB0IDogdCAqIHQgKiB0ICogdDtcbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIG91dCB3aXRoIGEgcXVhcnRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVhc2VPdXRRdWFydCA9ICh0KSA9PiB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgPyB0IDogMSAtICgtLXQpICogdCAqIHQgKiB0O1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gYW5kIG91dCB3aXRoIGEgcXVhcnRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVhc2VJbk91dFF1YXJ0ID0gKHQpID0+IHtcbiAgaWYgKHQgPT0gMCB8fCB0ID09IDEpIHtcbiAgICByZXR1cm4gdDtcbiAgfSBlbHNlIGlmICh0IDwgLjUpIHtcbiAgICByZXR1cm4gOCAqIHQgKiB0ICogdCAqIHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDEgLSA4ICogKC0tdCkgKiB0ICogdCAqIHQ7XG4gIH1cbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYSBxdWludGljIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5leHBvcnQgY29uc3QgZWFzZUluUXVpbnQgPSAodCkgPT4ge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IHQgKiB0ICogdCAqIHQgKiB0O1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBxdWludGljIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5leHBvcnQgY29uc3QgZWFzZU91dFF1aW50ID0gKHQpID0+IHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiAxICsgKC0tdCkgKiB0ICogdCAqIHQgKiB0O1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgaW4gYW5kIG91dCB3aXRoIGEgcXVpbnRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVhc2VJbk91dFF1aW50ID0gKHQpID0+IHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiB0IDwgLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICpcbiAgICAgICgtLXQpICogdCAqIHQgKiB0ICogdDtcbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYW4gZXhwb25lbnRpYWwgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5FeHBvID0gKHQpID0+IHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYW4gZXhwb25lbnRpYWwgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlT3V0RXhwbyA9ICh0KSA9PiB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgPyB0IDogKDEgLSBNYXRoLnBvdygyLCAtMTAgKiB0KSk7XG59O1xuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiBhbmQgb3V0IHdpdGggYW4gZXhwb25lbnRpYWwgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5PdXRFeHBvID0gKHQpID0+IHtcbiAgaWYgKHQgPT0gMCB8fCB0ID09IDEpIHtcbiAgICByZXR1cm4gdDtcbiAgfSBlbHNlIGlmICh0IDwgLjUpIHtcbiAgICByZXR1cm4gLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqICh0ICogMiAtIDEpKSk7XG4gIH1cbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYSBjaXJjdWxhciBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVhc2VJbkNpcmMgPSAodCkgPT4ge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IDEgLSBNYXRoLnNxcnQoMSAtICh0ICogdCkpO1xufTtcblxuLyoqXG4gKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBjaXJjdWxhciBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVhc2VPdXRDaXJjID0gKHQpID0+IHtcbiAgcmV0dXJuICh0ID09IDAgfHwgdCA9PSAxKSA/IHQgOiBNYXRoLnNxcnQoMSAtICh0IC0gMSkgKiAodCAtIDEpKTtcbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhIGNpcmN1bGFyIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5leHBvcnQgY29uc3QgZWFzZUluT3V0Q2lyYyA9ICh0KSA9PiB7XG4gIGlmICh0ID09IDAgfHwgdCA9PSAxKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0gZWxzZSBpZiAodCA8IC41KSB7XG4gICAgcmV0dXJuIC0uNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0ICogNCkgLSAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLjUgKiAoTWF0aC5zcXJ0KDEgLSA0ICogKHQgLSAxKSAqICh0IC0gMSkpICsgMSk7XG4gIH1cbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFmdGVyIGJvdW5kaW5nIGJhY2t3YXJkcyBhdCB0aGUgYmVnaW5uaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5leHBvcnQgY29uc3QgZWFzZUluQmFjayA9ICh0KSA9PiB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgPyB0IDogdCAqIHQgKiAoMi43MDE1OCAqIHQgLSAxLjcwMTU4KTtcbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIG91dCBhZnRlciBib3VuZGluZyBwYXN0IHRoZSBlbmQgcG9pbnQgYW5kIGJhY2suXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlT3V0QmFjayA9ICh0KSA9PiB7XG4gIHJldHVybiAodCA9PSAwIHx8IHQgPT0gMSkgP1xuICAgICAgdCA6XG4gICAgICAodCAtIDEpICogKHQgLSAxKSAqICgyLjcwMTU4ICogKHQgLSAxKSArIDEuNzAxNTgpICsgMTtcbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhbiBpbml0aWFsIGFuZCBlbmRpbmcgbW92ZW1lbnQgYmV5b25kIHRoZVxuICogZnVsbCByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVhc2VJbk91dEJhY2sgPSAodCkgPT4ge1xuICBpZiAodCA9PSAwIHx8IHQgPT0gMSkge1xuICAgIHJldHVybiB0O1xuICB9IGVsc2UgaWYgKHQgPCAuNSkge1xuICAgIHJldHVybiAuNSAqICh0ICogMikgKiAodCAqIDIpICogKDMuNTk0OTA5NSAqICh0ICogMikgLSAyLjU5NDkwOTUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAuNSAqICgodCAqIDIgLSAyKSAqICh0ICogMiAtIDIpICpcbiAgICAgICAgKDMuNTk0OTA5NSAqICh0ICogMiAtIDIpICsgMi41OTQ5MDk1KSArIDIpO1xuICB9XG59O1xuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBpbiB3aXRoIGFuIGVsYXN0aWMgc3ByaW5neSBtb3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5FbGFzdGljID0gKHQpID0+IHtcbiAgaWYgKHQgPT0gMCB8fCB0ID09IDEpIHtcbiAgICByZXR1cm4gdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLTEgKiAoXG4gICAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKlxuICAgICAgICBNYXRoLnNpbigodCAtIDEuMDc1KSAqICgyICogTWF0aC5QSSkgLyAuMylcbiAgICApO1xuICB9XG59O1xuXG4vKipcbiAqIEVhc2VzIHRoZSB2YWx1ZSBvdXQgd2l0aCBhbiBlbGFzdGljIHNwcmluZ3kgbW90aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5leHBvcnQgY29uc3QgZWFzZU91dEVsYXN0aWMgPSAodCkgPT4ge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IE1hdGgucG93KDIsIC0xMCAqIHQpICpcbiAgICAgIE1hdGguc2luKCh0IC0gLjA3NSkgKiAoMiAqIE1hdGguUEkpIC8gLjMpICsgMTtcbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhbiBlbGFzdGljIHNwcmluZ3kgbW90aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5leHBvcnQgY29uc3QgZWFzZUluT3V0RWxhc3RpYyA9ICh0KSA9PiB7XG4gIGlmICh0ID09IDAgfHwgdCA9PSAxKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0gZWxzZSBpZiAodCA8IC41KSB7XG4gICAgcmV0dXJuIC0uNSAqIChNYXRoLnBvdygyLCAxMCAqICgodCAqIDIpIC0gMSkpICpcbiAgICAgICAgTWF0aC5zaW4oKHQgKiAyIC0gMS4xMTI1KSAqIDIgKiBNYXRoLlBJIC8gLjQ1KSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC41ICogTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICpcbiAgICAgICAgTWF0aC5zaW4oKHQgKiAyIC0gMS4xMTI1KSAqIDIgKiBNYXRoLlBJIC8gLjQ1KSArIDE7XG4gIH1cbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYSBzaW1wbGUgcGh5c2ljcyBib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5Cb3VuY2UgPSAodCkgPT4ge1xuICByZXR1cm4gKHQgPT0gMCB8fCB0ID09IDEpID8gdCA6IDEgLSBlYXNlT3V0Qm91bmNlKDEgLSB0KTtcbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIG91dCB3aXRoIGEgc2ltcGxlIHBoeXNpY3MgYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5leHBvcnQgY29uc3QgZWFzZU91dEJvdW5jZSA9ICh0KSA9PiB7XG4gIGlmICh0ID09IDAgfHwgdCA9PSAxKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0gZWxzZSBpZiAodCA8IDEgLyAyLjc1KSB7XG4gICAgcmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xuICB9IGVsc2UgaWYgKHQgPCAyIC8gMi43NSkge1xuICAgIHJldHVybiA3LjU2MjUgKiAodCAtIDEuNSAvIDIuNzUpICogKHQgLSAxLjUgLyAyLjc1KSArIC43NTtcbiAgfSBlbHNlIGlmICh0IDwgMi41IC8gMi43NSkge1xuICAgIHJldHVybiA3LjU2MjUgKiAodCAtIDIuMjUgLyAyLjc1KSAqICh0IC0gMi4yNSAvIDIuNzUpICsgLjkzNzU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDcuNTYyNSAqICh0IC0gMi42MjUgLyAyLjc1KSAqICh0IC0gMi42MjUgLyAyLjc1KSArIC45ODQzNzU7XG4gIH1cbn07XG5cbi8qKlxuICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBzdGFydGluZyBhbmQgZW5kaW5nIGJvdW5jZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cbmV4cG9ydCBjb25zdCBlYXNlSW5PdXRCb3VuY2UgPSAodCkgPT4ge1xuICBpZiAodCA9PSAwIHx8IHQgPT0gMSkge1xuICAgIHJldHVybiB0O1xuICB9IGVsc2UgaWYgKHQgPCAuNSkge1xuICAgIHJldHVybiBlYXNlSW5Cb3VuY2UodCAqIDIpICogLjU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIC41ICsgLjU7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgd2l0aG91dCBhbnkgZWFzaW5nLiBUaGlzIGlzIG9ubHkgdXNlZnVsIGlmIGEgc2NyaXB0IGlzXG4gKiBleHBlY3RpbmcgYW4gZWFzaW5nIG1ldGhvZCwgYnV0IG9uZSBpc24ndCBuZWVkZWQgaW4gdGhhdCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqL1xuZXhwb3J0IGNvbnN0IGxpbmVhciA9ICh0KSA9PiB7XG4gIHJldHVybiB0O1xufTtcblxuLyoqXG4gKiBBIG1hcCBmb3IgZWFzaW5nIGZ1bmN0aW9ucy5cbiAqIFdlIG5lZWQgdGhpcyBtYXAgdG8gcmVmZXJlbmNlIGVhc2luZyBmdW5jdGlvbiBiYXNlZCBvbiBuYW1lLlxuICogSXQgaXMgdXNlZnVsIHdoZW4gdGhlIGVhc2luZyBmdW5jdGlvbiBpcyBkZWZpbmVkIGluIHJ1bi10aW1lLlxuICovXG5leHBvcnQgY29uc3QgZWFzaW5nRnVuY01hcCA9IG5ldyBNYXAoW1xuICBbJ2Vhc2UnLCBlYXNlXSxcbiAgWydlYXNlSW5TaW5lJywgZWFzZUluU2luZV0sXG4gIFsnZWFzZU91dFNpbmUnLCBlYXNlT3V0U2luZV0sXG4gIFsnZWFzZUluT3V0U2luZScsIGVhc2VJbk91dFNpbmVdLFxuICBbJ2Vhc2VJblF1YWQnLCBlYXNlSW5RdWFkXSxcbiAgWydlYXNlT3V0UXVhZCcsIGVhc2VPdXRRdWFkXSxcbiAgWydlYXNlSW5PdXRRdWFkJywgZWFzZUluT3V0UXVhZF0sXG4gIFsnZWFzZUluQ3ViaWMnLCBlYXNlSW5DdWJpY10sXG4gIFsnZWFzZU91dEN1YmljJywgZWFzZU91dEN1YmljXSxcbiAgWydlYXNlSW5PdXRDdWJpYycsIGVhc2VJbk91dEN1YmljXSxcbiAgWydlYXNlSW5RdWFydCcsIGVhc2VJblF1YXJ0XSxcbiAgWydlYXNlT3V0UXVhcnQnLCBlYXNlT3V0UXVhcnRdLFxuICBbJ2Vhc2VJbk91dFF1YXJ0JywgZWFzZUluT3V0UXVhcnRdLFxuICBbJ2Vhc2VJblF1aW50JywgZWFzZUluUXVpbnRdLFxuICBbJ2Vhc2VPdXRRdWludCcsIGVhc2VPdXRRdWludF0sXG4gIFsnZWFzZUluT3V0UXVpbnQnLCBlYXNlSW5PdXRRdWludF0sXG4gIFsnZWFzZUluRXhwbycsIGVhc2VJbkV4cG9dLFxuICBbJ2Vhc2VPdXRFeHBvJywgZWFzZU91dEV4cG9dLFxuICBbJ2Vhc2VJbk91dEV4cG8nLCBlYXNlSW5PdXRFeHBvXSxcbiAgWydlYXNlSW5DaXJjJywgZWFzZUluQ2lyY10sXG4gIFsnZWFzZU91dENpcmMnLCBlYXNlT3V0Q2lyY10sXG4gIFsnZWFzZUluT3V0Q2lyYycsIGVhc2VJbk91dENpcmNdLFxuICBbJ2Vhc2VJbkJhY2snLCBlYXNlSW5CYWNrXSxcbiAgWydlYXNlT3V0QmFjaycsIGVhc2VPdXRCYWNrXSxcbiAgWydlYXNlSW5PdXRCYWNrJywgZWFzZUluT3V0QmFja10sXG4gIFsnZWFzZUluRWxhc3RpYycsIGVhc2VJbkVsYXN0aWNdLFxuICBbJ2Vhc2VPdXRFbGFzdGljJywgZWFzZU91dEVsYXN0aWNdLFxuICBbJ2Vhc2VJbk91dEVsYXN0aWMnLCBlYXNlSW5PdXRFbGFzdGljXSxcbiAgWydlYXNlSW5Cb3VuY2UnLCBlYXNlSW5Cb3VuY2VdLFxuICBbJ2Vhc2VPdXRCb3VuY2UnLCBlYXNlT3V0Qm91bmNlXSxcbiAgWydlYXNlSW5PdXRCb3VuY2UnLCBlYXNlSW5PdXRCb3VuY2VdLFxuICBbJ2xpbmVhcicsIGxpbmVhcl0sXG5dKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9lYXNpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IFRpbWVDb252ZXJzaW9ucyA9IHtcbiAgU0VDT05EU19JTl9EQVk6IDg2NDAwLFxuICBTRUNPTkRTX0lOX0hPVVI6IDM2MDAsXG4gIFNFQ09ORFNfSU5fTUlOVVRFOiA2MCxcbn07XG5cbi8qKlxuICogS2V5Ym9hcmRFdmVudC5rZXlDb2RlIHZhbHVlcyBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzOlxuICogaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPUtleWJvYXJkRXZlbnQua2V5Q29kZVxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEtleUNvZGVzID0ge1xuICBFTlRFUjogMTMsXG4gIEVTQzogMjcsXG4gIFNQQUNFOiAzMixcbiAgVEFCOiA5LFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvZ2xvYmFsL2NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHt0ZXN0c30gZnJvbSAnLi90ZXN0cyc7XG5cblxuLyoqXG4gKiBBIHV0aWxpdHkgZm9yIHRlc3RpbmcgcGxhdGZvcm0gYW5kIGZlYXR1cmUgc3VwcG9ydCBvZiB0aGUgYnJvd3Nlci5cbiAqIEFkZHMgdXRpbGl0eSBjbGFzc2VzIG9udG8gdGhlIGh0bWwgZWxlbWVudCBmb3IgZWFjaCB0ZXN0LlxuICogRXhwb3NlcyB0ZXN0cyBmb3IgdXNlIGluIEphdmFTY3JpcHQsIGUuZy5cbiAqIGNvbnN0IGRldGVjdCA9IG5ldyBEZXRlY3QoKTtcbiAqIGlmIChkZXRlY3QubWFjKSB7IC4uLiB9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERldGVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdXRpbGl0eSBmb3IgdGVzdGluZyBwbGF0Zm9ybSBhbmQgZmVhdHVyZSBzdXBwb3J0IG9mIHRoZSBicm93c2VyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm0gVGhlIHBsYXRmb3JtIHN0cmluZyBvciBhIHN0dWIgZm9yIHRlc3RpbmcuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB3aW4gVGhlIHdpbmRvdyBvYmplY3Qgb3IgYSBzdHViIGZvciB0ZXN0aW5nLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm0sIHdpbiA9IHdpbmRvdykge1xuICAgIHRoaXMuaHRtbEVsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgLy8gUnVuIGVhY2ggdGVzdCBhbmQgdG9nZ2xlIG9uL29mZiB0aGUgY2xhc3NlczpcbiAgICAvLyBlLmcuIGJyb3dzZXIgaXMgb24gaU9TOlxuICAgIC8vIEFkZCAuaW9zLCAubm8tbWFjLCAubm8tYW5kcm9pZFxuICAgIC8vIGUuZy4gYnJvd3NlciBzdXBwb3J0cyB0b3VjaDpcbiAgICAvLyBBZGQgLm9udG91Y2hzdGFydFxuICAgIE9iamVjdC5rZXlzKHRlc3RzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHRlc3QgPSB0ZXN0c1trZXldO1xuICAgICAgY29uc3QgcGFzc1Rlc3QgPSB0ZXN0KHdpbiwgcGxhdGZvcm0pO1xuICAgICAgLy8gTWFrZSB0aGUgdGVzdCBhY2Nlc3NpYmxlIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgIHRoaXNba2V5XSA9IHRlc3RzW2tleV0od2luLCBwbGF0Zm9ybSk7XG4gICAgICB0aGlzLmh0bWxFbC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuZ2V0Q2xhc3NfKGtleSwgdHJ1ZSksIHBhc3NUZXN0KTtcbiAgICAgIHRoaXMuaHRtbEVsLmNsYXNzTGlzdC50b2dnbGUodGhpcy5nZXRDbGFzc18oa2V5LCBmYWxzZSksICFwYXNzVGVzdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyBmb3IgYSBmZWF0dXJlIHN1cHBvcnQgY2xhc3MgYmFzZWQgb24gdGhlIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXN0IFRoZSBuYW1lIG9mIHRoZSB0ZXN0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhc3MgV2hldGhlciBvciBub3QgdGhlIHRlc3QgcGFzc2VkLlxuICAgKiBAcmV0dXJuIGEgc3RyaW5nIGZvciBhIGZlYXR1cmUgc3VwcG9ydCBjbGFzcy5cbiAgICovXG4gIGdldENsYXNzXyh0ZXN0LCBwYXNzKSB7XG4gICAgY29uc3QgcHJlZml4ID0gcGFzcyA/ICcnIDogJ25vLSc7XG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke3Rlc3R9YDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvcHJvdmlkZXJzL2RldGVjdC9kZXRlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7bGJDbGFzc01peGlufSBmcm9tICcuL21peGluJztcbmltcG9ydCB7cHViU3ViU2hhcmVkfSBmcm9tICcuL3B1YnN1Yi1zaGFyZWQnO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IExCIEJhc2UgQ29tcG9uZW50OlxuICogQ29tbW9uIGJhc2UgY29tcG9uZW50IHRoYXQgaW5jbHVkZXMgTGF6eSBCb25lcyBzcGVjaWZpY1xuICogdXRpbGl0eSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzLlxuICovXG4vLyAhIFRPRE8gKGNsYXl0b25taXN1cmFAKSBOZWVkIHRvIGV4cGxvcmUgaWYgdGhpcyBpcyB1bm5lY2Vzc2FyeSBub3cuXG5jbGFzcyBDb21wb25lbnRCYXNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHshT2JqZWN0fHVuZGVmaW5lZH0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshT2JqZWN0PHN0cmluZywgYm9vbGVhbnxudW1iZXJ8c3RyaW5nPn0gKi9cbiAgICB0aGlzLm9wdGlvbnNfID0ge307XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnQgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMucm9vdF8gPSByb290O1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IVB1YlN1Yn0gKi9cbiAgICB0aGlzLnB1YlN1YlNoYXJlZF8gPSBwdWJTdWJTaGFyZWQ7XG5cbiAgICAvLyBXZSdsbCBsYXppbHkgaW52b2tlIGluaXRpYWxpemUgdy8gbGJBdXRvSW5pdC5cbiAgICB0aGlzLmluaXRpYWxpemUgPSB0aGlzLmluaXRpYWxpemUuYmluZCh0aGlzLCAuLi5hcmdzKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExCUGxhaW5Db21wb25lbnQgZXh0ZW5kcyBsYkNsYXNzTWl4aW4oQ29tcG9uZW50QmFzZSkge31cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvYmFzZS9wbGFpbi5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFB1YlN1YiBmcm9tICcuLi9wdWItc3ViJztcbmltcG9ydCB7c3RyaW5ncywgUVVPVEVfUkVffSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJlYWtwb2ludE1vbml0b3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCcmVha3BvaW50TW9uaXRvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlQnJlYWtwb2ludENoYW5nZSBBIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZVxuICAgKiAgIGJyZWFrcG9pbnQgY2hhbmdlcy4gQWRkaXRpb25hbCBmdW5jdGlvbnMgY2FuIGJlIHJlZ2lzdGVyZWQgdXNpbmdcbiAgICogICB3YXRjaEJyZWFrcG9pbnRDaGFuZ2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihoYW5kbGVCcmVha3BvaW50Q2hhbmdlKSB7XG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IVB1YlN1Yn0gKi9cbiAgICB0aGlzLnB1YlN1Yl8gPSBuZXcgUHViU3ViKCk7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmh0bWxFbF8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN0cmluZ3MuSFRNTF9TRUxFQ1RPUik7XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmFjdGl2ZUJyZWFrcG9pbnRfID0gJyc7XG5cbiAgICB0aGlzLmluaXRpYWxpemVfKGhhbmRsZUJyZWFrcG9pbnRDaGFuZ2UpO1xuICB9XG5cbiAgZ2V0IGJyZWFrcG9pbnQoKSB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaHRtbEVsXywgc3RyaW5ncy5CRUZPUkVfU0VMRUNUT1IpO1xuICAgIHJldHVybiBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3RyaW5ncy5DT05URU5UX1BST1BFUlRZKVxuICAgICAgICAucmVwbGFjZShRVU9URV9SRV8sICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSByZXNpemUgbGlzdGVuZXIgd2l0aCBhIGNhbGxiYWNrIHRoYXQgYnJvYWRjYXN0cyBhIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZUJyZWFrcG9pbnRDaGFuZ2UgQSBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGVcbiAgICogICBicmVha3BvaW50IGNoYW5nZXMuXG4gICAqL1xuICBpbml0aWFsaXplXyhoYW5kbGVCcmVha3BvaW50Q2hhbmdlKSB7XG4gICAgdGhpcy5yZXNpemVMaXN0ZW5lcigoe2JyZWFrcG9pbnQsIGV2ZW50fSkgPT4ge1xuICAgICAgaWYgKGJyZWFrcG9pbnQgIT09IHRoaXMuYWN0aXZlQnJlYWtwb2ludF8pIHtcbiAgICAgICAgdGhpcy5wdWJTdWJfLmJyb2FkY2FzdChcbiAgICAgICAgICAgIHN0cmluZ3MuQlJFQUtQT0lOVF9DSEFOR0VfRVZFTlRfTkFNRSxcbiAgICAgICAgICAgIHticmVha3BvaW50LCBldmVudH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZUJyZWFrcG9pbnRfID0gYnJlYWtwb2ludDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgaGFuZGxlQnJlYWtwb2ludENoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy53YXRjaEJyZWFrcG9pbnRDaGFuZ2UoaGFuZGxlQnJlYWtwb2ludENoYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIHJ1biB3aGVuIHRoZSBicmVha3BvaW50IGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVCcmVha3BvaW50Q2hhbmdlIEEgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlXG4gICAqICAgYnJlYWtwb2ludCBjaGFuZ2VzLlxuICAgKi9cbiAgd2F0Y2hCcmVha3BvaW50Q2hhbmdlKGhhbmRsZUJyZWFrcG9pbnRDaGFuZ2UpIHtcbiAgICB0aGlzLnB1YlN1Yl8uc3Vic2NyaWJlKFxuICAgICAgICBzdHJpbmdzLkJSRUFLUE9JTlRfQ0hBTkdFX0VWRU5UX05BTUUsXG4gICAgICAgIGhhbmRsZUJyZWFrcG9pbnRDaGFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHdpbmRvdyByZXNpemUgbGlzdGVuZXIgd2l0aCBhIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gcmVzaXplQ2FsbGJhY2sgQSBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGVcbiAgICogICB3aW5kb3cgaXMgcmVzaXplZC5cbiAgICovXG4gIHJlc2l6ZUxpc3RlbmVyKHJlc2l6ZUNhbGxiYWNrKSB7XG4gICAgbGV0IHRpbWVvdXQgPSBudWxsO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgdGltZW91dCAmJiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJyZWFrcG9pbnQgPSB0aGlzLmJyZWFrcG9pbnQ7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7YnJlYWtwb2ludCwgZXZlbnR9O1xuICAgICAgICByZXNpemVDYWxsYmFjayhwYXlsb2FkKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihzdHJpbmdzLlJFU0laRV9FVkVOVF9OQU1FLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoc3RyaW5ncy5SRVNJWkVfRVZFTlRfTkFNRSwgaGFuZGxlcik7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9icmVha3BvaW50LW1vbml0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IEVYUElSQVRJT05fS0VZID0gJ2V4cGlyYXRpb24nO1xuXG4vKiogQGNvbnN0IHtudW1iZXJ9IE9uZSBkYXksIGluIG1pbGxpc2Vjb25kcy4gKi9cbmNvbnN0IERFRkFVTFRfRVhQSVJFX01TID0gODY0MDAwMDA7XG5cbi8qKiBAcHJpdmF0ZSB7P0xvY2FsU3RvcmV9ICovXG5sZXQgaW5zdGFuY2U7XG5cblxuLyoqXG4gKiBDbGFzcyB0aGF0IGFkZHMgZnVuY3Rpb25hbGl0eSB0byBMb2NhbFN0b3JhZ2UuXG4gKiBFbmFibGVzIHN0b3Jpbmcgb2JqZWN0LXNjYWxlIHZhbHVlcyBpbiBhIHNpbmdsZSBuYXRpdmUgTG9jYWxTdG9yYWdlIGtleS5cbiAqIFRoaXMgaXMgZG9uZSBieSBtYWludGFpbmluZyBhbiBvYmplY3QgaW4gbWVtb3J5IGFuZCB1c2luZyBKU09OLnBhcnNlIGFuZFxuICogSlNPTi5zdHJpbmdpZnkgdG8gcmVhZC93cml0ZSBzeW5jIHRvIExvY2FsU3RvcmFnZS5cbiAqIEluY2x1ZGVzIGRlZmF1bHQgZXhwaXJhdGlvbiBkYXRlIHNldHRpbmcgYW5kIGNoZWNraW5nLiBJZiB0aGUgc3RvcmUgaXMgZm91bmRcbiAqIHRvIGJlIGV4cGlyZWQsIGl0IGlzIHJlbW92ZWQgYW5kIHJlc2V0LlxuICpcbiAqIFVzYWdlXG4gKiAtLS0tLVxuICogY29uc3QgbG9jYWxTdG9yZSA9IG5ldyBMb2NhbFN0b3JlKCdsYXp5Ym9uZXMnKTtcbiAqIGxvY2FsU3RvcmUuaW5zZXJ0KHtcbiAqICAgJ3Rlc3QnOiAxMjM0NSxcbiAqIH0pO1xuICogY29uc3QgdmFsdWUgPSBsb2NhbFN0b3JlLnJlZGVlbSgndGVzdCcpO1xuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2FsU3RvcmUge1xuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIExvY2FsU3RvcmFnZSBmb3IgdGhlIGdpdmVuIGtleSBhbmQgY29udmVydHMgaXRcbiAgICogdG8gYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVLZXkgVGhlIG5hbWUgb2YgdGhlIExvY2FsU3RvcmFnZSBrZXkuXG4gICAqIEBwYXJhbSB7PW51bWJlcn0gbGlmZXRpbWUgSG93IG1hbnkgbWlsbGlzZWNvbmRzIHRoZSBpdGVtIHNob3VsZCBsaXZlXG4gICAqICAgaW4gTG9jYWxTdG9yYWdlLlxuICAgKiBAcmV0dXJuIHtMb2NhbFN0b3JlfSBBIG5ldyBMb2NhbFN0b3JlIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RvcmVLZXksIGxpZmV0aW1lID0gREVGQVVMVF9FWFBJUkVfTVMpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZSA9IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFzdG9yZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIG5hbWUgbXVzdCBiZSBwcm92aWRlZCBmb3IgdGhlIGtleSBpbiBMb2NhbFN0b3JhZ2UuJyk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7b2JqZWN0fSAqL1xuICAgIHRoaXMuY29uZmlnXyA9IHtzdG9yZUtleSwgbGlmZXRpbWV9O1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IXdpbmRvdy5sb2NhbFN0b3JhZ2V9ICovXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2VfID0gd2luZG93LmxvY2FsU3RvcmFnZTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVN0b3JlKHN0b3JlS2V5KTtcblxuICAgIHRoaXMuY2hlY2tFeHBpcmF0aW9uXyh0aGlzLnN0b3JlXyk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIExvY2FsU3RvcmFnZSBmb3IgdGhlIGdpdmVuIGtleSBhbmQgY29udmVydHMgaXRcbiAgICogdG8gYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBMb2NhbFN0b3JhZ2Uga2V5IHRvIGdldC5cbiAgICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsICo+fSBUaGUgc3RvcmUgcmV0cmVpdmVkIGZyb20gTG9jYWxTdG9yYWdlLCBvciBhXG4gICAqICAgbmV3IGVtcHR5IG9iamVjdC5cbiAgICovXG4gIGluaXRpYWxpemVTdG9yZShrZXkpIHtcbiAgICBpZiAodGhpcy5sb2NhbFN0b3JhZ2VDb250YWluc18oa2V5KSkge1xuICAgICAgdGhpcy5zdG9yZV8gPVxuICAgICAgICAgIEpTT04ucGFyc2UodGhpcy5sb2NhbFN0b3JhZ2VfLmdldEl0ZW0odGhpcy5jb25maWdfLnN0b3JlS2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcmVfID0ge1xuICAgICAgICBbRVhQSVJBVElPTl9LRVldOlxuICAgICAgICAgICAgdGhpcy5nZXROZXdFeHBpcmF0aW9uRGF0ZVRpbWVfKHRoaXMuY29uZmlnXy5saWZldGltZSksXG4gICAgICB9O1xuICAgICAgdGhpcy5zYXZlXyh0aGlzLnN0b3JlXyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0b3JlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzdG9yZSBvYmplY3QgYW5kIHVwZGF0ZXMgTG9jYWxTdG9yYWdlLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAqPn0gZGF0YSBUaGUgZGF0YSB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBsaWZldGltZSBPcHRpb25hbCBhbW91bnQgb2YgdGltZSBmcm9tIG5vdyB0byBzZXRcbiAgICogICB0aGUgbmV3IGV4cGlyYXRpb24uXG4gICAqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCAqPn0gVGhlIHN0b3JlIG9iamVjdC5cbiAgICovXG4gIGluc2VydChkYXRhLCBsaWZldGltZSkge1xuICAgIGlmIChsaWZldGltZSkge1xuICAgICAgZGF0YSA9IHRoaXMudXBkYXRlRXhwaXJhdGlvbl8oZGF0YSwgbGlmZXRpbWUpO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlXyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RvcmVfLCBkYXRhKTtcbiAgICB0aGlzLnNhdmVfKHRoaXMuc3RvcmVfKTtcbiAgICByZXR1cm4gdGhpcy5zdG9yZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBrZXkgZnJvbSB0aGUgc3RvcmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBnZXQuXG4gICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5IGluIHRoZSBzdG9yZS5cbiAgICovXG4gIHJlZGVlbShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZV9ba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIG9iamVjdCBrZXkvdmFsdWUgZnJvbSB0aGUgc3RvcmUgYW5kIHVwZGF0ZXMgTG9jYWxTdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gZGVsZXRlLlxuICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgKj59IFRoZSBzdG9yZSBvYmplY3QuXG4gICAqL1xuICByZW1vdmUoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuc3RvcmVfW2tleV07XG4gICAgdGhpcy5zYXZlXyh0aGlzLnN0b3JlXyk7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGluc3RhbmNlJ3MgZW50cnkgaW4gTG9jYWxTdG9yYWdlIGFuZCByZXNldHMgdGhlIHN0b3JlIHRvIGFuXG4gICAqIGVtcHR5IG9iamVjdCB3aXRoIGEgZnJlc2ggZXhwaXJhdGlvbi5cbiAgICovXG4gIGVtcHR5KCkge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlXy5yZW1vdmVJdGVtKHRoaXMuY29uZmlnXy5zdG9yZUtleSk7XG4gICAgdGhpcy5zdG9yZV8gPSB0aGlzLmluaXRpYWxpemVTdG9yZSh0aGlzLmNvbmZpZ18uc3RvcmVLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBleHBpcmF0aW9uIGtleSBmcm9tIHRoZSBzdG9yZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgZXhwaXJhdGlvbiBkYXRldGltZS5cbiAgICovXG4gIGdldEV4cGlyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkZWVtKEVYUElSQVRJT05fS0VZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgJ2V4cGlyYXRpb24nIGtleS5cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPn0gZGF0YSBUaGUgZGF0YSB0byB1cGRhdGUgdGhlIGtleSBvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpZmV0aW1lIFRoZSBhbW91bnQgb2YgdGltZSBmcm9tIG5vdyB0byBzZXQgdGhlIG5ld1xuICAgKiAgIGV4cGlyYXRpb24uXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBkYXRhIHdpdGggYW4gdXBkYXRlZCBleHBpcmF0aW9uIGtleS5cbiAgICovXG4gIHVwZGF0ZUV4cGlyYXRpb25fKGRhdGEsIGxpZmV0aW1lKSB7XG4gICAgZGF0YVtFWFBJUkFUSU9OX0tFWV0gPSB0aGlzLmdldE5ld0V4cGlyYXRpb25EYXRlVGltZV8obGlmZXRpbWUpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgbG9jYWxTdG9yYWdlIGVudHJ5IGlzIGV4cGlyZWQsIGFuZCBpZiBpdCBpcywgcmVtb3ZlcyBpdC5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgKj59IHN0b3JlIFRoZSBzdG9yZSBvYmplY3QuXG4gICAqL1xuICBjaGVja0V4cGlyYXRpb25fKHN0b3JlKSB7XG4gICAgY29uc3QgZXhwaXJhdGlvbkRhdGVUaW1lID0gc3RvcmVbRVhQSVJBVElPTl9LRVldO1xuICAgIGlmIChleHBpcmF0aW9uRGF0ZVRpbWUgJiYgRGF0ZS5ub3coKSA+IGV4cGlyYXRpb25EYXRlVGltZSkge1xuICAgICAgdGhpcy5lbXB0eSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGRhdGV0aW1lIG51bWJlciBieSBhZGRpbmcgdGhlIGN1cnJlbnQgZGF0ZXRpbWUgYW5kIGEgbGlmZXRpbWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaWZldGltZSBUaGUgYW1vdW50IG9mIHRpbWUgZnJvbSBub3cgdG8gc2V0IHRoZSBuZXdcbiAgICogICBleHBpcmF0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgbmV3IDEzLWRpZ2l0IGVwb2NoIHRpbWUuXG4gICAqL1xuICBnZXROZXdFeHBpcmF0aW9uRGF0ZVRpbWVfKGxpZmV0aW1lKSB7XG4gICAgcmV0dXJuICtuZXcgRGF0ZSArIGxpZmV0aW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgTG9jYWxTdG9yYWdlIGNvbnRhaW5zIGEgZ2l2ZW4ga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gbG9vayB1cC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBMb2NhbFN0b3JhZ2UgY29udGFpbnMgdGhlIGdpdmVuIGtleS5cbiAgICovXG4gIGxvY2FsU3RvcmFnZUNvbnRhaW5zXyhrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLmxvY2FsU3RvcmFnZV8uZ2V0SXRlbShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBjdXJyZW50IHN0b3JlIG9iamVjdCB0byBhIHN0cmluZyBhbmQgc2F2ZXMgaXQgdG8gTG9jYWxTdG9yYWdlLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAqPn0gc3RvcmUgVGhlIHN0b3JlIG9iamVjdC5cbiAgICovXG4gIHNhdmVfKHN0b3JlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBKU09OLnN0cmluZ2lmeShzdG9yZSk7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2VfLnNldEl0ZW0odGhpcy5jb25maWdfLnN0b3JlS2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9sb2NhbC1zdG9yZS9sb2NhbC1zdG9yZS5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ2FuY2VsIEFuaW1hdGlvbiBGcmFtZSBzaGltLlxuY29uc3QgY2FuY2VsQW5pbUZyYW1lID1cbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbiAvLyBSZXF1ZXN0IEFuaW1hdGlvbiBGcmFtZSBzaGltLlxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgZW5jYXBzdWxhdGVzIFJlcXVlc3QgQW5pbWF0aW9uIEZyYW1lLlxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBSYWYge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gLSBDdXJyZW50IFJhZiBsb29wcyB1bmlxdWUgbm9uLXplcm8gaWRlbnRpZmllci4gKi9cbiAgICB0aGlzLmxvb3BfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gLSBGbGFnIHRoYXQgd2lsbCBwYXVzZSBSYWYgbG9vcC4gKi9cbiAgICB0aGlzLnN0b3BfID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgdXAgUmFmIGFuZCBleGVjdXRlcyB0aGUgYGNhbGxiYWNrYCBvbiBlYWNoIGZyYW1lLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHs/T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICB0aWNrZXIoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAvLyBSYWYgcmVuZGVyZXIuXG4gICAgY29uc3QgcmVuZGVyID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0b3BfKSB7XG4gICAgICAgIC8vIENhbGxiYWNrIHRvIHJ1biBvbiBlYWNoIFJhZiB0aWNrLlxuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHRpbWVzdGFtcCk7XG4gICAgICAgIHRoaXMubG9vcF8gPSByZXF1ZXN0QW5pbUZyYW1lKHJlbmRlcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFN0YXJ0IFJhZiBsb29wLlxuICAgIHRoaXMubG9vcF8gPSByZXF1ZXN0QW5pbUZyYW1lKHJlbmRlcik7XG4gIH1cblxuICAvKipcbiAgICogUGxheXMgdGhlIFJhZiBsb29wLlxuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIHRoaXMuc3RvcF8gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgUmFmIGxvb3AuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuc3RvcF8gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgdGhlIFJhZiBpbnN0YW5jZS5cbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICBjYW5jZWxBbmltRnJhbWUodGhpcy5sb29wXyk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9yYWYvcmFmLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQXV0aCBmcm9tICcuL2F1dGgnO1xuXG5cbi8qKlxuICogTWlsbGVzZWNvbmRzIGluIDI0IGhvdXJzLlxuICogICAgIDI0IGhycyBpbiBhIGRheSAqIDYwIG1pbnMgaW4gYW4gaG91ciAqXG4gKiAgICAgNjAgc2VjcyBpbiBhIG1pbnV0ZSAqIDEwMDAgbWlsbHMgaW4gYSBzZWNvbmRcbiAqIEBwcml2YXRlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE9ORV9EQVlfID0gMjQgKiA2MCAqIDYwICogMTAwMDtcblxuLyoqIEBwcml2YXRlIHtlbnVtfSAqL1xuY29uc3QgU2Vzc2lvblN0b3JhZ2VLZXlzXyA9IHtcbiAgREFUQTogJ1lUQ3JlYXRvcnNEYXRhQVBJJyxcbiAgVElNRVNUQU1QOiAnWVRDcmVhdG9yc1RpbWVzdGFtcCcsXG4gIFRPS0VOOiAnWVRDcmVhdG9yc0FjY2Vzc1Rva2VuJyxcbiAgVUlEOiAnWVRDcmVhdG9yc1VJRCcsXG59O1xuXG4vKiogQHByaXZhdGUgQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBZVF9EQVRBX0VORFBPSU5UXyA9XG4gICAgJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL3lvdXR1YmUvdjMvY2hhbm5lbHMnICtcbiAgICAnP2tleT1BSXphU3lESFhyNE9Mc1JoYnhxUWFhQzlnTUdLV1BxaElQTTg4UWsnICtcbiAgICAnJnBhcnQ9c25pcHBldCxzdGF0aXN0aWNzJyArXG4gICAgJyZtaW5lPXRydWUnICtcbiAgICAnJmFjY2Vzc190b2tlbj0nO1xuXG5cbi8qKlxuICogUmV0cmlldmVzIHVzZXIgWW91VHViZSBEYXRhIChzbmlwcGV0LHN0YXRpc3RpY3MpIHdpdGggaGVscCBmcm9tIHRoZSBZVEMgQXV0aFxuICogcHJvdmlkZXIuIEl0IGV4cG9zZXMgYSBjYWxsYmFjayBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgZGF0YSByZXF1ZXN0XG4gKiBpcyBzdWNjZXNzZnVsLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBZVERhdGEgZXh0ZW5kcyBBdXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB1c2VyIFlUIERhdGEgb25jZSB0aGUgYWNjZXNzIHRva2VuIGlzIHJlY2lldmVkIG9uIHNpZ24gaW4gYmVmb3JlXG4gICAqIGZpcmluZyB0aGUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gdXNlciBUaGUgdXNlciBkYXRhIHRyZWUgZ2l2ZW4gYnkgRmlyZWJhc2Ugd2hlbiBzaWduZWQgaW4uXG4gICAqL1xuICBvblNpZ25Jbih1c2VyKSB7XG4gICAgdGhpcy5nZXRBY2Nlc3NUb2tlbl8odXNlcikudGhlbigodG9rZW4pID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTZXNzaW9uU3RvcmFnZUtleXNfLkRBVEEpO1xuICAgICAgY29uc3QgdWlkID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oU2Vzc2lvblN0b3JhZ2VLZXlzXy5VSUQpO1xuICAgICAgY29uc3QgdGltZXN0YW1wID1cbiAgICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTZXNzaW9uU3RvcmFnZUtleXNfLlRJTUVTVEFNUCk7XG4gICAgICBjb25zdCBoYXNCZWVuMjRocnMgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wID49IE9ORV9EQVlfO1xuXG4gICAgICBpZiAoZGF0YSAmJiAodWlkID09PSB1c2VyLnVpZCkgJiYgIWhhc0JlZW4yNGhycykge1xuICAgICAgICAvLyBTZXNzaW9uIHN0b3JhZ2UgZGF0YSBpcyBhdmFpbGFibGUsIGl0IGJlbG9uZ3MgdG8gdGhlIHNhbWUgdXNlciBhbmRcbiAgICAgICAgLy8gYW5kIGl0IGhhcyBiZWVuIGxlc3MgdGhhbiAyNGhycyBvbGQuXG4gICAgICAgIHRoaXMub25ZVERhdGFSZWFkeSh1c2VyLCBKU09OLnBhcnNlKGRhdGEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNlc3Npb24gc3RvcmFnZSBkYXRhIGlzIG5vdCBhdmFpbGFiZTsgbWFrZSBhIG5ldyByZXF1ZXN0LlxuICAgICAgICB0aGlzLmRhdGFSZXF1ZXN0Xyh1c2VyLCB0b2tlbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgYWNjZXNzIHRva2VuIGZyb20gc2Vzc2lvbiBzdG9yYWdlIG9uIHNpZ24gb3V0LlxuICAgKi9cbiAgb25TaWduT3V0KCkge1xuICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtcHR5IG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBkYXRhIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAgICogQHBhcmFtIHshT2JqZWN0fSB1c2VyIFRoZSB1c2VyIGRhdGEgdHJlZSBnaXZlbiBieSBGaXJlYmFzZSB3aGVuIHNpZ25lZCBpbi5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBkYXRhIFRoZSB1c2VyJ3MgWW91VHViZSBkYXRhIHRyZWUuXG4gICAqL1xuICBvbllURGF0YVJlYWR5KHVzZXIsIGRhdGEpIHt9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSBzaWduIGluIHJlc3VsdHMgYW5kIHN0b3JlcyBpdCBpbiBzZXNzaW9uXG4gICAqIHN0b3JhZ2UuIElmIHRoZSB1c2VyIGlzIHJldHVybmluZyB0byB0aGUgcGFnZSBhbmQgaXMgc3RpbGwgc2lnbmVkIGluLCB0aGVuXG4gICAqIHRoZSBhY2Nlc3MgdG9rZW4gaW4gc2Vzc2lvbiBzdG9yYWdlIGlzIHVzZWQuIElmIHRoYXQncyBtaXNzaW5nLCB0aGUgdXNlciBpc1xuICAgKiBmb3JjZWQgdG8gc2lnbiBiYWNrIGluIHRvIGNyZWF0ZSBhIG5ldyBhY2Nlc3MgdG9rZW4uXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gdXNlciBUaGUgdXNlciBkYXRhIHRyZWUgZ2l2ZW4gYnkgRmlyZWJhc2Ugd2hlbiBzaWduZWQgaW4uXG4gICAqIEByZXR1cm4geyFQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0QWNjZXNzVG9rZW5fKHVzZXIpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHRva2VuO1xuXG4gICAgICBBdXRoLkZCX0FVVEguZ2V0UmVkaXJlY3RSZXN1bHQoKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdC5jcmVkZW50aWFsKSB7XG4gICAgICAgICAgLy8gVXNlciBuZXdseSBzaWduZWQgaW4gc28gc3RvcmUgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgICB0b2tlbiA9IHJlc3VsdC5jcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuXG4gICAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oU2Vzc2lvblN0b3JhZ2VLZXlzXy5UT0tFTiwgdG9rZW4pO1xuICAgICAgICAgIHJlc29sdmUodG9rZW4pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQcmV2aW91c2x5IHN0b3JlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgIHRva2VuID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oU2Vzc2lvblN0b3JhZ2VLZXlzXy5UT0tFTik7XG5cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgLy8gQWNlc3MgdG9rZW4gaXMgYXZhaWxhYmxlIGluIHNlc3Npb24gc3RvcmFnZS5cbiAgICAgICAgICByZXNvbHZlKHRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgYWNjZXNzIHRva2VuIGlzIG1pc3NpbmcgZnJvbSBzZXNzaW9uIHN0b3JhZ2UsIHNvIHRoZSB1c2VyIG5lZWRzXG4gICAgICAgICAgLy8gdG8gc2lnbiBpbiB0byBnZXQgYSBuZXcgb25lLlxuICAgICAgICAgIEF1dGguc2lnbk91dCgpO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgcmVxdWVzdCB0byB0aGUgWVQgRGF0YSBBUEkuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gdXNlciBUaGUgdXNlciBkYXRhIHRyZWUgZ2l2ZW4gYnkgRmlyZWJhc2Ugd2hlbiBzaWduZWQgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgYWNjZXNzIHRva2VuLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YVJlcXVlc3RfKHVzZXIsIHRva2VuKSB7XG4gICAgY29uc3QgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgaHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoaHR0cC5yZWFkeVN0YXRlID09IDQgJiYgaHR0cC5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgIC8vIFN1Y2Nlc3NmdWwgcmVxdWVzdC5cbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoaHR0cC5yZXNwb25zZVRleHQpO1xuXG4gICAgICAgIC8vIFN0b3JlIGRhdGEuXG4gICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgU2Vzc2lvblN0b3JhZ2VLZXlzXy5EQVRBLCBodHRwLnJlc3BvbnNlVGV4dCk7XG5cbiAgICAgICAgLy8gU3RvcmUgVUlELlxuICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShTZXNzaW9uU3RvcmFnZUtleXNfLlVJRCwgdXNlci51aWQpO1xuXG4gICAgICAgIC8vIFN0b3JlIFRpbWVzdGFtcC5cbiAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICBTZXNzaW9uU3RvcmFnZUtleXNfLlRJTUVTVEFNUCwgRGF0ZS5ub3coKSk7XG5cbiAgICAgICAgLy8gQ2FsbGJhY2suXG4gICAgICAgIHRoaXMub25ZVERhdGFSZWFkeSh1c2VyLCBkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoaHR0cC5zdGF0dXMgPT0gNDAxKSB7XG4gICAgICAgIC8vIFRpbWUgdG8gcmVmcmVzaCB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAgICBBdXRoLnNpZ25PdXQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaHR0cC5vcGVuKCdHRVQnLCBZVF9EQVRBX0VORFBPSU5UXyArIHRva2VuLCB0cnVlKTtcbiAgICBodHRwLnNlbmQoKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wcm92aWRlcnMveXQtZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gSW1wb3J0IE1EQ3MuXG5pbXBvcnQge01EQ1JpcHBsZX0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZSc7XG5cbi8vIEltcG9ydCBQYWdlIGNvbnN0cnVjdG9ycy5cbmltcG9ydCBJbmRleFBhZ2UgZnJvbSAnLi9wYWdlcyc7XG5pbXBvcnQgQnJvbnplIGZyb20gJy4vcGFnZXMvYmVuZWZpdHMvYnJvbnplJztcbmltcG9ydCBHcmFwaGl0ZSBmcm9tICcuL3BhZ2VzL2JlbmVmaXRzL2dyYXBoaXRlJztcbmltcG9ydCBPcGFsIGZyb20gJy4vcGFnZXMvYmVuZWZpdHMvb3BhbCc7XG5pbXBvcnQgU2lsdmVyIGZyb20gJy4vcGFnZXMvYmVuZWZpdHMvc2lsdmVyJztcbmltcG9ydCBCZW5lZml0cyBmcm9tICcuL3BhZ2VzL2JlbmVmaXRzJztcbmltcG9ydCBBd2FyZHMgZnJvbSAnLi9wYWdlcy9hd2FyZHMnO1xuaW1wb3J0IENyZWF0b3JzQmFubmVyIGZyb20gJy4vY3JlYXRvcnMtYmFubmVyL2Jhbm5lcic7XG5pbXBvcnQge2xvY2FsU3RvcmFnZUJhbm5lcktleX0gZnJvbSAnLi9jcmVhdG9ycy1iYW5uZXIvY29uc3RhbnRzJztcblxuLy8gSW1wb3J0IExhenkgQm9uZXMgY29tcG9uZW50cyBhbWQgcHJvdmlkZXJzLlxuaW1wb3J0ICogYXMgYWNjb3JkaW9uIGZyb20gJ0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24nO1xuaW1wb3J0ICogYXNcbiAgICBkcmF3ZXIgZnJvbSAnQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24tZHJhd2VyJztcbmltcG9ydCB7TEJBdXRvU2Nyb2xsfSBmcm9tICdAZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvYXV0by1zY3JvbGwnO1xuaW1wb3J0IHtMQk5hdn0gZnJvbSAnQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2hlYWRlci9uYXYnO1xuaW1wb3J0IHtsYkF1dG9Jbml0fSBmcm9tICdAZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9hdXRvLWluaXQvYXV0by1pbml0JztcbmltcG9ydCB7TEJGb290ZXJ9IGZyb20gJ0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9mb290ZXInO1xuaW1wb3J0IExvY2FsU3RvcmUgZnJvbSAnQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvbG9jYWwtc3RvcmUvbG9jYWwtc3RvcmUnO1xuaW1wb3J0IFlUUGxheWVyIGZyb20gJ0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy95dC1wbGF5ZXInO1xuXG4vLyBSZWdpc3RlciBhbmQgYXV0b2luaXQgUGFnZSBjb25zdHJ1Y3RvcnMuXG5sYkF1dG9Jbml0LnJlZ2lzdGVyKCdJbmRleFBhZ2UnLCBJbmRleFBhZ2UpO1xubGJBdXRvSW5pdC5yZWdpc3RlcignQmVuZWZpdHMnLCBCZW5lZml0cyk7XG5sYkF1dG9Jbml0LnJlZ2lzdGVyKCdHcmFwaGl0ZScsIEdyYXBoaXRlKTtcbmxiQXV0b0luaXQucmVnaXN0ZXIoJ09wYWwnLCBPcGFsKTtcbmxiQXV0b0luaXQucmVnaXN0ZXIoJ0Jyb256ZScsIEJyb256ZSk7XG5sYkF1dG9Jbml0LnJlZ2lzdGVyKCdTaWx2ZXInLCBTaWx2ZXIpO1xubGJBdXRvSW5pdC5yZWdpc3RlcignQXdhcmRzJywgQXdhcmRzKTtcblxuLy8gUmVnaXN0ZXIgYW5kIGF1dG9pbml0IE1EQ3MgYW5kIExhenkgQm9uZXMgY29tcG9uZW50cy5cbmxiQXV0b0luaXQucmVnaXN0ZXIoJ0xCQWNjb3JkaW9uJywgYWNjb3JkaW9uLkxCQWNjb3JkaW9uKTtcbmxiQXV0b0luaXQucmVnaXN0ZXIoJ0xCQWNjb3JkaW9uRHJhd2VyJywgZHJhd2VyLkxCQWNjb3JkaW9uRHJhd2VyKTtcbmxiQXV0b0luaXQucmVnaXN0ZXIoJ01EQ1JpcHBsZScsIE1EQ1JpcHBsZSk7XG5sYkF1dG9Jbml0LnJlZ2lzdGVyKCdMQkF1dG9TY3JvbGwnLCBMQkF1dG9TY3JvbGwpO1xubGJBdXRvSW5pdC5yZWdpc3RlcignTEJOYXYnLCBMQk5hdik7XG5sYkF1dG9Jbml0LnJlZ2lzdGVyKCdMQkZvb3RlcicsIExCRm9vdGVyKTtcbmxiQXV0b0luaXQucmVnaXN0ZXIoJ1lUUGxheWVyJywgWVRQbGF5ZXIpO1xuXG5cbmNvbnN0IGxvY2FsU3RvcmUgPSBuZXcgTG9jYWxTdG9yZShsb2NhbFN0b3JhZ2VCYW5uZXJLZXkpO1xuICBuZXcgQ3JlYXRvcnNCYW5uZXIobG9jYWxTdG9yZSk7XG5cbmxiQXV0b0luaXQoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Z2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGlzQWN0aXZhdGVkOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgYWN0aXZhdGlvbkV2ZW50OiBFdmVudCxcbiAqICAgaXNQcm9ncmFtbWF0aWM6IChib29sZWFufHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBBY3RpdmF0aW9uU3RhdGVUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGRlYWN0aXZhdGU6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgZm9jdXM6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgYmx1cjogKHN0cmluZ3x1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgTGlzdGVuZXJJbmZvVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZGVhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZm9jdXM6IGZ1bmN0aW9uKCksXG4gKiAgIGJsdXI6IGZ1bmN0aW9uKClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lcnNUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHg6IG51bWJlcixcbiAqICAgeTogbnVtYmVyXG4gKiB9fVxuICovXG5sZXQgUG9pbnRUeXBlO1xuXG4vLyBBY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIHRoZSByb290IGVsZW1lbnQgb2YgZWFjaCBpbnN0YW5jZSBmb3IgYWN0aXZhdGlvblxuY29uc3QgQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nLCAna2V5ZG93biddO1xuXG4vLyBEZWFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gZG9jdW1lbnRFbGVtZW50IHdoZW4gYSBwb2ludGVyLXJlbGF0ZWQgZG93biBldmVudCBvY2N1cnNcbmNvbnN0IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTID0gWyd0b3VjaGVuZCcsICdwb2ludGVydXAnLCAnbW91c2V1cCddO1xuXG4vLyBUcmFja3MgYWN0aXZhdGlvbnMgdGhhdCBoYXZlIG9jY3VycmVkIG9uIHRoZSBjdXJyZW50IGZyYW1lLCB0byBhdm9pZCBzaW11bHRhbmVvdXMgbmVzdGVkIGFjdGl2YXRpb25zXG4vKiogQHR5cGUgeyFBcnJheTwhRXZlbnRUYXJnZXQ+fSAqL1xubGV0IGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmlwcGxlQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4gLyogYm9vbGVhbiAtIGNhY2hlZCAqLyB7fSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKC8qIHRhcmdldDogIUV2ZW50VGFyZ2V0ICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICgvKiB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyogQ2xpZW50UmVjdCAqLyB7fSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IC8qIHt4OiBudW1iZXIsIHk6IG51bWJlcn0gKi8ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1JpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUNsaWVudFJlY3R9ICovXG4gICAgdGhpcy5mcmFtZV8gPSAvKiogQHR5cGUgeyFDbGllbnRSZWN0fSAqLyAoe3dpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5hY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5kZWFjdGl2YXRlXyhlKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5mb2N1c0hhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVGb2N1cygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbig/RXZlbnQ9KX0gKi9cbiAgICB0aGlzLmJsdXJIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlQmx1cigpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMubGF5b3V0KCk7XG5cbiAgICAvKiogQHByaXZhdGUge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXJ9fSAqL1xuICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzXyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdTY2FsZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfID0gKCkgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0V2ZW50fSAqL1xuICAgIHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBjb21wdXRlIHRoaXMgcHJvcGVydHkgc28gdGhhdCB3ZSBhcmUgbm90IHF1ZXJ5aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGllbnRcbiAgICogdW50aWwgdGhlIHBvaW50IGluIHRpbWUgd2hlcmUgdGhlIGZvdW5kYXRpb24gcmVxdWVzdHMgaXQuIFRoaXMgcHJldmVudHMgc2NlbmFyaW9zIHdoZXJlXG4gICAqIGNsaWVudC1zaWRlIGZlYXR1cmUtZGV0ZWN0aW9uIG1heSBoYXBwZW4gdG9vIGVhcmx5LCBzdWNoIGFzIHdoZW4gY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlclxuICAgKiBhbmQgdGhlbiBpbml0aWFsaXplZCBhdCBtb3VudCB0aW1lIG9uIHRoZSBjbGllbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdXBwb3J0c1ByZXNzUmlwcGxlXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5icm93c2VyU3VwcG9ydHNDc3NWYXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9XG4gICAqL1xuICBkZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IGZhbHNlLFxuICAgICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiBmYWxzZSxcbiAgICAgIHdhc0VsZW1lbnRNYWRlQWN0aXZlOiBmYWxzZSxcbiAgICAgIGFjdGl2YXRpb25FdmVudDogbnVsbCxcbiAgICAgIGlzUHJvZ3JhbW1hdGljOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpbml0KCkge1xuICAgIGNvbnN0IHN1cHBvcnRzUHJlc3NSaXBwbGUgPSB0aGlzLnN1cHBvcnRzUHJlc3NSaXBwbGVfKCk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyUm9vdEhhbmRsZXJzXyhzdXBwb3J0c1ByZXNzUmlwcGxlKTtcblxuICAgIGlmIChzdXBwb3J0c1ByZXNzUmlwcGxlKSB7XG4gICAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoUk9PVCk7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgICAgICAgLy8gVW5ib3VuZGVkIHJpcHBsZXMgbmVlZCBsYXlvdXQgbG9naWMgYXBwbGllZCBpbW1lZGlhdGVseSB0byBzZXQgY29vcmRpbmF0ZXMgZm9yIGJvdGggc2hhZGUgYW5kIHJpcHBsZVxuICAgICAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1ByZXNzUmlwcGxlXygpKSB7XG4gICAgICBpZiAodGhpcy5hY3RpdmF0aW9uVGltZXJfKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pO1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GR19BQ1RJVkFUSU9OKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyk7XG4gICAgICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfID0gMDtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1JPT1QsIFVOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFJPT1QpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ3NzVmFyc18oKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZGVyZWdpc3RlclJvb3RIYW5kbGVyc18oKTtcbiAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN1cHBvcnRzUHJlc3NSaXBwbGUgUGFzc2VkIGZyb20gaW5pdCB0byBzYXZlIGEgcmVkdW5kYW50IGZ1bmN0aW9uIGNhbGxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZ2lzdGVyUm9vdEhhbmRsZXJzXyhzdXBwb3J0c1ByZXNzUmlwcGxlKSB7XG4gICAgaWYgKHN1cHBvcnRzUHJlc3NSaXBwbGUpIHtcbiAgICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKGUpIHtcbiAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlclJvb3RIYW5kbGVyc18oKSB7XG4gICAgQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBkZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbW92ZUNzc1ZhcnNfKCkge1xuICAgIGNvbnN0IHtzdHJpbmdzfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4gICAgT2JqZWN0LmtleXMoc3RyaW5ncykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgaWYgKGsuaW5kZXhPZignVkFSXycpID09PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoc3RyaW5nc1trXSwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjdGl2YXRlXyhlKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNTdXJmYWNlRGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgcmVhY3RpbmcgdG8gZm9sbG93LW9uIGV2ZW50cyBmaXJlZCBieSB0b3VjaCBkZXZpY2UgYWZ0ZXIgYW4gYWxyZWFkeS1wcm9jZXNzZWQgdXNlciBpbnRlcmFjdGlvblxuICAgIGNvbnN0IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ID0gdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF87XG4gICAgY29uc3QgaXNTYW1lSW50ZXJhY3Rpb24gPSBwcmV2aW91c0FjdGl2YXRpb25FdmVudCAmJiBlICYmIHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50LnR5cGUgIT09IGUudHlwZTtcbiAgICBpZiAoaXNTYW1lSW50ZXJhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQgPSB0cnVlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA9IGUgPT09IG51bGw7XG4gICAgYWN0aXZhdGlvblN0YXRlLmFjdGl2YXRpb25FdmVudCA9IGU7XG4gICAgYWN0aXZhdGlvblN0YXRlLndhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA/IGZhbHNlIDogKFxuICAgICAgZS50eXBlID09PSAnbW91c2Vkb3duJyB8fCBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICdwb2ludGVyZG93bidcbiAgICApO1xuXG4gICAgY29uc3QgaGFzQWN0aXZhdGVkQ2hpbGQgPVxuICAgICAgZSAmJiBhY3RpdmF0ZWRUYXJnZXRzLmxlbmd0aCA+IDAgJiYgYWN0aXZhdGVkVGFyZ2V0cy5zb21lKCh0YXJnZXQpID0+IHRoaXMuYWRhcHRlcl8uY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpKTtcbiAgICBpZiAoaGFzQWN0aXZhdGVkQ2hpbGQpIHtcbiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlc2V0IGFjdGl2YXRpb24gc3RhdGUsIHdoaWxlIHByZXNlcnZpbmcgbG9naWMgdGhhdCBwcmV2ZW50cyB0b3VjaCBmb2xsb3ctb24gZXZlbnRzXG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlKSB7XG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzLnB1c2goLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChlLnRhcmdldCkpO1xuICAgICAgdGhpcy5yZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKTtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUgPSB0aGlzLmNoZWNrRWxlbWVudE1hZGVBY3RpdmVfKGUpO1xuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIFJlc2V0IGFycmF5IG9uIG5leHQgZnJhbWUgYWZ0ZXIgdGhlIGN1cnJlbnQgZXZlbnQgaGFzIGhhZCBhIGNoYW5jZSB0byBidWJibGUgdG8gcHJldmVudCBhbmNlc3RvciByaXBwbGVzXG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbiAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlICYmIChlLmtleSA9PT0gJyAnIHx8IGUua2V5Q29kZSA9PT0gMzIpKSB7XG4gICAgICAgIC8vIElmIHNwYWNlIHdhcyBwcmVzc2VkLCB0cnkgYWdhaW4gd2l0aGluIGFuIHJBRiBjYWxsIHRvIGRldGVjdCA6YWN0aXZlLCBiZWNhdXNlIGRpZmZlcmVudCBVQXMgcmVwb3J0XG4gICAgICAgIC8vIGFjdGl2ZSBzdGF0ZXMgaW5jb25zaXN0ZW50bHkgd2hlbiB0aGV5J3JlIGNhbGxlZCB3aXRoaW4gZXZlbnQgaGFuZGxpbmcgY29kZTpcbiAgICAgICAgLy8gLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MzU5NzFcbiAgICAgICAgLy8gLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjkzNzQxXG4gICAgICAgIC8vIFdlIHRyeSBmaXJzdCBvdXRzaWRlIHJBRiB0byBzdXBwb3J0IEVkZ2UsIHdoaWNoIGRvZXMgbm90IGV4aGliaXQgdGhpcyBwcm9ibGVtLCBidXQgd2lsbCBjcmFzaCBpZiBhIENTU1xuICAgICAgICAvLyB2YXJpYWJsZSBpcyBzZXQgd2l0aGluIGEgckFGIGNhbGxiYWNrIGZvciBhIHN1Ym1pdCBidXR0b24gaW50ZXJhY3Rpb24gKCMyMjQxKS5cbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlXyhlKTtcbiAgICAgICAgaWYgKGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgLy8gUmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSBpbW1lZGlhdGVseSBpZiBlbGVtZW50IHdhcyBub3QgbWFkZSBhY3RpdmUuXG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8oZSkge1xuICAgIHJldHVybiAoZSAmJiBlLnR5cGUgPT09ICdrZXlkb3duJykgPyB0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZUFjdGl2ZSgpIDogdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudD19IGV2ZW50IE9wdGlvbmFsIGV2ZW50IGNvbnRhaW5pbmcgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYW5pbWF0ZUFjdGl2YXRpb25fKCkge1xuICAgIGNvbnN0IHtWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCBWQVJfRkdfVFJBTlNMQVRFX0VORH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTiwgRkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0RFQUNUSVZBVElPTl9USU1FT1VUX01TfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycztcblxuICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG5cbiAgICBsZXQgdHJhbnNsYXRlU3RhcnQgPSAnJztcbiAgICBsZXQgdHJhbnNsYXRlRW5kID0gJyc7XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgY29uc3Qge3N0YXJ0UG9pbnQsIGVuZFBvaW50fSA9IHRoaXMuZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpO1xuICAgICAgdHJhbnNsYXRlU3RhcnQgPSBgJHtzdGFydFBvaW50Lnh9cHgsICR7c3RhcnRQb2ludC55fXB4YDtcbiAgICAgIHRyYW5zbGF0ZUVuZCA9IGAke2VuZFBvaW50Lnh9cHgsICR7ZW5kUG9pbnQueX1weGA7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCB0cmFuc2xhdGVTdGFydCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX0VORCwgdHJhbnNsYXRlRW5kKTtcbiAgICAvLyBDYW5jZWwgYW55IG9uZ29pbmcgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gYW5pbWF0aW9uc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyk7XG4gICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG5cbiAgICAvLyBGb3JjZSBsYXlvdXQgaW4gb3JkZXIgdG8gcmUtdHJpZ2dlciB0aGUgYW5pbWF0aW9uLlxuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrXygpLCBERUFDVElWQVRJT05fVElNRU9VVF9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7e3N0YXJ0UG9pbnQ6IFBvaW50VHlwZSwgZW5kUG9pbnQ6IFBvaW50VHlwZX19XG4gICAqL1xuICBnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfKCkge1xuICAgIGNvbnN0IHthY3RpdmF0aW9uRXZlbnQsIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcn0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG5cbiAgICBsZXQgc3RhcnRQb2ludDtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyKSB7XG4gICAgICBzdGFydFBvaW50ID0gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKFxuICAgICAgICAvKiogQHR5cGUgeyFFdmVudH0gKi8gKGFjdGl2YXRpb25FdmVudCksXG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93UGFnZU9mZnNldCgpLCB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQb2ludCA9IHtcbiAgICAgICAgeDogdGhpcy5mcmFtZV8ud2lkdGggLyAyLFxuICAgICAgICB5OiB0aGlzLmZyYW1lXy5oZWlnaHQgLyAyLFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2VudGVyIHRoZSBlbGVtZW50IGFyb3VuZCB0aGUgc3RhcnQgcG9pbnQuXG4gICAgc3RhcnRQb2ludCA9IHtcbiAgICAgIHg6IHN0YXJ0UG9pbnQueCAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgICAgeTogc3RhcnRQb2ludC55IC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgfTtcblxuICAgIGNvbnN0IGVuZFBvaW50ID0ge1xuICAgICAgeDogKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6ICh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICByZXR1cm4ge3N0YXJ0UG9pbnQsIGVuZFBvaW50fTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJvdGggd2hlbiBhIHBvaW50aW5nIGRldmljZSBpcyByZWxlYXNlZCwgYW5kIHdoZW4gdGhlIGFjdGl2YXRpb24gYW5pbWF0aW9uIGVuZHMuXG4gICAgLy8gVGhlIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gc2hvdWxkIG9ubHkgcnVuIGFmdGVyIGJvdGggb2YgdGhvc2Ugb2NjdXIuXG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge2hhc0RlYWN0aXZhdGlvblVYUnVuLCBpc0FjdGl2YXRlZH0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgY29uc3QgYWN0aXZhdGlvbkhhc0VuZGVkID0gaGFzRGVhY3RpdmF0aW9uVVhSdW4gfHwgIWlzQWN0aXZhdGVkO1xuXG4gICAgaWYgKGFjdGl2YXRpb25IYXNFbmRlZCAmJiB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8pIHtcbiAgICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB9LCBudW1iZXJzLkZHX0RFQUNUSVZBVElPTl9NUyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpIHtcbiAgICBjb25zdCB7RkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgfVxuXG4gIHJlc2V0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXy5hY3RpdmF0aW9uRXZlbnQ7XG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIC8vIFRvdWNoIGRldmljZXMgbWF5IGZpcmUgYWRkaXRpb25hbCBldmVudHMgZm9yIHRoZSBzYW1lIGludGVyYWN0aW9uIHdpdGhpbiBhIHNob3J0IHRpbWUuXG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzIGV2ZW50IHVudGlsIGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhhdCBzdWJzZXF1ZW50IGV2ZW50cyBhcmUgZm9yIG5ldyBpbnRlcmFjdGlvbnMuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IG51bGwsIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5UQVBfREVMQVlfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWFjdGl2YXRlXyhlKSB7XG4gICAgY29uc3QgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBzY2VuYXJpb3Mgc3VjaCBhcyB3aGVuIHlvdSBoYXZlIGEga2V5dXAgZXZlbnQgdGhhdCBibHVycyB0aGUgZWxlbWVudC5cbiAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gLyoqIEB0eXBlIHshQWN0aXZhdGlvblN0YXRlVHlwZX0gKi8gKE9iamVjdC5hc3NpZ24oe30sIGFjdGl2YXRpb25TdGF0ZSkpO1xuXG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYykge1xuICAgICAgY29uc3QgZXZ0T2JqZWN0ID0gbnVsbDtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGVEZWFjdGl2YXRpb25fKGV2dE9iamVjdCwgc3RhdGUpKTtcbiAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfLmhhc0RlYWN0aXZhdGlvblVYUnVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltYXRlRGVhY3RpdmF0aW9uXyhlLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZGVhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmRlYWN0aXZhdGVfKGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFuaW1hdGVEZWFjdGl2YXRpb25fKGUsIHt3YXNBY3RpdmF0ZWRCeVBvaW50ZXIsIHdhc0VsZW1lbnRNYWRlQWN0aXZlfSkge1xuICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgfHwgd2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLmxheW91dEZyYW1lXykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGxheW91dEludGVybmFsXygpIHtcbiAgICB0aGlzLmZyYW1lXyA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIGNvbnN0IG1heERpbSA9IE1hdGgubWF4KHRoaXMuZnJhbWVfLmhlaWdodCwgdGhpcy5mcmFtZV8ud2lkdGgpO1xuXG4gICAgLy8gU3VyZmFjZSBkaWFtZXRlciBpcyB0cmVhdGVkIGRpZmZlcmVudGx5IGZvciB1bmJvdW5kZWQgdnMuIGJvdW5kZWQgcmlwcGxlcy5cbiAgICAvLyBVbmJvdW5kZWQgcmlwcGxlIGRpYW1ldGVyIGlzIGNhbGN1bGF0ZWQgc21hbGxlciBzaW5jZSB0aGUgc3VyZmFjZSBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGJlIHBhZGRlZCBhcHByb3ByaWF0ZWx5XG4gICAgLy8gdG8gZXh0ZW5kIHRoZSBoaXRib3gsIGFuZCB0aGUgcmlwcGxlIGlzIGV4cGVjdGVkIHRvIG1lZXQgdGhlIGVkZ2VzIG9mIHRoZSBwYWRkZWQgaGl0Ym94ICh3aGljaCBpcyB0eXBpY2FsbHlcbiAgICAvLyBzcXVhcmUpLiBCb3VuZGVkIHJpcHBsZXMsIG9uIHRoZSBvdGhlciBoYW5kLCBhcmUgZnVsbHkgZXhwZWN0ZWQgdG8gZXhwYW5kIGJleW9uZCB0aGUgc3VyZmFjZSdzIGxvbmdlc3QgZGlhbWV0ZXJcbiAgICAvLyAoY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGlhZ29uYWwgcGx1cyBhIGNvbnN0YW50IHBhZGRpbmcpLCBhbmQgYXJlIGNsaXBwZWQgYXQgdGhlIHN1cmZhY2UncyBib3JkZXIgdmlhXG4gICAgLy8gYG92ZXJmbG93OiBoaWRkZW5gLlxuICAgIGNvbnN0IGdldEJvdW5kZWRSYWRpdXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBoeXBvdGVudXNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuZnJhbWVfLndpZHRoLCAyKSArIE1hdGgucG93KHRoaXMuZnJhbWVfLmhlaWdodCwgMikpO1xuICAgICAgcmV0dXJuIGh5cG90ZW51c2UgKyBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuUEFERElORztcbiAgICB9O1xuXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpID8gbWF4RGltIDogZ2V0Qm91bmRlZFJhZGl1cygpO1xuXG4gICAgLy8gUmlwcGxlIGlzIHNpemVkIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGxhcmdlc3QgZGltZW5zaW9uIG9mIHRoZSBzdXJmYWNlLCB0aGVuIHNjYWxlcyB1cCB1c2luZyBhIENTUyBzY2FsZSB0cmFuc2Zvcm1cbiAgICB0aGlzLmluaXRpYWxTaXplXyA9IG1heERpbSAqIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5JTklUSUFMX09SSUdJTl9TQ0FMRTtcbiAgICB0aGlzLmZnU2NhbGVfID0gdGhpcy5tYXhSYWRpdXNfIC8gdGhpcy5pbml0aWFsU2l6ZV87XG5cbiAgICB0aGlzLnVwZGF0ZUxheW91dENzc1ZhcnNfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdXBkYXRlTGF5b3V0Q3NzVmFyc18oKSB7XG4gICAgY29uc3Qge1xuICAgICAgVkFSX0ZHX1NJWkUsIFZBUl9MRUZULCBWQVJfVE9QLCBWQVJfRkdfU0NBTEUsXG4gICAgfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NJWkUsIGAke3RoaXMuaW5pdGlhbFNpemVffXB4YCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0NBTEUsIHRoaXMuZmdTY2FsZV8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lXy53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgICB0b3A6IE1hdGgucm91bmQoKHRoaXMuZnJhbWVfLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfTEVGVCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLmxlZnR9cHhgKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX1RPUCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLnRvcH1weGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHVuYm91bmRlZCAqL1xuICBzZXRVbmJvdW5kZWQodW5ib3VuZGVkKSB7XG4gICAgY29uc3Qge1VOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKHVuYm91bmRlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9jdXMoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKSk7XG4gIH1cblxuICBoYW5kbGVCbHVyKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JpcHBsZUZvdW5kYXRpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgLy8gUmlwcGxlIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHRoZSBcInJvb3RcIiBjb21wb25lbnQgaXMgcmVhbGx5IGEgXCJtaXhpblwiIG9mIHNvcnRzLFxuICAvLyBnaXZlbiB0aGF0IGl0J3MgYW4gJ3VwZ3JhZGUnIHRvIGFuIGV4aXN0aW5nIGNvbXBvbmVudC4gVGhhdCBiZWluZyBzYWlkIGl0IGlzIHRoZSByb290XG4gIC8vIENTUyBjbGFzcyB0aGF0IGFsbCBvdGhlciBDU1MgY2xhc3NlcyBkZXJpdmUgZnJvbS5cbiAgUk9PVDogJ21kYy1yaXBwbGUtdXBncmFkZWQnLFxuICBVTkJPVU5ERUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS11bmJvdW5kZWQnLFxuICBCR19GT0NVU0VEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tYmFja2dyb3VuZC1mb2N1c2VkJyxcbiAgRkdfQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtYWN0aXZhdGlvbicsXG4gIEZHX0RFQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtZGVhY3RpdmF0aW9uJyxcbn07XG5cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFZBUl9MRUZUOiAnLS1tZGMtcmlwcGxlLWxlZnQnLFxuICBWQVJfVE9QOiAnLS1tZGMtcmlwcGxlLXRvcCcsXG4gIFZBUl9GR19TSVpFOiAnLS1tZGMtcmlwcGxlLWZnLXNpemUnLFxuICBWQVJfRkdfU0NBTEU6ICctLW1kYy1yaXBwbGUtZmctc2NhbGUnLFxuICBWQVJfRkdfVFJBTlNMQVRFX1NUQVJUOiAnLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1zdGFydCcsXG4gIFZBUl9GR19UUkFOU0xBVEVfRU5EOiAnLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1lbmQnLFxufTtcblxuY29uc3QgbnVtYmVycyA9IHtcbiAgUEFERElORzogMTAsXG4gIElOSVRJQUxfT1JJR0lOX1NDQUxFOiAwLjYsXG4gIERFQUNUSVZBVElPTl9USU1FT1VUX01TOiAyMjUsIC8vIENvcnJlc3BvbmRzIHRvICRtZGMtcmlwcGxlLXRyYW5zbGF0ZS1kdXJhdGlvbiAoaS5lLiBhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcbiAgRkdfREVBQ1RJVkFUSU9OX01TOiAxNTAsIC8vIENvcnJlc3BvbmRzIHRvICRtZGMtcmlwcGxlLWZhZGUtb3V0LWR1cmF0aW9uIChpLmUuIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXG4gIFRBUF9ERUxBWV9NUzogMzAwLCAvLyBEZWxheSBiZXR3ZWVuIHRvdWNoIGFuZCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIG9uIHRvdWNoIGRldmljZXNcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQge01EQ0NvbXBvbmVudH0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtNRENSaXBwbGV9IGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUvaW5kZXgnO1xuXG5pbXBvcnQgTURDRGlhbG9nRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQge01EQ0RpYWxvZ0ZvdW5kYXRpb259O1xuZXhwb3J0IHt1dGlsfTtcblxuZXhwb3J0IGNsYXNzIE1EQ0RpYWxvZyBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBNRENEaWFsb2cocm9vdCk7XG4gIH1cblxuICBnZXQgb3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uXy5pc09wZW4oKTtcbiAgfVxuXG4gIGdldCBhY2NlcHRCdXR0b25fKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoTURDRGlhbG9nRm91bmRhdGlvbi5zdHJpbmdzLkFDQ0VQVF9TRUxFQ1RPUik7XG4gIH1cblxuICBnZXQgZGlhbG9nU3VyZmFjZV8oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENEaWFsb2dGb3VuZGF0aW9uLnN0cmluZ3MuRElBTE9HX1NVUkZBQ0VfU0VMRUNUT1IpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmZvY3VzVHJhcF8gPSB1dGlsLmNyZWF0ZUZvY3VzVHJhcEluc3RhbmNlKHRoaXMuZGlhbG9nU3VyZmFjZV8sIHRoaXMuYWNjZXB0QnV0dG9uXyk7XG4gICAgdGhpcy5mb290ZXJCdG5SaXBwbGVzXyA9IFtdO1xuXG4gICAgY29uc3QgZm9vdGVyQnRucyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvckFsbCgnLm1kYy1kaWFsb2dfX2Zvb3Rlcl9fYnV0dG9uJyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGZvb3RlckJ0bjsgZm9vdGVyQnRuID0gZm9vdGVyQnRuc1tpXTsgaSsrKSB7XG4gICAgICB0aGlzLmZvb3RlckJ0blJpcHBsZXNfLnB1c2gobmV3IE1EQ1JpcHBsZShmb290ZXJCdG4pKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZm9vdGVyQnRuUmlwcGxlc18uZm9yRWFjaCgocmlwcGxlKSA9PiByaXBwbGUuZGVzdHJveSgpKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8ub3BlbigpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5jbG9zZSgpO1xuICB9XG5cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBNRENEaWFsb2dGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGFkZEJvZHlDbGFzczogKGNsYXNzTmFtZSkgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6IChjbGFzc05hbWUpID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKHRhcmdldCwgY2xhc3NOYW1lKSA9PiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4gdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB0aGlzLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4gdGhpcy5kaWFsb2dTdXJmYWNlXy5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4gdGhpcy5kaWFsb2dTdXJmYWNlXy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IChoYW5kbGVyKSA9PiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKGhhbmRsZXIpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKSxcbiAgICAgIG5vdGlmeUFjY2VwdDogKCkgPT4gdGhpcy5lbWl0KE1EQ0RpYWxvZ0ZvdW5kYXRpb24uc3RyaW5ncy5BQ0NFUFRfRVZFTlQpLFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB0aGlzLmVtaXQoTURDRGlhbG9nRm91bmRhdGlvbi5zdHJpbmdzLkNBTkNFTF9FVkVOVCksXG4gICAgICB0cmFwRm9jdXNPblN1cmZhY2U6ICgpID0+IHRoaXMuZm9jdXNUcmFwXy5hY3RpdmF0ZSgpLFxuICAgICAgdW50cmFwRm9jdXNPblN1cmZhY2U6ICgpID0+IHRoaXMuZm9jdXNUcmFwXy5kZWFjdGl2YXRlKCksXG4gICAgICBpc0RpYWxvZzogKGVsKSA9PiBlbCA9PT0gdGhpcy5kaWFsb2dTdXJmYWNlXyxcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENEaWFsb2dGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuICh7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYWRkQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKC8qIHRhcmdldDogRXZlbnRUYXJnZXQsIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBub3RpZnlBY2NlcHQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7fSxcbiAgICAgIHRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICB1bnRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICBpc0RpYWxvZzogKC8qIGVsOiBFbGVtZW50ICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDRGlhbG9nRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3MoZXZ0LnRhcmdldCwgY3NzQ2xhc3Nlcy5CQUNLRFJPUCkpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRpYWxvZ0NsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZURpYWxvZ0NsaWNrXyhldnQpO1xuICAgIHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSAmJiBldnQua2V5ID09PSAnRXNjYXBlJyB8fCBldnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudGltZXJJZF8gPSAwO1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZXJFbmRfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVBbmltYXRpb25UaW1lckVuZF8oZXZ0KTtcbiAgfTtcblxuICBkZXN0cm95KCkge1xuICAgIC8vIEVuc3VyZSB0aGF0IGRpYWxvZyBpcyBjbGVhbmVkIHVwIHdoZW4gZGVzdHJveWVkXG4gICAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICAvLyBGaW5hbCBjbGVhbnVwIG9mIGFuaW1hdGluZyBjbGFzcyBpbiBjYXNlIHRoZSB0aW1lciBoYXMgbm90IGNvbXBsZXRlZC5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWRfKTtcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZF8pO1xuICAgIHRoaXMudGltZXJJZF8gPSBzZXRUaW1lb3V0KHRoaXMuYW5pbWF0aW9uVGltZXJFbmRfLCBNRENEaWFsb2dGb3VuZGF0aW9uLm51bWJlcnMuRElBTE9HX0FOSU1BVElPTl9USU1FX01TKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVTY3JvbGxfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmRpYWxvZ0NsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWRfKTtcbiAgICB0aGlzLnRpbWVySWRfID0gc2V0VGltZW91dCh0aGlzLmFuaW1hdGlvblRpbWVyRW5kXywgTURDRGlhbG9nRm91bmRhdGlvbi5udW1iZXJzLkRJQUxPR19BTklNQVRJT05fVElNRV9NUyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgYWNjZXB0KHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5QWNjZXB0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgY2FuY2VsKHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgaGFuZGxlRGlhbG9nQ2xpY2tfKGV2dCkge1xuICAgIGNvbnN0IHt0YXJnZXR9ID0gZXZ0O1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3ModGFyZ2V0LCBjc3NDbGFzc2VzLkFDQ0VQVF9CVE4pKSB7XG4gICAgICB0aGlzLmFjY2VwdCh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyh0YXJnZXQsIGNzc0NsYXNzZXMuQ0FOQ0VMX0JUTikpIHtcbiAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUFuaW1hdGlvblRpbWVyRW5kXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8udHJhcEZvY3VzT25TdXJmYWNlKCk7XG4gICAgfVxuICB9O1xuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvZm91bmRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtZGlhbG9nJyxcbiAgT1BFTjogJ21kYy1kaWFsb2ctLW9wZW4nLFxuICBBTklNQVRJTkc6ICdtZGMtZGlhbG9nLS1hbmltYXRpbmcnLFxuICBCQUNLRFJPUDogJ21kYy1kaWFsb2dfX2JhY2tkcm9wJyxcbiAgU0NST0xMX0xPQ0s6ICdtZGMtZGlhbG9nLXNjcm9sbC1sb2NrJyxcbiAgQUNDRVBUX0JUTjogJ21kYy1kaWFsb2dfX2Zvb3Rlcl9fYnV0dG9uLS1hY2NlcHQnLFxuICBDQU5DRUxfQlROOiAnbWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24tLWNhbmNlbCcsXG59O1xuXG5jb25zdCBzdHJpbmdzID0ge1xuICBPUEVOX0RJQUxPR19TRUxFQ1RPUjogJy5tZGMtZGlhbG9nLS1vcGVuJyxcbiAgRElBTE9HX1NVUkZBQ0VfU0VMRUNUT1I6ICcubWRjLWRpYWxvZ19fc3VyZmFjZScsXG4gIEFDQ0VQVF9TRUxFQ1RPUjogJy5tZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tYWNjZXB0JyxcbiAgQUNDRVBUX0VWRU5UOiAnTURDRGlhbG9nOmFjY2VwdCcsXG4gIENBTkNFTF9FVkVOVDogJ01EQ0RpYWxvZzpjYW5jZWwnLFxufTtcblxuY29uc3QgbnVtYmVycyA9IHtcbiAgRElBTE9HX0FOSU1BVElPTl9USU1FX01TOiAxMjAsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUZvY3VzVHJhcCBmcm9tICdmb2N1cy10cmFwJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvY3VzVHJhcEluc3RhbmNlKHN1cmZhY2VFbCwgYWNjZXB0QnV0dG9uRWwsIGZvY3VzVHJhcEZhY3RvcnkgPSBjcmVhdGVGb2N1c1RyYXApIHtcbiAgcmV0dXJuIGZvY3VzVHJhcEZhY3Rvcnkoc3VyZmFjZUVsLCB7XG4gICAgaW5pdGlhbEZvY3VzOiBhY2NlcHRCdXR0b25FbCxcbiAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogdHJ1ZSxcbiAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RpYWxvZy91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdGFiYmFibGUgPSByZXF1aXJlKCd0YWJiYWJsZScpO1xuXG52YXIgbGlzdGVuaW5nRm9jdXNUcmFwID0gbnVsbDtcblxuZnVuY3Rpb24gZm9jdXNUcmFwKGVsZW1lbnQsIHVzZXJPcHRpb25zKSB7XG4gIHZhciB0YWJiYWJsZU5vZGVzID0gW107XG4gIHZhciBmaXJzdFRhYmJhYmxlTm9kZSA9IG51bGw7XG4gIHZhciBsYXN0VGFiYmFibGVOb2RlID0gbnVsbDtcbiAgdmFyIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IG51bGw7XG4gIHZhciBhY3RpdmUgPSBmYWxzZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICB2YXIgdGFiRXZlbnQgPSBudWxsO1xuXG4gIHZhciBjb250YWluZXIgPSAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KVxuICAgIDogZWxlbWVudDtcblxuICB2YXIgY29uZmlnID0gdXNlck9wdGlvbnMgfHwge307XG4gIGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGVcbiAgICA6IHRydWU7XG4gIGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMuZXNjYXBlRGVhY3RpdmF0ZXNcbiAgICA6IHRydWU7XG5cbiAgdmFyIHRyYXAgPSB7XG4gICAgYWN0aXZhdGU6IGFjdGl2YXRlLFxuICAgIGRlYWN0aXZhdGU6IGRlYWN0aXZhdGUsXG4gICAgcGF1c2U6IHBhdXNlLFxuICAgIHVucGF1c2U6IHVucGF1c2UsXG4gIH07XG5cbiAgcmV0dXJuIHRyYXA7XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGUoYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKGFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgdmFyIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIG9uQWN0aXZhdGU6IChhY3RpdmF0ZU9wdGlvbnMgJiYgYWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkFjdGl2YXRlLFxuICAgIH07XG5cbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBpZiAoZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUpIHtcbiAgICAgIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlKGRlYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKCFhY3RpdmUpIHJldHVybjtcblxuICAgIHZhciBkZWZhdWx0ZWREZWFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIHJldHVybkZvY3VzOiAoZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1c1xuICAgICAgICA6IGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSxcbiAgICAgIG9uRGVhY3RpdmF0ZTogKGRlYWN0aXZhdGVPcHRpb25zICYmIGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkRlYWN0aXZhdGUsXG4gICAgfTtcblxuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSkge1xuICAgICAgZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5Rm9jdXMobm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uKTtcbiAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaWYgKHBhdXNlZCB8fCAhYWN0aXZlKSByZXR1cm47XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKCFwYXVzZWQgfHwgIWFjdGl2ZSkgcmV0dXJuO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGFkZExpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghYWN0aXZlKSByZXR1cm47XG5cbiAgICAvLyBUaGVyZSBjYW4gYmUgb25seSBvbmUgbGlzdGVuaW5nIGZvY3VzIHRyYXAgYXQgYSB0aW1lXG4gICAgaWYgKGxpc3RlbmluZ0ZvY3VzVHJhcCkge1xuICAgICAgbGlzdGVuaW5nRm9jdXNUcmFwLnBhdXNlKCk7XG4gICAgfVxuICAgIGxpc3RlbmluZ0ZvY3VzVHJhcCA9IHRyYXA7XG5cbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZvY3VzZWQgZWxlbWVudCBkb2Vzbid0IGNhcHR1cmUgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBmb2N1cyB0cmFwIGFjdGl2YXRpb25cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeUZvY3VzKGZpcnN0Rm9jdXNOb2RlKCkpO1xuICAgIH0sIDApO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgY2hlY2tGb2N1cywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB0cnVlKTtcblxuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGlmICghYWN0aXZlIHx8IGxpc3RlbmluZ0ZvY3VzVHJhcCAhPT0gdHJhcCkgcmV0dXJuO1xuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBjaGVja0ZvY3VzLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrQ2xpY2ssIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXksIHRydWUpO1xuXG4gICAgbGlzdGVuaW5nRm9jdXNUcmFwID0gbnVsbDtcblxuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUZvck9wdGlvbihvcHRpb25OYW1lKSB7XG4gICAgdmFyIG9wdGlvblZhbHVlID0gY29uZmlnW29wdGlvbk5hbWVdO1xuICAgIHZhciBub2RlID0gb3B0aW9uVmFsdWU7XG4gICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25WYWx1ZSk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgJyArIG9wdGlvbk5hbWUgKyAnYCByZWZlcnMgdG8gbm8ga25vd24gbm9kZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBub2RlID0gb3B0aW9uVmFsdWUoKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIGRpZCBub3QgcmV0dXJuIGEgbm9kZScpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcnN0Rm9jdXNOb2RlKCkge1xuICAgIHZhciBub2RlO1xuICAgIGlmIChnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKSAhPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ2luaXRpYWxGb2N1cycpO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBub2RlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHRhYmJhYmxlTm9kZXNbMF0gfHwgZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpO1xuICAgIH1cblxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuXFwndCBoYXZlIGEgZm9jdXMtdHJhcCB3aXRob3V0IGF0IGxlYXN0IG9uZSBmb2N1c2FibGUgZWxlbWVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBkb25lIG9uIG1vdXNlZG93biBhbmQgdG91Y2hzdGFydCBpbnN0ZWFkIG9mIGNsaWNrXG4gIC8vIHNvIHRoYXQgaXQgcHJlY2VkZXMgdGhlIGZvY3VzIGV2ZW50XG4gIGZ1bmN0aW9uIGNoZWNrUG9pbnRlckRvd24oZSkge1xuICAgIGlmIChjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMgJiYgIWNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgIGRlYWN0aXZhdGUoeyByZXR1cm5Gb2N1czogZmFsc2UgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGljayhlKSB7XG4gICAgaWYgKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcykgcmV0dXJuO1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0ZvY3VzKGUpIHtcbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIC8vIENoZWNraW5nIGZvciBhIGJsdXIgbWV0aG9kIGhlcmUgcmVzb2x2ZXMgYSBGaXJlZm94IGlzc3VlICgjMTUpXG4gICAgaWYgKHR5cGVvZiBlLnRhcmdldC5ibHVyID09PSAnZnVuY3Rpb24nKSBlLnRhcmdldC5ibHVyKCk7XG5cbiAgICBpZiAodGFiRXZlbnQpIHtcbiAgICAgIHJlYWRqdXN0Rm9jdXModGFiRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrS2V5KGUpIHtcbiAgICBpZiAoZS5rZXkgPT09ICdUYWInIHx8IGUua2V5Q29kZSA9PT0gOSkge1xuICAgICAgaGFuZGxlVGFiKGUpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMgIT09IGZhbHNlICYmIGlzRXNjYXBlRXZlbnQoZSkpIHtcbiAgICAgIGRlYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVUYWIoZSkge1xuICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcblxuICAgIGlmIChlLnRhcmdldC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykgJiYgTnVtYmVyKGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSkgPCAwKSB7XG4gICAgICByZXR1cm4gdGFiRXZlbnQgPSBlO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgY3VycmVudEZvY3VzSW5kZXggPSB0YWJiYWJsZU5vZGVzLmluZGV4T2YoZS50YXJnZXQpO1xuXG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gZmlyc3RUYWJiYWJsZU5vZGUgfHwgdGFiYmFibGVOb2Rlcy5pbmRleE9mKGUudGFyZ2V0KSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRyeUZvY3VzKGxhc3RUYWJiYWJsZU5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyeUZvY3VzKHRhYmJhYmxlTm9kZXNbY3VycmVudEZvY3VzSW5kZXggLSAxXSk7XG4gICAgfVxuXG4gICAgaWYgKGUudGFyZ2V0ID09PSBsYXN0VGFiYmFibGVOb2RlKSByZXR1cm4gdHJ5Rm9jdXMoZmlyc3RUYWJiYWJsZU5vZGUpO1xuXG4gICAgdHJ5Rm9jdXModGFiYmFibGVOb2Rlc1tjdXJyZW50Rm9jdXNJbmRleCArIDFdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKSB7XG4gICAgdGFiYmFibGVOb2RlcyA9IHRhYmJhYmxlKGNvbnRhaW5lcik7XG4gICAgZmlyc3RUYWJiYWJsZU5vZGUgPSB0YWJiYWJsZU5vZGVzWzBdO1xuICAgIGxhc3RUYWJiYWJsZU5vZGUgPSB0YWJiYWJsZU5vZGVzW3RhYmJhYmxlTm9kZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBmdW5jdGlvbiByZWFkanVzdEZvY3VzKGUpIHtcbiAgICBpZiAoZS5zaGlmdEtleSkgcmV0dXJuIHRyeUZvY3VzKGxhc3RUYWJiYWJsZU5vZGUpO1xuXG4gICAgdHJ5Rm9jdXMoZmlyc3RUYWJiYWJsZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXNjYXBlRXZlbnQoZSkge1xuICByZXR1cm4gZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJyB8fCBlLmtleUNvZGUgPT09IDI3O1xufVxuXG5mdW5jdGlvbiB0cnlGb2N1cyhub2RlKSB7XG4gIGlmICghbm9kZSB8fCAhbm9kZS5mb2N1cykgcmV0dXJuO1xuICBpZiAobm9kZSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgIHJldHVybjtcblxuICBub2RlLmZvY3VzKCk7XG4gIGlmIChub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgIG5vZGUuc2VsZWN0KCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c1RyYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgZWxlbWVudERvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCB8fCBlbDtcbiAgdmFyIGJhc2ljVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG5cbiAgLy8gQSBub2RlIGlzIFwiYXZhaWxhYmxlXCIgaWZcbiAgLy8gLSBpdCdzIGNvbXB1dGVkIHN0eWxlXG4gIHZhciBpc1VuYXZhaWxhYmxlID0gY3JlYXRlSXNVbmF2YWlsYWJsZShlbGVtZW50RG9jdW1lbnQpO1xuXG4gIHZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICAgJ2lucHV0JyxcbiAgICAnc2VsZWN0JyxcbiAgICAnYVtocmVmXScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnW3RhYmluZGV4XScsXG4gIF07XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJykpO1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVDb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgaWYgKFxuICAgICAgY2FuZGlkYXRlU2VsZWN0b3JzLnNvbWUoZnVuY3Rpb24oY2FuZGlkYXRlU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgfSlcbiAgICApIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoY2FuZGlkYXRlcyk7XG4gICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjYW5kaWRhdGUsIGNhbmRpZGF0ZUluZGV4QXR0ciwgY2FuZGlkYXRlSW5kZXg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2FuZGlkYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW2ldO1xuICAgIGNhbmRpZGF0ZUluZGV4QXR0ciA9IHBhcnNlSW50KGNhbmRpZGF0ZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKVxuICAgIGNhbmRpZGF0ZUluZGV4ID0gaXNOYU4oY2FuZGlkYXRlSW5kZXhBdHRyKSA/IGNhbmRpZGF0ZS50YWJJbmRleCA6IGNhbmRpZGF0ZUluZGV4QXR0cjtcblxuICAgIGlmIChcbiAgICAgIGNhbmRpZGF0ZUluZGV4IDwgMFxuICAgICAgfHwgKGNhbmRpZGF0ZS50YWdOYW1lID09PSAnSU5QVVQnICYmIGNhbmRpZGF0ZS50eXBlID09PSAnaGlkZGVuJylcbiAgICAgIHx8IGNhbmRpZGF0ZS5kaXNhYmxlZFxuICAgICAgfHwgaXNVbmF2YWlsYWJsZShjYW5kaWRhdGUsIGVsZW1lbnREb2N1bWVudClcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjYW5kaWRhdGVJbmRleCA9PT0gMCkge1xuICAgICAgYmFzaWNUYWJiYWJsZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZUluZGV4LFxuICAgICAgICBub2RlOiBjYW5kaWRhdGUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGFiYmFibGVOb2RlcyA9IG9yZGVyZWRUYWJiYWJsZXNcbiAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleCA/IGEuaW5kZXggLSBiLmluZGV4IDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG4gICAgfSlcbiAgICAubWFwKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhLm5vZGVcbiAgICB9KTtcblxuICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0YWJiYWJsZU5vZGVzLCBiYXNpY1RhYmJhYmxlcyk7XG5cbiAgcmV0dXJuIHRhYmJhYmxlTm9kZXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUlzVW5hdmFpbGFibGUoZWxlbWVudERvY3VtZW50KSB7XG4gIC8vIE5vZGUgY2FjaGUgbXVzdCBiZSByZWZyZXNoZWQgb24gZXZlcnkgY2hlY2ssIGluIGNhc2VcbiAgLy8gdGhlIGNvbnRlbnQgb2YgdGhlIGVsZW1lbnQgaGFzIGNoYW5nZWRcbiAgdmFyIGlzT2ZmQ2FjaGUgPSBbXTtcblxuICAvLyBcIm9mZlwiIG1lYW5zIGBkaXNwbGF5OiBub25lO2AsIGFzIG9wcG9zZWQgdG8gXCJoaWRkZW5cIixcbiAgLy8gd2hpY2ggbWVhbnMgYHZpc2liaWxpdHk6IGhpZGRlbjtgLiBnZXRDb21wdXRlZFN0eWxlXG4gIC8vIGFjY3VyYXRlbHkgcmVmbGVjdHMgdmlzaWJsaXR5IGluIGNvbnRleHQgYnV0IG5vdFxuICAvLyBcIm9mZlwiIHN0YXRlLCBzbyB3ZSBuZWVkIHRvIHJlY3Vyc2l2ZWx5IGNoZWNrIHBhcmVudHMuXG5cbiAgZnVuY3Rpb24gaXNPZmYobm9kZSwgbm9kZUNvbXB1dGVkU3R5bGUpIHtcbiAgICBpZiAobm9kZSA9PT0gZWxlbWVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gRmluZCB0aGUgY2FjaGVkIG5vZGUgKEFycmF5LnByb3RvdHlwZS5maW5kIG5vdCBhdmFpbGFibGUgaW4gSUU5KVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBpc09mZkNhY2hlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXNPZmZDYWNoZVtpXVswXSA9PT0gbm9kZSkgcmV0dXJuIGlzT2ZmQ2FjaGVbaV1bMV07XG4gICAgfVxuXG4gICAgbm9kZUNvbXB1dGVkU3R5bGUgPSBub2RlQ29tcHV0ZWRTdHlsZSB8fCBlbGVtZW50RG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgIGlmIChub2RlQ29tcHV0ZWRTdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHJlc3VsdCA9IGlzT2ZmKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgfVxuXG4gICAgaXNPZmZDYWNoZS5wdXNoKFtub2RlLCByZXN1bHRdKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gaXNVbmF2YWlsYWJsZShub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVsZW1lbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gZWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICBpZiAoaXNPZmYobm9kZSwgY29tcHV0ZWRTdHlsZSkpIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbic7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZSc7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGVtcHR5IGZvdW5kYXRpb24gaW4gb3JkZXIgdG8gaGF2ZSB0aGUgWVQgSWZyYW1lIEFQSSBsb2FkIHZpYSB0aGVcbiAqIGFkYXB0ZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBMQklmcmFtZUFwaUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshT2JqZWN0fSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihMQklmcmFtZUFwaUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy92aWRlby1pZnJhbWUvZm91bmRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtBdHRycywgREVGQVVMVF9TRVRUSU5HU30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtNRENDb21wb25lbnR9IGZyb20gJ0BtYXRlcmlhbC9iYXNlJztcbmltcG9ydCB7TEJQbGF5ZXJGb3VuZGF0aW9ufSBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtkZWxlZ2F0ZSwgdW5kZWxlZ2F0ZX0gZnJvbSAnLi4vLi4vLi4vcHJvdmlkZXJzL3V0aWxzL3V0aWxzJztcblxuLyoqIEBlbnVtIHshWVQuUGxheWVyfSAqL1xuY29uc3QgWVRQbGF5ZXJzID0gTEJQbGF5ZXJGb3VuZGF0aW9uLllUUGxheWVycztcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBZVFBsYXllciBhZGFwdGVyIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBZVFBsYXllciBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBZVFBsYXllciBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290IFRoZSBzZWxlY3RvciBvZiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFZVFBsYXllcn1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBZVFBsYXllcihyb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIExCUGxheWVyRm91bmRhdGlvbi5cbiAgICogQHJldHVybiB7IUxCUGxheWVyRm91bmRhdGlvbn1cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTEJQbGF5ZXJGb3VuZGF0aW9uKHtcbiAgICAgIGdldEF0dHI6IChlbCwgYXR0cikgPT4ge1xuICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgfSxcbiAgICAgIHN0b3JlUGxheWVyOiAobGlzdCwgcGxheWVyLCBpZCkgPT4ge1xuICAgICAgICBsaXN0W2lkXSA9IHBsYXllcjtcbiAgICAgIH0sXG4gICAgICBwbGF5OiAocGxheWVyKSA9PiB7XG4gICAgICAgIHJldHVybiBwbGF5ZXIucGxheVZpZGVvKCk7XG4gICAgICB9LFxuICAgICAgcGF1c2U6IChwbGF5ZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHBsYXllci5wYXVzZVZpZGVvKCk7XG4gICAgICB9LFxuICAgICAgc3RvcDogKHBsYXllcikgPT4ge1xuICAgICAgICByZXR1cm4gcGxheWVyLnN0b3BWaWRlbygpO1xuICAgICAgfSxcbiAgICAgIG5leHQ6IChwbGF5ZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHBsYXllci5uZXh0VmlkZW8oKTtcbiAgICAgIH0sXG4gICAgICBwcmV2aW91czogKHBsYXllcikgPT4ge1xuICAgICAgICByZXR1cm4gcGxheWVyLnByZXZpb3VzVmlkZW8oKTtcbiAgICAgIH0sXG4gICAgICBjdWVWaWRlbzogKHBsYXllciwgY3VlSWQpID0+IHtcbiAgICAgICAgcmV0dXJuIHBsYXllci5jdWVWaWRlb0J5SWQoY3VlSWQpO1xuICAgICAgfSxcbiAgICAgIGN1ZVBsYXlsaXN0OiAocGxheWVyLCBjdWVJZCkgPT4ge1xuICAgICAgICByZXR1cm4gcGxheWVyLmN1ZVBsYXlsaXN0KHtcbiAgICAgICAgICBsaXN0VHlwZTogJ3BsYXlsaXN0JyxcbiAgICAgICAgICBsaXN0OiBjdWVJZCxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVsZWdhdGVFdmVudEhhbmRsZXI6IChzZWxlY3RvciwgZXZlbnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZShkb2N1bWVudCwgc2VsZWN0b3IsIGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gICAgICB9LFxuICAgICAgdW5kZWxlZ2F0ZUV2ZW50SGFuZGxlcjogKHNlbGVjdG9yLCBldmVudFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHVuZGVsZWdhdGUoZG9jdW1lbnQsIHNlbGVjdG9yLCBldmVudFR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZXMgYWxsIFlvdVR1YmUgdmlkZW9zIG9uIHRoZSBwYWdlIGJlZm9yZVxuICAgKiBwbGF5aW5nIGN1cnJlbnQgdmlkZW8uXG4gICAqL1xuICBwbGF5VmlkZW8oKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5wYXVzZUFsbE90aGVyVmlkZW9zKHtcbiAgICAgIGRhdGE6IC0xLFxuICAgICAgdGFyZ2V0OiB0aGlzLnBsYXllckluc3RhbmNlXyxcbiAgICB9KTtcblxuICAgIHRoaXMucG9sbFBsYXllclN0YXRlXygoKSA9PiB0aGlzLnBsYXllckluc3RhbmNlXy5wbGF5VmlkZW8oKSk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyB0aGUgYFlULlBsYXllcmAgaW50ZXJmYWNlIGhhcyBsb2FkZWRcbiAgICogYmVmb3JlIGZpcmluZyB0aGUgYGNvbXBsZXRlQ2FsbGJhY2tgLlxuICAgKiBAcGFyYW0gez9GdW5jdGlvbn0gY29tcGxldGVDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcG9sbFBsYXllclN0YXRlXyhjb21wbGV0ZUNhbGxiYWNrKSB7XG4gICAgaWYgKCdwbGF5VmlkZW8nIGluIHRoaXMucGxheWVySW5zdGFuY2VfKSB7XG4gICAgICBjb21wbGV0ZUNhbGxiYWNrKCk7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucG9sbFRpbWVySWRfKTtcbiAgICAgIHRoaXMucG9sbFRpbWVySWRfID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb2xsVGltZXJJZF8gPSB3aW5kb3cuc2V0VGltZW91dChcbiAgICAgICAgICB0aGlzLnBvbGxQbGF5ZXJTdGF0ZV8uYmluZCh0aGlzLCBjb21wbGV0ZUNhbGxiYWNrKSwgMTAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHJlbGV2YW50IGBZVFBsYXllcmAgYW5kIGBZVC5QbGF5ZXJgIHN0YXRlcy5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucGxheWVySW5zdGFuY2VfICYmICgnc3RvcFZpZGVvJyBpbiB0aGlzLnBsYXllckluc3RhbmNlXykpIHtcbiAgICAgIHRoaXMucGxheWVySW5zdGFuY2VfLnN0b3BWaWRlbygpO1xuICAgICAgdGhpcy5wbGF5ZXJJbnN0YW5jZV8gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBvbGxUaW1lcklkXykge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnBvbGxUaW1lcklkXyk7XG4gICAgICB0aGlzLnBvbGxUaW1lcklkXyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKFlUUGxheWVyc1t0aGlzLnZpZGVvSWRfXSkge1xuICAgICAgZGVsZXRlIFlUUGxheWVyc1t0aGlzLnZpZGVvSWRfXTtcbiAgICAgIHRoaXMudmlkZW9JZF8gPSAnJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgcGFzc2VzIGluIHRoZSBwbGF5ZXIgc2V0dGluZ3MgdG8gcmVuZGVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBvbGxUaW1lcklkXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7P3dpbmRvdy5ZVC5QbGF5ZXJ9ICovXG4gICAgdGhpcy5wbGF5ZXJJbnN0YW5jZV87XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnZpZGVvSWRfID0gJyc7XG5cbiAgICBjb25zdCB2aWRlb0lkID0gdGhpcy5yb290Xy5nZXRBdHRyaWJ1dGUoQXR0cnMuVklERU9fSUQpO1xuICAgIGNvbnN0IHBhcnNlZEpTT04gPSBKU09OLnBhcnNlKHRoaXMucm9vdF8uZ2V0QXR0cmlidXRlKEF0dHJzLlNFVFRJTkdTKSk7XG4gICAgLy8gVGhlIGZvbGxvd2luZyBPYmplY3QgY29uc3RydWN0b3IgY29lcmNlcyB0aGUgcmVzdWx0IG9mIEpTT04ucGFyc2UgdG8gYW5cbiAgICAvLyBvYmplY3QsIHNhdGlzZnlpbmcgYSBHQ0MgdHlwZSB3YXJuaW5nLlxuICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9XG4gICAgICAgIG5ldyBPYmplY3QocGFyc2VkSlNPTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LW9iamVjdFxuICAgIGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgdXNlclNldHRpbmdzKTtcblxuICAgIHRoaXMucmVuZGVyUGxheWVyXyh2aWRlb0lkLCBzZXR0aW5ncyk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIFlUIHBsYXllciB3aXRoIHRoZSBnaXZlbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSB2aWRlb0lkXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZ3xudW1iZXI+fSBzZXR0aW5nc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVuZGVyUGxheWVyXyh2aWRlb0lkLCBzZXR0aW5ncykge1xuICAgIHZpZGVvSWQgPSBzZXR0aW5ncy5saXN0ID8gdW5kZWZpbmVkIDogdmlkZW9JZDtcblxuICAgIGNvbnN0IHBsYXllciA9IG5ldyB3aW5kb3cuWVQuUGxheWVyKHRoaXMucm9vdF8sIHtcbiAgICAgIGhlaWdodDogJzEwMCcsXG4gICAgICB3aWR0aDogJzEwMCcsXG4gICAgICB2aWRlb0lkLFxuICAgICAgLy8gTGVhcm4gbW9yZSBhYm91dCBldmVudHMgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3lvdXR1YmUvaWZyYW1lX2FwaV9yZWZlcmVuY2UjRXZlbnRzXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgb25SZWFkeTogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZm91bmRhdGlvbl8uc3RvcmVQbGF5ZXIodmlkZW9JZCwgc2V0dGluZ3MsIHBsYXllcik7XG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uXy5yZWdpc3RlclBsYXllckV2ZW50cygpO1xuICAgICAgICB9LFxuICAgICAgICBvblN0YXRlQ2hhbmdlOiAoZSkgPT4ge1xuICAgICAgICAgIHRoaXMuZm91bmRhdGlvbl8ucGF1c2VBbGxPdGhlclZpZGVvcyhlKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAvLyBTZWUgYWxsIHN1cHBvcnRlZCBwbGF5ZXIgdmFycyBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20veW91dHViZS9wbGF5ZXJfcGFyYW1ldGVycz9wbGF5ZXJWZXJzaW9uPUhUTUw1I1BhcmFtZXRlcnNcbiAgICAgIHBsYXllclZhcnM6IHNldHRpbmdzLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wbGF5ZXJJbnN0YW5jZV8gPSBwbGF5ZXI7XG4gICAgdGhpcy52aWRlb0lkXyA9IHZpZGVvSWQ7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvdmlkZW8taWZyYW1lL3l0LXBsYXllci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtBdHRycywgSnNvbktleXMsIFlUUGxheWVycywgU2VsZWN0b3JzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlJztcblxuXG5leHBvcnQgY2xhc3MgTEJQbGF5ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgWVRQbGF5ZXJzKCkge1xuICAgIHJldHVybiBZVFBsYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhZGFwdGVyIHdpdGggYWxsIGZ1bmN0aW9ucyBkZWZpbmVkLlxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0QXR0cjogKC8qIGVsOiAhRWxlbWVudCwgYXR0cjogc3RyaW5nICovKSA9PiAvKiBzdHJpbmcgKi8ge30sXG4gICAgICBzdG9yZVBsYXllcjogKC8qIGxpc3Q6ICFBcnJheSwgcGxheWVyOiAhWVQuUGxheWVyLCBpZDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHBsYXk6ICgvKiBwbGF5ZXI6ICFZVC5QbGF5ZXIgKi8pID0+IHt9LFxuICAgICAgcGF1c2U6ICgvKiBwbGF5ZXI6ICFZVC5QbGF5ZXIgKi8pID0+IHt9LFxuICAgICAgc3RvcDogKC8qIHBsYXllcjogIVlULlBsYXllciAqLykgPT4ge30sXG4gICAgICBuZXh0OiAoLyogcGxheWVyOiAhWVQuUGxheWVyICovKSA9PiB7fSxcbiAgICAgIHByZXZpb3VzOiAoLyogcGxheWVyOiAhWVQuUGxheWVyICovKSA9PiB7fSxcbiAgICAgIGN1ZVZpZGVvOiAoLyogcGxheWVyOiAhWVQuUGxheWVyLCBjdWVJZDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGN1ZVBsYXlsaXN0OiAoLyogcGxheWVyOiAhWVQuUGxheWVyLCBjdWVJZDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGRlbGVnYXRlRXZlbnRIYW5kbGVyOiAoLyogc2VsZWN0b3I6IHN0cmluZywgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgICAgICAgaGFuZGxlcjogIUZ1bmN0aW9uKD8pICovKSA9PiB7fSxcbiAgICAgIHVuZGVsZWdhdGVFdmVudEhhbmRsZXI6ICgvKiBzZWxlY3Rvcjogc3RyaW5nLCBldmVudFR5cGU6IHN0cmluZyxcbiAgICAgICAgICBoYW5kbGVyOiAhRnVuY3Rpb24oPykgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXNlcyB0aGUgWVQgSWZyYW1lIEFQSSB0byBhdHRhY2ggYSBZVCBwbGF5ZXIgb250byBlYWNoIGRlc2lnbmF0ZWQgZWxlbWVudFxuICAgKiBpbiB0aGUgRE9NLiBFdmVudCBkZWxlZ2F0aW9uIGlzIGFkZGVkIHRvIGFsbG93IGN1c3RvbSBjb250cm9scyBmb3IgZWFjaFxuICAgKiBwbGF5ZXIgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTEJQbGF5ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgYWRkaW5nIHRoZSBzYW1lIGV2ZW50IGxpc3RlbmVycyBtdWx0aXBsZSB0aW1lcy5cbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50c1JlZ2lzdGVyZWRfID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBZVCBwbGF5ZXIgaW50byBhbiBvYmplY3QgaW4gb3JkZXIgdG8gZ2V0IGl0IGxhdGVyLiBUaGUga2V5IGlzXG4gICAqIHRoZSBpbml0aWFsIHZpZGVvIG9yIHBsYXlsaXN0IElEIGFuZCB0aGUgdmFsdWUgaXMgdGhlIFlULlBsYXllciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSB2aWRlb0lkXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZ3xudW1iZXI+fSBzZXR0aW5nc1xuICAgKiBAcGFyYW0geyFZVC5QbGF5ZXJ9IHBsYXllclxuICAgKi9cbiAgc3RvcmVQbGF5ZXIodmlkZW9JZCwgc2V0dGluZ3MsIHBsYXllcikge1xuICAgIGNvbnN0IGlkID0gc2V0dGluZ3MubGlzdCB8fCB2aWRlb0lkO1xuICAgIHRoaXMuYWRhcHRlcl8uc3RvcmVQbGF5ZXIoWVRQbGF5ZXJzLCBwbGF5ZXIsIGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZXMgYWxsIG90aGVyIHBsYXllcnMgd2hlbiBvbmUgaXMgcGxheWVkLlxuICAgKiBAcGFyYW0ge3tcbiAgICogICBkYXRhOiAhWVQuUGxheWVyU3RhdGUsXG4gICAqICAgdGFyZ2V0OiAhWVQuUGxheWVyLFxuICAgKiB9fSBlXG4gICAqL1xuICBwYXVzZUFsbE90aGVyVmlkZW9zKGUpIHtcbiAgICBpZiAoZS5kYXRhID09IHdpbmRvdy5ZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HKSB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gWVRQbGF5ZXJzKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCAhPSBZVFBsYXllcnNba2V5XSkge1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8ucGF1c2UoWVRQbGF5ZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGZyb20gdGhlIHRhcmdldCdzIGV2ZW50IGF0dHJpYnV0ZSBhbmQgcGFyc2VzIGl0IHRvIGRlY2lkZVxuICAgKiB3aGljaCBZVCBBUEkgZXZlbnQgdG8gdHJpZ2dlci5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gdGFyZ2V0IFRoZSBlbGVtZW50IGJlaW5nIGludGVyYWN0ZWQgd2l0aCB0byBtYW5pcHVsYXRlXG4gICAqICAgICB0aGUgWVQgcGxheWVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcGxheWVyRXZlbnRIYW5kbGVyXyh0YXJnZXQpIHtcbiAgICBjb25zdCBwYXJzZWRFdmVudCA9IEpTT04ucGFyc2UodGhpcy5hZGFwdGVyXy5nZXRBdHRyKHRhcmdldCwgQXR0cnMuRVZFTlQpKTtcbiAgICBjb25zdCBwbGF5ZXJFdmVudCA9IHBhcnNlZEV2ZW50W0pzb25LZXlzLkVWRU5UX1RZUEVdO1xuICAgIGNvbnN0IHBsYXllcklkID0gcGFyc2VkRXZlbnRbSnNvbktleXMuUExBWUVSX0lEXTtcbiAgICBjb25zdCBjdWVJZCA9IHBhcnNlZEV2ZW50W0pzb25LZXlzLkNVRV9JRF07XG5cbiAgICBpZiAoY3VlSWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl9bcGxheWVyRXZlbnRdKFlUUGxheWVyc1twbGF5ZXJJZF0sIGN1ZUlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyX1twbGF5ZXJFdmVudF0oWVRQbGF5ZXJzW3BsYXllcklkXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGVnYXRlcyBhbiBldmVudCBmb3IgZWxlbWVudHMgd2l0aCBhIHNwZWNpZmljIHNlbGVjdG9yIHRoYXQgd2lsbCBhbGxvd1xuICAgKiBkZXZlbG9wZXJzIHRvIGJ1aWxkIGN1c3RvbSBjb250cm9sIGZvciB0aGUgWVQgcGxheWVycy5cbiAgICovXG4gIHJlZ2lzdGVyUGxheWVyRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLmV2ZW50c1JlZ2lzdGVyZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudHNSZWdpc3RlcmVkXyA9IHRydWU7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlbGVnYXRlRXZlbnRIYW5kbGVyKFNlbGVjdG9ycy5FVkVOVCwgJ2NsaWNrJyxcbiAgICAgICAgdGhpcy5wbGF5ZXJFdmVudEhhbmRsZXJfLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnRzIGZyb20gZWxlbWVudHMuXG4gICAqL1xuICB1bnJlZ2lzdGVyUGxheWVyRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5ldmVudHNSZWdpc3RlcmVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRzUmVnaXN0ZXJlZF8gPSBmYWxzZTtcblxuICAgIHRoaXMuYWRhcHRlcl8udW5kZWxlZ2F0ZUV2ZW50SGFuZGxlcihTZWxlY3RvcnMuRVZFTlQsICdjbGljaycsXG4gICAgICAgIHRoaXMucGxheWVyRXZlbnRIYW5kbGVyXy5iaW5kKHRoaXMpKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy92aWRlby1pZnJhbWUveXQtcGxheWVyL2ZvdW5kYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7fTtcblxuLyoqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59ICovXG5leHBvcnQgY29uc3QgcmUgPSB7XG4gIFNJTkdMRV9RVU9URTogJ1xcJycsXG4gIFNJTkdMRV9RVU9URV9XSVRIX0FMUEhBX05VTTogJ1thLXpBLVowLTldKFxcJylbYS16QS1aMC05XScsXG4gIFNJTkdMRV9RVU9URV9TTEFTSDogJ1xcXFxcXFxcXFwnJyxcbiAgU0lOR0xFX1FVT1RFX0VTQ0FQRUQ6ICcmIzM5OycsXG4gIFNJTkdMRV9RVU9URV9FTlRJVFk6ICcmYXBvczsnLFxuICBET1VCTEVfUVVPVEVfRVNDQVBFRDogJyYjMzQ7JyxcbiAgRE9VQkxFX1FVT1RFX0VOVElUWTogJyZxdW90OycsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBERUZBVUxUX09QVElPTlNfS0VZOiAnZGF0YS1sYi1vcHRpb25zJyxcbiAgREVGQVVMVF9PUFRJT05TX0tFWV9MQjogJ2xiLW9wdGlvbnMnLFxuICBFVkVOVF9LRVlfUFJFRklYOiAndGFyZ2V0LicsXG4gIENMSUNLX0FDVElPTjogJ2NsaWNrJyxcbiAgSU1QUkVTU0lPTl9BQ1RJT046ICdpbXByZXNzaW9uJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7fTtcblxuLyoqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsIEFycmF5PCo+Pn0gKi9cbmV4cG9ydCBjb25zdCBsaXN0cyA9IHtcbiAgVFJBTlNGT1JNUzogW1xuICAgICd0cmFuc2xhdGUnLFxuICAgICd0cmFuc2xhdGVYJyxcbiAgICAndHJhbnNsYXRlWScsXG4gICAgJ3RyYW5zbGF0ZVonLFxuICAgICd0cmFuc2xhdGUzZCcsXG4gICAgJ3NjYWxlJyxcbiAgICAnc2NhbGVYJyxcbiAgICAnc2NhbGVZJyxcbiAgICAnc2NhbGVaJyxcbiAgICAnc2NhbGUzZCcsXG4gICAgJ3NrZXcnLFxuICAgICdza2V3WCcsXG4gICAgJ3NrZXdZJyxcbiAgICAncm90YXRlJyxcbiAgICAncm90YXRlWCcsXG4gICAgJ3JvdGF0ZVknLFxuICAgICdyb3RhdGVaJyxcbiAgICAncm90YXRlM2QnLFxuICAgIF0sXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9iYXNlL2NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZSc7XG5cbmV4cG9ydCBjbGFzcyBMQkdsdWVDYXJvdXNlbEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0T3B0aW9uczogKCkgPT4gLyogT2JqZWN0ICovICh7fSksXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKExCR2x1ZUNhcm91c2VsRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2dsdWUtY2Fyb3VzZWwvZm91bmRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHt9O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBPUFRJT05TX0tFWTogJ2dsdWUtY2Fyb3VzZWwnLFxuICBNT0RFTF9QUkVGSVg6ICdsYi1jYXJvdXNlbC1tb2RlbC0nLFxuICAvLyBTZWxlY3RvcnNcbiAgR0xVRV9DQVJPVVNFTF9TRUxFQ1RPUjogJy5nbHVlLWNhcm91c2VsJyxcbiAgR0xVRV9QQUdJTkFUSU9OX05FWFRfU0VMRUNUT1I6ICcuZ2x1ZS1wYWdpbmF0aW9uLW5leHQnLFxuICBHTFVFX1BBR0lOQVRJT05fUEFHRV9MSVNUX1NFTEVDVE9SOiAnLmdsdWUtcGFnaW5hdGlvbi1wYWdlLWxpc3QnLFxuICBHTFVFX1BBR0lOQVRJT05fUFJFVklPVVNfU0VMRUNUT1I6ICcuZ2x1ZS1wYWdpbmF0aW9uLXByZXZpb3VzJyxcbiAgLy8gQXR0cmlidXRlc1xuICBHTFVFX1BBR0lOQVRJT05fREFUQTogJ2RhdGEtZ2x1ZS1wYWdpbmF0aW9uJyxcbiAgQ1VSUkVOVF9QQUdFX0VWRU5UOiAnZ2x1ZXBhZ2luYXRpb25jdXJyZW50cGFnZScsXG59O1xuXG4vKiogQGVudW0ge0FycmF5PCo+fSAqL1xuZXhwb3J0IGNvbnN0IGxpc3RzID0ge1xuICBJR05PUkVfT1BUSU9OUzogWydzdGFydFBhZ2UnLCAnY3ljbGljYWwnXSxcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2dsdWUtY2Fyb3VzZWwvY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtDYXJvdXNlbEFkYXB0ZXJ9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge0Nhcm91c2VsRm91bmRhdGlvbn0gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCB7Q2Fyb3VzZWxJbWFnZUFkYXB0ZXJ9IGZyb20gJy4uL2ltYWdlL2FkYXB0ZXInO1xuaW1wb3J0IHtDYXJvdXNlbEltYWdlRm91bmRhdGlvbn0gZnJvbSAnLi4vaW1hZ2UvZm91bmRhdGlvbic7XG5pbXBvcnQge0VsZW1lbnRzVG9nZ2xlcn0gZnJvbSAnLi9lbGVtZW50c3RvZ2dsZXInO1xuaW1wb3J0IHtNRENDb21wb25lbnR9IGZyb20gJy4uLy4uL21kYy9jb21wb25lbnQnO1xuaW1wb3J0IHtNb2RlbEZhY3Rvcnl9IGZyb20gJy4uLy4uL3BhZ2luYXRpb24vbW9kZWxmYWN0b3J5JztcbmltcG9ydCB7T3B0aW9uc30gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7UmVzcG9uc2l2ZU1vbml0b3J9IGZyb20gJy4uLy4uLy4uL21xL3Jlc3BvbnNpdmVtb25pdG9yJztcblxuLyoqXG4gKiBAZmluYWwgQGV4dGVuZHMge01EQ0NvbXBvbmVudDwhQ2Fyb3VzZWxGb3VuZGF0aW9uPn1cbiAqL1xuY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IENhcm91c2VsKHJvb3QsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihyb290LCBmb3VuZGF0aW9uID0gdW5kZWZpbmVkLCAuLi5hcmdzKSB7XG4gICAgc3VwZXIocm9vdCwgZm91bmRhdGlvbiwgLi4uYXJncyk7XG5cbiAgICAvKiogQHByaXZhdGUge09wdGlvbnN8dW5kZWZpbmVkfSAqL1xuICAgIHRoaXMub3B0aW9uc187XG5cbiAgICAvKiogQHByaXZhdGUge1Jlc3BvbnNpdmVNb25pdG9yfHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnJtXztcblxuICAgIHRoaXMubW9uaXRvclVua25vd25TaXplSW1hZ2VzXygpO1xuXG4gICAgY29uc3QgYnJlYWtwb2ludHMgPSB0aGlzLnJvb3RfLmRhdGFzZXRbJ2dsdWVDYXJvdXNlbEJyZWFrcG9pbnRzJ107XG4gICAgaWYgKGJyZWFrcG9pbnRzKSB7XG4gICAgICB0aGlzLnJtXyA9IG5ldyBSZXNwb25zaXZlTW9uaXRvcih7XG4gICAgICAgIGJyZWFrcG9pbnQ6IGJyZWFrcG9pbnRzLnNwbGl0KCcsJyksXG4gICAgICAgIGVudGVyOiAoKSA9PiB0aGlzLmZvdW5kYXRpb25fLnN0YXJ0KCksXG4gICAgICAgIGxlYXZlOiAoKSA9PiB0aGlzLmZvdW5kYXRpb25fLmRlc3Ryb3koKSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb25fLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zICovXG4gIGluaXRpYWxpemUob3B0X29wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnNfID0gb3B0X29wdGlvbnM7XG4gIH1cblxuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICBjb25zdCBwYWdpbmF0aW9uTW9kZWwgPSBNb2RlbEZhY3RvcnkuZ2V0KFxuICAgICAgICB0aGlzLnJvb3RfLmRhdGFzZXRbJ2dsdWVQYWdpbmF0aW9uJ10pO1xuICAgIGNvbnN0IHRvZ2dsZXIgPSBuZXcgRWxlbWVudHNUb2dnbGVyKHRoaXMucm9vdF8pO1xuICAgIGNvbnN0IGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgY29uc3QgaGFtbWVyID0gbmV3IEhhbW1lci5NYW5hZ2VyKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyAodGhpcy5yb290XykpO1xuICAgIGhhbW1lci5hZGQobmV3IEhhbW1lci5QYW4oe2RpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMfSkpO1xuXG4gICAgY29uc3QgLyoqICFDYXJvdXNlbEFkYXB0ZXIgKi8gYWRhcHRlciA9IHtcbiAgICAgIGNvdW50SXRlbXM6ICgpID0+IHRoaXMucm9vdF8uY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgZ2V0UGFnaW5hdGlvbk1vZGVsOiAoKSA9PiBwYWdpbmF0aW9uTW9kZWwsXG4gICAgICB0b2dnbGVFbGVtZW50czogKGRpc3BsYXlNYXAsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHRvZ2dsZXIudG9nZ2xlRWxlbWVudHMoZGlzcGxheU1hcCk7XG4gICAgICAgIC8vIHtAY29kZSBFbGVtZW50c1RvZ2dsZXJ9IHJlbmRlcnMgRE9NIHVwZGF0ZXMgaW1tZWRpYXRlbHkuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9LFxuICAgICAgcmVzZXRFbGVtZW50czogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHRvZ2dsZXIucmVzZXRFbGVtZW50cygpO1xuICAgICAgICAvLyB7QGNvZGUgRWxlbWVudHNUb2dnbGVyfSByZW5kZXJzIERPTSB1cGRhdGVzIGltbWVkaWF0ZWx5LlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSxcbiAgICAgIGlzUnRsOiAoKSA9PiBkb2NFbC5kaXIgPT0gJ3J0bCcsXG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBzZXRTdHlsZTogKHByb3AsIHZhbHVlKSA9PiB0aGlzLnJvb3RfLnN0eWxlW3Byb3BdID0gdmFsdWUsXG4gICAgICBmb2N1c1RpbGU6IChlbCkgPT4gZWwuZm9jdXMoKSxcbiAgICAgIGdldFBhcmVudEVsZW1lbnRXaWR0aDogKCkgPT5cbiAgICAgICAgICB0aGlzLnJvb3RfLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsXG4gICAgICBnZXRDaGlsZEVsZW1lbnRzOiAoKSA9PiBbLi4udGhpcy5yb290Xy5jaGlsZHJlbl0sXG4gICAgICBnZXRUaWxlRGltZW5zaW9uczogKGVsKSA9PiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHNldFRpbGVTdHlsZTogKGVsLCBwcm9wLCB2YWx1ZSkgPT4gZWwuc3R5bGVbcHJvcF0gPSB2YWx1ZSxcbiAgICAgIHNldFRpbGVBdHRyOiAoZWwsIGF0dHIsIHZhbHVlKSA9PiBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxuICAgICAgcm1UaWxlQXR0cjogKGVsLCBhdHRyKSA9PiBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ciksXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT5cbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICByZWdpc3RlclN3aXBlU3RhcnQ6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbW1lci5vbigncGFuc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBoYW5kbGVyKHt4OiBldmVudC5kZWx0YVgsIHk6IGV2ZW50LmRlbHRhWX0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyU3dpcGVTdGFydDogKGhhbmRsZXIpID0+IGhhbW1lci5vZmYoJ3BhbnN0YXJ0JywgaGFuZGxlciksXG4gICAgICByZWdpc3RlclN3aXBlTW92ZTogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFtbWVyLm9uKCdwYW5tb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaGFuZGxlcih7eDogZXZlbnQuZGVsdGFYLCB5OiBldmVudC5kZWx0YVl9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclN3aXBlTW92ZTogKGhhbmRsZXIpID0+IGhhbW1lci5vZmYoJ3Bhbm1vdmUnLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyU3dpcGVFbmQ6IChoYW5kbGVyKSA9PiBoYW1tZXIub24oJ3BhbmVuZCcsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclN3aXBlRW5kOiAoaGFuZGxlcikgPT4gaGFtbWVyLm9mZigncGFuZW5kJywgaGFuZGxlciksXG4gICAgICByZWdpc3RlclN3aXBlQ2FuY2VsOiAoaGFuZGxlcikgPT4gaGFtbWVyLm9uKCdwYW5jYW5jZWwnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJTd2lwZUNhbmNlbDogKGhhbmRsZXIpID0+IGhhbW1lci5vZmYoJ3BhbmNhbmNlbCcsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJNb3VzZUxlYXZlOiAoaGFuZGxlcikgPT5cbiAgICAgICAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJNb3VzZUxlYXZlOiAoaGFuZGxlcikgPT5cbiAgICAgICAgICB0aGlzLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoYW5kbGVyKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBDYXJvdXNlbEZvdW5kYXRpb24oYWRhcHRlciwgdGhpcy5vcHRpb25zXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnJtXyAmJiB0aGlzLnJtXy5kZXN0cm95KCk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8ucmVmcmVzaCgpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFBcnJheTxFbGVtZW50Pn0gKi9cbiAgZ2V0QWRkZWRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uXy5nZXRBZGRlZEVsZW1lbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1vbml0b3JVbmtub3duU2l6ZUltYWdlc18oKSB7XG4gICAgY29uc3Qge1VOS05PV05fU0laRV9JTUFHRV9FTEVNRU5UU30gPSBDYXJvdXNlbEltYWdlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIGNvbnN0IGltYWdlRWxlbWVudHMgPVxuICAgICAgICB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3JBbGwoVU5LTk9XTl9TSVpFX0lNQUdFX0VMRU1FTlRTKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpbWFnZUVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBpbWdFbCA9IC8qKiBAdHlwZSB7IUhUTUxJbWFnZUVsZW1lbnR9ICovIChpbWFnZUVsZW1lbnRzW2ldKTtcbiAgICAgIHRoaXMuY3JlYXRlQ2Fyb3VzZWxJbWFnZUNvbXBvbmVudF8oaW1nRWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wb25lbnRzIGFyZSBjcmVhdGVkIGhlcmUgaW5zdGVhZCBvZiBpbiBkaXN0aW5jdCBjb21wb25lbnQgY2xhc3NlcyxcbiAgICogYmVjYXVzZSBjaGlsZCBpbWFnZXMgYXJlIHVuYWJsZSB0byBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjYXJvdXNlbFxuICAgKiBjb21wb25lbnQgaW5zdGFuY2UsIG5vciBkaXNwYXRjaCBidWJibGluZyBldmVudHMgdG8gaXQgc2luY2UgdGhleSBjYW4gYmVcbiAgICogcmVtb3ZlZCBmcm9tIHRoZSBET00gd2hlbiB0aGVpciBsb2FkIGV2ZW50IGlzIGZpcmVkLlxuICAgKiBAcGFyYW0geyFIVE1MSW1hZ2VFbGVtZW50fSBlbCBJbWFnZSBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVDYXJvdXNlbEltYWdlQ29tcG9uZW50XyhlbCkge1xuICAgIGNvbnN0IC8qKiBAdHlwZSB7IUNhcm91c2VsSW1hZ2VBZGFwdGVyfSAqLyBhZGFwdGVyID0ge1xuICAgICAgZ2V0V2lkdGg6ICgpID0+IGVsLndpZHRoLFxuICAgICAgZ2V0SGVpZ2h0OiAoKSA9PiBlbC5oZWlnaHQsXG4gICAgICBpc0ZldGNoaW5nQ29tcGxldGU6ICgpID0+IGVsLmNvbXBsZXRlLFxuICAgICAgcmVnaXN0ZXJMb2FkSGFuZGxlcjogKGhhbmRsZXIpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJMb2FkSGFuZGxlcjogKGhhbmRsZXIpID0+XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGhhbmRsZXIpLFxuICAgICAgbm90aWZ5TG9hZDogKCkgPT4gdGhpcy5yZWZyZXNoKCksXG4gICAgfTtcblxuICAgIGNvbnN0IGNhcm91c2VsSW1hZ2VGb3VuZGF0aW9uID0gbmV3IENhcm91c2VsSW1hZ2VGb3VuZGF0aW9uKGFkYXB0ZXIpO1xuICAgIGNhcm91c2VsSW1hZ2VGb3VuZGF0aW9uLmluaXQoKTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7Q2Fyb3VzZWx9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvY29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuXG4vKiogQHJlY29yZCAqL1xuZnVuY3Rpb24gT3B0aW9ucygpIHt9XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuT3B0aW9ucy5wcm90b3R5cGUuY3VycmVudFBhZ2U7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuT3B0aW9ucy5wcm90b3R5cGUudG90YWxQYWdlcztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5PcHRpb25zLnByb3RvdHlwZS50b3RhbEl0ZW1zO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbk9wdGlvbnMucHJvdG90eXBlLml0ZW1zUGVyUGFnZTtcblxuLyoqIEB0eXBlIHtib29sZWFufSAqL1xuT3B0aW9ucy5wcm90b3R5cGUuY3ljbGljYWw7XG5cbi8qKiBAdHlwZSB7IUFycmF5PHN0cmluZz59ICovXG5PcHRpb25zLnByb3RvdHlwZS50aXRsZXM7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuT3B0aW9ucy5wcm90b3R5cGUubWF4TGVuZ3RoO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbk9wdGlvbnMucHJvdG90eXBlLnRpbWVyO1xuXG4vKiogQHR5cGUge3N0cmluZ30gKi9cbk9wdGlvbnMucHJvdG90eXBlLmFjdGl2ZUVsO1xuXG5leHBvcnQge09wdGlvbnN9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtPcHRpb25zfSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHtDYXJvdXNlbEFkYXB0ZXJ9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJy4uLy4uL21kYy9mb3VuZGF0aW9uJztcbmltcG9ydCB7TmF2aWdhdG9yfSBmcm9tICcuL25hdmlnYXRvcic7XG5pbXBvcnQge1BhZ2luYXRpb25Nb2RlbH0gZnJvbSAnLi4vLi4vcGFnaW5hdGlvbi9tb2RlbCc7XG5pbXBvcnQge3N0cmluZ3MgYXMgcGFnaW5hdGlvblN0cmluZ3N9IGZyb20gJy4uLy4uL3BhZ2luYXRpb24vY29uc3RhbnRzJztcbmltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vcmVuZGVyZXInO1xuaW1wb3J0IHtTd2lwZX0gZnJvbSAnLi9zd2lwZSc7XG5pbXBvcnQge1RpbGVNYXB9IGZyb20gJy4vdGlsZW1hcC90aWxlbWFwJztcbmltcG9ydCB7Y3NzQ2xhc3NlcywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtlYXNlT3V0UXVhcnR9IGZyb20gJy4uLy4uLy4uL2Z4L2Vhc2luZyc7XG5pbXBvcnQge2RlYm91bmNlfSBmcm9tICcuLi8uLi8uLi9kZWJvdW5jZS9kZWJvdW5jZSc7XG5cbi8qKlxuICogQGZpbmFsIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFnbHVlLnVpLmNhcm91c2VsLkNhcm91c2VsQWRhcHRlcj59XG4gKi9cbmNsYXNzIENhcm91c2VsRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshT3B0aW9uc30gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqIEBleHBvcnQgKi9cbiAgICAgIGVsYXN0aWNFZGdlOiB0cnVlLFxuICAgICAgLyoqIEBleHBvcnQgKi9cbiAgICAgIGVkZ2VGcmljdGlvbjogNCxcbiAgICAgIC8qKiBAZXhwb3J0ICovXG4gICAgICBlYXNpbmc6IGVhc2VPdXRRdWFydCxcbiAgICAgIC8qKiBAZXhwb3J0ICovXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IC43NSxcbiAgICAgIC8qKiBAZXhwb3J0ICovXG4gICAgICBleHBhbmQ6IDAsXG4gICAgICAvKiogQGV4cG9ydCAqL1xuICAgICAganVtcDogZmFsc2UsXG4gICAgICAvKiogQGV4cG9ydCAqL1xuICAgICAgY2VudGVyOiB0cnVlLFxuICAgICAgLyoqIEBleHBvcnQgKi9cbiAgICAgIGdyb3VwOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUNhcm91c2VsQWRhcHRlcn0gYWRhcHRlclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGFkYXB0ZXIpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmVsZW1lbnRfO1xuXG4gICAgLyoqIEBwcml2YXRlIHshUGFnaW5hdGlvbk1vZGVsfSAqL1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7IVRpbGVNYXB9ICovXG4gICAgdGhpcy50aWxlTWFwXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7IVJlbmRlcmVyfSAqL1xuICAgIHRoaXMucmVuZGVyZXJfO1xuXG4gICAgLyoqIEBwcml2YXRlIHshTmF2aWdhdG9yfSAqL1xuICAgIHRoaXMubmF2aWdhdG9yXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7IVN3aXBlfSAqL1xuICAgIHRoaXMuc3dpcGVfO1xuXG4gICAgLyoqIEBwcml2YXRlIHshT3B0aW9uc30gKi9cbiAgICB0aGlzLm9wdGlvbnNfID0gLyoqIEB0eXBlIHshT3B0aW9uc30gKi8gKFxuICAgICAgICBPYmplY3QuYXNzaWduKENhcm91c2VsRm91bmRhdGlvbi5kZWZhdWx0cywgb3B0aW9ucykpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5yZXNpemVEYmNIYW5kbGVyXyA9IGRlYm91bmNlKFxuICAgICAgICAoKSA9PiB0aGlzLmhhbmRsZVJlc2l6ZV8oKSwgQ2Fyb3VzZWxGb3VuZGF0aW9uLm51bWJlcnMuUkVTSVpFX0RFTEFZKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMuY3VycmVudFBhZ2VIYW5kbGVyXyA9IHRoaXMudXBkYXRlXy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5wcmV2aW91c1RpbGVIYW5kbGVyXyA9IHRoaXMuc2VsZWN0UHJldmlvdXNfLmJpbmQodGhpcyk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLm5leHRUaWxlSGFuZGxlcl8gPSB0aGlzLnNlbGVjdE5leHRfLmJpbmQodGhpcyk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc0VuYWJsZWRfID0gZmFsc2U7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXyA9IHRoaXMuYWRhcHRlci5nZXRQYWdpbmF0aW9uTW9kZWwoKTtcbiAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8udG90YWxQYWdlcyA9IHRoaXMuYWRhcHRlci5jb3VudEl0ZW1zKCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLnRvdGFsSXRlbXMgPSB0aGlzLnBhZ2luYXRpb25Nb2RlbF8udG90YWxQYWdlcztcbiAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8uc2V0Rm9jdXNNYWluRWxlbWVudEhhbmRsZXIoKCkgPT4ge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLnJlbmRlcmVyXy5nZXRTbmFwcGVkVGlsZUVsZW1lbnQoKTtcbiAgICAgIGVsICYmIHRoaXMuYWRhcHRlci5mb2N1c1RpbGUoZWwpO1xuICAgIH0pO1xuXG4gICAgdGhpcy50aWxlTWFwXyA9IG5ldyBUaWxlTWFwKFxuICAgICAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8uY3ljbGljYWwsXG4gICAgICAgIHRoaXMub3B0aW9uc18uZWxhc3RpY0VkZ2UsXG4gICAgICAgIHRoaXMub3B0aW9uc18uY2VudGVyKTtcblxuICAgIHRoaXMudGlsZU1hcF8uZnJhbWVFeHBhbmQgPSB0aGlzLm9wdGlvbnNfLmV4cGFuZDtcblxuICAgIHRoaXMucmVuZGVyZXJfID0gbmV3IFJlbmRlcmVyKHRoaXMudGlsZU1hcF8sIHRoaXMuYWRhcHRlcixcbiAgICAgICAgdGhpcy5vcHRpb25zXy5ncm91cCk7XG4gICAgdGhpcy5yZW5kZXJlcl8ucmVzZXRFbGVtZW50cygpO1xuXG4gICAgdGhpcy5uYXZpZ2F0b3JfID0gbmV3IE5hdmlnYXRvcih0aGlzLnRpbGVNYXBfLCB0aGlzLnJlbmRlcmVyXyxcbiAgICAgICAgdGhpcy5vcHRpb25zXyk7XG5cbiAgICB0aGlzLnN3aXBlXyA9IG5ldyBTd2lwZSh0aGlzLnRpbGVNYXBfLCB0aGlzLm5hdmlnYXRvcl8sIHRoaXMuYWRhcHRlcixcbiAgICAgICAgdGhpcy51cGRhdGVQYWdpbmF0aW9uXy5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbnNfKTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLmlzRW5hYmxlZF8pIHJldHVybjtcbiAgICB0aGlzLmlzRW5hYmxlZF8gPSB0cnVlO1xuXG4gICAgdGhpcy5zd2lwZV8uaW5pdCgpO1xuICAgIHRoaXMucmVuZGVyZXJfLmluaXQoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyLmFkZENsYXNzKENhcm91c2VsRm91bmRhdGlvbi5jc3NDbGFzc2VzLlJFQURZKTtcbiAgICAgIHRoaXMubmF2aWdhdG9yXy5zZWxlY3RUaWxlKHRoaXMucGFnaW5hdGlvbk1vZGVsXy5jdXJyZW50UGFnZSAtIDEpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZURiY0hhbmRsZXJfKTtcblxuICAgIGNvbnN0IHtDVVJSRU5UX1BBR0VfRVZFTlQsIFBSRVZJT1VTX0VWRU5ULCBORVhUX0VWRU5UfSA9IHBhZ2luYXRpb25TdHJpbmdzO1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXy5saXN0ZW4oQ1VSUkVOVF9QQUdFX0VWRU5ULCB0aGlzLmN1cnJlbnRQYWdlSGFuZGxlcl8pO1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXy5saXN0ZW4oUFJFVklPVVNfRVZFTlQsIHRoaXMucHJldmlvdXNUaWxlSGFuZGxlcl8pO1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXy5saXN0ZW4oTkVYVF9FVkVOVCwgdGhpcy5uZXh0VGlsZUhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmlzRW5hYmxlZF8pIHJldHVybjtcbiAgICB0aGlzLmlzRW5hYmxlZF8gPSBmYWxzZTtcblxuICAgIHRoaXMubmF2aWdhdG9yXyAmJiB0aGlzLm5hdmlnYXRvcl8uc3RvcEFuaW1hdGlvbigpO1xuICAgIHRoaXMucmVuZGVyZXJfICYmIHRoaXMucmVuZGVyZXJfLnJlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLnN3aXBlXyAmJiB0aGlzLnN3aXBlXy5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoQ2Fyb3VzZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXMuUkVBRFkpO1xuICAgIHRoaXMuYWRhcHRlci5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZURiY0hhbmRsZXJfKTtcblxuICAgIGNvbnN0IHtDVVJSRU5UX1BBR0VfRVZFTlQsIFBSRVZJT1VTX0VWRU5ULCBORVhUX0VWRU5UfSA9IHBhZ2luYXRpb25TdHJpbmdzO1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXy51bmxpc3RlbihDVVJSRU5UX1BBR0VfRVZFTlQsXG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2VIYW5kbGVyXyk7XG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLnVubGlzdGVuKFBSRVZJT1VTX0VWRU5ULCB0aGlzLnByZXZpb3VzVGlsZUhhbmRsZXJfKTtcbiAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8udW5saXN0ZW4oTkVYVF9FVkVOVCwgdGhpcy5uZXh0VGlsZUhhbmRsZXJfKTtcblxuICAgIHRoaXMucmVzaXplRGJjSGFuZGxlcl8uY2FuY2VsKCk7XG5cbiAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8uY2xlYXJGb2N1c01haW5FbGVtZW50SGFuZGxlcigpO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICBpZiAoIXRoaXMuaXNFbmFibGVkXykgcmV0dXJuO1xuICAgIHRoaXMucmVuZGVyZXJfLmluaXQoKCkgPT4ge1xuICAgICAgdGhpcy5uYXZpZ2F0b3JfLnNlbGVjdFRpbGUodGhpcy5wYWdpbmF0aW9uTW9kZWxfLmN1cnJlbnRQYWdlIC0gMSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhwb3NlcyB0aGUgbGlzdCBvZiBlbGVtZW50cyB0aGF0IHdlcmUgaW5qZWN0ZWQgaW4gdGhlIERPTSBkdXJpbmcgdGhlIGxhc3RcbiAgICogZHJhdyBjeWNsZSBvZiB0aGUgcmVuZGVyZXIuXG4gICAqIEByZXR1cm4geyFBcnJheTxFbGVtZW50Pn1cbiAgICovXG4gIGdldEFkZGVkRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmdldEFkZGVkRWxlbWVudHMoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzZWxlY3RQcmV2aW91c18oKSB7XG4gICAgdGhpcy5uYXZpZ2F0b3JfLnNlbGVjdFByZXZpb3VzKHRoaXMudXBkYXRlUGFnaW5hdGlvbl8uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc2VsZWN0TmV4dF8oKSB7XG4gICAgdGhpcy5uYXZpZ2F0b3JfLnNlbGVjdE5leHQodGhpcy51cGRhdGVQYWdpbmF0aW9uXy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1cGRhdGVfKCkge1xuICAgIGlmICh0aGlzLnN3aXBlXy5pc1N3aXBpbmcoKSkgcmV0dXJuO1xuICAgIGNvbnN0IHNuYXBwZWRUaWxlID0gdGhpcy50aWxlTWFwXy5nZXRDdXJyZW50U25hcHBlZFRpbGUoKTtcbiAgICBpZiAoc25hcHBlZFRpbGUgJiZcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLmN1cnJlbnRQYWdlICE9IHNuYXBwZWRUaWxlLmluZGV4ICsgMSkge1xuICAgICAgdGhpcy5uYXZpZ2F0b3JfLnNlbGVjdFRpbGUodGhpcy5wYWdpbmF0aW9uTW9kZWxfLmN1cnJlbnRQYWdlIC0gMSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHVwZGF0ZVBhZ2luYXRpb25fKCkge1xuICAgIGNvbnN0IHNuYXBwZWRUaWxlID0gdGhpcy50aWxlTWFwXy5nZXRDdXJyZW50U25hcHBlZFRpbGUoKTtcbiAgICBpZiAoc25hcHBlZFRpbGUpIHtcbiAgICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXy5jdXJyZW50UGFnZSA9IHNuYXBwZWRUaWxlLmluZGV4ICsgMTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgaGFuZGxlUmVzaXplXygpIHtcbiAgICBjb25zdCBuZXdGcmFtZVdpZHRoID0gdGhpcy5hZGFwdGVyLmdldFBhcmVudEVsZW1lbnRXaWR0aCgpO1xuICAgIGlmIChuZXdGcmFtZVdpZHRoICE9IHRoaXMudGlsZU1hcF8uZnJhbWVXaWR0aCkge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IHtDYXJvdXNlbEZvdW5kYXRpb259O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvZm91bmRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdGllcyByZWxhdGluZyB0byBrZXlib2FyZCBmb2N1cy5cbiAqXG4gKiBUT0RPKGdsdWUtZGV2KTogVXBkYXRlIG1vZGFsIGFuZCBoZXJjIGhlYWRlciB0byBoYXZlIHV0aWxzIGhlcmUuIGIvMzQzODc0MzNcbiAqL1xuXG5cblxuaW1wb3J0IHtlbmFibGUgYXMgZWxNYXRjaGVzRW5hYmxlfSBmcm9tICcuLi8uLi9zaGltL2VsZW1lbnRtYXRjaGVzL2VsZW1lbnRtYXRjaGVzJztcblxuZWxNYXRjaGVzRW5hYmxlKCk7XG5cblxuLyoqXG4gKiBRdWVyeSBzZWxlY3RvcnMgZm9yIGVsZW1lbnRzIHRoYXQgY2FuIHJlY2VpdmUgZm9jdXMuXG4gKiBAY29uc3Qge0FycmF5PHN0cmluZz59XG4gKi9cbmNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UX1NFTEVDVE9SUyA9IFtcbiAgJ2lucHV0JyxcbiAgJ3RleHRhcmVhJyxcbiAgJ3NlbGVjdCcsXG4gICdidXR0b24nLFxuICAnaWZyYW1lJyxcbiAgJ1tyb2xlPVwiYnV0dG9uXCJdJyxcbiAgJ2EnLFxuICAnW3RhYmluZGV4XScsXG5dO1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGFibGUgdG8gcmVjZWl2ZSBmb2N1cy4gTm90ZSB0aGF0IHRoaXMgd2lsbFxuICogcmV0dXJuIHRydWUgZXZlbiBmb3IgZWxlbWVudHMgd2hlcmUgdGhlIHVzZXIgaXNuJ3QgYWJsZSB0byBtb3ZlIGZvY3VzXG4gKiB0byB0aGUgZWxlbWVudCBidXQgamF2YXNjcmlwdCBpcyBhYmxlIHRvIG1vdmUgZm9jdXMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgRWxlbWVudCB0byBjaGVjayBmb3IgZm9jdXNhYmlsaXR5LlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGZvY3VzYWJsZVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnRGb2N1c2FibGUoZWwpIHtcbiAgcmV0dXJuIEZPQ1VTQUJMRV9FTEVNRU5UX1NFTEVDVE9SUy5maWx0ZXIoKHNlbGVjdG9yKSA9PiB7XG4gICAgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9KS5sZW5ndGggPiAwO1xufTtcblxuXG4vKipcbiAqIEdldCBhbGwgY2hpbGQgZm9jdXNhYmxlIGVsZW1lbnRzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBUaGUgcGFyZW50IGVsZW1lbnQuXG4gKiBAcmV0dXJuIHshQXJyYXk8RWxlbWVudD59IEFycmF5IGNvbnRhaW5pbmcgYWxsIGNoaWxkIGZvY3VzYWJsZSBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoZWwpIHtcbiAgdmFyIGlucHV0cyA9IFtdLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JykpO1xuICB2YXIgYW5jaG9ycyA9IFtdLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKSk7XG4gIHZhciB0ZXh0YXJlYXMgPSBbXS5zbGljZS5hcHBseShlbC5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpKTtcbiAgdmFyIHNlbGVjdHMgPSBbXS5zbGljZS5hcHBseShlbC5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKSk7XG4gIHZhciBidXR0b25zID0gW10uc2xpY2UuYXBwbHkoZWwucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJykpO1xuICB2YXIgaWZyYW1lcyA9IFtdLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lmcmFtZScpKTtcbiAgdmFyIHJvbGVCdG5FbGVtZW50cyA9IFtdLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgJ1tyb2xlPVwiYnV0dG9uXCJdJyArXG4gICAgJzpub3QoaW5wdXQpJyArXG4gICAgJzpub3QoYSknICtcbiAgICAnOm5vdCh0ZXh0YXJlYSknICtcbiAgICAnOm5vdChzZWxlY3QpJyArXG4gICAgJzpub3QoYnV0dG9uKScgK1xuICAgICc6bm90KGlmcmFtZSknKSk7XG4gIHZhciB0YWJpbmRleEVsZW1lbnRzID0gIFtdLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgJ1t0YWJpbmRleD1cIjBcIl0nICtcbiAgICAnOm5vdChbcm9sZT1cImJ1dHRvblwiXSknICtcbiAgICAnOm5vdChpbnB1dCknICtcbiAgICAnOm5vdChhKScgK1xuICAgICc6bm90KHRleHRhcmVhKScgK1xuICAgICc6bm90KHNlbGVjdCknICtcbiAgICAnOm5vdChidXR0b24pJyArXG4gICAgJzpub3QoaWZyYW1lKScpKTtcbiAgcmV0dXJuIGlucHV0cy5jb25jYXQoYW5jaG9ycykuY29uY2F0KHRleHRhcmVhcykuY29uY2F0KHNlbGVjdHMpXG4gICAgICAuY29uY2F0KGJ1dHRvbnMpLmNvbmNhdChpZnJhbWVzKS5jb25jYXQocm9sZUJ0bkVsZW1lbnRzKVxuICAgICAgLmNvbmNhdCh0YWJpbmRleEVsZW1lbnRzKTtcbn07XG5cblxuZXhwb3J0IHtGT0NVU0FCTEVfRUxFTUVOVF9TRUxFQ1RPUlMsIGlzRWxlbWVudEZvY3VzYWJsZSwgZ2V0Rm9jdXNhYmxlRWxlbWVudHN9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvZG9tL2ZvY3VzX3V0aWwvZm9jdXMtdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBvbHlmaWxsIGZvciBFbGVtZW50Lm1hdGNoZXMoKS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlc1xuICovXG5cblxuXG4vKipcbiAqIEVuYWJsZXMgcG9seWZpbGwgZm9yIEVsZW1lbnQubWF0Y2hlcygpLlxuICogQHBhcmFtIHtXaW5kb3c9fSBvcHRfd2luZG93IFJlZmVyZW5jZSB0byBhIHdpbmRvdyBvYmplY3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwb2x5ZmlsbCBoYXMgYmVlbiBlbmFibGVkLiBXaWxsIGJlIGZhbHNlIGlmXG4gKiAgICAgYWxyZWFkeSBzdXBwb3J0ZWQgbmF0aXZlbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGUob3B0X3dpbmRvdykge1xuICB2YXIgd2luID0gb3B0X3dpbmRvdyB8fCB3aW5kb3c7XG4gIGlmICghd2luLkVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbiAgICBsZXQgbm9kZSA9IHdpbi5FbGVtZW50O1xuICAgIHdpbi5FbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID1cbiAgICAgICAgd2luLkVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICB3aW4uRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgIHdpbi5FbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICB3aW4uRWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICB3aW4uRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IChub2RlLmRvY3VtZW50IHx8IG5vZGUub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwocyk7XG4gICAgICAgICAgdmFyIGkgPSBtYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDAgJiYgbWF0Y2hlcy5pdGVtKGkpICE9PSBub2RlKSB7fVxuICAgICAgICAgIHJldHVybiBpID4gLTE7XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3NoaW0vZWxlbWVudG1hdGNoZXMvZWxlbWVudG1hdGNoZXMuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG5pbXBvcnQge0l0ZXJhYmxlVGlsZU1hcH0gZnJvbSAnLi9pdGVyYWJsZXRpbGVtYXAnO1xuaW1wb3J0IHtUaWxlfSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IHtUaWxlSXRlcmF0b3J9IGZyb20gJy4vdGlsZWl0ZXJhdG9yJztcblxuXG4vKipcbiAqIEl0ZXJhdGVzIGFsbCB0aWxlcyBjb250YWluZWQgYmV0d2VlbiBhbmQgaW5zaWRlIHR3byBmcmFtZSBib3VuZHMuXG4gKi9cbmNsYXNzIENvbnRhaW5lZFRpbGVJdGVyYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUl0ZXJhYmxlVGlsZU1hcH0gdGlsZU1hcCBBIHRpbGUgbWFwLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcm9tRnJhbWVYIFRoZSBmcmFtZSBwb3NpdGlvbiB0byBpdGVyYXRlIGZyb20uXG4gICAqICAgICBJZiBub3QgcHJvdmlkZWQsIHdpbGwgdXNlIHRoZSB0aWxlbWFwJ3MgZnJhbWUgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3RvRnJhbWVYIFRoZSBmcmFtZSBwb3NpdGlvbiB0byBpdGVyYXRlIHRvLlxuICAgKiAgICAgSWYgbm90IHByb3ZpZGVkLCB3aWxsIGl0ZXJhdGUgb3ZlciBhbGwgdGlsZXMgY29udGFpbmVkIGluIHRoZSBmcmFtZVxuICAgKiAgICAgcG9zaXRpb25lZCBhdCB7QGNvZGUgb3B0X2Zyb21GcmFtZVh9LlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZU1hcCwgb3B0X2Zyb21GcmFtZVgsIG9wdF90b0ZyYW1lWCkge1xuICAgIC8qKiBAcHJpdmF0ZSB7IUl0ZXJhYmxlVGlsZU1hcH0gKi9cbiAgICB0aGlzLnRpbGVNYXBfID0gdGlsZU1hcDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gV2hldGhlciBpdGVyYXRpb24gaGFzIGNvbXBsZXRlZC4gKi9cbiAgICB0aGlzLmRvbmVfID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMudGlsZU1hcF8uaXNWYWxpZCgpKSB7XG4gICAgICB0aGlzLmRvbmVfID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmZyb21GcmFtZVhfID0gKG9wdF9mcm9tRnJhbWVYICE9IHVuZGVmaW5lZCkgP1xuICAgICAgICBvcHRfZnJvbUZyYW1lWCA6IHRoaXMudGlsZU1hcF8uZ2V0RnJhbWVYKCk7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLnRvRnJhbWVYXyA9IChvcHRfdG9GcmFtZVggIT0gdW5kZWZpbmVkKSA/XG4gICAgICAgIG9wdF90b0ZyYW1lWCA6IHRoaXMuZnJvbUZyYW1lWF87XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59IFdoZXRoZXIgdG8gaXRlcmF0ZSB0aWxlcyBmb3J3YXJkLiAqL1xuICAgIHRoaXMubW92ZUZvcndhcmRfID0gdGhpcy50b0ZyYW1lWF8gPj0gdGhpcy5mcm9tRnJhbWVYXztcblxuICAgIHZhciBzdGFydFRpbGUgPSB0aGlzLmdldFN0YXJ0VGlsZV8oKTtcbiAgICBpZiAoIXN0YXJ0VGlsZSkge1xuICAgICAgdGhpcy5kb25lXyA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50aWxlSXRlcmF0b3JfID1cbiAgICAgICAgbmV3IFRpbGVJdGVyYXRvcih0aWxlTWFwLCBzdGFydFRpbGUsIG51bGwsIHRoaXMubW92ZUZvcndhcmRfKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBpdGVyYXRvciB0byB0aGUgbmV4dCB0aWxlLlxuICAgKiBAcmV0dXJuIHshSXRlcmF0b3JPYmplY3R9XG4gICAqL1xuICBuZXh0KCkge1xuICAgIGlmICh0aGlzLmRvbmVfKSB7XG4gICAgICByZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICAgIH1cblxuICAgIGNvbnN0IHRpbGUgPSB0aGlzLnRpbGVJdGVyYXRvcl8ubmV4dCgpLnZhbHVlO1xuICAgIGlmICghdGlsZSkge1xuICAgICAgdGhpcy5kb25lXyA9IHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMubW92ZUZvcndhcmRfKSB7XG4gICAgICB2YXIgZnJhbWVSaWdodEJvdW5kID0gdGhpcy50b0ZyYW1lWF8gKyB0aGlzLnRpbGVNYXBfLmZyYW1lV2lkdGg7XG4gICAgICBpZiAodGlsZS54ICsgdGlsZS53aWR0aCA+PSBmcmFtZVJpZ2h0Qm91bmQpIHtcbiAgICAgICAgdGhpcy5kb25lXyA9IHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHRpbGUueCA8PSB0aGlzLnRvRnJhbWVYXykge1xuICAgICAgdGhpcy5kb25lXyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0aWxlLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpcnN0IHRpbGUgdG8gaXRlcmF0ZSBmcm9tLlxuICAgKiBAcmV0dXJuIHtUaWxlfHVuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFN0YXJ0VGlsZV8oKSB7XG4gICAgdmFyIGJvdW5kID0gdGhpcy5mcm9tRnJhbWVYXyArXG4gICAgICAgICh0aGlzLm1vdmVGb3J3YXJkXyA/IDAgOiB0aGlzLnRpbGVNYXBfLmZyYW1lV2lkdGggLSAxKTtcblxuICAgIHZhciBpc1RpbGVCZXlvbmRCb3VuZDtcblxuICAgIGlmIChib3VuZCA+PSAwKSB7XG4gICAgICBpc1RpbGVCZXlvbmRCb3VuZCA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRpbGUgJiYgKHRpbGUueCArIHRpbGUud2lkdGggLSAxKSA8IGJvdW5kO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNUaWxlQmV5b25kQm91bmQgPSBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHJldHVybiB0aWxlICYmIHRpbGUueCA+IGJvdW5kO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgLyoqICFUaWxlICovIGZpcnN0VGlsZSA9IHtcbiAgICAgIGluZGV4OiAwLFxuICAgICAgeDogMCxcbiAgICB9O1xuXG4gICAgdmFyIGl0ZXJhdG9yID1cbiAgICAgICAgbmV3IFRpbGVJdGVyYXRvcih0aGlzLnRpbGVNYXBfLCBmaXJzdFRpbGUsIG51bGwsIChib3VuZCA+PSAwKSk7XG5cbiAgICB2YXIgdGlsZTtcbiAgICBkbyB7XG4gICAgICB0aWxlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIH0gd2hpbGUgKGlzVGlsZUJleW9uZEJvdW5kKHRpbGUpKTtcblxuICAgIHJldHVybiB0aWxlO1xuICB9XG5cbn1cblxuXG4vKipcbiAqIEl0ZXJhdG9yIG9iamVjdC5cbiAqIEB0eXBlZGVmIHshe1xuICogICB2YWx1ZTogKFRpbGV8dW5kZWZpbmVkKSxcbiAqICAgZG9uZTogYm9vbGVhblxuICogfX1cbiAqL1xubGV0IEl0ZXJhdG9yT2JqZWN0O1xuXG5leHBvcnQge0NvbnRhaW5lZFRpbGVJdGVyYXRvcn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9jYXJvdXNlbC90aWxlbWFwL2NvbnRhaW5lZHRpbGVpdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbmltcG9ydCB7SXRlcmFibGVUaWxlTWFwfSBmcm9tICcuL2l0ZXJhYmxldGlsZW1hcCc7XG5cblxuLyoqXG4gKiBJdGVyYXRlcyB0aWxlIGluZGV4ZXMuXG4gKi9cbmNsYXNzIEluZGV4SXRlcmF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFJdGVyYWJsZVRpbGVNYXB9IHRpbGVNYXAgQSB0aWxlIG1hcC5cbiAgICogQHBhcmFtIHs/bnVtYmVyPX0gb3B0X2Zyb21JbmRleCBUaGUgdGlsZSBpbmRleCB0byBpdGVyYXRlIGZyb20uXG4gICAqIEBwYXJhbSB7P251bWJlcj19IG9wdF90b0luZGV4IFRoZSB0aWxlIGluZGV4IHRvIGl0ZXJhdGUgdG8uXG4gICAqIEBwYXJhbSB7P2Jvb2xlYW49fSBvcHRfbW92ZUZvcndhcmQgV2hldGhlciB0byBpdGVyYXRlIGZvcndhcmQuXG4gICAqICAgICAoRGVmYXVsdDogdHJ1ZSlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpbGVNYXAsIG9wdF9mcm9tSW5kZXgsIG9wdF90b0luZGV4LCBvcHRfbW92ZUZvcndhcmQpIHtcbiAgICAvKiogQHByaXZhdGUgeyFJdGVyYWJsZVRpbGVNYXB9ICovXG4gICAgdGhpcy50aWxlTWFwXyA9IHRpbGVNYXA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gVGhlIGN1cnJlbnQgdGlsZSBpbmRleC4gKi9cbiAgICB0aGlzLmluZGV4XyA9IChvcHRfZnJvbUluZGV4ICE9IHVuZGVmaW5lZCkgPyBvcHRfZnJvbUluZGV4IDogMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P251bWJlcn0gVGhlIHRpbGUgaW5kZXggd2hlcmUgdGhlIGl0ZXJhdG9yIHNob3VsZCBzdG9wLiAqL1xuICAgIHRoaXMudG9JbmRleF8gPSAob3B0X3RvSW5kZXggIT0gdW5kZWZpbmVkKSA/XG4gICAgICAgIE1hdGgubWluKE1hdGgubWF4KG9wdF90b0luZGV4LCAwKSwgdGhpcy50aWxlTWFwXy5nZXRUaWxlc0NvdW50KCkgLSAxKSA6XG4gICAgICAgIG51bGw7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59IFdoZXRoZXIgdG8gaXRlcmF0ZSB0aWxlcyBmb3J3YXJkLiAqL1xuICAgIHRoaXMubW92ZUZvcndhcmRfID0gKG9wdF9tb3ZlRm9yd2FyZCAhPSBmYWxzZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59IFdoZXRoZXIgaXRlcmF0aW9uIGhhcyBjb21wbGV0ZWQuICovXG4gICAgdGhpcy5kb25lXyA9IGZhbHNlO1xuICB9XG5cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGl0ZXJhdG9yIHRvIHRoZSBuZXh0IHRpbGUuXG4gICAqIEByZXR1cm4geyFJdGVyYXRvck9iamVjdH1cbiAgICovXG4gIG5leHQoKSB7XG4gICAgaWYgKHRoaXMuZG9uZV8pIHtcbiAgICAgIHJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleF87XG4gICAgdGhpcy5pbmRleF8gKz0gdGhpcy5tb3ZlRm9yd2FyZF8gPyAxIDogLTE7XG5cbiAgICBpZiAoaW5kZXggPT0gdGhpcy50b0luZGV4Xykge1xuICAgICAgdGhpcy5kb25lXyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW5kZXhfIDwgMCkge1xuICAgICAgaWYgKHRoaXMudGlsZU1hcF8uaXNDeWNsaWNhbCgpKSB7XG4gICAgICAgIHRoaXMuaW5kZXhfID0gdGhpcy50aWxlTWFwXy5nZXRUaWxlc0NvdW50KCkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kb25lXyA9IHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5kZXhfID49IHRoaXMudGlsZU1hcF8uZ2V0VGlsZXNDb3VudCgpKSB7XG4gICAgICBpZiAodGhpcy50aWxlTWFwXy5pc0N5Y2xpY2FsKCkpIHtcbiAgICAgICAgdGhpcy5pbmRleF8gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kb25lXyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHt2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlfTtcbiAgfVxuXG59XG5cblxuLyoqXG4gKiBJdGVyYXRvciBvYmplY3QuXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAgdmFsdWU6ICh1bmRlZmluZWR8bnVtYmVyKSxcbiAqICAgZG9uZTogYm9vbGVhblxuICogfX1cbiAqL1xubGV0IEl0ZXJhdG9yT2JqZWN0O1xuXG5leHBvcnQge0luZGV4SXRlcmF0b3J9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwvdGlsZW1hcC9pbmRleGl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtJdGVyYWJsZVRpbGVNYXB9IGZyb20gJy4vaXRlcmFibGV0aWxlbWFwJztcbmltcG9ydCB7VGlsZX0gZnJvbSAnLi90aWxlJztcbmltcG9ydCB7VGlsZUl0ZXJhdG9yfSBmcm9tICcuL3RpbGVpdGVyYXRvcic7XG5pbXBvcnQge1Zpc2liaWxpdHl9IGZyb20gJy4vdmlzaWJpbGl0eSc7XG5cblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIHRoZSB2aXNpYmlsaXR5IHN0YXR1cyBvZiBlYWNoIHRpbGUgaW4gYSB0aWxlIG1hcC5cbiAqL1xuY2xhc3MgVmlzaWJpbGl0eUl0ZXJhdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHshSXRlcmFibGVUaWxlTWFwfSB0aWxlTWFwIEEgdGlsZSBtYXAuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aWxlTWFwKSB7XG4gICAgLyoqIEBwcml2YXRlIHshSXRlcmFibGVUaWxlTWFwfSAqL1xuICAgIHRoaXMudGlsZU1hcF8gPSB0aWxlTWFwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9IEhvdyBtYW55IHRpbGVzIHdlcmUgaXRlcmF0ZWQuICovXG4gICAgdGhpcy50aWxlQ291bnRfID0gMDtcblxuICAgIHZhciBmaXJzdFRpbGVYID0gMDtcbiAgICBpZiAodGhpcy50aWxlTWFwXy5pc0N5Y2xpY2FsKCkgJiYgdGhpcy50aWxlTWFwXy5pc1ZhbGlkKCkpIHtcbiAgICAgIHdoaWxlIChmaXJzdFRpbGVYID4gdGhpcy50aWxlTWFwXy5nZXRGcmFtZVgoKSkge1xuICAgICAgICBmaXJzdFRpbGVYIC09IHRoaXMudGlsZU1hcF8uZ2V0QWxsVGlsZXNXaWR0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciAvKiogIVRpbGUgKi8gZmlyc3RUaWxlID0ge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICB4OiBmaXJzdFRpbGVYLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaWxlIGl0ZXJhdG9yLlxuICAgICAqIEBwcml2YXRlIHshVGlsZUl0ZXJhdG9yfVxuICAgICAqL1xuICAgIHRoaXMudGlsZUl0ZXJhdG9yXyA9IG5ldyBUaWxlSXRlcmF0b3IodGhpcy50aWxlTWFwXywgZmlyc3RUaWxlLCBudWxsKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gV2hldGhlciBpdGVyYXRpb24gaGFzIGNvbXBsZXRlZC4gKi9cbiAgICB0aGlzLmRvbmVfID0gZmFsc2U7XG5cbiAgICAvLyBEb24ndCBpdGVyYXRlIGlmIGFsbCB0aWxlcyBoYXZlIGEgemVybyB3aWR0aFxuICAgIGlmICghdGhpcy50aWxlTWFwXy5pc1ZhbGlkKCkpIHtcbiAgICAgIHRoaXMuZG9uZV8gPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBpdGVyYXRvciB0byB0aGUgbmV4dCB0aWxlLlxuICAgKiBAcmV0dXJuIHshSXRlcmF0b3JPYmplY3R9XG4gICAqL1xuICBuZXh0KCkge1xuICAgIHZhciB0aWxlID0gdGhpcy50aWxlSXRlcmF0b3JfLm5leHQoKS52YWx1ZTtcbiAgICBpZiAoIXRpbGUgfHwgdGhpcy5kb25lXykge1xuICAgICAgcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgICB9XG5cbiAgICB2YXIgY3ljbGVkT25jZSA9ICh0aGlzLnRpbGVDb3VudF8gPj0gdGhpcy50aWxlTWFwXy5nZXRUaWxlc0NvdW50KCkpO1xuICAgIHZhciBmcmFtZVJpZ2h0Qm91bmQgPSB0aGlzLnRpbGVNYXBfLmdldEZyYW1lWCgpICsgdGhpcy50aWxlTWFwXy5mcmFtZVdpZHRoICtcbiAgICAgICAgdGhpcy50aWxlTWFwXy5mcmFtZUV4cGFuZDtcbiAgICBpZiAoY3ljbGVkT25jZSAmJiB0aWxlLnggPj0gZnJhbWVSaWdodEJvdW5kKSB7XG4gICAgICByZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICAgIH1cblxuICAgIHZhciB2c2IgPSB0aGlzLnRpbGVNYXBfLmdldFRpbGVWaXNpYmlsaXR5KHRpbGUuaW5kZXgsIHRpbGUueCk7XG4gICAgdGhpcy50aWxlQ291bnRfKys7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgaW5kZXg6IHRpbGUuaW5kZXgsXG4gICAgICAgIHZzYjogdnNiLFxuICAgICAgfSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgIH07XG4gIH1cblxufVxuXG5cbi8qKlxuICogSXRlcmF0b3IgdmFsdWUuXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAgaW5kZXg6IG51bWJlcixcbiAqICAgdnNiOiBWaXNpYmlsaXR5XG4gKiB9fVxuICovXG5sZXQgVmFsdWU7XG5cblxuLyoqXG4gKiBJdGVyYXRvciBvYmplY3QuXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAgdmFsdWU6ICh1bmRlZmluZWR8VmFsdWUpLFxuICogICBkb25lOiBib29sZWFuXG4gKiB9fVxuICovXG5sZXQgSXRlcmF0b3JPYmplY3Q7XG5cbmV4cG9ydCB7VmlzaWJpbGl0eUl0ZXJhdG9yfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL3RpbGVtYXAvdmlzaWJpbGl0eWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtsaW5lYXIsIGVhc2V9IGZyb20gJy4vZWFzaW5nJztcblxuLyoqXG4gKiBBIHN1cGVyIGxpZ2h0d2VpZ2h0IGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIFR3ZWVuTGl0ZS5cbiAqIFNvbWVob3cgaXQncyBUd2VlbkxpdGVMaXRlLiBBUEkgaXMgaWRlbnRpY2FsIGJ1dFxuICogICAtIGl0IGNhbiBvbmx5IHR3ZWVuIG9iamVjdHMgd2l0aCBudW1iZXIgcHJvcGVydGllcyxcbiAqICAgLSBpdCBjYW4gbm90IGFjY2VwdCBhbiBhcnJheSBvZiBvYmplY3RzLFxuICogICAtIGl0IGNhbiBub3QgcmV0cmlldmUgZWxlbWVudHMgZnJvbSBhIHNlbGVjdG9yLFxuICogICAtIG9ubHkgYSBoYW5kZnVsIG9mIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBhcmUgc3VwcG9ydGVkIChsaXN0ZWQgaW5cbiAqICAgICB7QGNvZGUgUkVTRVJWRURfUFJPUFN9LFxuICogICDigJMgYW5pbWF0aW9ucyBhbHdheXMgcGxheSBpbW1lZGlhdGVseSBhbmQgY2FuIG9ubHkgYmUga2lsbGVkLCBub3QgcGF1c2VkXG4gKiAgICAgb3IgcmVzdW1lZC5cbiAqL1xuY2xhc3MgVHdlZW4ge1xuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9kb2NzLyMvSFRNTDUvR1NBUC9Ud2VlbkxpdGUvVHdlZW5MaXRlL1xuICAgKiBAcGFyYW0geyFPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgc2hvdWxkIGJlIHR3ZWVuZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IHZhcnMgRW5kIHZhbHVlcyBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHR3ZWVuZWQsXG4gICAqICAgICBhbmQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuICAgIC8qKiBAcHJpdmF0ZSB7IU9iamVjdH0gKi9cbiAgICB0aGlzLnRhcmdldF8gPSB0YXJnZXQ7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IGR1cmF0aW9uO1xuXG4gICAgLyoqIEBwcml2YXRlIHtPYmplY3R9ICovXG4gICAgdGhpcy5vcHRpb25zXyA9IHZhcnM7XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSBvZiB0YXJnZXQgb2JqZWN0LCB0byBrZWVwIHJlZmVyZW5jZXMgb2Ygc3RhcnQgdmFsdWVzLlxuICAgICAqIEBwcml2YXRlIHshT2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRQcm9wc18gPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbihudW1iZXIpOiBudW1iZXJ9IEVhc2luZyBtZXRob2QuICovXG4gICAgdGhpcy5lYXNlRnVuY18gPSB2YXJzWydlYXNlJ10gfHwgbGluZWFyO1xuXG4gICAgLyoqIEBwcml2YXRlIHtGdW5jdGlvbn0gSGFuZGxlciBjYWxsZWQgb24gZWFjaCBmcmFtZS4gKi9cbiAgICB0aGlzLm9uVXBkYXRlXyA9IHZhcnNbJ29uVXBkYXRlJ10gfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlcnMgcGFzc2VkIHRvIHtAY29kZSBvblVwZGF0ZX0gaGFuZGxlci5cbiAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8IU9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5vblVwZGF0ZVBhcmFtc18gPSB2YXJzWydvblVwZGF0ZVBhcmFtcyddIHx8IG51bGw7XG5cbiAgICAvKiogQHByaXZhdGUge0Z1bmN0aW9ufSBIYW5kbGVyIGNhbGxlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy4gKi9cbiAgICB0aGlzLm9uQ29tcGxldGVfID0gdmFyc1snb25Db21wbGV0ZSddIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSBvZiBlbmQgdmFsdWVzIG9iamVjdCB3aXRob3V0IHRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMuXG4gICAgICogQHByaXZhdGUgeyFPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5lbmRQcm9wc18gPSB7fTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSBUaW1lc3RhbXAgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0cyBwbGF5aW5nLiAqL1xuICAgIHRoaXMuc3RhcnRUaW1lXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gVGltZXN0YW1wIGFmdGVyIHdoaWNoIHRoZSBhbmltYXRpb24gbXVzdCBlbmQuICovXG4gICAgdGhpcy5lbmRUaW1lXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gQW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QgaWQgKi9cbiAgICB0aGlzLmZyYW1lUmVxdWVzdElkXyA9IDA7XG5cbiAgICB0aGlzLnBsYXlfKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTdGFydHMgcGxheWluZyB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcGxheV8oKSB7XG4gICAgLy8gSXNvbGF0ZSB0aGUgZW5kIG9mIHZhbHVlcyBvZiB0d2VlbmVkIHByb3BlcnRpZXMgZnJvbSB0aGUgY29uZmlndXJhdGlvblxuICAgIC8vIHByb3BlcnRpZXMuXG4gICAgZm9yIChsZXQgb3B0aW9uIGluIHRoaXMub3B0aW9uc18pIHtcbiAgICAgIGlmIChSRVNFUlZFRF9QUk9QUy5pbmRleE9mKG9wdGlvbikgPT0gLTEpIHtcbiAgICAgICAgdGhpcy5lbmRQcm9wc19bb3B0aW9uXSA9IHRoaXMub3B0aW9uc19bb3B0aW9uXSAtXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UHJvcHNfW29wdGlvbl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydFRpbWVfID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmVuZFRpbWVfID0gdGhpcy5zdGFydFRpbWVfICsgdGhpcy5kdXJhdGlvbl8gKiAxMDAwO1xuICAgIHRoaXMuZnJhbWVSZXF1ZXN0SWRfID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnRpY2tfLmJpbmQodGhpcykpO1xuICB9XG5cblxuICAvKipcbiAgICogU2V0cyB0aGUgYW5pbWF0aW9uIHByb2dyZXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGluZGljYXRpbmcgdGhlIHByb2dyZXNzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvZ3Jlc3NfKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSkpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSB2YWx1ZSAqICh0aGlzLmVuZFRpbWVfIC0gdGhpcy5zdGFydFRpbWVfKSAvIDEwMDA7XG4gICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLmVuZFByb3BzXykge1xuICAgICAgaWYgKCF0aGlzLmVuZFByb3BzXy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG4gICAgICB0aGlzLnRhcmdldF9bcHJvcF0gPSBlYXNlKFxuICAgICAgICAgIGVsYXBzZWQsXG4gICAgICAgICAgdGhpcy5zdGFydFByb3BzX1twcm9wXSxcbiAgICAgICAgICB0aGlzLmVuZFByb3BzX1twcm9wXSxcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uXyxcbiAgICAgICAgICB0aGlzLmVhc2VGdW5jXyk7XG4gICAgfVxuXG4gICAgdGhpcy5vblVwZGF0ZV8gJiYgdGhpcy5vblVwZGF0ZV8uYXBwbHkobnVsbCwgdGhpcy5vblVwZGF0ZVBhcmFtc18pO1xuICB9XG5cbiAgLyoqXG4gICAqIEtpbGxzIHRoZSBhbmltYXRpb24uXG4gICAqL1xuICBraWxsKCkge1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lUmVxdWVzdElkXyk7XG4gICAgdGhpcy5vcHRpb25zXyA9IG51bGw7XG4gICAgdGhpcy5vblVwZGF0ZV8gPSBudWxsO1xuICAgIHRoaXMub25Db21wbGV0ZV8gPSBudWxsO1xuICB9XG5cblxuICAvKipcbiAgICogUGxheXMgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGlja18oKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBwcm9ncmVzcyA9IChub3cgLSB0aGlzLnN0YXJ0VGltZV8pIC8gdGhpcy5kdXJhdGlvbl8gLyAxMDAwO1xuICAgIHRoaXMucHJvZ3Jlc3NfKHByb2dyZXNzKTtcblxuICAgIGlmIChEYXRlLm5vdygpIDwgdGhpcy5lbmRUaW1lXykge1xuICAgICAgdGhpcy5mcmFtZVJlcXVlc3RJZF8gPVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy50aWNrXy5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm9ncmVzc18oMSk7XG4gICAgICB0aGlzLm9uQ29tcGxldGVfICYmIHRoaXMub25Db21wbGV0ZV8oKTtcbiAgICAgIHRoaXMua2lsbCgpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0d2VlbiBpbnN0YW5jZSB0aGF0IGFuaW1hdGVzIHRvIHRoZSBzcGVjaWZpZWQgZGVzdGluYXRpb24gdmFsdWVzLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgc2hvdWxkIGJlIHR3ZWVuZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IHZhcnMgRW5kIHZhbHVlcyBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHR3ZWVuZWQsXG4gICAqICAgICBhbmQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgKiBAcmV0dXJuIHshVHdlZW59XG4gICAqL1xuICBzdGF0aWMgdG8odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG4gIH07XG59XG5cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIHByb3BlcnRpZXMuXG4gKiBAY29uc3QgeyFBcnJheTxzdHJpbmc+fVxuICovXG5jb25zdCBSRVNFUlZFRF9QUk9QUyA9IFtcbiAgJ2Vhc2UnLCAnb25VcGRhdGUnLCAnb25VcGRhdGVQYXJhbXMnLCAnb25Db21wbGV0ZScsXG5dO1xuXG5leHBvcnQge1R3ZWVufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL2Z4L3R3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtDYXJvdXNlbEFkYXB0ZXJ9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge05hdmlnYXRvcn0gZnJvbSAnLi9uYXZpZ2F0b3InO1xuaW1wb3J0IHtPcHRpb25zfSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHtUaWxlTWFwfSBmcm9tICcuL3RpbGVtYXAvdGlsZW1hcCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN3aXBlRGlyZWN0aW9ufSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBNYW5hZ2VzIHN3aXBlIGludGVyYWN0aW9ucy5cbiAqL1xuY2xhc3MgU3dpcGUge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFUaWxlTWFwfSB0aWxlTWFwIFRoZSB0aWxlIG1hcCBkZWZpbml0aW9uLlxuICAgKiBAcGFyYW0geyFOYXZpZ2F0b3J9IG5hdmlnYXRvciBUaGUgY2Fyb3VzZWwgbmF2aWdhdGlvblxuICAgKiAgICAgbWFuYWdlci5cbiAgICogQHBhcmFtIHshQ2Fyb3VzZWxBZGFwdGVyfSBhZGFwdGVyIFRoZSBhZGFwdGVyIGludGVyZmFjZS5cbiAgICogQHBhcmFtIHshRnVuY3Rpb259IG1vdmVIYW5kbGVyIEEgY2FsbGJhY2sgZXhlY3V0ZWQgb24gZXZlcnkgc3dpcGUgdXBkYXRlLlxuICAgKiBAcGFyYW0geyFPcHRpb25zfSBvcHRpb25zIFRoZSBjYXJvdXNlbCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZU1hcCwgbmF2aWdhdG9yLCBhZGFwdGVyLCBtb3ZlSGFuZGxlciwgb3B0aW9ucykge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMudGlsZU1hcF8gPSB0aWxlTWFwO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5hZGFwdGVyXyA9IGFkYXB0ZXI7XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLm5hdmlnYXRvcl8gPSBuYXZpZ2F0b3I7XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLm1vdmVIYW5kbGVyXyA9IG1vdmVIYW5kbGVyO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5vcHRpb25zXyA9IG9wdGlvbnM7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc1J0bF8gPSB0aGlzLmFkYXB0ZXJfLmlzUnRsKCk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59IFdoZXRoZXIgYSBzd2lwZSBnZXN0dXJlIGlzIG9uZ29pbmcuICovXG4gICAgdGhpcy5pc1N3aXBpbmdfID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBsYXN0IHN3aXBlIGdlc3R1cmUgc3RhcnRlZC4gKi9cbiAgICB0aGlzLnN0YXJ0VGltZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9IFRoZSBmcmFtZSBwb3NpdGlvbiB3aGVuIHRoZSBzd2lwZSBnZXN0dXJlIHN0YXJ0ZWQuICovXG4gICAgdGhpcy5zdGFydEZyYW1lWF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvaW50ZXIgcG9zaXRpb24gd2hlbiB0aGUgc3dpcGUgZ2VzdHVyZSBzdGFydGVkLlxuICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFN3aXBlWF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIGRpc3RhbmNlIHRoZSB1c2VyIGhhcyBtb3ZlZCB0aGVpciBmaW5nZXIgc2luY2Ugc3dpcGVTdGFydC5cbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3dpcGVEZWx0YV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5oYW5kbGVTdGFydEhhbmRsZXJfID0gdGhpcy5oYW5kbGVTdGFydF8uYmluZCh0aGlzKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMuaGFuZGxlTW92ZUhhbmRsZXJfID0gdGhpcy5oYW5kbGVNb3ZlXy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5oYW5kbGVFbmRIYW5kbGVyXyA9IHRoaXMuaGFuZGxlRW5kXy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5oYW5kbGVNb3VzZUxlYXZlSGFuZGxlcl8gPSB0aGlzLmhhbmRsZU1vdXNlTGVhdmVfLmJpbmQodGhpcyk7XG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5zd2lwZUxvY2tlZF8gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudHMgbGlzdGVuaW5nLlxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyU3dpcGVTdGFydCh0aGlzLmhhbmRsZVN0YXJ0SGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTd2lwZU1vdmUodGhpcy5oYW5kbGVNb3ZlSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTd2lwZUVuZCh0aGlzLmhhbmRsZUVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyU3dpcGVDYW5jZWwodGhpcy5oYW5kbGVFbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3Rlck1vdXNlTGVhdmUodGhpcy5oYW5kbGVNb3VzZUxlYXZlSGFuZGxlcl8pO1xuICB9XG5cblxuICAvKipcbiAgICogU3RvcHMgZXZlbnRzIGxpc3RlbmluZy5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU3dpcGVTdGFydCh0aGlzLmhhbmRsZVN0YXJ0SGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclN3aXBlTW92ZSh0aGlzLmhhbmRsZU1vdmVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU3dpcGVFbmQodGhpcy5oYW5kbGVFbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU3dpcGVDYW5jZWwodGhpcy5oYW5kbGVFbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyTW91c2VMZWF2ZSh0aGlzLmhhbmRsZU1vdXNlTGVhdmVIYW5kbGVyXyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGEgc3dpcGUgZ2VzdHVyZSBpcyBvbmdvaW5nLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNTd2lwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzU3dpcGluZ187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGxvY2sgc3RhdHVzIG9mIHN3aXBpbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1N3aXBlTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLnN3aXBlTG9ja2VkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBhIHN3aXBlIHN0YXJ0IGV2ZW50LlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGNvb3JkcyBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHN3aXBlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU3RhcnRfKGNvb3Jkcykge1xuICAgIHRoaXMubmF2aWdhdG9yXy5zdG9wQW5pbWF0aW9uKCk7XG5cbiAgICAvLyBJbiBjYXNlIHdlIGFyZSBpbnRlcnJ1cHRpbmcgYSBza2lwIHRyYW5zaXRpb24sIHJlLWVuYWJsZSBhbGwgdGlsZXNcbiAgICB0aGlzLnRpbGVNYXBfLmVuYWJsZUhpZGRlblRpbGVzKCk7XG5cbiAgICB0aGlzLnN0YXJ0VGltZV8gPSArbmV3IERhdGUoKTtcbiAgICB0aGlzLnN0YXJ0RnJhbWVYXyA9IHRoaXMudGlsZU1hcF8uZ2V0RnJhbWVYKCk7XG4gICAgdGhpcy5zdGFydFN3aXBlWF8gPSBjb29yZHMueDtcbiAgICB0aGlzLmlzU3dpcGluZ18gPSB0cnVlO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5TV0lQSU5HKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGEgc3dpcGUgbW92ZSBldmVudC5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBjb29yZHMgVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBzd2lwZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZU1vdmVfKGNvb3Jkcykge1xuICAgIGlmICghdGhpcy5pc1N3aXBpbmdfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zd2lwZURlbHRhXyA9IChjb29yZHMueCAtIHRoaXMuc3RhcnRTd2lwZVhfKSAqICh0aGlzLmlzUnRsXyA/IC0xIDogMSk7XG4gICAgdmFyIGZyYW1lWCA9IHRoaXMuc3RhcnRGcmFtZVhfIC0gdGhpcy5zd2lwZURlbHRhXztcblxuICAgIC8vIHVwZGF0ZSB0aGUgc3dpcGUgbG9jayBzdGF0dXNcbiAgICB0aGlzLnN3aXBlTG9ja2VkXyA9IHRoaXMubG9ja1N3aXBlXyhmcmFtZVgpO1xuXG4gICAgLy8gQXBwbHkgZnJpY3Rpb24gb24gbm9uLWN5Y2xpY2FsIGNhcm91c2VscyB3aGVuIHRoZSBmcmFtZSBleGNlZWRzIGl0c1xuICAgIC8vIGJvdW5kcyBieSBhcHBseWluZyBhIGNvZWZmaWNpZW50IHRvIHRoZSBhbW91bnQgb2YgcGl4ZWxzIHRoYXQgZXhjZWVkZWRcbiAgICAvLyBvbmUgb2YgdGhlIHR3byBib3VuZGFyaWVzLlxuICAgIGlmICh0aGlzLnRpbGVNYXBfLmlzRnJhbWVYRXhjZWVkaW5nQm91bmRzKGZyYW1lWCkpIHtcbiAgICAgIHZhciBleGNlZWQ7XG4gICAgICB2YXIgZnJpY3Rpb24gPSB0aGlzLm9wdGlvbnNfLmVkZ2VGcmljdGlvbjtcbiAgICAgIGlmIChmcmFtZVggPiB0aGlzLnRpbGVNYXBfLmdldE1heEZyYW1lWCgpICsgMSkge1xuICAgICAgICBleGNlZWQgPSBmcmFtZVggLSB0aGlzLnRpbGVNYXBfLmdldE1heEZyYW1lWCgpO1xuICAgICAgICBmcmFtZVggPSB0aGlzLnRpbGVNYXBfLmdldE1heEZyYW1lWCgpICsgKGV4Y2VlZCAvIGZyaWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWVYIDwgdGhpcy50aWxlTWFwXy5nZXRNaW5GcmFtZVgoKSAtIDEpIHtcbiAgICAgICAgZXhjZWVkID0gdGhpcy50aWxlTWFwXy5nZXRNaW5GcmFtZVgoKSAtIGZyYW1lWDtcbiAgICAgICAgZnJhbWVYID0gdGhpcy50aWxlTWFwXy5nZXRNaW5GcmFtZVgoKSAtIChleGNlZWQgLyBmcmljdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzU3dpcGVMb2NrZWQoKSkge1xuICAgICAgdGhpcy5uYXZpZ2F0b3JfLnNldEZyYW1lUG9zaXRpb24oZnJhbWVYKTtcbiAgICAgIHRoaXMubW92ZUhhbmRsZXJfKCk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgYSBzd2lwZSBlbmQgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVFbmRfKCkge1xuICAgIHRoaXMuaXNTd2lwaW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5TV0lQSU5HKTtcblxuICAgIHZhciBzbmFwcGVkVGlsZSA9IHRoaXMudGlsZU1hcF8uZ2V0Q3VycmVudFNuYXBwZWRUaWxlKCk7XG4gICAgaWYgKCFzbmFwcGVkVGlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpZEZsaWNrXygpKSB7XG4gICAgICAvLyBHbyBvbmUgdGlsZSBmdXJ0aGVyIGluIHRoZSBzd2lwZSBkaXJlY3Rpb25cbiAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5tb3ZlSGFuZGxlcl8uYmluZCh0aGlzKTtcblxuICAgICAgLy8gSWYgY2Fyb3VzZWwgZG9lcyBub3QgcGFnaW5hdGUgZ3JvdXBzIG9mIHRpbGVzLCBtb3ZlIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgIC8vIGZyYW1lIHBvc2l0aW9uLCBvdGhlcndpc2UgZnJvbSB0aGUgY3VycmVudCBhbmltYXRpb24gZGVzdGluYXRpb24uXG4gICAgICB2YXIgZnJhbWVYID0gIXRoaXMubmF2aWdhdG9yXy5pc1BhZ2luYXRpbmdHcm91cHMoKSA/XG4gICAgICAgICAgdGhpcy5zdGFydEZyYW1lWF8gOiBudWxsO1xuXG4gICAgICBpZiAodGhpcy5zd2lwZURlbHRhXyA+PSAwKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdG9yXy5zZWxlY3RQcmV2aW91cyhoYW5kbGVyLCBmcmFtZVgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0b3JfLnNlbGVjdE5leHQoaGFuZGxlciwgZnJhbWVYKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR28gdG8gdGhlIHRpbGUgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgc25hcCBwb3NpdGlvbi5cbiAgICAgIHZhciBpbmRleCA9IHNuYXBwZWRUaWxlLmluZGV4O1xuICAgICAgdGhpcy5uYXZpZ2F0b3JfLnNlbGVjdFRpbGUoaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuc3dpcGVEZWx0YV8gPSAwO1xuICB9XG5cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnZXN0dXJlIHRoYXQganVzdCBlbmRlZCBpcyBjb25zaWRlcmVkIGEgJ2ZsaWNrJy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGxhc3QgZ2VzdHVyZSBpcyBjb25zaWRlcmVkIGEgJ2ZsaWNrJy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpZEZsaWNrXygpIHtcbiAgICB2YXIgbm93ID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIGR1cmF0aW9uID0gbm93IC0gdGhpcy5zdGFydFRpbWVfO1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKHRoaXMuc3dpcGVEZWx0YV8pO1xuICAgIHZhciBmbGlja2VkID0gKGR1cmF0aW9uIDwgU3dpcGUuRkxJQ0tfRFVSQVRJT05fKSAmJlxuICAgICAgICAoZGlzdGFuY2UgPiBTd2lwZS5GTElDS19ESVNUQU5DRV8pO1xuXG4gICAgcmV0dXJuIGZsaWNrZWQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB1c2VyJ3MgbW91c2UgbGVhdmVzIHRoZSBwYWdlcyBlbGVtZW50LCBwcm9jZXNzIGFzIGEgc3dpcGUgZW5kXG4gICAqIGV2ZW50IG9ubHkgd2hlbiB0aGUgdXNlciBpcyBwcmVzc2luZy4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgdXNlclxuICAgKiBjb3VsZCBoYXZlIHN0YXJ0ZWQgdG8gZHJhZyB0aGUgY2Fyb3VzZWwgYW5kIGxpZnRlZCB0aGUgbW91c2UgYnV0dG9uXG4gICAqIG91dHNpZGUgb2YgdGhlIGVsZW1lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVNb3VzZUxlYXZlXygpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIHVzZXIgYWN0dWFsbHkgaW50ZW5kZWQgdG8gZmxpY2svc3dpcGUgcmF0aGVyIHRoYW4ganVzdFxuICAgIC8vIGhhcHBlbmluZyB0byBtb3VzZSBvdmVyIHdoZW4gdGhlIGNhcm91c2VsIGlzIGluIHRyYW5zaXQuIFdpdGhvdXQgdGhpc1xuICAgIC8vIGNoZWNrIHRoZSBjYXJvdXNlbCBjb3VsZCBzdG9wIGF0IHRoZSB3cm9uZyBzbGlkZSAoc3VjaCBhcyB0aGUgbGFzdCBzbGlkZVxuICAgIC8vIHRoZXkgbW91c2VkIG92ZXIpLlxuICAgIHRoaXMuaXNTd2lwaW5nXyAmJiB0aGlzLmhhbmRsZUVuZF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyBjdXJyZW50IGZyYW1lIHdpdGggbGFzdCBmcmFtZSB0byBnZXQgdGhlIHN3aXBlIGRpcmVjdGlvbi4gSWZcbiAgICogc3dpcGluZyByaWdodCBhbmQgbGFzdCBwYWdlIGlzIHNob3duLCBzd2lwaW5nIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50RnJhbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGxvY2tTd2lwZV8oY3VycmVudEZyYW1lKSB7XG4gICAgY29uc3QgcGFnaW5hdGlvbk1vZGVsID0gKHRoaXMuYWRhcHRlcl8uZ2V0UGFnaW5hdGlvbk1vZGVsKVxuICAgICAgICA/IHRoaXMuYWRhcHRlcl8uZ2V0UGFnaW5hdGlvbk1vZGVsKCkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBDaGVjayBpZiBjeWNsaWNhbCBmbGFnIGlzIHNldCB0byB0cnVlLCBubyBsb2NraW5nIG9uIGN5Y2xpY2FsLlxuICAgIGNvbnN0IGN5Y2xpY2FsID0gKHBhZ2luYXRpb25Nb2RlbCkgPyBwYWdpbmF0aW9uTW9kZWwuY3ljbGljYWwgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBHZXQgdG90YWwgcGFnZXMgYW5kIGN1cnJlbnQgcGFnZSBudW1iZXIuXG4gICAgY29uc3QgdG90YWxQYWdlcyA9IChwYWdpbmF0aW9uTW9kZWwpID8gcGFnaW5hdGlvbk1vZGVsLnRvdGFsUGFnZXMgOiAwO1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlID0gKHBhZ2luYXRpb25Nb2RlbCkgPyBwYWdpbmF0aW9uTW9kZWwuY3VycmVudFBhZ2UgOiAwO1xuXG4gICAgLy8gR2V0IHN3aXBlIGRpcmVjdGlvblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9ICh0aGlzLm5hdmlnYXRvcl8uY3VycmVudEZyYW1lID4gY3VycmVudEZyYW1lKVxuICAgICAgICA/IHN3aXBlRGlyZWN0aW9uLlNXSVBFX0xFRlQgOiBzd2lwZURpcmVjdGlvbi5TV0lQRV9SSUdIVDtcblxuICAgIC8vIElmIGxhc3QgcGFnZSBpcyBhY3RpdmUgYW5kIHVzZXIgaXMgc3dpcGluZyByaWdodFxuICAgIHJldHVybiAhISghY3ljbGljYWwgJiYgdG90YWxQYWdlcyA9PT0gY3VycmVudFBhZ2VcbiAgICAgICAgJiYgZGlyZWN0aW9uID09PSBzd2lwZURpcmVjdGlvbi5TV0lQRV9SSUdIVCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgYSBzd2lwZSBtdXN0IHN1cnBhc3MgdG8gYmUgY29uc2lkZXJlZCBhICdmbGljaycuXG4gKiBAY29uc3RcbiAqIEBwcml2YXRlIHtudW1iZXJ9XG4gKi9cblN3aXBlLkZMSUNLX0RJU1RBTkNFXyA9IDUwO1xuXG5cbi8qKlxuICogVGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyBhIHN3aXBlIHNob3VsZCBub3QgZXhjZWVkIHRvIGJlIGNvbnNpZGVyZWQgYVxuICogJ2ZsaWNrJy5cbiAqIEBjb25zdFxuICogQHByaXZhdGUge251bWJlcn1cbiAqL1xuU3dpcGUuRkxJQ0tfRFVSQVRJT05fID0gNTAwO1xuXG5leHBvcnQge1N3aXBlfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL3N3aXBlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSBzaW1wbGUgZnVuY3Rpb24gdG8gY3JlYXRlIGEgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQSBkZWJvdW5jZWQgZnVuY3Rpb24gd3JhcHMgYSBmdW5jdGlvbiwgYW5kIGRlbGF5IGl0cyBleGVjdXRpb24gZXZlcnkgdGltZVxuICogdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpcyBjYWxsZWQuIFRoaXMgaXMgZXF1aXZhbGVudCB0byBnb29nLmFzeW5jLkRlYm91bmNlclxuICogYnV0IGxpZ2h0ZXIgYW5kIGEgc2ltcGxlciBBUEkuXG4gKlxuICogQHNlZSBodHRwczovL2dsdWUtZG9jcy5hcHBzcG90LmNvbS9kb2NzL2NvbXBvbmVudHMvcmF3L2RlYm91bmNlXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAvLyBDYWxsIGEgZnVuY3Rpb24gMjUwbXMgYWZ0ZXIgdGhlIGxhc3Qgc2Nyb2xsIGV2ZW50IGZpcmVzLlxuICogdmFyIGhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uKCkge307XG4gKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZGVib3VuY2UoaGFuZGxlU2Nyb2xsLCAyNTApKTtcbiAqXG4gKi9cblxuXG5cbi8qKlxuICogQ29udmVuaWVuY2UgZmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQHRoaXMgeyFPYmplY3R9XG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRoZSBkZWxheSBpbiBtcyB1bnRpbCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIGV4ZWN1dGVkLlxuICogQHJldHVybiB7IUZ1bmN0aW9ufSBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgZGVib3VuY2UuRGVib3VuY2UoZm4sIGRlbGF5KTtcbiAgY29uc3Qgb3V0cHV0ID0gaW5zdGFuY2UuZGVib3VuY2UuYmluZChpbnN0YW5jZSk7XG5cbiAgLy8gTWFrZSBjYW5jZWwgQVBJIGF2YWlsYWJsZSBvbiB0aGUgcmV0dXJuZWQgZnVuY3Rpb25cbiAgY29uc3QgY2FuY2VsID0gKCgpID0+IHtcbiAgICBpbnN0YW5jZS5jYW5jZWwoKTtcblxuICAgIC8vIFJldHVybnMgdGhlIGRlYm91bmNlIGluc3RhbmNlIHRvIGFsbG93IGNoYWluaW5nIHdoZW4gdW5zdWJzY3JpYmluZyBmcm9tXG4gICAgLy8gYW4gZXZlbnQuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG4gIG91dHB1dC5jYW5jZWwgPSBjYW5jZWwuYmluZCh0aGlzKTtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbi8qKlxuICogRGVib3VuY2VzIGEgZnVuY3Rpb24gYWZ0ZXIgYSBnaXZlbiBkZWxheS5cbiAqL1xuY2xhc3MgRGVib3VuY2Uge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGhlIGRlbGF5IGluIG1zIHVudGlsIHRoZSBmdW5jdGlvbiBzaG91bGQgYmUgZXhlY3V0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmbiwgZGVsYXkpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmZuXyA9IGZuO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5kZWxheV8gPSBkZWxheTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P251bWJlcn0gSUQgb2YgdGhlIGxhc3QgZGVib3VuY2UgdGltZW91dCAqL1xuICAgIHRoaXMudGltZW91dElkXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRGVib3VuY2VzIGJ5IHJlaW5pdGlhbGl6aW5nIHRoZSB0aW1lciB1bnRpbCB0aGUgZnVuY3Rpb24gc2hvdWxkIGV4ZWN1dGUuXG4gICAqL1xuICBkZWJvdW5jZSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICB0aGlzLnRpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KHRoaXMuZm5fLCB0aGlzLmRlbGF5Xyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFueSBvbmdvaW5nIGRlYm91bmNpbmcgdGltZXIuXG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkXyk7XG4gIH1cbn1cblxuZGVib3VuY2UuRGVib3VuY2UgPSBEZWJvdW5jZTtcblxuXG5leHBvcnQge2RlYm91bmNlfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL2RlYm91bmNlL2RlYm91bmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtDYXJvdXNlbEltYWdlQWRhcHRlcn0gZnJvbSAnLi9hZGFwdGVyLmpzJztcbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnLi4vLi4vbWRjL2ZvdW5kYXRpb24uanMnO1xuXG4vKipcbiAqIEBmaW5hbCBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhQ2Fyb3VzZWxJbWFnZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBDYXJvdXNlbEltYWdlRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgTE9BREVEX0VWRU5UOiAnZ2x1ZWNhcm91c2VsaW1hZ2Vsb2FkZWQnLFxuICAgICAgVU5LTk9XTl9TSVpFX0lNQUdFX0VMRU1FTlRTOlxuICAgICAgICAgICcuZ2x1ZS1jYXJvdXNlbC1pbWFnZSwgW2RhdGEtZ2x1ZS1jYXJvdXNlbC1pbWFnZV0nLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQ2Fyb3VzZWxJbWFnZUFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihhZGFwdGVyKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaW5pdGlhbFdpZHRoXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaW5pdGlhbEhlaWdodF87XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLmxvYWRIYW5kbGVyXztcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5pbml0aWFsV2lkdGhfID0gdGhpcy5hZGFwdGVyLmdldFdpZHRoKCk7XG4gICAgdGhpcy5pbml0aWFsSGVpZ2h0XyA9IHRoaXMuYWRhcHRlci5nZXRIZWlnaHQoKTtcblxuICAgIC8vIEltYWdlIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkLCBzdG9wIGhlcmVcbiAgICBpZiAodGhpcy5hZGFwdGVyLmlzRmV0Y2hpbmdDb21wbGV0ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkSGFuZGxlcl8gPSB0aGlzLmhhbmRsZUxvYWRfLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVyTG9hZEhhbmRsZXIodGhpcy5sb2FkSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXIuZGVyZWdpc3RlckxvYWRIYW5kbGVyKHRoaXMubG9hZEhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTG9hZF8oKSB7XG4gICAgLy8gVGhlIGltYWdlIHNpemUgaGFzIGNoYW5nZWQgYWZ0ZXIgbG9hZGluZywgd2UgbmVlZCB0byBhc2sgdGhlIGNhcm91c2VsXG4gICAgLy8gdG8gdXBkYXRlIGl0cyBpbnRlcm5hbCBtZWFzdXJlbWVudHMuXG4gICAgY29uc3QgZGltZW5zaW9uc0hhdmVDaGFuZ2VkID1cbiAgICAgICAgKHRoaXMuYWRhcHRlci5nZXRXaWR0aCgpICE9IHRoaXMuaW5pdGlhbFdpZHRoXykgfHxcbiAgICAgICAgKHRoaXMuYWRhcHRlci5nZXRIZWlnaHQoKSAhPSB0aGlzLmluaXRpYWxIZWlnaHRfKTtcblxuICAgIGRpbWVuc2lvbnNIYXZlQ2hhbmdlZCAmJiB0aGlzLmFkYXB0ZXIubm90aWZ5TG9hZCgpO1xuICAgIHRoaXMuYWRhcHRlci5kZXJlZ2lzdGVyTG9hZEhhbmRsZXIodGhpcy5sb2FkSGFuZGxlcl8pO1xuICB9XG5cbn1cblxuZXhwb3J0IHtDYXJvdXNlbEltYWdlRm91bmRhdGlvbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9pbWFnZS9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtUb2dnbGVyfSBmcm9tICcuL3RvZ2dsZXInO1xuaW1wb3J0IHtWaXNpYmlsaXR5fSBmcm9tICcuL3RpbGVtYXAvdmlzaWJpbGl0eSc7XG5cblxuLyoqXG4gKiBBZGQgb3IgcmVtb3ZlIGNoaWxkIGVsZW1lbnRzIG9mIGEgY29udGFpbmVyIGJhc2VkIG9uIGEgZGlzcGxheSBtYXAuXG4gKi9cbmNsYXNzIEVsZW1lbnRzVG9nZ2xlciBleHRlbmRzIFRvZ2dsZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBjb250YWluZXJFbCBUaGUgZWxlbWVudHMgaW1tZWRpYXRlIHBhcmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lckVsKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuY29udGFpbmVyRWxfID0gY29udGFpbmVyRWw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZ2luYWwgbGlzdCBvZiBjaGlsZCBlbGVtZW50cy5cbiAgICAgKiBAcHJpdmF0ZSB7IUFycmF5PEVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMuZWxzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgdmlzaWJsZSBlbGVtZW50cywgYnV0IHdoZXJlIGVhY2ggZWxlbWVudCBpbmRleCBpcyBpZGVudGljYWxcbiAgICAgKiB0byBpdHMgYXNzb2NpYXRlZCB0aWxlIGluIHRoZSBkaXNwbGF5IG1hcC5cbiAgICAgKiBAcHJpdmF0ZSB7IUFycmF5PEVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMudmlzaWJsZUVsc01hcF8gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYWNoZSBvZiBhbGwgdGlsZSBlbGVtZW50cyBhbmQgdGhlIGNsb25lcyBjcmVhdGVkIHdoZW4gYSB0aWxlIGlzXG4gICAgICogdmlzaWJsZSBzZXZlcmFsIHRpbWVzIGluIHRoZSB2aWV3cG9ydC4gVGhlc2UgZWxlbWVudHMgYXJlIHJldXNlZCBhcyBtdWNoXG4gICAgICogYXMgcG9zc2libGUgZm9yIHBlcmZvcm1hbmNlIHNha2UuXG4gICAgICogQHByaXZhdGUgeyFBcnJheTxFbGVtZW50Pn1cbiAgICAgKi9cbiAgICB0aGlzLmVsQ2FjaGVfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGF2YWlsYWJsZSB0aWxlcy5cbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsZXNDb3VudF8gPSAwO1xuICB9XG5cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgdGlsZSBlbGVtZW50cyBiYXNlZCBvbiBhIGRpc3BsYXkgbWFwLlxuICAgKiBAcGFyYW0geyFBcnJheTxWaXNpYmlsaXR5Pn0gbmV3TWFwIEEgZGlzcGxheSBtYXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdG9nZ2xlRWxlbWVudHMobmV3TWFwKSB7XG4gICAgaWYgKHRoaXMuaXNNYXBJZGVudGljYWwobmV3TWFwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYWdlc0xlbiA9IHRoaXMudGlsZXNDb3VudF87XG4gICAgaWYgKCFwYWdlc0xlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvbGRNYXAgPSB0aGlzLnZpc2libGVFbHNNYXBfO1xuXG4gICAgLy8gRGlzcGxheSBtYXAgaXMgY2xvbmVkIHRvIHJlcGxhY2UgdmlzaWJsZSBpdGVtcyB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZWlyXG4gICAgLy8gYXNzb2NpYXRlZCBlbGVtZW50LlxuICAgIG5ld01hcCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShuZXdNYXApO1xuICAgIHZhciB2c2JIaWRkZW4gPSBWaXNpYmlsaXR5LkhJRERFTjtcblxuICAgIC8vIENvbnZlcnQgb2xkIGFuZCBuZXcgZGlzcGxheSBtYXBzIGludG8gYSB0ZW1wb3JhcnkgZGF0YSBtb2RlbC5cbiAgICAvLyBJZiBhbiBpdGVtIGlzIHZpc2libGUgKHBhcnRpYWxseSBvciBub3QpIGl0cyBUaWxlTWFwLlZpc2liaWxpdHkgdmFsdWVcbiAgICAvLyBpcyByZXBsYWNlZCBieSBpdHMgaW5kZXguIElmIGl0IGlzIG5vdCB2aXNpYmxlLCB0aGUgdmFsdWUgYmVjb21lc1xuICAgIC8vICdmYWxzZScuIEZvciBleGFtcGxlLCBnaXZlbiBhIHRpbGUgbWFwIG9mIDQgYXZhaWxhYmxlIHRpbGVzOlxuICAgIC8vXG4gICAgLy8gW1BBUlRJQUxMWSwgVklTSUJMRSwgUEFSVElBTExZLCBISURERU5dIOKGkiBbMCwgMSwgMiwgZmFsc2VdXG4gICAgLy9cbiAgICAvLyBbSElEREVOLCBISURERU4sIEhJRERFTiwgUEFSVElBTExZLCBWSVNJQkxFLCBWSVNJQkxFLCBQQVJUSUFMTFldXG4gICAgLy8g4oaSIFtmYWxzZSwgZmFsc2UsIGZhbHNlLCAzLCAwLCAxLCAyXVxuICAgIC8vXG4gICAgLy8gVGhpcyBkYXRhIG1vZGVsIG1ha2VzIGVhc2llciBjb21wYXJpbmcgb2xkIGFuZCBuZXcgZGlzcGxheSBtYXBzLCB0byBmaW5kXG4gICAgLy8gd2hpY2ggRE9NIGVsZW1lbnRzIG5lZWQgdG8gYmUgcHJlc2VydmVkLCBhZGRlZCBvciByZW1vdmVkLlxuICAgIHZhciByZXBsYWNlV2l0aEluZGV4ID0gZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgIC8vIEJhc2VkIG9uIHRoZSBwcm92ZW5hbmNlIG9mIHRoZSBkaXNwbGF5IG1hcCwgaXRlbSBjYW4gYmUgZWl0aGVyIGFcbiAgICAgIC8vIERPTSBlbGVtZW50IG9yIGEgVGlsZU1hcC5WaXNpYmlsaXR5IHZhbHVlLlxuICAgICAgcmV0dXJuIChpdGVtID4gdnNiSGlkZGVuIHx8ICEhaXRlbSkgPyBpbmRleCAlIHBhZ2VzTGVuIDogZmFsc2U7XG4gICAgfTtcbiAgICB2YXIgb2xkTWFwSW5kZXhlcyA9IG9sZE1hcC5tYXAocmVwbGFjZVdpdGhJbmRleCk7XG4gICAgdmFyIG5ld01hcEluZGV4ZXMgPSBuZXdNYXAubWFwKHJlcGxhY2VXaXRoSW5kZXgpO1xuXG4gICAgLy8gRmluZCBsYXJnZXN0IGludGVyc2VjdGlvbiBiZXR3ZWVuIG9sZCBhbmQgbmV3IG1hcHMuIFRoaXMgd2lsbCBkZXNjcmliZVxuICAgIC8vIHRoZSBjaGFpbiBvZiBET00gZWxlbWVudHMgdGhhdCBuZWVkIHRvIGJlIHByZXNlcnZlZC5cbiAgICB2YXIgaW50ZXJzZWN0ID0gRWxlbWVudHNUb2dnbGVyXG4gICAgICAgIC5nZXRNYXBzSW50ZXJzZWN0aW9uXyhvbGRNYXBJbmRleGVzLCBuZXdNYXBJbmRleGVzKTtcblxuICAgIC8vIEZpcnN0IHBhc3M6IHJlbW92ZSBlbGVtZW50cyBub24gdmlzaWJsZSBhbnltb3JlXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9sZE1hcC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGxhc3RJbmRleCA9IGludGVyc2VjdC5tYXAxICsgaW50ZXJzZWN0Lmxlbmd0aDtcbiAgICAgIHZhciBlbCA9IG9sZE1hcFtpXTtcblxuICAgICAgaWYgKGkgPCBpbnRlcnNlY3QubWFwMSB8fCBpID49IGxhc3RJbmRleCB8fCAhaW50ZXJzZWN0KSB7XG4gICAgICAgIC8vIEVsZW1lbnQgaXMgb3V0c2lkZSB0aGUgaW50ZXJzZWN0aW9uIGluIHRoZSBvbGQgbWFwIG9yIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uLCBzbyByZW1vdmUgaXQgZnJvbSBET00uXG4gICAgICAgIGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG5cbiAgICAgIH0gZWxzZSBpZiAoaSA+PSBpbnRlcnNlY3QubWFwMSAmJiBpIDwgbGFzdEluZGV4KSB7XG4gICAgICAgIC8vIEVsZW1lbnQgaXMgaW5zaWRlIHRoZSBpbnRlcnNlY3Rpb24gc28gaXQgc2hvdWxkIGJlIHByZXNlcnZlZCwgYWRkIGFcbiAgICAgICAgLy8gcmVmZXJlbmNlIHRvIHRoZSBuZXcgbWFwLlxuICAgICAgICB2YXIgbmV3SW5kZXggPSBpbnRlcnNlY3QubWFwMiArIGkgLSBpbnRlcnNlY3QubWFwMTtcbiAgICAgICAgbmV3TWFwW25ld0luZGV4XSA9IGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNlY29uZCBwYXNzOiBhZGQgbmV3bHkgdmlzaWJsZSBlbGVtZW50c1xuICAgIHZhciBmaXJzdEVsID0gbmV3TWFwW2ludGVyc2VjdC5tYXAyXSB8fCB0aGlzLmNvbnRhaW5lckVsXy5maXJzdENoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBuZXdNYXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChuZXdNYXBbaV0gPiB2c2JIaWRkZW4pIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5yZXVzZVBhZ2VFbGVtZW50XyhpKTtcblxuICAgICAgICAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBuZXcgYWRkZWQgZWxlbWVudFxuICAgICAgICBuZXdNYXBbaV0gPSBlbDtcblxuICAgICAgICBpZiAoaSA8IGludGVyc2VjdC5tYXAyKSB7XG4gICAgICAgICAgLy8gRWxlbWVudCBzaG91bGQgYmUgcHJlcGVuZGVkIGJlZm9yZSB0aGUgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgdGhpcy5jb250YWluZXJFbF8uaW5zZXJ0QmVmb3JlKGVsLCBmaXJzdEVsKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEVsZW1lbnQgc2hvdWxkIGJlIGFwcGVuZGVkIGFmdGVyIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsXy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnZpc2libGVFbHNNYXBfID0gbmV3TWFwO1xuICB9XG5cblxuICAvKipcbiAgICogUmVzdG9yZXMgYWxsIHRpbGVzIGFzIHRoZXkgaW5pdGlhbGx5IHdlcmUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVzZXRFbGVtZW50cygpIHtcbiAgICB2YXIgdnNiVmFsdWUgPSBWaXNpYmlsaXR5LlZJU0lCTEU7XG4gICAgdmFyIGRpc3BsYXlNYXAgPSBuZXcgQXJyYXkodGhpcy50aWxlc0NvdW50XykuZmlsbCh2c2JWYWx1ZSk7XG4gICAgdGhpcy50b2dnbGVFbGVtZW50cyhkaXNwbGF5TWFwKTtcblxuICAgIHRoaXMuY2FjaGVFbGVtZW50c18oKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGNhY2hlIG9mIHJlZmVyZW5jZXMgdG8gY2hpbGQgZWxlbWVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWNoZUVsZW1lbnRzXygpIHtcbiAgICB2YXIgZWxzID0gdGhpcy5jb250YWluZXJFbF8uY2hpbGRyZW47XG5cbiAgICB0aGlzLmVsc18gPSBbXTtcbiAgICB0aGlzLnZpc2libGVFbHNNYXBfID0gW107XG4gICAgdGhpcy5lbENhY2hlXyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGVsOyBlbCA9IGVsc1tpXTsgaSsrKSB7XG4gICAgICB0aGlzLmVsc18ucHVzaChlbCk7XG4gICAgICB0aGlzLnZpc2libGVFbHNNYXBfLnB1c2goZWwpO1xuICAgICAgdGhpcy5lbENhY2hlXy5wdXNoKGVsKTtcbiAgICB9XG5cbiAgICB0aGlzLnRpbGVzQ291bnRfID0gZWxzLmxlbmd0aDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIERPTSBlbGVtZW50IGZvciBhIHNwZWNpZmllZCB0aWxlIGluZGV4LiBJZiB0aGVyZSBpcyBubyBlbGVtZW50XG4gICAqIGF2YWlsYWJsZSAoaWUuIG5vdCBhZGRlZCB0byB0aGUgRE9NIHlldCksIGNyZWF0ZXMgYSBuZXcgY2xvbmUgYW5kIHN0b3Jlc1xuICAgKiBpdCBpbiBjYWNoZSBhcyBhIHNlY29uZGFyeSBjbG9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlIG1hcC5cbiAgICogQHJldHVybiB7IUVsZW1lbnR9IEEgRE9NIGVsZW1lbnQgZm9yIGEgdGlsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJldXNlUGFnZUVsZW1lbnRfKGkpIHtcbiAgICB2YXIgZWw7XG4gICAgdmFyIGogPSBpICUgdGhpcy50aWxlc0NvdW50XztcbiAgICB3aGlsZSAoaiA8IHRoaXMudGlsZXNDb3VudF8pIHtcbiAgICAgIGVsID0gdGhpcy5lbENhY2hlX1tqXTtcbiAgICAgIGlmIChlbCAmJiAhZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBSZXVzZSBhIGNhY2hlZCBlbGVtZW50LlxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgICBqICs9IHRoaXMudGlsZXNDb3VudF87XG4gICAgfVxuXG4gICAgLy8gQ2FuJ3QgZmluZCBhIGNhY2hlZCBlbGVtZW50IGF2YWlsYWJsZSBmb3IgdGhpcyB0aWxlLCBzbyBjcmVhdGUgYSBuZXdcbiAgICAvLyBjbG9uZVxuICAgIGVsID0gdGhpcy5lbHNfW2kgJSB0aGlzLnRpbGVzQ291bnRfXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgdGhpcy5lbENhY2hlX1tpXSA9IGVsO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG59XG5cblxuLyoqXG4gKiBMb29rcyBmb3IgYSBzdWItYXJyYXkgaW5zaWRlIGFuIGFycmF5LlxuICogQHBhcmFtIHshQXJyYXl9IHN1YiBBIHN1Yi1hcnJheSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSB7IUFycmF5fSBsaXN0IFRoZSBhcnJheSB3aGVyZSB0byBsb29rIHRoZSBzdWItYXJyYXkgaW50by5cbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHN1Yi1hcnJheSBpbiB0aGUgYXJyYXksIG9yIC0xIGlmXG4gKiAgICAgaXQgY291bGQgbm90IGJlIGZvdW5kLlxuICogQHByaXZhdGVcbiAqL1xuRWxlbWVudHNUb2dnbGVyLmlzQXJyYXlJbmNsdWRlZF8gPSBmdW5jdGlvbihzdWIsIGxpc3QpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjEgPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbjE7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gc3ViLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgaWYgKGxpc3RbaSArIGpdICE9PSBzdWJbal0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqID09IGxlbjIpIHtcbiAgICAgIC8vIFN1Y2Nlc3NmdWxseSBwYXJzZWQgYWxsIHN1Yi1hcnJheSwgdGhpcyBtZWFucyBpdCBpcyBlbnRpcmVseSBpbmNsdWRlZFxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIC8vIFN1Yi1hcnJheSBpcyBub3QgaW5jbHVkZWRcbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gZGlzcGxheSBtYXBzLlxuICogQHBhcmFtIHshQXJyYXk8bnVtYmVyfGJvb2xlYW4+fSBtYXAxIEEgbGlzdCBvZiBpbmRleGVzIG9mIHZpc2libGUgZWxlbWVudHMuXG4gKiBAcGFyYW0geyFBcnJheTxudW1iZXJ8Ym9vbGVhbj59IG1hcDIgQSBsaXN0IG9mIGluZGV4ZXMgb2YgdmlzaWJsZSBlbGVtZW50cy5cbiAqIEByZXR1cm4ge09iamVjdHxib29sZWFufSBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3b1xuICogICAgIGRpc3BsYXkgbWFwcywgb3IgZmFsc2UgaWYgdGhlcmUgd2FzIG5vIGludGVyc2VjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkVsZW1lbnRzVG9nZ2xlci5nZXRNYXBzSW50ZXJzZWN0aW9uXyA9IGZ1bmN0aW9uKG1hcDEsIG1hcDIpIHtcbiAgZm9yICh2YXIgbGVuID0gbWFwMS5sZW5ndGg7IGxlbiA+PSAxOyBsZW4tLSkge1xuICAgIGZvciAodmFyIGkxID0gMDsgaTEgPD0gbWFwMS5sZW5ndGggLSBsZW47IGkxKyspIHtcblxuICAgICAgaWYgKG1hcDFbaTFdID09PSBmYWxzZSB8fCBtYXAxW2kxICsgbGVuIC0gMV0gPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2xpY2UgPSBtYXAxLnNsaWNlKGkxLCBpMSArIGxlbik7XG4gICAgICB2YXIgaTIgPSBFbGVtZW50c1RvZ2dsZXIuaXNBcnJheUluY2x1ZGVkXyhzbGljZSwgbWFwMik7XG5cbiAgICAgIGlmIChpMiAhPSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgaW50ZXJzZWN0aW9uIGluIHRoZSBmaXJzdCBtYXBcbiAgICAgICAgICBtYXAxOiBpMSxcbiAgICAgICAgICAvLyBUaGUgaW5kZXggb2YgdGhlIGludGVyc2VjdGlvbiBpbiB0aGUgc2Vjb25kIG1hcFxuICAgICAgICAgIG1hcDI6IGkyLFxuICAgICAgICAgIC8vIFRoZSBsZW5ndGggb2YgdGhlIGludGVyc2VjdGlvblxuICAgICAgICAgIGxlbmd0aDogbGVuLFxuICAgICAgICAgIC8vIFRoZSBsaXN0IG9mIGl0ZW1zIGluIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgICAgICBzbGljZTogc2xpY2UsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE5vIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBtYXBzXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7RWxlbWVudHNUb2dnbGVyfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsL2VsZW1lbnRzdG9nZ2xlci5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbmltcG9ydCB7VmlzaWJpbGl0eX0gZnJvbSAnLi90aWxlbWFwL3Zpc2liaWxpdHknO1xuXG5cbi8qKlxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gZm9yIGEgY2xhc3MgdGhhdCB3aWxsIGFkZCBvciByZW1vdmUgdGlsZVxuICogZWxlbWVudHMgdG8gdGhlIERPTSBiYXNlZCBvbiBhIGRpc3BsYXkgbWFwLlxuICovXG5jbGFzcyBUb2dnbGVyIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBBIGNvcHkgb2YgdGhlIGxhc3QgYXBwbGllZCBkaXNwbGF5IG1hcC5cbiAgICAgKiBAcHJpdmF0ZSB7IUFycmF5PFZpc2liaWxpdHk+fVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudE1hcF8gPSBbXTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHRpbGUgZWxlbWVudHMgYmFzZWQgb24gYSBkaXNwbGF5IG1hcC5cbiAgICogQHBhcmFtIHshQXJyYXk8VmlzaWJpbGl0eT59IG5ld01hcCBBXG4gICAqICAgICBkaXNwbGF5IG1hcC5cbiAgICovXG4gIHRvZ2dsZUVsZW1lbnRzKG5ld01hcCkge31cblxuXG4gIC8qKlxuICAgKiBSZXN0b3JlcyBhbGwgZWxlbWVudHMgYXMgdGhleSBpbml0aWFsbHkgd2VyZS5cbiAgICovXG4gIHJlc2V0RWxlbWVudHMoKSB7fVxuXG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIGEgZGlzcGxheSBtYXAgd2l0aCB0aGUgbGFzdCBhcHBsaWVkLlxuICAgKiBAcGFyYW0geyFBcnJheTxWaXNpYmlsaXR5Pn0gbmV3TWFwIEEgZGlzcGxheSBtYXAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGRpc3BsYXkgbWFwIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBpc01hcElkZW50aWNhbChuZXdNYXApIHtcbiAgICB2YXIgaXNNYXBJdGVtSWRlbnRpY2FsID0gKGl0ZW0sIGksIG1hcCkgPT4ge1xuICAgICAgcmV0dXJuICEhbWFwW2ldID09ICEhdGhpcy5jdXJyZW50TWFwX1tpXTtcbiAgICB9O1xuICAgIGlmIChuZXdNYXAubGVuZ3RoID09IHRoaXMuY3VycmVudE1hcF8ubGVuZ3RoICYmXG4gICAgICAgIG5ld01hcC5ldmVyeShpc01hcEl0ZW1JZGVudGljYWwpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50TWFwXyA9IG5ld01hcC5zbGljZSgpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7VG9nZ2xlcn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9jYXJvdXNlbC9jYXJvdXNlbC90b2dnbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSBsaWdodHdlaWdodCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgT2JzZXJ2YWJsZSBwYXR0ZXJuLCB3aXRoXG4gKiBhIENsb3N1cmUtbGlrZSBBUEkuXG4gKi9cblxuXG5cbmNsYXNzIEV2ZW50VGFyZ2V0IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHByaXZhdGUgeyFMaXN0ZW5lck1hcH0gKi9cbiAgICB0aGlzLmxpc3RlbmVyc18gPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudC5cbiAgICogTm90ZTogVGhpcyBpbnRlcmZhY2UgZGlmZmVycyBmcm9tIHRoZSBDbG9zdXJlIGRpc3BhdGNoRXZlbnQgbWV0aG9kLiBUaGVcbiAgICogcGFyYW1ldGVycyBhcmUgZGlmZmVyZW50LiBTZWUge0Bjb2RlIGdvb2cuZXZlbnRzLkxpc3RlbmFibGUuZGlzcGF0Y2hFdmVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtFdmVudExpa2U9fSBldmVudERhdGEgQWRkaXRpb25hbCBldmVudCBkYXRhLlxuICAgKi9cbiAgZGlzcGF0Y2hFdmVudChldnRUeXBlLCBldmVudERhdGEgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0xpc3RfKGV2dFR5cGUpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsaXN0ZW5lcjsgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07IGkrKykge1xuICAgICAgbGlzdGVuZXIoZXZlbnREYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVucyB0byBhbiBldmVudCwgYW5kIGV4ZWN1dGVzIGEgaGFuZGxlciBmdW5jdGlvbiB3aGVuIGl0IGZpcmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgbGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0xpc3RfKGV2dFR5cGUpO1xuICAgIGxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGxpc3RlbmluZyB0byBhbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHVubGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0xpc3RfKGV2dFR5cGUpO1xuICAgIGZvciAobGV0IGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGggPSBsaXN0ZW5lcnNbaV07XG4gICAgICBpZiAoaCA9PSBoYW5kbGVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEByZXR1cm4geyFBcnJheTwhRnVuY3Rpb24+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGlzdGVuZXJzTGlzdF8oZXZ0VHlwZSkge1xuICAgIGlmICghdGhpcy5saXN0ZW5lcnNfW2V2dFR5cGVdKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc19bZXZ0VHlwZV0gPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzX1tldnRUeXBlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgb24gdGhlIGhvc3QgY29tcG9uZW50LlxuICAgKi9cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIGZvciAobGV0IGV2dFR5cGUgaW4gdGhpcy5saXN0ZW5lcnNfKSB7XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnNfLmhhc093blByb3BlcnR5KGV2dFR5cGUpKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzX1tldnRUeXBlXS5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy51bmxpc3RlbihldnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBBbHNvIHNlZSB7QGNvZGUgZ29vZy5ldmVudHMuRXZlbnRMaWtlfVxuICogQHR5cGVkZWYge3N0cmluZ3xPYmplY3R9XG4gKi9cbmxldCBFdmVudExpa2U7XG5cblxuLyoqIEB0eXBlZGVmIHshT2JqZWN0PHN0cmluZywgIUFycmF5PCFGdW5jdGlvbj4+fSAqL1xubGV0IExpc3RlbmVyTWFwO1xuXG5cbmV4cG9ydCB7RXZlbnRUYXJnZXQsIEV2ZW50TGlrZX07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi9ldmVudHMvZXZlbnR0YXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG5cbi8qKlxuICogQ2FsbHMgaGFuZGxlciBmdW5jdGlvbnMgd2hlbiB0aGUgZG9jdW1lbnQgb2JqZWN0IG1hdGNoZXMgYSBtZWRpYSBxdWVyeSwgb3JcbiAqIHdoZW4gYSBDU1MtaW5qZWN0ZWQgbmFtZWQgYnJlYWtwb2ludCBpcyBpbmNsdWRlZCBpbiBhIGxpc3Qgb2Ygc3RyaW5ncy4gQ2FuXG4gKiBhbHNvIGNhbGwgYW5vdGhlciBoYW5kbGVyIHdoZW4gb25lIG9mIHRoZSBjb25kaXRpb24gYWJvdmUgZG9lcyBub3QgYXBwbHlcbiAqIGFueW1vcmUuXG4gKlxuICogVGhpcyB0eXBpY2FsbHkgY2FuIGJlIHVzZWQgdG8gZW5hYmxlIG9yIGRpc2FibGUgYSBVSSBjb21wb25lbnQgYmFzZWQgb24gdGhlXG4gKiB2aWV3cG9ydCBzaXplLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogbmV3IFJlc3BvbnNpdmVNb25pdG9yKHtcbiAqICAgYnJlYWtwb2ludDogWydtZWRpdW0nLCAnbGFyZ2UnXSxcbiAqICAgZW50ZXI6IChzaXplKSA9PiBjb21wb25lbnQuc3RhcnQoKSxcbiAqICAgbGVhdmU6IChzaXplKSA9PiBjb21wb25lbnQuc3RvcCgpLFxuICogfSk7XG4gKlxuICogbmV3IFJlc3BvbnNpdmVNb25pdG9yKHtcbiAqICAgbWVkaWE6ICcobWluLXdpZHRoOiA2MDBweCknLFxuICogICB0cmFuc2Zvcm06IChtcWwpID0+IGNvbXBvbmVudC5zdGFydCgpLFxuICogICByZXZlcnQ6IChtcWwpID0+IGNvbXBvbmVudC5zdG9wKCksXG4gKiB9KTtcbiAqXG4gKiBuZXcgUmVzcG9uc2l2ZU1vbml0b3IoW3tcbiAqICAgbWVkaWE6ICcobWF4LXdpZHRoOiA0MDBweCknLFxuICogICB0cmFuc2Zvcm06IChtcWwpID0+IGNvbXBvbmVudDEuc3RhcnQoKSxcbiAqIH0sIHtcbiAqICAgbWVkaWE6ICcobWluLXdpZHRoOiA1MDFweCkgYW5kIChtYXgtd2lkdGg6IDgwMHB4KScsXG4gKiAgIHRyYW5zZm9ybTogY29tcG9uZW50Mi5zdGFydCgpLFxuICogfV0pO1xuICpcbiAqIEZvciBzaW1wbGVyIHVzZSBjYXNlcywgaXQgaXMgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgZnVuY3Rpb24gY2FsbGVkIGV2ZXJ5XG4gKiB0aW1lIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAqXG4gKiBjb25zdCBybSA9IG5ldyBSZXNwb25zaXZlTW9uaXRvcigpO1xuICogcm0ubGlzdGVuKChzaXplKSA9PiB7XG4gKiAgIGlmIChzaXplID09ICdtZWRpdW0nKSB7XG4gKiAgICAgY29tcG9uZW50LnN0YXJ0KCk7XG4gKiAgIH1cbiAqIH0pO1xuICovXG5jbGFzcyBSZXNwb25zaXZlTW9uaXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVzcG9uc2l2ZU1vbml0b3IuUnVsZVNldD19IGNvbmZpZ1J1bGVzIE9uZSBvciBzZXZlcmFsXG4gICAqICAgICBtZWRpYSBxdWVyaWVzIGFzc29jaWF0ZWQgd2l0aCBjYWxsYmFja3MgdG8gdHJpZ2dlciB3aGVuIHRoZWlyIHJlc3VsdFxuICAgKiAgICAgY2hhbmdlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZ1J1bGVzID0gW10pIHtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyZWQgbWVkaWEgcXVlcnkgcnVsZXM7XG4gICAgICogQHByaXZhdGUgeyFBcnJheTwhUmVzcG9uc2l2ZU1vbml0b3IuTWVkaWFRdWVyeVJ1bGVIYW5kbGVyTWFwPn1cbiAgICAgKi9cbiAgICB0aGlzLm1xUnVsZUhhbmRsZXJNYXBzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb25zIHVzZWQgdG8gbGlzdGVuIHRvIGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAgICAgKiBAcHJpdmF0ZSB7IUFycmF5PCFmdW5jdGlvbihzdHJpbmcpPn1cbiAgICAgKi9cbiAgICB0aGlzLmJwQ2hhbmdlSGFuZGxlcnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmVkIGJyZWFrcG9pbnQgcnVsZXMuXG4gICAgICogQHByaXZhdGUgeyFBcnJheTwhUmVzcG9uc2l2ZU1vbml0b3IuQnJlYWtwb2ludFJ1bGVIYW5kbGVyTWFwPn1cbiAgICAgKi9cbiAgICB0aGlzLmJwUnVsZUhhbmRsZXJNYXBzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbmFtZWQgYnJlYWtwb2ludC5cbiAgICAgKiBAcHJpdmF0ZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudEJyZWFrcG9pbnRfID0gdGhpcy5yZWFkQnJlYWtwb2ludF8oKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBuYW1lZCBicmVha3BvaW50LlxuICAgICAqIEBwcml2YXRlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wcmV2aW91c0JyZWFrcG9pbnRfID0gJyc7XG5cbiAgICAvLyBTZXR1cCBtZWRpYSBxdWVyeSBydWxlc1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWdSdWxlcykpIHtcbiAgICAgIGNvbmZpZ1J1bGVzID0gW2NvbmZpZ1J1bGVzXTtcbiAgICB9XG4gICAgY29uZmlnUnVsZXMuZm9yRWFjaCh0aGlzLmFkZFJ1bGVfLmJpbmQodGhpcykpO1xuXG4gICAgLy8gU2V0dXAgbmFtZWQgYnJlYWtwb2ludHMgbGlzdGVuaW5nXG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnZwVXBkYXRlSGFuZGxlcl8gPSB0aGlzLmhhbmRsZVZpZXdwb3J0VXBkYXRlXy5iaW5kKHRoaXMpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRSZWFkeScsIHRoaXMudnBVcGRhdGVIYW5kbGVyXyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMudnBVcGRhdGVIYW5kbGVyXyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy52cFVwZGF0ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIG1lZGlhIHF1ZXJ5IG9yIGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAgICogQHBhcmFtIHshRnVuY3Rpb258IVJlc3BvbnNpdmVNb25pdG9yLlJ1bGV9IGhhbmRsZXJcbiAgICovXG4gIGxpc3RlbihoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuYnBDaGFuZ2VIYW5kbGVyc18ucHVzaCgvKiogIUZ1bmN0aW9uICovIGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZFJ1bGVfKC8qKiAhUmVzcG9uc2l2ZU1vbml0b3IuUnVsZSAqLyBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgbGlzdGVuaW5nIHRvIG1lZGlhIHF1ZXJ5IG9yIGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAgICogQHBhcmFtIHshRnVuY3Rpb258IVJlc3BvbnNpdmVNb25pdG9yLlJ1bGV9IGhhbmRsZXJcbiAgICovXG4gIHVubGlzdGVuKGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGhhbmRsZXI7IGhhbmRsZXIgPSB0aGlzLmJwQ2hhbmdlSGFuZGxlcnNfW2ldOyBpKyspIHtcbiAgICAgICAgaWYgKGhhbmRsZXIgPT0gaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuYnBDaGFuZ2VIYW5kbGVyc18uc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVJ1bGVfKC8qKiAhUmVzcG9uc2l2ZU1vbml0b3IuUnVsZSAqLyBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgbGlzdGVuaW5nIHRvIGFsbCBtZWRpYSBxdWVyeSBhbmQgYnJlYWtwb2ludCBydWxlcy5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jdXJyZW50QnJlYWtwb2ludF8gPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwLCBtcTsgbXEgPSB0aGlzLm1xUnVsZUhhbmRsZXJNYXBzX1tpXTsgaSsrKSB7XG4gICAgICBtcS5tcWwucmVtb3ZlTGlzdGVuZXIobXEuaGFuZGxlcik7XG4gICAgfVxuXG4gICAgdGhpcy5tcVJ1bGVIYW5kbGVyTWFwc18gPSBbXTtcbiAgICB0aGlzLmJwUnVsZUhhbmRsZXJNYXBzXyA9IFtdO1xuICAgIHRoaXMuYnBDaGFuZ2VIYW5kbGVyc18gPSBbXTtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50UmVhZHknLCB0aGlzLnZwVXBkYXRlSGFuZGxlcl8pO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnZwVXBkYXRlSGFuZGxlcl8pO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMudnBVcGRhdGVIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBrbm93biBuYW1lZCBicmVha3BvaW50LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRDdXJyZW50QnJlYWtwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QnJlYWtwb2ludF87XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgY2FsbGJhY2sgZnVuY3Rpb25zIG9uIGEgbWVkaWEgcXVlcnkgb3IgYSBzZXQgb2YgbmFtZWQgYnJlYWtwb2ludHMuXG4gICAqIEBwYXJhbSB7IVJlc3BvbnNpdmVNb25pdG9yLlJ1bGV9IHJ1bGUgQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkUnVsZV8ocnVsZSkge1xuICAgIGNvbnN0IGJwUnVsZSA9IC8qKiBAdHlwZSB7UmVzcG9uc2l2ZU1vbml0b3IuQnJlYWtwb2ludFJ1bGV9ICovIChydWxlKTtcbiAgICBpZiAoYnBSdWxlLmJyZWFrcG9pbnQpIHtcbiAgICAgIHRoaXMuYWRkQnJlYWtwb2ludFJ1bGVfKGJwUnVsZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbXFSdWxlID0gLyoqIEB0eXBlIHtSZXNwb25zaXZlTW9uaXRvci5NZWRpYVF1ZXJ5UnVsZX0gKi8gKHJ1bGUpO1xuICAgIGlmIChtcVJ1bGUubWVkaWEpIHtcbiAgICAgIHRoaXMuYWRkTWVkaWFRdWVyeVJ1bGVfKG1xUnVsZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGUgY2FsbGJhY2sgZnVuY3Rpb25zIG9uIGEgbWVkaWEgcXVlcnkgb3IgYSBzZXQgb2YgbmFtZWQgYnJlYWtwb2ludHMuXG4gICAqIEBwYXJhbSB7IVJlc3BvbnNpdmVNb25pdG9yLlJ1bGV9IHJ1bGUgQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVtb3ZlUnVsZV8ocnVsZSkge1xuICAgIGNvbnN0IGJwUnVsZSA9IC8qKiBAdHlwZSB7UmVzcG9uc2l2ZU1vbml0b3IuQnJlYWtwb2ludFJ1bGV9ICovIChydWxlKTtcbiAgICBpZiAoYnBSdWxlLmJyZWFrcG9pbnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQnJlYWtwb2ludFJ1bGVfKGJwUnVsZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbXFSdWxlID0gLyoqIEB0eXBlIHtSZXNwb25zaXZlTW9uaXRvci5NZWRpYVF1ZXJ5UnVsZX0gKi8gKHJ1bGUpO1xuICAgIGlmIChtcVJ1bGUubWVkaWEpIHtcbiAgICAgIHRoaXMucmVtb3ZlTWVkaWFRdWVyeVJ1bGVfKG1xUnVsZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGNhbGxiYWNrIGZ1bmN0aW9ucyBvbiBhIHNldCBvZiBuYW1lZCBicmVha3BvaW50cy5cbiAgICogQHBhcmFtIHshUmVzcG9uc2l2ZU1vbml0b3IuQnJlYWtwb2ludFJ1bGV9IHJ1bGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZEJyZWFrcG9pbnRSdWxlXyhydWxlKSB7XG4gICAgY29uc3QgY2hlY2tCcmVha3BvaW50ID0gKHNpemUpID0+IHtcbiAgICAgIGNvbnN0IGJwcyA9IHJ1bGUuYnJlYWtwb2ludDtcbiAgICAgIGNvbnN0IGVudGVyQnJlYWtwb2ludCA9XG4gICAgICAgICAgYnBzLmluZGV4T2YodGhpcy5wcmV2aW91c0JyZWFrcG9pbnRfKSA9PSAtMSAmJlxuICAgICAgICAgIGJwcy5pbmRleE9mKHRoaXMuY3VycmVudEJyZWFrcG9pbnRfKSAhPSAtMTtcblxuICAgICAgaWYgKGVudGVyQnJlYWtwb2ludCkge1xuICAgICAgICBydWxlLmVudGVyKHNpemUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxlYXZlQnJlYWtwb2ludCA9XG4gICAgICAgICAgcnVsZS5sZWF2ZSAmJlxuICAgICAgICAgIGJwcy5pbmRleE9mKHRoaXMucHJldmlvdXNCcmVha3BvaW50XykgIT0gLTEgJiZcbiAgICAgICAgICBicHMuaW5kZXhPZih0aGlzLmN1cnJlbnRCcmVha3BvaW50XykgPT0gLTE7XG5cbiAgICAgIGlmIChsZWF2ZUJyZWFrcG9pbnQpIHtcbiAgICAgICAgcnVsZS5sZWF2ZShzaXplKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gS2VlcHMgcmVmZXJlbmNlcyBmb3IgbGF0ZXIgdW5yZWdpc3RyYXRpb24gcHVycG9zZXNcbiAgICB0aGlzLmJwUnVsZUhhbmRsZXJNYXBzXy5wdXNoKHtcbiAgICAgIHJ1bGU6IHJ1bGUsXG4gICAgICBoYW5kbGVyOiBjaGVja0JyZWFrcG9pbnQsXG4gICAgfSk7XG5cbiAgICBjaGVja0JyZWFrcG9pbnQodGhpcy5nZXRDdXJyZW50QnJlYWtwb2ludCgpKTtcbiAgICB0aGlzLmxpc3RlbihjaGVja0JyZWFrcG9pbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGUgY2FsbGJhY2sgZnVuY3Rpb25zIG9uIGEgc2V0IG9mIG5hbWVkIGJyZWFrcG9pbnRzLlxuICAgKiBAcGFyYW0geyFSZXNwb25zaXZlTW9uaXRvci5CcmVha3BvaW50UnVsZX0gcnVsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVtb3ZlQnJlYWtwb2ludFJ1bGVfKHJ1bGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgYnBNYXA7IGJwTWFwID0gdGhpcy5icFJ1bGVIYW5kbGVyTWFwc19baV07IGkrKykge1xuICAgICAgaWYgKGJwTWFwLnJ1bGUgPT0gcnVsZSkge1xuICAgICAgICB0aGlzLnVubGlzdGVuKGJwTWFwLmhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBjYWxsYmFjayBmdW5jdGlvbnMgb24gYSBtZWRpYSBxdWVyeS5cbiAgICogQHBhcmFtIHshUmVzcG9uc2l2ZU1vbml0b3IuTWVkaWFRdWVyeVJ1bGV9IHJ1bGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZE1lZGlhUXVlcnlSdWxlXyhydWxlKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLmhhbmRsZU1lZGlhUXVlcnlDaGFuZ2VfKHJ1bGUudHJhbnNmb3JtLCBydWxlLnJldmVydCk7XG4gICAgY29uc3QgaGFuZGxlciA9IGNhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgY29uc3QgbXFsID0gd2luZG93Lm1hdGNoTWVkaWEocnVsZS5tZWRpYSk7XG4gICAgbXFsLmFkZExpc3RlbmVyKGhhbmRsZXIpO1xuXG4gICAgLy8gS2VlcHMgcmVmZXJlbmNlcyBmb3IgbGF0ZXIgdW5yZWdpc3RyYXRpb24gcHVycG9zZXNcbiAgICB0aGlzLm1xUnVsZUhhbmRsZXJNYXBzXy5wdXNoKHtcbiAgICAgIHJ1bGU6IHJ1bGUsXG4gICAgICBtcWw6IG1xbCxcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgfSk7XG5cbiAgICAvLyBUcmlnZ2VycyBjYWxsYmFjayBhdCBvbmNlIGlmIHRoZSBtZWRpYSBxdWVyeSByZXN1bHQgaXMgdHJ1ZS5cbiAgICBpZiAobXFsLm1hdGNoZXMpIHtcbiAgICAgIGNhbGxiYWNrKG1xbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGUgY2FsbGJhY2sgZnVuY3Rpb25zIG9uIGEgbWVkaWEgcXVlcnkuXG4gICAqIEBwYXJhbSB7IVJlc3BvbnNpdmVNb25pdG9yLk1lZGlhUXVlcnlSdWxlfSBydWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW1vdmVNZWRpYVF1ZXJ5UnVsZV8ocnVsZSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBtcU1hcDsgbXFNYXAgPSB0aGlzLm1xUnVsZUhhbmRsZXJNYXBzX1tpXTsgaSsrKSB7XG4gICAgICBpZiAobXFNYXAucnVsZSA9PSBydWxlKSB7XG4gICAgICAgIG1xTWFwLm1xbC5yZW1vdmVMaXN0ZW5lcihtcU1hcC5oYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb3N1cmUgZnVuY3Rpb24gdGhhdCB3aWxsIHRyaWdnZXIgY2FsbGJhY2tzIGJhc2VkIG9uIHRoZSBtZWRpYVxuICAgKiBxdWVyeSdzIHJlc3VsdC5cbiAgICogQHBhcmFtIHshRnVuY3Rpb259IHRyYW5zZm9ybUZ1bmMgRnVuY3Rpb24gdG8gY2FsbCBpZiB0aGUgbWVkaWEgcXVlcnlcbiAgICogICAgIHJlc3VsdCBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0X3JldmVydEZ1bmMgRnVuY3Rpb24gdG8gY2FsbCBpZiB0aGUgbWVkaWEgcXVlcnlcbiAgICogICAgIHJlc3VsdCByZXZlcnRzIHRvIGZhbHNlLlxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oTWVkaWFRdWVyeUxpc3QpfSBBIGZ1bmN0aW9uIHVzZWQgYXMgaGFuZGxlciBvZiBhIG1lZGlhXG4gICAqICAgICBxdWVyeSBsaXN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTWVkaWFRdWVyeUNoYW5nZV8odHJhbnNmb3JtRnVuYywgb3B0X3JldmVydEZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obXFsKSB7XG4gICAgICBpZiAobXFsLm1hdGNoZXMpIHtcbiAgICAgICAgdHJhbnNmb3JtRnVuYyhtcWwpO1xuICAgICAgfSBlbHNlIGlmIChvcHRfcmV2ZXJ0RnVuYykge1xuICAgICAgICBvcHRfcmV2ZXJ0RnVuYyhtcWwpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYnJlYWtwb2ludCBjYWxsYmFja3MgaWYgdGhlIGN1cnJlbnQgbmFtZWQgYnJlYWtwb2ludCBwYXJzZWQgZnJvbSB0aGVcbiAgICogRE9NIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBwcmV2aW91cyBjYWxsLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVmlld3BvcnRVcGRhdGVfKCkge1xuICAgIGNvbnN0IGJyZWFrcG9pbnQgPSB0aGlzLnJlYWRCcmVha3BvaW50XygpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRCcmVha3BvaW50XyA9PSBicmVha3BvaW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2aW91c0JyZWFrcG9pbnRfID0gdGhpcy5jdXJyZW50QnJlYWtwb2ludF87XG4gICAgdGhpcy5jdXJyZW50QnJlYWtwb2ludF8gPSBicmVha3BvaW50O1xuXG4gICAgLy8gQ2FsbCBicmVha3BvaW50IGhhbmRsZXJzXG4gICAgZm9yIChsZXQgaSA9IDAsIGhhbmRsZXI7IGhhbmRsZXIgPSB0aGlzLmJwQ2hhbmdlSGFuZGxlcnNfW2ldOyBpKyspIHtcbiAgICAgIGhhbmRsZXIodGhpcy5jdXJyZW50QnJlYWtwb2ludF8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG5hbWVkIGJyZWFrcG9pbnQgY3VycmVudGx5IGluamVjdGVkIGluIERPTS5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVhZEJyZWFrcG9pbnRfKCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHksICc6YWZ0ZXInKTtcbiAgICBjb25zdCBjb250ZW50ID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2NvbnRlbnQnKTtcbiAgICBjb25zdCBicmVha3BvaW50ID0gY29udGVudC5yZXBsYWNlKC9bXCJcXCddL2csICcnKTtcbiAgICByZXR1cm4gYnJlYWtwb2ludDtcbiAgfVxuXG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHVuaXF1ZSBtb25pdG9yIGluc3RhbmNlLlxuICogQHJldHVybiB7IVJlc3BvbnNpdmVNb25pdG9yfVxuICovXG5SZXNwb25zaXZlTW9uaXRvci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIVJlc3BvbnNpdmVNb25pdG9yLmluc3RhbmNlXykge1xuICAgIFJlc3BvbnNpdmVNb25pdG9yLmluc3RhbmNlXyA9IG5ldyBSZXNwb25zaXZlTW9uaXRvcigpO1xuICB9XG4gIHJldHVybiBSZXNwb25zaXZlTW9uaXRvci5pbnN0YW5jZV87XG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIG1lZGlhOiBzdHJpbmcsXG4gKiAgIHRyYW5zZm9ybTogZnVuY3Rpb24oTWVkaWFRdWVyeUxpc3QpLFxuICogICByZXZlcnQ6ICh1bmRlZmluZWR8ZnVuY3Rpb24oTWVkaWFRdWVyeUxpc3QpKVxuICogfX1cbiAqL1xuUmVzcG9uc2l2ZU1vbml0b3IuTWVkaWFRdWVyeVJ1bGU7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAgcnVsZTogIVJlc3BvbnNpdmVNb25pdG9yLk1lZGlhUXVlcnlSdWxlLFxuICogICBtcWw6IE1lZGlhUXVlcnlMaXN0LFxuICogICBoYW5kbGVyOiBmdW5jdGlvbihNZWRpYVF1ZXJ5TGlzdClcbiAqIH19XG4gKi9cblJlc3BvbnNpdmVNb25pdG9yLk1lZGlhUXVlcnlSdWxlSGFuZGxlck1hcDtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHshe1xuICogICBicmVha3BvaW50OiAoc3RyaW5nfEFycmF5PHN0cmluZz4pLFxuICogICBlbnRlcjogZnVuY3Rpb24oc3RyaW5nKSxcbiAqICAgbGVhdmU6ICh1bmRlZmluZWR8ZnVuY3Rpb24oc3RyaW5nKSlcbiAqIH19XG4gKi9cblJlc3BvbnNpdmVNb25pdG9yLkJyZWFrcG9pbnRSdWxlO1xuXG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIHJ1bGU6ICFSZXNwb25zaXZlTW9uaXRvci5CcmVha3BvaW50UnVsZSxcbiAqICAgaGFuZGxlcjogZnVuY3Rpb24oc3RyaW5nKVxuICogfX1cbiAqL1xuUmVzcG9uc2l2ZU1vbml0b3IuQnJlYWtwb2ludFJ1bGVIYW5kbGVyTWFwO1xuXG5cbi8qKlxuICogQHR5cGVkZWYgeyhSZXNwb25zaXZlTW9uaXRvci5NZWRpYVF1ZXJ5UnVsZXxSZXNwb25zaXZlTW9uaXRvci5CcmVha3BvaW50UnVsZSl9XG4gKi9cblJlc3BvbnNpdmVNb25pdG9yLlJ1bGU7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7KCFSZXNwb25zaXZlTW9uaXRvci5SdWxlfCFBcnJheTwhUmVzcG9uc2l2ZU1vbml0b3IuUnVsZT4pfVxuICovXG5SZXNwb25zaXZlTW9uaXRvci5SdWxlU2V0O1xuXG5leHBvcnQge1Jlc3BvbnNpdmVNb25pdG9yfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL21xL3Jlc3BvbnNpdmVtb25pdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtNRENDb21wb25lbnR9IGZyb20gJy4uLy4uL21kYy9jb21wb25lbnQnO1xuaW1wb3J0IHtNb2RlbEZhY3Rvcnl9IGZyb20gJy4uL21vZGVsZmFjdG9yeSc7XG5pbXBvcnQge05leHRBZGFwdGVyfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtQYWdpbmF0aW9uTmV4dEZvdW5kYXRpb259IGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGZpbmFsIEBleHRlbmRzIHtNRENDb21wb25lbnQ8IVBhZ2luYXRpb25OZXh0Rm91bmRhdGlvbj59XG4gKi9cbmNsYXNzIFBhZ2luYXRpb25OZXh0IGV4dGVuZHMgTURDQ29tcG9uZW50IHtcblxuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgUGFnaW5hdGlvbk5leHQocm9vdCk7XG4gIH1cblxuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICBjb25zdCBwYWdpbmF0aW9uTW9kZWwgPVxuICAgICAgICBNb2RlbEZhY3RvcnkuZ2V0KHRoaXMucm9vdF8uZGF0YXNldFsnZ2x1ZVBhZ2luYXRpb24nXSk7XG5cbiAgICBjb25zdCAvKiogIU5leHRBZGFwdGVyICovIGFkYXB0ZXIgPSB7XG4gICAgICBnZXRQYWdpbmF0aW9uTW9kZWw6ICgpID0+IHBhZ2luYXRpb25Nb2RlbCxcbiAgICAgIHNldERpc2FibGVkOiAoZGlzYWJsZWQpID0+IHRoaXMucm9vdF8uZGlzYWJsZWQgPSBkaXNhYmxlZCxcbiAgICAgIGdldERhdGFBdHRyOiAobmFtZSkgPT4gdGhpcy5yb290Xy5kYXRhc2V0W25hbWVdLFxuICAgICAgcmVnaXN0ZXJDbGlja0hhbmRsZXI6IChoYW5kbGVyKSA9PiB0aGlzLmxpc3RlbignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJDbGlja0hhbmRsZXI6IChoYW5kbGVyKSA9PiB0aGlzLnVubGlzdGVuKCdjbGljaycsIGhhbmRsZXIpLFxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFBhZ2luYXRpb25OZXh0Rm91bmRhdGlvbihhZGFwdGVyKTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7UGFnaW5hdGlvbk5leHR9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9uZXh0L2NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbmltcG9ydCB7UGFnaW5hdGlvbk1vZGVsfSBmcm9tICcuLi9tb2RlbCc7XG5cbi8qKiBAcmVjb3JkICovXG5jbGFzcyBOZXh0QWRhcHRlciB7XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFQYWdpbmF0aW9uTW9kZWx9XG4gICAqL1xuICBnZXRQYWdpbmF0aW9uTW9kZWwoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXREYXRhQXR0cihuYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyQ2xpY2tIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyQ2xpY2tIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbn1cblxuZXhwb3J0IHtOZXh0QWRhcHRlcn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL25leHQvYWRhcHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJy4uLy4uL21kYy9mb3VuZGF0aW9uJztcbmltcG9ydCB7UGFnaW5hdGlvbk1vZGVsfSBmcm9tICcuLi9tb2RlbCc7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBGb3VuZGF0aW9uIGZvciBhIGNvbXBvbmVudCB0aGF0IHBhZ2luYXRlcyB0byB0aGUgbmV4dCBwYWdlIHdoZW4gY2xpY2tlZC5cbiAqIEBmaW5hbCBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhZ2x1ZS51aS5wYWdpbmF0aW9uLk5leHRBZGFwdGVyPn1cbiAqL1xuY2xhc3MgUGFnaW5hdGlvbk5leHRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKGFkYXB0ZXIpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshUGFnaW5hdGlvbk1vZGVsfSAqL1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZU1vZGVsID1cbiAgICAgICAgICB0aGlzLmFkYXB0ZXIuZ2V0RGF0YUF0dHIoJ2dsdWVQYWdpbmF0aW9uVXBkYXRlTW9kZWwnKSAhPSAnZmFsc2UnO1xuICAgICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLm5leHQodXBkYXRlTW9kZWwpO1xuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnVwZGF0ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy51cGRhdGVfKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXyA9IHRoaXMuYWRhcHRlci5nZXRQYWdpbmF0aW9uTW9kZWwoKTtcblxuICAgIHRoaXMuYWRhcHRlci5yZWdpc3RlckNsaWNrSGFuZGxlcih0aGlzLmNsaWNrSGFuZGxlcl8pO1xuXG4gICAgY29uc3Qge0NVUlJFTlRfUEFHRV9FVkVOVCwgVE9UQUxfUEFHRVNfRVZFTlR9ID0gc3RyaW5ncztcbiAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8ubGlzdGVuKENVUlJFTlRfUEFHRV9FVkVOVCwgdGhpcy51cGRhdGVIYW5kbGVyXyk7XG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLmxpc3RlbihUT1RBTF9QQUdFU19FVkVOVCwgdGhpcy51cGRhdGVIYW5kbGVyXyk7XG5cbiAgICB0aGlzLnVwZGF0ZV8oKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyLmRlcmVnaXN0ZXJDbGlja0hhbmRsZXIodGhpcy5jbGlja0hhbmRsZXJfKTtcblxuICAgIGNvbnN0IHtDVVJSRU5UX1BBR0VfRVZFTlQsIFRPVEFMX1BBR0VTX0VWRU5UfSA9IHN0cmluZ3M7XG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLnVubGlzdGVuKENVUlJFTlRfUEFHRV9FVkVOVCwgdGhpcy51cGRhdGVIYW5kbGVyXyk7XG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLnVubGlzdGVuKFRPVEFMX1BBR0VTX0VWRU5ULCB0aGlzLnVwZGF0ZUhhbmRsZXJfKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIERPTSBhdHRyaWJ1dGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlXygpIHtcbiAgICB0aGlzLmFkYXB0ZXIuc2V0RGlzYWJsZWQodGhpcy5wYWdpbmF0aW9uTW9kZWxfLmlzTGFzdCgpKTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7UGFnaW5hdGlvbk5leHRGb3VuZGF0aW9ufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dsdWUvbGliL3VpL3BhZ2luYXRpb24vbmV4dC9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbmltcG9ydCB7TURDQ29tcG9uZW50fSBmcm9tICcuLi8uLi9tZGMvY29tcG9uZW50JztcbmltcG9ydCB7TW9kZWxGYWN0b3J5fSBmcm9tICcuLi9tb2RlbGZhY3RvcnknO1xuaW1wb3J0IHtPcHRpb25zfSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHtQYWdlTGlzdEFkYXB0ZXJ9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge1BhZ2luYXRpb25QYWdlTGlzdEZvdW5kYXRpb259IGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQge2VuYWJsZSBhcyBjbG9zZXN0U2hpbUVuYWJsZX0gZnJvbSAnLi4vLi4vLi4vc2hpbS9lbGVtZW50L2Nsb3Nlc3QnO1xuXG5jbG9zZXN0U2hpbUVuYWJsZSgpO1xuXG4vKipcbiAqIEBmaW5hbCBAZXh0ZW5kcyB7TURDQ29tcG9uZW50PCFQYWdpbmF0aW9uUGFnZUxpc3RGb3VuZGF0aW9uPn1cbiAqL1xuY2xhc3MgUGFnaW5hdGlvblBhZ2VMaXN0IGV4dGVuZHMgTURDQ29tcG9uZW50IHtcblxuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdpbmF0aW9uUGFnZUxpc3Qocm9vdCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICBzdXBlcihyb290LCBmb3VuZGF0aW9uLCAuLi5hcmdzKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IU9wdGlvbnN8T2JqZWN0fSAqL1xuICAgIHRoaXMub3B0aW9uc187XG4gIH1cblxuICAvKiogQHBhcmFtIHshT3B0aW9uc3xPYmplY3Q9fSBvcHRpb25zICovXG4gIGluaXRpYWxpemUob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zXyA9IG9wdGlvbnM7XG4gIH1cblxuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICBjb25zdCBwYWdpbmF0aW9uTW9kZWwgPSBNb2RlbEZhY3RvcnkuZ2V0KFxuICAgICAgICB0aGlzLnJvb3RfLmRhdGFzZXRbJ2dsdWVQYWdpbmF0aW9uJ10pO1xuICAgIGNvbnN0IGNoaWxkRWxlbWVudHMgPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJyk7XG4gICAgY29uc3QgcGFnZUVsZW1lbnRzID0gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAnW2RhdGEtZ2x1ZS1wYWdpbmF0aW9uLXBhZ2VdJyk7XG5cbiAgICBsZXQgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oKSB7fTtcbiAgICBsZXQgYmx1ckhhbmRsZXJzXyA9IFtdO1xuICAgIGxldCBmb2N1c0hhbmRsZXJzXyA9IFtdO1xuXG4gICAgY29uc3QgLyoqICFQYWdlTGlzdEFkYXB0ZXIgKi8gYWRhcHRlciA9IHtcbiAgICAgIGdldFBhZ2luYXRpb25Nb2RlbDogKCkgPT4gcGFnaW5hdGlvbk1vZGVsLFxuICAgICAgc2V0QXJpYVNlbGVjdGVkOiAoaW5kZXgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGVsOyBlbCA9IHBhZ2VFbGVtZW50c1tpXTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZmxhZyA9IChpID09IGluZGV4IC0gMSk7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgZmxhZyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRBY3RpdmVCdXR0b246IChpbmRleCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZWw7IGVsID0gY2hpbGRFbGVtZW50c1tpXTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaXNBY3RpdmUgPSAoaSA9PSBpbmRleCAtIDEpO1xuICAgICAgICAgIGNvbnN0IHtBQ1RJVkV9ID0gUGFnaW5hdGlvblBhZ2VMaXN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgICAgICAgIC8vIGNsYXNzTGlzdC50b2dnbGUoKSdzIDJuZCBhcmd1bWVudCBuZXZlciBpbXBsZW1lbnRlZCBvbiBJRVxuICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChBQ1RJVkUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0VGFiSW5kZXg6IChpbmRleCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZWw7IGVsID0gcGFnZUVsZW1lbnRzW2ldOyBpKyspIHtcbiAgICAgICAgICAvLyBNYWtlIG9ubHkgdGhlIGFjdGl2ZSB0YWIgZm9jdXNhYmxlIHZpYSB0YWIuXG4gICAgICAgICAgY29uc3QgdGFiSW5kZXggPSAoaSA9PT0gaW5kZXggLSAxKSA/ICcwJyA6ICctMSc7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldEFyaWFMYWJlbDogKGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gcGFnZUVsZW1lbnRzW2luZGV4IC0gMV07XG4gICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgICAgIH0sXG4gICAgICBzZXRBcmlhTGFiZWw6IChpbmRleCwgbGFiZWwpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSBwYWdlRWxlbWVudHNbaW5kZXggLSAxXTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyQ2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICBjbGlja0hhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBwYWdlSWQgPVxuICAgICAgICAgICAgICBwYXJzZUludChldmVudC50YXJnZXQuZGF0YXNldFsnZ2x1ZVBhZ2luYXRpb25QYWdlJ10sIDEwKTtcbiAgICAgICAgICBwYWdlSWQgJiYgaGFuZGxlcihwYWdlSWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RlbignY2xpY2snLCBjbGlja0hhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJDbGlja0hhbmRsZXI6IChoYW5kbGVyKSA9PiB0aGlzLnVubGlzdGVuKCdjbGljaycsIGNsaWNrSGFuZGxlciksXG4gICAgICByZWdpc3RlcktleUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJLZXlIYW5kbGVyOiAoaGFuZGxlcikgPT4gdGhpcy51bmxpc3Rlbigna2V5ZG93bicsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJGb2N1c0hhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBlbDsgZWwgPSBwYWdlRWxlbWVudHNbaV07IGkrKykge1xuICAgICAgICAgIGNvbnN0IGZvY3VzSGFuZGxlciA9ICgpID0+IGhhbmRsZXIoaSArIDEpO1xuICAgICAgICAgIGZvY3VzSGFuZGxlcnNfW2ldID0gZm9jdXNIYW5kbGVyO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZm9jdXNIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJGb2N1c0hhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBlbDsgZWwgPSBwYWdlRWxlbWVudHNbaV07IGkrKykge1xuICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZm9jdXNIYW5kbGVyc19baV0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJCbHVySGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGVsOyBlbCA9IHBhZ2VFbGVtZW50c1tpXTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgYmx1ckhhbmRsZXIgPSAoKSA9PiBoYW5kbGVyKGkgKyAxKTtcbiAgICAgICAgICBibHVySGFuZGxlcnNfW2ldID0gYmx1ckhhbmRsZXI7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGJsdXJIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJCbHVySGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGVsOyBlbCA9IHBhZ2VFbGVtZW50c1tpXTsgaSsrKSB7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGJsdXJIYW5kbGVyc19baV0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0SGFzRm9jdXM6IChpc0ZvY3VzZWQpID0+IHtcbiAgICAgICAgaWYgKGlzRm9jdXNlZCkge1xuICAgICAgICAgIHRoaXMucm9vdF8uY2xhc3NMaXN0LmFkZChcbiAgICAgICAgICAgICAgUGFnaW5hdGlvblBhZ2VMaXN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzLklTX0ZPQ1VTRURfV0lUSElOKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJvb3RfLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgIFBhZ2luYXRpb25QYWdlTGlzdEZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5JU19GT0NVU0VEX1dJVEhJTik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmb2N1czogKGluZGV4KSA9PiB7XG4gICAgICAgIHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihgW2RhdGEtZ2x1ZS1wYWdpbmF0aW9uLXBhZ2U9XCIke2luZGV4fVwiXWApXG4gICAgICAgICAgICAuZm9jdXMoKTtcbiAgICAgIH0sXG4gICAgICBpc1J0bDogKCkgPT4gISF0aGlzLnJvb3RfLmNsb3Nlc3QoJ1tkaXI9cnRsXScpLFxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFBhZ2luYXRpb25QYWdlTGlzdEZvdW5kYXRpb24oYWRhcHRlciwgdGhpcy5vcHRpb25zXyk7XG4gIH1cblxufVxuXG5leHBvcnQge1BhZ2luYXRpb25QYWdlTGlzdH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL3BhZ2VsaXN0L2NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG5cbmltcG9ydCB7S2V5LCBLZXlDb2RlfSBmcm9tICcuLi8uLi8uLi9ldmVudHMva2V5JztcbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnLi4vLi4vbWRjL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtQYWdlTGlzdEFkYXB0ZXJ9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge09wdGlvbnN9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQge1BhZ2luYXRpb25Nb2RlbH0gZnJvbSAnLi4vbW9kZWwnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge3N0cmluZ3MgYXMgcGFnaW5hdGlvblN0cmluZ3N9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQge2hhbmRsZUFycm93S2V5fSBmcm9tICcuLi9rZXl1dGlsJztcblxuXG4vKipcbiAqIEZvdW5kYXRpb24gZm9yIGEgY29tcG9uZW50IHRoYXQgaGFuZGxlcyBhIGdyb3VwIG9mIGJ1dHRvbnMgd2hpY2gsIHdoZW5cbiAqIGNsaWNrZWQsIHBhZ2luYXRlIHRvIGEgc3BlY2lmaWMgcGFnZS4gQ29tcGFyZWQgdG8gdGhlIFRhYiBjb21wb25lbnQsIGl0IGFsc29cbiAqIGhhcyBzb21lIGExMXkgZmVhdHVyZXMgbGlrZSBwYXVzaW5nIGFueSBydW5uaW5nIHRpbWVyIHdoZW4gZm9jdXNlZCwgb3JcbiAqIHJlZGlyZWN0IHRoZSBmb2N1cyB0byB0aGUgbWFpbiBjb250ZW50IGVsZW1lbnQuXG4gKiBAZmluYWwgQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IVBhZ2VMaXN0QWRhcHRlcj59XG4gKi9cbmNsYXNzIFBhZ2luYXRpb25QYWdlTGlzdEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcblxuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUGFnZUxpc3RBZGFwdGVyfSBhZGFwdGVyXG4gICAqIEBwYXJhbSB7IU9wdGlvbnN8T2JqZWN0PX0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoYWRhcHRlcik7XG5cbiAgICAvKiogQHByaXZhdGUgeyFPcHRpb25zfSAqL1xuICAgIHRoaXMub3B0aW9uc18gPSAvKiogQHR5cGUgeyFPcHRpb25zfSAqLyAob3B0aW9ucyk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFQYWdpbmF0aW9uTW9kZWx9ICovXG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gKGluZGV4KSA9PiB0aGlzLmhhbmRsZVNlbGVjdFBhZ2VfKGluZGV4KTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLmtleUhhbmRsZXJfID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZUtleVByZXNzXyhldmVudCk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnVwZGF0ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy51cGRhdGVfKCk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLmZvY3VzSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUZvY3VzXygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUJsdXJfKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXyA9IHRoaXMuYWRhcHRlci5nZXRQYWdpbmF0aW9uTW9kZWwoKTtcblxuICAgIHRoaXMuYWRhcHRlci5yZWdpc3RlckNsaWNrSGFuZGxlcih0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlci5yZWdpc3RlcktleUhhbmRsZXIodGhpcy5rZXlIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVyRm9jdXNIYW5kbGVyKHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVyQmx1ckhhbmRsZXIodGhpcy5ibHVySGFuZGxlcl8pO1xuXG4gICAgY29uc3Qge0NVUlJFTlRfUEFHRV9FVkVOVH0gPSBwYWdpbmF0aW9uU3RyaW5ncztcbiAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8ubGlzdGVuKENVUlJFTlRfUEFHRV9FVkVOVCwgdGhpcy51cGRhdGVIYW5kbGVyXyk7XG5cbiAgICB0aGlzLnVwZGF0ZV8oKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyLmRlcmVnaXN0ZXJDbGlja0hhbmRsZXIodGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXIuZGVyZWdpc3RlcktleUhhbmRsZXIodGhpcy5rZXlIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyLmRlcmVnaXN0ZXJGb2N1c0hhbmRsZXIodGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXIuZGVyZWdpc3RlckJsdXJIYW5kbGVyKHRoaXMuYmx1ckhhbmRsZXJfKTtcblxuICAgIGNvbnN0IHtDVVJSRU5UX1BBR0VfRVZFTlR9ID0gcGFnaW5hdGlvblN0cmluZ3M7XG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLnVubGlzdGVuKENVUlJFTlRfUEFHRV9FVkVOVCwgdGhpcy51cGRhdGVIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgRE9NIGF0dHJpYnV0ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVfKCkge1xuICAgIHRoaXMuYWRhcHRlci5zZXRUYWJJbmRleCh0aGlzLnBhZ2luYXRpb25Nb2RlbF8uY3VycmVudFBhZ2UpO1xuICAgIHRoaXMuYWRhcHRlci5zZXRBcmlhU2VsZWN0ZWQodGhpcy5wYWdpbmF0aW9uTW9kZWxfLmN1cnJlbnRQYWdlKTtcbiAgICB0aGlzLmFkYXB0ZXIuc2V0QWN0aXZlQnV0dG9uKHRoaXMucGFnaW5hdGlvbk1vZGVsXy5jdXJyZW50UGFnZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTZWxlY3RQYWdlXyhpbmRleCkge1xuICAgIGlmIChpbmRleCAhPSB0aGlzLnBhZ2luYXRpb25Nb2RlbF8uY3VycmVudFBhZ2UpIHtcbiAgICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXy5jdXJyZW50UGFnZSA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8uc3RvcFRpbWVyKCk7XG4gICAgICAvLyBTaW5jZSB0aGUgY3VycmVudFBhZ2UgaGFzIG5vdCBjaGFuZ2VkIGhlcmUsIHdlIGFzc3VtZSB0aGF0IGl0c1xuICAgICAgLy8gYXNzb2NpYXRlZCBlbGVtZW50IGlzIGFscmVhZHkgdmlzaWJsZSBhbmQgZm9jdXNhYmxlIGluIHRoZSBET00uIFRoYXRcbiAgICAgIC8vIG1heSBub3QgbmVjZXNzYXJpbHkgdHJ1ZSBpbiB0aGUgY2FzZSB3aGVyZSB0aGVyZSBpcyBhIGRlbGF5IHVudGlsIHRoZVxuICAgICAgLy8gZWxlbWVudCBiZWNvbWVzIHZpc2libGUgYW5kIGZvY3VzYWJsZSwgZm9yIGluc3RhbmNlIHdpdGggYW4gYW5pbWF0ZWRcbiAgICAgIC8vIGNhcm91c2VsLiBJbiB0aGF0IGNhc2UsIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBnZXQgZm9jdXMgd2lsbCBub3RcbiAgICAgIC8vIG5lY2Vzc2FyeSBiZSB0aGUgb25lIGFzc29jaWF0ZWQgdG8gdGhlIHBhZ2luYXRpb24gYnV0dG9uIHRoYXRcbiAgICAgIC8vIHByZXZpb3VzbHkgaGFkIGZvY3VzLlxuICAgICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLmZvY3VzTWFpbkVsZW1lbnQoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgaGFuZGxlRm9jdXNfKCkge1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXy5zdG9wVGltZXIoKTtcbiAgICB0aGlzLmFkYXB0ZXIuc2V0SGFzRm9jdXModHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUJsdXJfKCkge1xuICAgIHRoaXMuYWRhcHRlci5zZXRIYXNGb2N1cyhmYWxzZSk7XG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLnN0YXJ0VGltZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgcGFnaW5hdGlvbiBtb2RlbCB0byB0aGUgbmV4dCBvciBwcmV2aW91cyBwYWdlIHdoZW4gdGhlIHVzZXIgdXNlc1xuICAgKiB0aGUgcmlnaHQvbGVmdCBhcnJvdyBrZXlzLiBNb3ZlcyBmb2N1cyB0byB0aGUgbmV3IGN1cnJlbnQgcGFnZSBidXR0b24uXG4gICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUtleVByZXNzXyhlKSB7XG4gICAgY29uc3QgaXNSdGwgPSB0aGlzLmFkYXB0ZXIuaXNSdGwoKTtcbiAgICBoYW5kbGVBcnJvd0tleShlLCB0aGlzLnBhZ2luYXRpb25Nb2RlbF8sIGlzUnRsLFxuICAgICAgICAocGFnZSkgPT4gdGhpcy5hZGFwdGVyLmZvY3VzKHBhZ2UpKTtcbiAgfVxufVxuXG5leHBvcnQge1BhZ2luYXRpb25QYWdlTGlzdEZvdW5kYXRpb259O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wYWdlbGlzdC9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnYWN0aXZlJyxcbiAgUEFHRV9MSVNUOiAnZ2x1ZS1vLXBhZ2luYXRpb25fX3BhZ2UtbGlzdCcsXG4gIFBBR0VfTElTVF9CVVRUT046ICdnbHVlLW8tcGFnaW5hdGlvbl9fcGFnZS1saXN0LWJ1dHRvbicsXG4gIFBBR0VfTElTVF9CVVRUT05fQ09OVEFJTkVSOiAnZ2x1ZS1vLXBhZ2luYXRpb25fX3BhZ2UtbGlzdC1idXR0b24tY29udGFpbmVyJyxcbiAgSVNfRk9DVVNFRF9XSVRISU46ICdnbHVlLWlzLWZvY3VzZWQtd2l0aGluJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgUEFHRV9QTEFDRUhPTERFUjogJ19QQUdFXycsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wYWdlbGlzdC9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGFuZGxpbmcga2V5Ym9hcmQgZXZlbnRzIGZvciBwYWdpbmF0aW9uLlxuICogQHBhY2thZ2VcbiAqL1xuXG5pbXBvcnQge0tleSwgS2V5Q29kZX0gZnJvbSAnLi4vLi4vZXZlbnRzL2tleS5qcyc7XG5pbXBvcnQge1BhZ2luYXRpb25Nb2RlbH0gZnJvbSAnLi9tb2RlbC5qcyc7XG5cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBhY3RpdmUgcGFnZSBvZiB0aGUgcGFnaW5hdGlvbiBjb21wb25lbnQgYmFzZWQgb24gbGVmdC9yaWdodFxuICogYXJyb3cga2V5IHByZXNzZXMgYW5kIGhhbmRsZXMgZm9jdXMuXG4gKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBlXG4gKiBAcGFyYW0geyFQYWdpbmF0aW9uTW9kZWx9IHBhZ2luYXRpb25Nb2RlbFxuICogQHBhcmFtIHtib29sZWFufSBpc1J0bCBGYWxzZSBpZiBsZWZ0IHRvIHJpZ2h0IGxhbmd1YWdlLiBUcnVlIGlmIHJpZ2h0IHRvIGxlZnRcbiAqICAgICBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IHRyaWdnZXJGb2N1cyBBIGZ1bmN0aW9uIHRvIHRyaWdnZXIgZm9jdXMgb24gYSB0YWIuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUFycm93S2V5KGUsIHBhZ2luYXRpb25Nb2RlbCwgaXNSdGwsIHRyaWdnZXJGb2N1cykge1xuICAvLyBga2V5YCBpcyB0aGUgbmV3IHN0YW5kYXJkIGJ1dCBpdCBpcyBpbiBkcmFmdCBmb3JtLiBTdXBwb3J0IGB3aGljaGAgYW5kXG4gIC8vIGBrZXlDb2RlYCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIGNvbnN0IGtleVByZXNzZWQgPSBlLmtleSB8fCBlLndoaWNoIHx8IGUua2V5Q29kZTtcblxuICAvLyBDcmVhdGUgYSByZXVzYWJsZSBmdW5jdGlvbiBmb3IgY29udmVuaWVuY2UgZm9yIGNoYW5naW5nIHRoZSBjdXJyZW50IHBhZ2VcbiAgLy8gdG8gdGhlIG5leHQgb3IgcHJldmlvdXMgcGFnZS5cbiAgY29uc3QgY2hhbmdlUGFnZSA9IChkaXJlY3Rpb24pID0+IHtcbiAgICAoZGlyZWN0aW9uID09PSAxKSA/XG4gICAgICAgIHBhZ2luYXRpb25Nb2RlbC5uZXh0KCkgOiBwYWdpbmF0aW9uTW9kZWwucHJldmlvdXMoKTtcblxuICAgIC8vIE1vdmUgZm9jdXMgdG8gdGhlIG5ldyBidXR0b24uXG4gICAgdHJpZ2dlckZvY3VzKHBhZ2luYXRpb25Nb2RlbC5jdXJyZW50UGFnZSk7XG4gIH07XG5cbiAgc3dpdGNoIChrZXlQcmVzc2VkKSB7XG4gICAgY2FzZSBLZXkuUklHSFQ6XG4gICAgY2FzZSBLZXlDb2RlLlJJR0hUOlxuICAgICAgLy8gRmxpcCBhcnJvdyBrZXkgZnVuY3Rpb25hbGl0eSBmb3IgcmlnaHQgdG8gbGVmdCBsYW5ndWFnZXMuXG4gICAgICBjaGFuZ2VQYWdlKGlzUnRsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgS2V5LkxFRlQ6XG4gICAgY2FzZSBLZXlDb2RlLkxFRlQ6XG4gICAgICBjaGFuZ2VQYWdlKGlzUnRsID8gMSA6IC0xKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlcyBFTlRFUiBrZXkgcHJlc3NlcyB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgcGFnZSBhc3NvY2lhdGVkXG4gKiB3aXRoIHRoaXMgdGFiIGFuZCBtb3ZlIHRoZSBrZXlib2FyZCBmb2N1cy5cbiAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGVcbiAqIEBwYXJhbSB7IVBhZ2luYXRpb25Nb2RlbH0gcGFnaW5hdGlvbk1vZGVsXG4gKiBAcGFyYW0ge251bWJlcn0gZm9jdXNlZFRhYlBhZ2UgVGhlIHBhZ2UgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogICAgIHRoYXQgcmVjZWl2ZWQgdGhlIGtleWJvYXJkIGV2ZW50LlxuICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gdHJpZ2dlckZvY3VzIEEgZnVuY3Rpb24gdG8gdHJpZ2dlciBmb2N1cyBvbiBhIHRhYi5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRW50ZXJLZXkoZSwgcGFnaW5hdGlvbk1vZGVsLCBmb2N1c2VkVGFiUGFnZSwgdHJpZ2dlckZvY3VzKSB7XG4gIGNvbnN0IGtleVByZXNzZWQgPSBlLmtleSB8fCBlLndoaWNoIHx8IGUua2V5Q29kZTtcblxuICBpZiAoa2V5UHJlc3NlZCA9PSBLZXkuRU5URVIgfHwga2V5UHJlc3NlZCA9PSBLZXlDb2RlLkVOVEVSKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHBhZ2luYXRpb25Nb2RlbC5jdXJyZW50UGFnZSA9IGZvY3VzZWRUYWJQYWdlO1xuICAgIC8vIFRyaWdnZXJpbmcgZm9jdXMgaXMgbmVjZXNzYXJ5IG9uIGEgZGVsYXkgYXMgc29tZSBzY3JlZW4gcmVhZGVyc1xuICAgIC8vIChDaHJvbWV2b3gpIHdlaXJkbHkgbW92ZSB0aGUgZm9jdXMgdG8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3RcbiAgICAvLyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGZpbmQgdGhlIGVsZW1lbnQgbWF0Y2hpbmcgdGhlIGlkIChhbmQgdGhlXG4gICAgLy8gZWxlbWVudCBkb2Vzbid0IGV4aXN0KS5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHRyaWdnZXJGb2N1cyhwYWdpbmF0aW9uTW9kZWwuY3VycmVudFBhZ2UpLCAxKTtcbiAgfVxufVxuXG5leHBvcnQge2hhbmRsZUFycm93S2V5LCBoYW5kbGVFbnRlcktleX07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi91aS9wYWdpbmF0aW9uL2tleXV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUG9seWZpbGwgZm9yIElFOSsgZm9yIGVsZW1lbnQuY2xvc2VzdCB3aGljaCBpc24ndCBzdXBwb3J0ZWRcbiAqIG5hdGl2ZWx5IHVudGlsIEVkZ2UgMTUrIGFuZCBub3Qgc3VwcG9ydGVkIGJ5IElFIGF0IGFsbC5cbiAqL1xuXG5cblxuLyoqXG4gKiBFbmFibGVzIHBvbHlmaWxsIGZvciBFbGVtZW50LmNsb3Nlc3QoKS5cbiAqIEBwYXJhbSB7V2luZG93PX0gd2luIFJlZmVyZW5jZSB0byBhIHdpbmRvdyBvYmplY3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwb2x5ZmlsbCBoYXMgYmVlbiBlbmFibGVkLiBXaWxsIGJlIGZhbHNlIGlmXG4gKiAgICAgYWxyZWFkeSBzdXBwb3J0ZWQgbmF0aXZlbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGUod2luID0gd2luZG93KSB7XG4gIGlmICghd2luLkVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QpIHtcbiAgICB3aW4uRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCA9XG4gICAgICAgIC8qKiBAdGhpcyB7d2luZG93LkVsZW1lbnR9ICovXG4gICAgICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICBpZiAoIXdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSByZXR1cm4gbnVsbDtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMocykpIHJldHVybiBlbDtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nbHVlL2xpYi9zaGltL2VsZW1lbnQvY2xvc2VzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG5pbXBvcnQge01EQ0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbWRjL2NvbXBvbmVudCc7XG5pbXBvcnQge01vZGVsRmFjdG9yeX0gZnJvbSAnLi4vbW9kZWxmYWN0b3J5JztcbmltcG9ydCB7UHJldmlvdXNBZGFwdGVyfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtQYWdpbmF0aW9uUHJldmlvdXNGb3VuZGF0aW9ufSBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG5cbi8qKlxuICogQGZpbmFsIEBleHRlbmRzIHtNRENDb21wb25lbnQ8IVBhZ2luYXRpb25QcmV2aW91c0ZvdW5kYXRpb24+fVxuICovXG5jbGFzcyBQYWdpbmF0aW9uUHJldmlvdXMgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdpbmF0aW9uUHJldmlvdXMocm9vdCk7XG4gIH1cblxuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICBjb25zdCBwYWdpbmF0aW9uTW9kZWwgPSBNb2RlbEZhY3RvcnkuZ2V0KFxuXG4gICAgICAgIHRoaXMucm9vdF8uZGF0YXNldFsnZ2x1ZVBhZ2luYXRpb24nXSk7XG5cbiAgICBjb25zdCAvKiogIVByZXZpb3VzQWRhcHRlciAqLyBhZGFwdGVyID0ge1xuICAgICAgZ2V0UGFnaW5hdGlvbk1vZGVsOiAoKSA9PiBwYWdpbmF0aW9uTW9kZWwsXG4gICAgICBzZXREaXNhYmxlZDogKGRpc2FibGVkKSA9PiB0aGlzLnJvb3RfLmRpc2FibGVkID0gZGlzYWJsZWQsXG4gICAgICBnZXREYXRhQXR0cjogKG5hbWUpID0+IHRoaXMucm9vdF8uZGF0YXNldFtuYW1lXSxcbiAgICAgIHJlZ2lzdGVyQ2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT4gdGhpcy5saXN0ZW4oJ2NsaWNrJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyQ2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT4gdGhpcy51bmxpc3RlbignY2xpY2snLCBoYW5kbGVyKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBQYWdpbmF0aW9uUHJldmlvdXNGb3VuZGF0aW9uKGFkYXB0ZXIpO1xuICB9XG5cbn1cblxuZXhwb3J0IHtQYWdpbmF0aW9uUHJldmlvdXN9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wcmV2aW91cy9jb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaW1wb3J0IHtQYWdpbmF0aW9uTW9kZWx9IGZyb20gJy4uL21vZGVsJztcblxuLyoqIEByZWNvcmQgKi9cbmNsYXNzIFByZXZpb3VzQWRhcHRlciB7XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFQYWdpbmF0aW9uTW9kZWx9XG4gICAqL1xuICBnZXRQYWdpbmF0aW9uTW9kZWwoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXREYXRhQXR0cihuYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyQ2xpY2tIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyQ2xpY2tIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbn1cblxuZXhwb3J0IHtQcmV2aW91c0FkYXB0ZXJ9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wcmV2aW91cy9hZGFwdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnLi4vLi4vbWRjL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtQYWdpbmF0aW9uTW9kZWx9IGZyb20gJy4uL21vZGVsJztcbmltcG9ydCB7c3RyaW5ncyBhcyBwYWdpbmF0aW9uU3RyaW5nc30gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEZvdW5kYXRpb24gZm9yIGEgY29tcG9uZW50IHRoYXQgcGFnaW5hdGVzIHRvIHRoZSBwcmV2aW91cyBwYWdlIHdoZW4gY2xpY2tlZC5cbiAqIEBmaW5hbCBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhZ2x1ZS51aS5wYWdpbmF0aW9uLlByZXZpb3VzQWRhcHRlcj59XG4gKi9cbmNsYXNzIFBhZ2luYXRpb25QcmV2aW91c0ZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoYWRhcHRlcik7XG5cbiAgICAvKiogQHByaXZhdGUgeyFQYWdpbmF0aW9uTW9kZWx9ICovXG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlTW9kZWwgPVxuICAgICAgICAgIHRoaXMuYWRhcHRlci5nZXREYXRhQXR0cignZ2x1ZVBhZ2luYXRpb25VcGRhdGVNb2RlbCcpICE9ICdmYWxzZSc7XG4gICAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8ucHJldmlvdXModXBkYXRlTW9kZWwpO1xuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnVwZGF0ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy51cGRhdGVfKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXyA9IHRoaXMuYWRhcHRlci5nZXRQYWdpbmF0aW9uTW9kZWwoKTtcblxuICAgIHRoaXMuYWRhcHRlci5yZWdpc3RlckNsaWNrSGFuZGxlcih0aGlzLmNsaWNrSGFuZGxlcl8pO1xuXG4gICAgY29uc3Qge0NVUlJFTlRfUEFHRV9FVkVOVCwgVE9UQUxfUEFHRVNfRVZFTlR9ID0gcGFnaW5hdGlvblN0cmluZ3M7XG4gICAgdGhpcy5wYWdpbmF0aW9uTW9kZWxfLmxpc3RlbihDVVJSRU5UX1BBR0VfRVZFTlQsIHRoaXMudXBkYXRlSGFuZGxlcl8pO1xuICAgIHRoaXMucGFnaW5hdGlvbk1vZGVsXy5saXN0ZW4oVE9UQUxfUEFHRVNfRVZFTlQsIHRoaXMudXBkYXRlSGFuZGxlcl8pO1xuXG4gICAgdGhpcy51cGRhdGVfKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlci5kZXJlZ2lzdGVyQ2xpY2tIYW5kbGVyKHRoaXMuY2xpY2tIYW5kbGVyXyk7XG5cbiAgICBjb25zdCB7Q1VSUkVOVF9QQUdFX0VWRU5ULCBUT1RBTF9QQUdFU19FVkVOVH0gPSBwYWdpbmF0aW9uU3RyaW5ncztcbiAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8udW5saXN0ZW4oQ1VSUkVOVF9QQUdFX0VWRU5ULCB0aGlzLnVwZGF0ZUhhbmRsZXJfKTtcbiAgICB0aGlzLnBhZ2luYXRpb25Nb2RlbF8udW5saXN0ZW4oVE9UQUxfUEFHRVNfRVZFTlQsIHRoaXMudXBkYXRlSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIERPTSBhdHRyaWJ1dGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlXygpIHtcbiAgICB0aGlzLmFkYXB0ZXIuc2V0RGlzYWJsZWQodGhpcy5wYWdpbmF0aW9uTW9kZWxfLmlzRmlyc3QoKSk7XG4gIH1cblxufVxuXG5leHBvcnQge1BhZ2luYXRpb25QcmV2aW91c0ZvdW5kYXRpb259O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2x1ZS9saWIvdWkvcGFnaW5hdGlvbi9wcmV2aW91cy9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzLCBldmVudHN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb3B0aW9ucyBkaWN0IHBhcnNlZCBmcm9tIERPTSBgbGItb3B0aW9ucz1gIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IGFjY29yZGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWZhdWx0T3BlbiAtIFdoZXRoZXIgYSBkcmF3ZXIgc2hvdWxkIGJlIG9wZW4gYnkgZGVmYXVsdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZGVmYXVsdEhpZGVBY2NvcmRpb24gLSBJbmRpY2F0ZXMgd2hldGhlciB0byBoaWRlIHRoZSBhY2NvcmRpb24gYnkgZGVmYXVsdC5cbiAqL1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9IC0gY29tcG9uZW50IHN0cmluZ3MgKi9cbmNvbnN0IHtMQUJFTF9BUklBfSA9IHN0cmluZ3M7XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gLSBjb21wb25lbnQgY2xhc3NlcyAqL1xuY29uc3Qge09QRU5fQ0xBU1MsXG4gICAgICAgVklTSUJMRV9DTEFTUyxcbiAgICAgICBIQVNfVE9HR0xFRF9DTEFTU30gPSBjc3NDbGFzc2VzO1xuXG4vKiogQGNvbnN0IHtudW1iZXJ9IC0gY29tcG9uZW50IG51bWJlcnMgKi9cbmNvbnN0IHtXQUlUX1VOVElMX1ZJU0lCTEVfVElNRSwgRU5URVJfS0VZfSA9IG51bWJlcnM7XG5cbmV4cG9ydCBjbGFzcyBMQkFjY29yZGlvbkZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBldmVudHM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRSb290OiAoKSA9PiAvKiBFbGVtZW50ICovIHt9LFxuICAgICAgZ2V0RHJhd2VySW5kZXhGcm9tRXZlbnQ6ICgvKiBldmVudDogRXZlbnQgKi8pID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0T3B0aW9uczogKCkgPT4gLyogT2JqZWN0ICovICh7fSksXG4gICAgICBnZXREcmF3ZXJzOiAoKSA9PiAvKiBBcnJheTogWVRBY2NvcmRpb25EcmF3ZXJDb21wb25lbnQgKi8gW10sXG4gICAgICBzZXRUb2dnbGVCdXR0b25BdHRyOiAoLyogYXR0cjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIG5vZGVFcXVhbHNUb2dnbGVCdXR0b246ICgvKiBldmVudDogRXZlbnQgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBhcHBlbmRDbGFzc0RyYXdlcnM6ICgvKiBzdHJpbmc6IGNsYXNzTmFtZSAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzc0RyYXdlcnM6ICgvKiBzdHJpbmc6IGNsYXNzTmFtZSAqLykgPT4ge30sXG4gICAgICBzZXREcmF3ZXJTdHlsZXM6ICgvKiBzdHlsZXM6IE9iamVjdCAqLykgPT4ge30sXG4gICAgICBkcmF3ZXJzSGF2ZU1hdGVyaWFsaXplZDogKC8qIHN0cmluZzogY2xhc3NOYW1lICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgYXBwZW5kQ2xhc3NUb2dnbGVCdXR0b246ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzc1RvZ2dsZUJ1dHRvbjogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGV2ZW50U3RvcFByb3BhZ2F0aW9uOiAoLyogZXZlbnQ6IEV2ZW50ICovKSA9PiB7fSxcbiAgICAgIGV2ZW50UHJldmVudERlZmF1bHQ6ICgvKiBldmVudDogRXZlbnQgKi8pID0+IHt9LFxuICAgICAgZW5hYmxlRHJhd2Vyc1RhYlN0YXRlOiAoKSA9PiB7fSxcbiAgICAgIGF0dGFjaEludGVyYWN0aW9uSGFuZGxlcjogKFxuICAgICAgICAgIC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXRhY2hJbnRlcmFjdGlvbkhhbmRsZXI6IChcbiAgICAgICAgICAvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgYXR0YWNoUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGV0YWNoUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihMQkFjY29yZGlvbkZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFhY2NvcmRpb25PcHRpb25zfSAqL1xuICAgIHRoaXMub3B0aW9uc18gPSB0aGlzLmFkYXB0ZXJfLmdldE9wdGlvbnMoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3Qge3N0cmluZ30gKi9cbiAgICB0aGlzLnJvb3RfID0gdGhpcy5hZGFwdGVyXy5nZXRSb290KCk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5vcGVuRHJhd2Vyc18gPSBmYWxzZTtcblxuICAgIC8vIENsaWNrIEhhbmRsZXJcbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAoZXZlbnQpID0+IHRoaXMudG9nZ2xlQXBwYXJhdHVzXyhldmVudCk7XG5cbiAgICAvLyBSZXNpemUgSGFuZGxlclxuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmNvbXB1dGVEcmF3ZXJSZXNpemVfKCk7XG5cbiAgICAvLyBLZXlib2FyZCBIYW5kbGVyXG4gICAgdGhpcy5rZXlib2FyZEhhbmRsZXJfID0gKGV2ZW50KSA9PiB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSBFTlRFUl9LRVk6XG4gICAgICAgICAgdGhpcy50b2dnbGVBcHBhcmF0dXNfKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gT3Blbi9DbG9zZS9Ub2dnbGUgRHJhd2VyIEhhbmRsZXJzXG4gICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5PUEVOX0RSQVdFUiwgKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LmlzRXF1YWxOb2RlKHRoaXMucm9vdF8pKSB7XG4gICAgICAgICAgdGhpcy5vcGVuRHJhd2VyQnlJbmRleChlLmRldGFpbC5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5DTE9TRV9EUkFXRVIsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldC5pc0VxdWFsTm9kZSh0aGlzLnJvb3RfKSkge1xuICAgICAgICAgIHRoaXMuY2xvc2VEcmF3ZXJCeUluZGV4KGUuZGV0YWlsLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzLlRPR0dMRV9EUkFXRVIsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldC5pc0VxdWFsTm9kZSh0aGlzLnJvb3RfKSkge1xuICAgICAgICAgIHRoaXMudG9nZ2xlRHJhd2VyQnlJbmRleChlLmRldGFpbC5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGFsbCB0aGUgZW50aXJlIGFjY29yZGlvbiBlbGVtZW50cyB2aXNpYmxlLlxuICAgKi9cbiAgbWFrZUFjY29yZGlvblZpc2libGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXREcmF3ZXJTdHlsZXMoe1xuICAgICAgJ2hlaWdodCc6ICdhdXRvJyxcbiAgICB9KTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hcHBlbmRDbGFzc0RyYXdlcnMoVklTSUJMRV9DTEFTUyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFwcGVuZENsYXNzVG9nZ2xlQnV0dG9uKEhBU19UT0dHTEVEX0NMQVNTKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VG9nZ2xlQnV0dG9uQXR0cihcbiAgICAgICAgICBMQUJFTF9BUklBLCB0aGlzLm9wdGlvbnNfLm9wZW5BbGxGYXFUZXh0KTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZW5hYmxlRHJhd2Vyc1RhYlN0YXRlKCk7XG4gICAgfSwgV0FJVF9VTlRJTF9WSVNJQkxFX1RJTUUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGVnYXRlcyBldmVudCBvbiBhY2NvcmRpb24gZHJhd2Vyc1xuICAgKiBhbmQgb24gdG9nZ2xlIGFsbCBidXR0b24uXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdG9nZ2xlQXBwYXJhdHVzXyhldmVudCkge1xuICAgIC8vIENoZWNrIGlmIGBldmVudC50YXJnZXRgIGlzIHRoZSB0b2dnbGUgYWxsIGJ1dHRvbi5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5ub2RlRXF1YWxzVG9nZ2xlQnV0dG9uKGV2ZW50KSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9uc18uZGVmYXVsdEhpZGVBY2NvcmRpb24gJiZcbiAgICAgICAgICF0aGlzLmFkYXB0ZXJfLmRyYXdlcnNIYXZlTWF0ZXJpYWxpemVkKCkpIHtcbiAgICAgICAgdGhpcy5tYWtlQWNjb3JkaW9uVmlzaWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5nZXREcmF3ZXJzKClcbiAgICAgICAgICAgIC5mb3JFYWNoKChkcmF3ZXIpID0+IHRoaXMuc2V0RHJhd2VyTGV2ZXJfKGRyYXdlcikpO1xuXG4gICAgICAgIHRoaXMuc3RhbXBUb2dnbGVCdXR0b25TdGF0ZV8oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0RHJhd2VySW5kZXhGcm9tRXZlbnQoZXZlbnQpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0RHJhd2VyQnlJbmRleChpbmRleCkub3BlblNodXREcmF3ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgZHJhd2VyIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSAwLWJhc2VkIGluZGV4IG9mIHRoZSBkcmF3ZXIgdG8gZ2V0LlxuICAgKi9cbiAgZ2V0RHJhd2VyQnlJbmRleChpbmRleCkge1xuICAgIGNvbnN0IGRyYXdlciA9IHRoaXMuYWRhcHRlcl8uZ2V0RHJhd2VycygpW2luZGV4XTtcbiAgICByZXR1cm4gZHJhd2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIGEgZHJhd2VyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIDAtYmFzZWQgaW5kZXggb2YgdGhlIGRyYXdlciB0byBvcGVuLlxuICAgKi9cbiAgb3BlbkRyYXdlckJ5SW5kZXgoaW5kZXgpIHtcbiAgICB0aGlzLmdldERyYXdlckJ5SW5kZXgoaW5kZXgpLm9wZW5EcmF3ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgYSBkcmF3ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgMC1iYXNlZCBpbmRleCBvZiB0aGUgZHJhd2VyIHRvIGNsb3NlLlxuICAgKi9cbiAgY2xvc2VEcmF3ZXJCeUluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5nZXREcmF3ZXJCeUluZGV4KGluZGV4KS5zaHV0RHJhd2VyKCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyBhIGRyYXdlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSAwLWJhc2VkIGluZGV4IG9mIHRoZSBkcmF3ZXIgdG8gdG9nZ2xlLlxuICAgKi9cbiAgdG9nZ2xlRHJhd2VyQnlJbmRleChpbmRleCkge1xuICAgIHRoaXMuZ2V0RHJhd2VyQnlJbmRleChpbmRleCkub3BlblNodXREcmF3ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRvZ2dsZSBidXR0b24gc3RhdGUgY2xhc3NlcywgYXR0cmlidXRlcywgYW5kIGZsYWdzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhbXBUb2dnbGVCdXR0b25TdGF0ZV8oKSB7XG4gICAgaWYgKHRoaXMub3BlbkRyYXdlcnNfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzVG9nZ2xlQnV0dG9uKE9QRU5fQ0xBU1MpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUb2dnbGVCdXR0b25BdHRyKFxuICAgICAgICAgIExBQkVMX0FSSUEsIHRoaXMub3B0aW9uc18ub3BlbkFsbEZhcVRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFwcGVuZENsYXNzVG9nZ2xlQnV0dG9uKE9QRU5fQ0xBU1MpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUb2dnbGVCdXR0b25BdHRyKFxuICAgICAgICAgIExBQkVMX0FSSUEsIHRoaXMub3B0aW9uc18uc2h1dEFsbEZhcVRleHQpO1xuICAgIH1cblxuICAgIC8vIEZsaXAgY3VycmVudCBzdGF0ZSBvZiBgb3BlbkRyYXdlcnNfYCBmbGFnO1xuICAgIHRoaXMub3BlbkRyYXdlcnNfID0gIXRoaXMub3BlbkRyYXdlcnNfO1xuICB9XG5cbiAvKipcbiAgKiBPcGVucyBvciBzaHV0cyBhY2NvcmRpb24gZHJhd2VycyBjb250aW5nZW50IG9uIGBvcGVuRHJhd2Vyc19gIGZsYWcuXG4gICogQHByaXZhdGVcbiAgKi9cbiAgc2V0RHJhd2VyTGV2ZXJfKGRyYXdlcikge1xuICAgIGlmICh0aGlzLm9wZW5EcmF3ZXJzXykge1xuICAgICAgZHJhd2VyLnNodXREcmF3ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd2VyLm9wZW5EcmF3ZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9vcHMgdGhyb3VnaCBhbGwgZHJhd2VycyBhbmQgcmUtY29tcHV0ZSBoZWlnaHQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wdXRlRHJhd2VyUmVzaXplXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmdldERyYXdlcnMoKS5mb3JFYWNoKChkcmF3ZXIpID0+XG4gICAgICAgIGRyYXdlci5jb21wdXRlRHJhd2VySGVpZ2h0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBhY2NvcmRpb24uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGV0YWNoSW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXRhY2hJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWJvYXJkSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGV0YWNoUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VzIG9wdGlvbnMgbWFwIHRvIGNvbmZpZ3VyZSBzcGVjaWFsIGFjY29yZGlvbiBjaGFyYWN0ZXJpc3Rjcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbmZpZ3VyZUFjY29yZGlvbl8oKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnNfLmRlZmF1bHRIaWRlQWNjb3JkaW9uKSB7XG4gICAgICB0aGlzLm1ha2VBY2NvcmRpb25WaXNpYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0RHJhd2VyU3R5bGVzKHsnaGVpZ2h0JzogMH0pO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBvcGVuIGEgZHJhd2VyIGJ5IGRlZmF1bHQuXG4gICAgaWYgKHRoaXMub3B0aW9uc18uaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRPcGVuJykpIHtcbiAgICAgIGNvbnN0IGRyYXdlciA9IHRoaXMuYWRhcHRlcl8uZ2V0RHJhd2VycygpW3RoaXMub3B0aW9uc18uZGVmYXVsdE9wZW5dO1xuICAgICAgZHJhd2VyLm9wZW5TaHV0RHJhd2VyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGFjY29yZGlvbiBzdGF0ZXMgYW5kIGJpbmQgZXZlbnQgaGFuZGxlcnMuXG4gICAqL1xuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYXR0YWNoSW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlib2FyZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmF0dGFjaEludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYXR0YWNoUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmNvbmZpZ3VyZUFjY29yZGlvbl8oKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24vZm91bmRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UnO1xuXG4vKiogQGNvbnN0IHtudW1iZXJ9IC0gY29tcG9uZW50IG51bWJlcnMgKi9cbmNvbnN0IHtFU0NBUEVfS0VZLCBFTlRFUl9LRVl9ID0gbnVtYmVycztcblxuLyoqIEBjb25zdCB7c3RyaW5nfSAtIGNvbXBvbmVudCBjbGFzc2VzICovXG5jb25zdCB7T1BFTl9DTEFTUywgQUNUSVZFX0NMQVNTfSA9IGNzc0NsYXNzZXM7XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gLSBjb21wb25lbnQgc3RyaW5ncyAqL1xuY29uc3Qge1xuICAgIERSQVdFUl9JTkRFWF9LRVksXG4gICAgSElEREVOX0FSSUEsXG4gICAgRVhQQU5ERURfQVJJQSxcbiAgICBDT05UUk9MU19BUklBLFxuICAgIElELFxuICAgIElEX1BSRUZJWCxcbiAgICBPUEVOX1RSQU5TSVRJT04sXG4gICAgU0hVVF9UUkFOU0lUSU9OfSA9IHN0cmluZ3M7XG5cbmV4cG9ydCBjbGFzcyBMQkFjY29yZGlvbkRyYXdlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgIC8qKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cbiAgIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCBudW1iZXI+fSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXREcmF3ZXJSb290OiAoKSA9PiAvKiBFbGVtZW50ICovIHt9LFxuICAgICAgZ2V0RHJhd2VyQm9keTogKCkgPT4gLyogRWxlbWVudCAqLyB7fSxcbiAgICAgIGdldERyYXdlckhlYWQ6ICgpID0+IC8qIEVsZW1lbnQgKi8ge30sXG4gICAgICBnZXREcmF3ZXJJbmRleDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBzZXREcmF3ZXJCb2R5QXR0cjogKC8qIGF0dHJOYW1lczogT2JqZWN0ICovKSA9PiB7fSxcbiAgICAgIHNldERyYXdlckhlYWRBdHRyOiAoLyogYXR0ck5hbWVzOiBPYmplY3QgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlRHJhd2VyQm9keUF0dHI6ICgvKiBhdHRyTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZURyYXdlckhlYWRBdHRyOiAoLyogYXR0ck5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXREcmF3ZXJSb290QXR0cjogKC8qIGF0dHJOYW1lOiBzdHJpbmcgKi8pID0+IC8qIHN0cmluZyAqLyAnJyxcbiAgICAgIGdldERyYXdlckJvZHlBdHRyOiAoLyogYXR0ck5hbWU6IHN0cmluZyAqLykgPT4gLyogc3RyaW5nICovICcnLFxuICAgICAgZ2V0RHJhd2VySGVhZEF0dHI6ICgvKiBhdHRyTmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmcgKi8gJycsXG4gICAgICBnZXREcmF3ZXJCb2R5SGVpZ2h0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIHNldERyYXdlckJvZHlTdHlsZTogKC8qIHByb3BlcnR5TmFtZXM6IE9iamVjdCAqLykgPT4ge30sXG4gICAgICBhcHBlbmRDbGFzc0RyYXdlckJvZHk6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzc0RyYXdlckJvZHk6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBhcHBlbmRDbGFzc0RyYXdlclJvb3Q6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzc0RyYXdlclJvb3Q6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBwcm9iZURPTUZvckNvbnRyb2xsZXI6ICgpID0+ICAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgZXZlbnRTdG9wUHJvcGFnYXRpb246ICgvKiBldmVudDogRXZlbnQgKi8pID0+IHt9LFxuICAgICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6ICgpID0+IC8qIE5vZGVMaXN0ICovIHt9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogKC8qIGVsZW1lbnQ6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZTogKC8qIGVsZW1lbnQ6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgcHJldmVudEVsZW1lbnRUYWI6ICgvKiBlbGVtZW50OiBFbGVtZW50ICovKSA9PiB7fSxcbiAgICAgIG5hbWVFcXVhbHNFdmVudFByb3BlcnR5OiAoXG4gICAgICAvKiBldmVudDogRXZlbnQsIHByb3BlcnR5TmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgZHJhd2VySGVhZEF0dGFjaEludGVyYWN0aW9uSGFuZGxlcjogKFxuICAgICAgICAvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZHJhd2VySGVhZERldGFjaEludGVyYWN0aW9uSGFuZGxlcjogKFxuICAgICAgICAvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgYXR0YWNoSW50ZXJhY3Rpb25IYW5kbGVyOiAoXG4gICAgICAgICAgLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRldGFjaEludGVyYWN0aW9uSGFuZGxlcjogKFxuICAgICAgICAgIC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihcbiAgICAgICAgT2JqZWN0LmFzc2lnbihMQkFjY29yZGlvbkRyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpXG4gICAgICApO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaW5lcnRfID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5sb2NhbENsaWNrQm91bmRfID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gLSB0cmFuc2l0aW9uIGRpcmVjdGlvbiAqL1xuICAgIHRoaXMudHJhbnNpdGlvbkFjdGlvbl8gPSBPUEVOX1RSQU5TSVRJT047XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gLSBDYWNoZSBkcmF3ZXIgYm9keSBgc2Nyb2xsSGVpZ2h0YC4gKi9cbiAgICB0aGlzLmRyYXdlckJvZHlIZWlnaHRfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gLSBGbGFnIHNldCB3aGVuIGRyYXdlciBpcyBvcGVuL3NodXQuICovXG4gICAgdGhpcy5kcmF3ZXJPcGVuXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9IC0gTnVtYmVyIG9mIHRpbWUga2V5IGBlbnRlcmAgcHJlc3NlZC4gKi9cbiAgICAvLyBYWFgoY2xheXRvbm1pc3VyYUApIHVzaW5nIGEgZmxhZyBgZHJhd2VyT3Blbl9gIGRvZXNuJ3Qgc2VlbVxuICAgIC8vIHRvIHdvcmsgY29ycmVjdGx5IHdpdGgga2V5Ym9hcmQgYW5kIGB0cmFuc2l0aW9uZW5kYCBoYW5kbGVyLlxuICAgIHRoaXMuZHJhd2VyRW50ZXJLZXlfID0gMDtcblxuICAgIC8vIENsaWNrIEhhbmRsZXJcbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMub3BlblNodXREcmF3ZXIoKTtcbiAgICB9O1xuXG4gICAgLy8gVHJhbnNpdGlvbiBIYW5kbGVyXG4gICAgdGhpcy50cmFuc2l0aW9uSGFuZGxlcl8gPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbkRyYXdlckNvbXBsZXRlXyhldmVudCk7XG4gICAgfTtcblxuICAgIC8vIEtleWJvYXJkSGFuZGxlclxuICAgIHRoaXMua2V5Ym9hcmRIYW5kbGVyXyA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgd2hpY2ggPSAoZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSk7XG4gICAgICAvLyBUbyBndWFyZCBhZ2FpbnN0IG5lc3RlZCBmb2N1c2FibGUgZWxlbWVudHMsIGNoZWNrIHRoYXQgdGhlIGV2ZW50XG4gICAgICAvLyB0YXJnZXQgaXMgZXF1YWwgdG8gdGhlIGRyYXdlcidzIGhlYWQgZWxlbWVudCBiZWZvcmUgZXhlY3V0aW5nXG4gICAgICAvLyB0aGUgcmVtYWluZGVyIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgIGlmICghdGhpcy5hZGFwdGVyXy5nZXREcmF3ZXJIZWFkKCkuaXNFcXVhbE5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAod2hpY2gpIHtcbiAgICAgICAgY2FzZSBFU0NBUEVfS0VZOlxuICAgICAgICAgIHRoaXMuc2h1dERyYXdlcigpO1xuICAgICAgICAgIHRoaXMuZHJhd2VyRW50ZXJLZXlfID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFTlRFUl9LRVk6XG4gICAgICAgICAgaWYgKCF0aGlzLmRyYXdlckVudGVyS2V5Xykge1xuICAgICAgICAgICAgdGhpcy5vcGVuRHJhd2VyKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdlckVudGVyS2V5XysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNodXREcmF3ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd2VyRW50ZXJLZXlfID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBvcGVuIGRyYXdlciBjaGlsZCBlbGVtZW50cyB0YWJiYWJsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlc3RvcmVUYWJLZXlfKCkge1xuICAgIGlmICghdGhpcy5pbmVydF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzYWJsZUVsZW1lbnRzKCkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pbmVydF8gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBzaHV0IGRyYXdlciBjaGlsZCBlbGVtZW50cyB1bnRhYmJhYmxlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJldmVudFRhYktleV8oKSB7XG4gICAgaWYgKHRoaXMuaW5lcnRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2FibGVFbGVtZW50cygpLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbGVtZW50KTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucHJldmVudEVsZW1lbnRUYWIoZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmluZXJ0XyA9IHRydWU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhbmQgY2FjaGVzIGRyYXdlciBoZWlnaHQuXG4gICAqL1xuICBjb21wdXRlSGVpZ2h0KCkge1xuICAgIHRoaXMuZHJhd2VyQm9keUhlaWdodF8gPSB0aGlzLmFkYXB0ZXJfLmdldERyYXdlckJvZHlIZWlnaHQoKTtcbiAgICBpZiAodGhpcy5kcmF3ZXJPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXREcmF3ZXJCb2R5U3R5bGUoe1xuICAgICAgICBoZWlnaHQ6IGAke3RoaXMuZHJhd2VyQm9keUhlaWdodF99cHhgLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB0byBydW4gb24gYHRyYW5zaXRpb25lbmRgIGV2ZW50LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyYW5zaXRpb25EcmF3ZXJDb21wbGV0ZV8oZXZlbnQpIHtcbiAgICAvLyBPbmx5IHRvZ2dsZSBzdGF0ZSB3aGVuIHRoZSBgb3BhY2l0eWAgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZWQuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLm5hbWVFcXVhbHNFdmVudFByb3BlcnR5KGV2ZW50LCAnb3BhY2l0eScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb25pdG9yVHJhbnNpdGlvbkFjdGlvbkxpZmVjeWNsZV8odGhpcy50cmFuc2l0aW9uQWN0aW9uXyk7XG4gIH1cblxuICAvKipcbiAgICogTW9uaXRvcnMgZHJhd2VyIGxpZmVzY3ljbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1vbml0b3JUcmFuc2l0aW9uQWN0aW9uTGlmZWN5Y2xlXyhhY3Rpb24pIHtcbiAgICBsZXQgZnV0dXJlQWN0aW9uID0gJyc7XG5cbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBPUEVOX1RSQU5TSVRJT046XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uYXBwZW5kQ2xhc3NEcmF3ZXJCb2R5KEFDVElWRV9DTEFTUyk7XG4gICAgICAgIGZ1dHVyZUFjdGlvbiA9IFNIVVRfVFJBTlNJVElPTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNIVVRfVFJBTlNJVElPTjpcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzc0RyYXdlckJvZHkoQUNUSVZFX0NMQVNTKTtcbiAgICAgICAgZnV0dXJlQWN0aW9uID0gT1BFTl9UUkFOU0lUSU9OO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zaXRpb25BY3Rpb25fID0gZnV0dXJlQWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgbmV3IGRyYXdlciBzdGF0ZS4gVXBkYXRlIHJlbGV2YW50IGRyYXdlciBhdHRyaWJ1dGVzIGFuZCBjbGFzc2VzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFtcERyYXdlclN0YXRlXyhzdGF0ZSkge1xuICAgIGNvbnN0IGRyYXdlckJvZHlBdHRycyA9IHt9O1xuICAgIGNvbnN0IGRyYXdlckhlYWRBdHRycyA9IHt9O1xuXG4gICAgZHJhd2VyQm9keUF0dHJzW0hJRERFTl9BUklBXSA9ICFzdGF0ZTtcbiAgICBkcmF3ZXJIZWFkQXR0cnNbRVhQQU5ERURfQVJJQV0gPSBzdGF0ZTtcbiAgICBkcmF3ZXJCb2R5QXR0cnNbRVhQQU5ERURfQVJJQV0gPSBzdGF0ZTtcblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0RHJhd2VyQm9keUF0dHIoZHJhd2VyQm9keUF0dHJzKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldERyYXdlckhlYWRBdHRyKGRyYXdlckhlYWRBdHRycyk7XG5cbiAgICB0aGlzLmRyYXdlck9wZW5fID0gc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBkcmF3ZXIgc3RhdGUgdG8gb3Blbi5cbiAgICovXG4gIG9wZW5EcmF3ZXIoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXREcmF3ZXJCb2R5U3R5bGUoe1xuICAgICAgaGVpZ2h0OiBgJHt0aGlzLmRyYXdlckJvZHlIZWlnaHRffXB4YCxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3RvcmVUYWJLZXlfKCk7XG4gICAgdGhpcy5zdGFtcERyYXdlclN0YXRlXyh0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFwcGVuZENsYXNzRHJhd2VyUm9vdChPUEVOX0NMQVNTKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGRyYXdlciBzdGF0ZSB0byBzaHV0LlxuICAgKi9cbiAgc2h1dERyYXdlcigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldERyYXdlckJvZHlTdHlsZSh7aGVpZ2h0OiAwLCBvcGFjaXR5OiAwfSk7XG4gICAgdGhpcy5wcmV2ZW50VGFiS2V5XygpO1xuICAgIHRoaXMuc3RhbXBEcmF3ZXJTdGF0ZV8oZmFsc2UpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3NEcmF3ZXJSb290KE9QRU5fQ0xBU1MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgZHJhd2VyIHN0YXRlLlxuICAgKi9cbiAgb3BlblNodXREcmF3ZXIoKSB7XG4gICAgaWYgKHRoaXMuZHJhd2VyT3Blbl8pIHtcbiAgICAgIHRoaXMuc2h1dERyYXdlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW5EcmF3ZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIGRyYXdlci5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kcmF3ZXJPcGVuXyA9IGZhbHNlO1xuXG4gICAgLy8gUmVtb3ZlIGJvZHkgYXR0cmlidXRlcy5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZURyYXdlckJvZHlBdHRyKCdzdHlsZScpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlRHJhd2VyQm9keUF0dHIoSUQpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlRHJhd2VyQm9keUF0dHIoSElEREVOX0FSSUEpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlRHJhd2VyQm9keUF0dHIoRVhQQU5ERURfQVJJQSk7XG5cbiAgICAvLyBSZW1vdmUgaGVhZCBhdHRyaWJ1dGVzLlxuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlRHJhd2VySGVhZEF0dHIoQ09OVFJPTFNfQVJJQSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVEcmF3ZXJIZWFkQXR0cihFWFBBTkRFRF9BUklBKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZURyYXdlckhlYWRBdHRyKERSQVdFUl9JTkRFWF9LRVkpO1xuXG4gICAgLy8gRGV0YWNoIGxpc3RlbmVyc1xuICAgIHRoaXMuYWRhcHRlcl8uZGV0YWNoSW50ZXJhY3Rpb25IYW5kbGVyKFxuICAgICAgICAndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkhhbmRsZXJfKTtcblxuICAgIHRoaXMuYWRhcHRlcl8uZGV0YWNoSW50ZXJhY3Rpb25IYW5kbGVyKFxuICAgICAgICAna2V5dXAnLCB0aGlzLmtleWJvYXJkSGFuZGxlcl8pO1xuXG4gICAgaWYgKHRoaXMubG9jYWxDbGlja0JvdW5kXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kcmF3ZXJIZWFkRGV0YWNoSW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsXG4gICAgICAgICAgdGhpcy5jbGlja0hhbmRsZXJfKTtcblxuICAgICAgdGhpcy5sb2NhbENsaWNrQm91bmRfID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGRyYXdlciBzdGF0ZXMgYW5kIGJpbmQgZXZlbnQgaGFuZGxlcnMuXG4gICAqL1xuICBpbml0KCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLnByb2JlRE9NRm9yQ29udHJvbGxlcigpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0RHJhd2VySW5kZXgoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0RHJhd2VyQm9keUF0dHIoSUQsIChJRF9QUkVGSVggKyBpbmRleCkpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXREcmF3ZXJIZWFkQXR0cihDT05UUk9MU19BUklBLCAoSURfUFJFRklYICsgaW5kZXgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBEYXRlLm5vdygpKSArIDE7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldERyYXdlckJvZHlBdHRyKElELCAoSURfUFJFRklYICsgaW5kZXgpKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0RHJhd2VySGVhZEF0dHIoQ09OVFJPTFNfQVJJQSwgKElEX1BSRUZJWCArIGluZGV4KSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRyYXdlckhlYWRBdHRhY2hJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJyxcbiAgICAgICAgICB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgICAgdGhpcy5sb2NhbENsaWNrQm91bmRfID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmF0dGFjaEludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleWJvYXJkSGFuZGxlcl8pO1xuICAgIHRoaXMuc3RhbXBEcmF3ZXJTdGF0ZV8oZmFsc2UpO1xuICAgIHRoaXMuY29tcHV0ZUhlaWdodCgpO1xuICAgIHRoaXMucHJldmVudFRhYktleV8oKTtcblxuICAgIHRoaXMuYWRhcHRlcl8uYXR0YWNoSW50ZXJhY3Rpb25IYW5kbGVyKFxuICAgICAgICAndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkhhbmRsZXJfKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24vYWNjb3JkaW9uLWRyYXdlci9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgVEFCX0RBVEEgPSAnZGF0YS1sYi10YWJpbmRleCc7XG5jb25zdCBUQUJfREFUQV9IQU5ETEVEID0gJ2RhdGEtbGItdGFiaW5kZXgtaGFuZGxlZCc7XG5cblxuLy8gU2V0IHNpbmdsZSBvciBtdWx0aXBsZSBhdHRyaWJ1dGVzIG9uIGVsZW1lbnQuXG5leHBvcnQgY29uc3Qgc2V0QXR0ciA9IChlbGVtZW50LCBhdHRyTmFtZSwgYXR0ckRhdGEpID0+IHtcbiAgaWYgKCFhdHRyRGF0YSAmJiBhdHRyTmFtZSA9PT0gT2JqZWN0KGF0dHJOYW1lKSkge1xuICAgIGNvbnN0IGF0dHJEYXRhID0gYXR0ck5hbWU7XG5cbiAgICBPYmplY3Qua2V5cyhhdHRyRGF0YSkuZm9yRWFjaCgoYXR0ck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJEYXR1bSA9IGF0dHJEYXRhW2F0dHJOYW1lXTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyRGF0dW0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGF0dHJOYW1lICYmIChhdHRyRGF0YSAhPT0gdW5kZWZpbmVkIHx8IGF0dHJEYXRhICE9PSBudWxsKSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyRGF0YSk7XG4gIH1cbn07XG5cbi8vIFNhdmUgdGhlIHRhYiBzdGF0ZSBmb3IgYW4gZWxlbWVudC5cbmV4cG9ydCBjb25zdCBzYXZlRWxlbWVudFRhYlN0YXRlID0gKGVsZW1lbnQpID0+IHtcbiAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoVEFCX0RBVEEsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShUQUJfREFUQSwgJzAnKTtcbiAgfVxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVELCB0cnVlKTtcbn07XG5cbi8vIFJlc3RvcmUgdGhlIHRhYiBzdGF0ZSBmb3IgYW4gZWxlbWVudCwgaWYgaXQgd2FzIHNhdmVkLlxuZXhwb3J0IGNvbnN0IHJlc3RvcmVFbGVtZW50VGFiU3RhdGUgPSAoZWxlbWVudCkgPT4ge1xuICAvLyBPbmx5IG1vZGlmeSBlbGVtZW50cyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQsIGluIGNhc2UgYW55dGhpbmcgd2FzIGR5bmFtaWNhbGx5IGFkZGVkIHNpbmNlIHdlIHNhdmVkIHN0YXRlLlxuICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoVEFCX0RBVEFfSEFORExFRCkpIHtcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoVEFCX0RBVEEpKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCBlbGVtZW50LmdldEF0dHJpYnV0ZShUQUJfREFUQSkpO1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoVEFCX0RBVEEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVEKTtcbiAgfVxufTtcblxuLy8gV2FsayBET00gdG8gZmluZCBzcGVjaWZpYyBwYXJlbnQgbm9kZS5cbi8vIGBvblBhcmVudE5vZGVNYXRjaGAgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuZXhwb3J0IGNvbnN0IHRyYXZlcnNlRE9NRm9yUGFyZW50RWxlbWVudCA9IChzdGFydE5vZGUsIG9uUGFyZW50Tm9kZU1hdGNoKSA9PiB7XG4gICAgLy8gU2V0IGBwYXJlbnRgIHRvIHN0YXJ0Tm9kZSxcbiAgICBsZXQgcGFyZW50ID0gc3RhcnROb2RlO1xuICAgIGxldCBleGlzdHMgPSBmYWxzZTtcbiAgICAvLyBUcmF2ZXJzZSBET00gaWYgYHBhcmVudGAgaXMgdHJ1dGh5LlxuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChvblBhcmVudE5vZGVNYXRjaChwYXJlbnQpKSB7XG4gICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gU2V0IGBwYXJlbnRgIHRvIHRoaXMgZWxlbWVudCdzIHBhcmVudC5cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQgJiYgb25QYXJlbnROb2RlTWF0Y2gocGFyZW50KSkge1xuICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0cztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2FjY29yZGlvbi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IExCQ29tcG9uZW50IGZyb20gJy4uL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtMQkF1dG9TY3JvbGxGb3VuZGF0aW9ufSBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG5cbi8qKlxuICogQ2xhc3MgdGhhdCBkZWZpbmVzIExCQXV0b1Njcm9sbFxuICovXG5leHBvcnQgY2xhc3MgTEJBdXRvU2Nyb2xsIGV4dGVuZHMgTEJDb21wb25lbnQge1xuICAvLyBJbnZva2VkIGJ5IGBtZGMuYXV0b0luaXQoKWBcbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICByZXR1cm4gbmV3IExCQXV0b1Njcm9sbChyb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBjb21wb25lbnQgZm91bmRhdGlvbiBhbmQgcGFzcyBpdCB0aGUgYWRhcHRlciBkaWN0LlxuICAgKiBAcmV0dXJuIHtMQkF1dG9TY3JvbGxGb3VuZGF0aW9ufVxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBMQkF1dG9TY3JvbGxGb3VuZGF0aW9uKHtcbiAgICAgIGdldE9wdGlvbnM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gICAgICB9LFxuICAgICAgYXR0YWNoQ2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gICAgICB9LFxuICAgICAgZ2V0RWxlbWVudFNjcm9sbFRhcmdldDogKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudFNjcm9sbFRhcmdldF8pIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50SWQgPSB0aGlzLnJvb3RfLmdldEF0dHJpYnV0ZSgnaHJlZicpLnJlcGxhY2UoL14jLywgJycpO1xuICAgICAgICAgIHRoaXMuZWxlbWVudFNjcm9sbFRhcmdldF8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTY3JvbGxUYXJnZXRfO1xuICAgICAgfSxcbiAgICAgIHByZXZlbnREZWZhdWx0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBjb21wb25lbnQgYW5kIHBhcnNlIG9wdGlvbnMgdG8gdXNlIGluIGFkYXB0ZXIuXG4gICAqL1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMucGFyc2VPcHRpb25zU3RyaW5nKCdhdXRvLXNjcm9sbCcpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2F1dG8tc2Nyb2xsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZSc7XG5pbXBvcnQgQXV0b1Njcm9sbCBmcm9tICcuLi8uLi9wcm92aWRlcnMvYXV0by1zY3JvbGwnO1xuXG5leHBvcnQgY2xhc3MgTEJBdXRvU2Nyb2xsRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRPcHRpb25zOiAoKSA9PiAvKiBPYmplY3QgKi8gKHt9KSxcbiAgICAgIGF0dGFjaENsaWNrSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcHJldmVudERlZmF1bHQ6ICgvKiBldmVudDogRXZlbnQgKi8pID0+IHt9LFxuICAgICAgZ2V0RWxlbWVudFNjcm9sbFRhcmdldDogKCkgPT4gLyogRWxlbWVudCAqLyB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTEJBdXRvU2Nyb2xsRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICo+fSAqL1xuICAgIHRoaXMub3B0aW9uc18gPSB0aGlzLmFkYXB0ZXJfLmdldE9wdGlvbnMoKTtcblxuICAgIHRoaXMuc2Nyb2xsUHJvdmlkZXJfID0gbmV3IEF1dG9TY3JvbGwodGhpcy5vcHRpb25zXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hdHRhY2hDbGlja0hhbmRsZXIodGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5lbGVtZW50U2Nyb2xsVGFyZ2V0XyA9IHRoaXMuYWRhcHRlcl8uZ2V0RWxlbWVudFNjcm9sbFRhcmdldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgY2xpY2tzIG9uIHRoZSBzY3JvbGwgdHJpZ2dlci5cbiAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgZXZlbnQgcmV0dXJuZWQgZnJvbSB0aGUgaGFuZGxlci5cbiAgICovXG4gIGhhbmRsZUNsaWNrXyhlKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudFNjcm9sbFRhcmdldF87XG4gICAgZWwgJiYgdGhpcy5zY3JvbGxQcm92aWRlcl8uc2Nyb2xsVG9FbGVtZW50KGVsKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9hdXRvLXNjcm9sbC9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IExCQ29tcG9uZW50IGZyb20gJy4uLy4uL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtMQk5hdkZvdW5kYXRpb259IGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQge0xCTW9iaWxlTmF2fSBmcm9tICcuLi9tb2JpbGUtbmF2JztcbmltcG9ydCB7Q2xhc3NlcywgU2VsZWN0b3JzLCBOdW1iZXJzfSBmcm9tICcuLi9uYXYvY29uc3RhbnRzJztcbmltcG9ydCB7ZGVsZWdhdGV9IGZyb20gJy4uLy4uLy4uL3Byb3ZpZGVycy91dGlscy91dGlscyc7XG5cblxuZXhwb3J0IGNsYXNzIExCTmF2IGV4dGVuZHMgTEJDb21wb25lbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTEJOYXYgY2xhc3MuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3QgVGhlIGhlYWRlciBjb21wb25lbnQgZWxlbWVudC5cbiAgICogQHJldHVybiB7IUxCTmF2fVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICByZXR1cm4gbmV3IExCTmF2KHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFMQk5hdkZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IExCTmF2Rm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGVsLCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfSxcbiAgICAgIGFkZExpc3RlbmVyOiAoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbCA9IHdpbmRvdykgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gICAgICB9LFxuICAgICAgY29udGFpbnNDbGFzczogKGVsLCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgICAgfSxcbiAgICAgIGRlbGVnYXRlRXZlbnQ6IChzZWxlY3RvciwgZXZlbnRUeXBlLCBoYW5kbGVyLCBlbCA9IGRvY3VtZW50KSA9PiB7XG4gICAgICAgIGRlbGVnYXRlKGVsLCBzZWxlY3RvciwgZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBnZXRCb3VuZGluZ1JlY3Q6IChlbCkgPT4ge1xuICAgICAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9LFxuICAgICAgZ2V0SGFzaDogKGxpbmspID0+IHtcbiAgICAgICAgcmV0dXJuIGxpbmsgPyBsaW5rLnNwbGl0KCcjJylbMV0gOiAnJztcbiAgICAgIH0sXG4gICAgICBnZXRPcHRpb25zOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICAgICAgfSxcbiAgICAgIGdldFJvb3RFbDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290XztcbiAgICAgIH0sXG4gICAgICBnZXRQYXJlbnROYXZJdGVtOiAoZWwpID0+IHtcbiAgICAgICAgY29uc3QgbmF2V3JhcHBlckNsYXNzID0gQ2xhc3Nlcy5OQVZfSVRFTV9XUkFQUEVSO1xuICAgICAgICBjb25zdCBwYXJlbnROYXZJdGVtU2VsZWN0b3IgPSBTZWxlY3RvcnMuTkFWX0lURU1TO1xuICAgICAgICBsZXQgY3VycmVudEVsID0gZWw7XG5cbiAgICAgICAgLy8gTW9iaWxlIG5hdi5cbiAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3Nlcy5TVUJOQVZfSVRFTSkpIHtcbiAgICAgICAgICByZXR1cm4gZWwucGFyZW50RWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKCFjdXJyZW50RWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hdldyYXBwZXJDbGFzcykpIHtcbiAgICAgICAgICBjdXJyZW50RWwgPSBjdXJyZW50RWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJyZW50RWwucXVlcnlTZWxlY3RvcihwYXJlbnROYXZJdGVtU2VsZWN0b3IpO1xuICAgICAgfSxcbiAgICAgIGdldFdpbmRvd1dpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIH0sXG4gICAgICBpc1Bhc3RCcmVha3BvaW50OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBzZXVkb0NvbnRlbnQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm1vYmlsZU5hdkVsXyxcbiAgICAgICAgICAgICc6OmJlZm9yZScpLmdldFByb3BlcnR5VmFsdWUoJ2NvbnRlbnQnKTtcblxuICAgICAgICByZXR1cm4gcHNldWRvQ29udGVudCAhPT0gJ1wibW9iaWxlXCInO1xuICAgICAgfSxcbiAgICAgIHF1ZXJ5RWw6IChzZWxlY3RvciwgZWwpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfSxcbiAgICAgIHF1ZXJ5QWxsOiAoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlDb21wb25lbnRTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IChlbCwgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXRBdHRyOiAoYXR0ciwgdmFsLCBlbCA9IHRoaXMucm9vdF8pID0+IHtcbiAgICAgICAgdGhpcy5zZXRBdHRyKGF0dHIsIHZhbCwgZWwpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUNsYXNzOiAoY2xhc3NOYW1lLCBhZGRDbGFzcywgZWwpID0+IHtcbiAgICAgICAgdGhpcy50b2dnbGVDbGFzcyhjbGFzc05hbWUsIGFkZENsYXNzLCBlbCk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF1dG9tYXRpY2FsbHkgZ2V0cyBjYWxsZWQgd2hlbiBgW2RhdGEtbWRjLWF1dG8taW5pdF1gIGlzIHByZXNlbnQgb25cbiAgICogdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemUoKSB7XG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5tb2JpbGVOYXZFbF8gPSB0aGlzLnF1ZXJ5Q29tcG9uZW50U2VsZWN0b3IoU2VsZWN0b3JzLk1PQklMRV9OQVYpO1xuXG4gICAgdGhpcy5wYXJzZU9wdGlvbnNTdHJpbmcoJ2hlYWRlcicpO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnNfLnN0aWNreSkge1xuICAgICAgdGhpcy5pbml0U2xpZGVBd2F5XygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3RfLmNsYXNzTGlzdC5hZGQoQ2xhc3Nlcy5TVElDS1kpO1xuICAgIH1cblxuICAgIExCTW9iaWxlTmF2LmF0dGFjaFRvKHRoaXMubW9iaWxlTmF2RWxfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgc2xpZGUtYXdheSBmdW5jdGlvbmFsaXR5IHRoYXQgbWFrZXMgdGhlIGhlYWRlciBzbGlkZVxuICAgKiB1cHdhcmQgb3V0IG9mIHRoZSB2aWV3cG9ydCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgZG93biB0aGUgcGFnZSwgYW5kIGJhY2tcbiAgICogaW50byB2aWV3IHdoZW4gdGhleSBzY3JvbGwgdXAgdGhlIHBhZ2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0U2xpZGVBd2F5XygpIHtcbiAgICB0aGlzLmxhc3RTY3JvbGxZXyA9IHdpbmRvdy5zY3JvbGxZO1xuICAgIHRoaXMubmV0U2Nyb2xsWV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIGEgc2V0VGltZW91dCB0aGF0IGtlZXBzIHRyYWNrIG9mIGlmIGEgbW91c2Vtb3ZlIGV2ZW50IGhhc1xuICAgICAqIG9jY3VycmVkIHJlY2VudGx5LlxuICAgICAqIEBwcml2YXRlIHs/bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubW91c2VNb3ZlVGltZW91dElkXztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBjb29yZGluYXRlcyBvZiB0aGUgbW91c2Ugd2hlbiB0aGUgdXNlciBzdGFydHNcbiAgICAgKiBhIHRpbWVkIG1vdXNlbW92ZS5cbiAgICAgKiBAcHJpdmF0ZSB7IU9iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm1vdXNlTW92ZU9yaWdpbmF0aW9uXyA9IHtcbiAgICAgIHg6IG51bGwsXG4gICAgICB5OiBudWxsLFxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGxfLmJpbmQodGhpcykpO1xuICAgIC8vIElmIHRoZSB1c2VyIG1vdmVzIHRoZWlyIG1vdXNlIGFyb3VuZCBvdmVyIGEgdGhyZXNob2xkLCByZXZlYWwgdGhlIG5hdi5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZV8uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgd2luZG93IHNjcm9sbCBldmVudCB3aGljaCBjYXVzZXMgdGhlIGhlYWRlciB0byBzbGlkZSBpbiBvciBvdXRcbiAgICogb2Ygdmlldy4gT25seSByZXNwb25kcyBhZnRlciB0aGUgdXNlciBoYXMgc2Nyb2xsZWQgYSB0aHJlc2hvbGQgZGlzdGFuY2UuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIERPTSBzY3JvbGwgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTY3JvbGxfKGUpIHtcbiAgICBjb25zdCBsYXN0U2Nyb2xsSW5jcmVtZW50ID0gd2luZG93LnNjcm9sbFkgLSB0aGlzLmxhc3RTY3JvbGxZXztcbiAgICB0aGlzLm5ldFNjcm9sbFlfICs9IGxhc3RTY3JvbGxJbmNyZW1lbnQ7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGhlYWRlciBpcyBhbHdheXMgaW4gdmlldyBuZWFyIHRoZSB0b3Agb2YgdGhlIHBhZ2UuXG4gICAgaWYgKHdpbmRvdy5zY3JvbGxZIDwgTnVtYmVycy5TTElERV9BV0FZX1NDUk9MTF9USFJFU0hPTEQpIHtcbiAgICAgIHRoaXMudG9nZ2xlSGVhZGVyU2xpZGVBd2F5KGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgdG9nZ2xlIHRoZSBoZWFkZXIgdmlzaWJpbGl0eSBpZiB3ZSd2ZSBtZXQgdGhlIHRocmVzaG9sZC5cbiAgICBpZiAoTWF0aC5hYnModGhpcy5uZXRTY3JvbGxZXykgPiBOdW1iZXJzLlNMSURFX0FXQVlfU0NST0xMX1RIUkVTSE9MRCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB1c2VyIGlzIHNjcm9sbGluZyB1cCBvciBkb3duIGFuZCB0cmlnZ2VyIGhpZGUvc2hvdy5cbiAgICAgIGNvbnN0IHNjcm9sbGluZ0Rvd24gPSB0aGlzLm5ldFNjcm9sbFlfID4gMDtcbiAgICAgIHRoaXMudG9nZ2xlSGVhZGVyU2xpZGVBd2F5KHNjcm9sbGluZ0Rvd24pO1xuICAgIH1cblxuICAgIHRoaXMubGFzdFNjcm9sbFlfID0gd2luZG93LnNjcm9sbFk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgbW91c2Vtb3ZlIGV2ZW50IHdoaWNoIGNhdXNlcyB0aGUgaGVhZGVyIHRvIHNsaWRlIGluIG9yIG91dFxuICAgKiBvZiB2aWV3LiBPbmx5IHJlc3BvbmRzIGFmdGVyIHRoZSB1c2VyIGhhcyBtb3ZlZCBhIHRocmVzaG9sZCBkaXN0YW5jZS5cbiAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgRE9NIG1vdXNlbW92ZSBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZU1vdXNlTW92ZV8oZSkge1xuICAgIGlmICh0aGlzLm1vdXNlTW92ZU9yaWdpbmF0aW9uXy54ID09PSBudWxsKSB7XG4gICAgICB0aGlzLm1vdXNlTW92ZU9yaWdpbmF0aW9uXy55ID0gZS5jbGllbnRZO1xuICAgICAgdGhpcy5tb3VzZU1vdmVPcmlnaW5hdGlvbl8ueCA9IGUuY2xpZW50WDtcbiAgICB9XG5cbiAgICBjb25zdCBkZWx0YVggPSBNYXRoLmFicyh0aGlzLm1vdXNlTW92ZU9yaWdpbmF0aW9uXy54IC0gZS5jbGllbnRYKTtcbiAgICBjb25zdCBkZWx0YVkgPSBNYXRoLmFicyh0aGlzLm1vdXNlTW92ZU9yaWdpbmF0aW9uXy55IC0gZS5jbGllbnRZKTtcblxuICAgIGlmIChkZWx0YVggPiBOdW1iZXJzLlNMSURFX0FXQVlfTU9VU0VNT1ZFX1RIUkVTSE9MRCB8fFxuICAgICAgICBkZWx0YVkgPiBOdW1iZXJzLlNMSURFX0FXQVlfTU9VU0VNT1ZFX1RIUkVTSE9MRCkge1xuICAgICAgdGhpcy50b2dnbGVIZWFkZXJTbGlkZUF3YXkoZmFsc2UpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VNb3ZlVGltZW91dElkXyk7XG4gICAgfVxuXG4gICAgLy8gQ2FuY2VsIHRoZSBleGlzdGluZyBhbmQgc3RhcnQgYSBuZXcgc2V0VGltZW91dC5cbiAgICB0aGlzLm1vdXNlTW92ZVRpbWVvdXRJZF8gJiYgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VNb3ZlVGltZW91dElkXyk7XG4gICAgdGhpcy5tb3VzZU1vdmVUaW1lb3V0SWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBVc2VyIG1vdmVkIG1vdXNlIHRvbyBzbG93bHksIHJlc2V0LlxuICAgICAgdGhpcy5yZXNldFNsaWRlQXdheV8oKTtcbiAgICB9LCBOdW1iZXJzLlNMSURFX0FXQVlfTU9VU0VNT1ZFX1JFU0VUX1RJTUUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgbmV0U2Nyb2xsWV8gYW5kIG1vdXNlTW92ZURlbHRhXyB2YXJpYWJsZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldFNsaWRlQXdheV8oKSB7XG4gICAgdGhpcy5uZXRTY3JvbGxZXyA9IDA7XG4gICAgdGhpcy5tb3VzZU1vdmVPcmlnaW5hdGlvbl8ueCA9IHRoaXMubW91c2VNb3ZlT3JpZ2luYXRpb25fLnkgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgaGVhZGVyIHRvIHNsaWRlIGluIG9yIG91dCBvZiB2aWV3LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNsaWRlQXdheSBJZiB0aGUgaGVhZGVyIHNob3VsZCBzbGlkZSBhd2F5LlxuICAgKi9cbiAgdG9nZ2xlSGVhZGVyU2xpZGVBd2F5KHNsaWRlQXdheSA9IHRydWUpIHtcbiAgICB0aGlzLnJvb3RfLmNsYXNzTGlzdC50b2dnbGUoQ2xhc3Nlcy5TTElERV9BV0FZLCBzbGlkZUF3YXkpO1xuICAgIC8vIFJlc2V0IGhlcmUgc2luY2UgdGhpcyBtZXRob2QgY2FuIGFsc28gYmUgY2FsbGVkIGFmdGVyIGEgbW91c2Vtb3ZlLCBvclxuICAgIC8vIGFzIGEgcHVibGljIEFQSS5cbiAgICB0aGlzLnJlc2V0U2xpZGVBd2F5XygpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2hlYWRlci9uYXYvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlJztcbmltcG9ydCB7QXR0cnMsIENsYXNzZXMsIEV2ZW50cywgS2V5cywgU2VsZWN0b3JzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuZXhwb3J0IGNsYXNzIExCTmF2Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGVsOiAhRWxlbWVudCwgY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYWRkTGlzdGVuZXI6ICgvKiBldmVudFR5cGU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogIUZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICBlbDogIUVsZW1lbnR8d2luZG93ICovKSA9PiB7fSxcbiAgICAgIGNvbnRhaW5zQ2xhc3M6ICgvKiBlbDogIUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBkZWxlZ2F0ZUV2ZW50OiAoLyogc2VsZWN0b3I6IHN0cmluZywgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogIUZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiAhRWxlbWVudHxkb2N1bWVudCAqLykgPT4ge30sXG4gICAgICBnZXRCb3VuZGluZ1JlY3Q6ICgvKiBlbDogIUVsZW1lbnQgKi8pID0+IC8qICFET01SZWN0ICovIHt9LFxuICAgICAgZ2V0SGFzaDogKC8qIGxpbms6IHN0cmluZyAqLykgPT4gLyogc3RyaW5nICovICcnLFxuICAgICAgZ2V0UGFyZW50TmF2SXRlbTogKC8qIHN1Ym5hdkVsOiAhRWxlbWVudCAqLykgPT4gLyogIUVsZW1lbnQgKi8ge30sXG4gICAgICBnZXRSb290RWw6ICgpID0+IC8qICFFbGVtZW50ICovIHt9LFxuICAgICAgZ2V0V2luZG93V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgaXNQYXN0QnJlYWtwb2ludDogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHF1ZXJ5RWw6ICgvKiBzZWxlY3Rvcjogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgIGVsOiAhRWxlbWVudCAqLykgPT4gLyogIUVsZW1lbnQgKi8ge30sXG4gICAgICBxdWVyeUFsbDogKC8qIHNlbGVjdG9yOiBzdHJpbmcgKi8pID0+IC8qICFBcnJheTwhRWxlbWVudD4gKi8gW10sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGVsOiAhRWxlbWVudCwgY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0QXR0cjogKC8qIGF0dHI6IHN0cmluZywgdmFsOiBzdHJpbmcsIGVsOiAhRWxlbWVudCAqLykgPT4ge30sXG4gICAgICB0b2dnbGVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzczogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgZWw6ICFFbGVtZW50ICovKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTEJOYXZGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshT2JqZWN0PHN0cmluZywgKj59ICovXG4gICAgdGhpcy5vcHRpb25zXyA9IHRoaXMuYWRhcHRlcl8uZ2V0T3B0aW9ucygpO1xuXG4gICAgLyoqXG4gICAgICogQWxsIGxpbmtzIHdpdGggaGFzaGVzLlxuICAgICAqIEBwcml2YXRlIHshQXJyYXk8P0VsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMuaGFzaExpbmtzXyA9IHRoaXMuYWRhcHRlcl8ucXVlcnlBbGwoU2VsZWN0b3JzLkhBU0hfTElOS1MpO1xuXG4gICAgaWYgKHRoaXMuaGFzaExpbmtzXykge1xuICAgICAgLyoqIEBwcml2YXRlIHshRWxlbWVudH0gKi9cbiAgICAgIHRoaXMuYWxsTmF2SXRlbXNfID0gdGhpcy5hZGFwdGVyXy5xdWVyeUFsbChTZWxlY3RvcnMuTkFWX0lURU1TKTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy5kZWxlZ2F0ZUV2ZW50KFNlbGVjdG9ycy5IQVNIX0xJTktTLCAnY2xpY2snLFxuICAgICAgICAgIHRoaXMuaGFuZGxlSGFzaExpbmtzXy5iaW5kKHRoaXMpKTtcblxuICAgICAgdGhpcy5oYW5kbGVIYXNoTGlua3NfKCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlIHshQXJyYXk8P0VsZW1lbnQ+fSAqL1xuICAgIHRoaXMuc3VibmF2c18gPSB0aGlzLmFkYXB0ZXJfLnF1ZXJ5QWxsKFNlbGVjdG9ycy5TVUJOQVYpO1xuXG4gICAgLy8gTm8gbmVlZCB0byBnbyBhbnkgZnVydGhlciBpZiB0aGVyZSBhcmUgbm8gc3VibmF2cyB0byB3b3JyeSBhYm91dC5cbiAgICBpZiAoIXRoaXMuc3VibmF2c18ubGVuZ3RoKSByZXR1cm47XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCBhbnkgb2YgdGhlIHN1Ym5hdnMgYXJlIHZpc2libGUuXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zdWJuYXZJc1Zpc2libGVfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXIgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZSB7IUVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5yb290XyA9IHRoaXMuYWRhcHRlcl8uZ2V0Um9vdEVsKCk7XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIGVsZW1lbnRzIHRoYXQgY29udGFpbiBpbmRpdmlkdWFsIG5hdiBpdGVtcyBhbmQgdGhlaXIgYWNjb21wYW55aW5nXG4gICAgICogc3VibmF2LCBpZiBvbmUgZXhpc3RzLlxuICAgICAqIEBwcml2YXRlIHshQXJyYXk8IUVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMubmF2SXRlbVdyYXBwZXJzXyA9IHRoaXMuYWRhcHRlcl8ucXVlcnlBbGwoU2VsZWN0b3JzLk5BVl9JVEVNX1dSQVBQRVIpO1xuXG4gICAgLy8gU2V0IGFjdGl2ZSBwYXJlbnQgbmF2IGl0ZW0gd2hlbiBhIHN1Ym5hdiBpdGVtIGlzIGFjdGl2ZSBvbiBsb2FkLlxuICAgIGNvbnN0IGFjdGl2ZVN1Ym5hdkl0ZW1zID0gdGhpcy5hZGFwdGVyXy5xdWVyeUFsbChcbiAgICAgICAgYCR7U2VsZWN0b3JzLkFDVElWRV9NT0JJTEVfU1VCTkFWX0lURU19LFxuICAgICAgICAgJHtTZWxlY3RvcnMuQUNUSVZFX1NVQk5BVl9JVEVNfWApO1xuXG4gICAgYWN0aXZlU3VibmF2SXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4gdGhpcy5zZXRBY3RpdmVQYXJlbnRfKGl0ZW0pKTtcblxuICAgIHRoaXMucmVnaXN0ZXJTdWJuYXZFdmVudHNfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVnaXN0ZXJTdWJuYXZFdmVudHNfKCkge1xuICAgIHRoaXMubmF2SXRlbVdyYXBwZXJzXy5mb3JFYWNoKCh3cmFwcGVyLCBpKSA9PiB7XG4gICAgICBjb25zdCBzdWJuYXYgPSB0aGlzLmFkYXB0ZXJfLnF1ZXJ5RWwoU2VsZWN0b3JzLlNVQk5BViwgd3JhcHBlcik7XG5cbiAgICAgIGlmIChzdWJuYXYpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRMaXN0ZW5lcihFdmVudHMuTU9VU0VFTlRFUiwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VFdmVudF8oZSwgc3VibmF2KTtcbiAgICAgICAgfSwgd3JhcHBlcik7XG5cbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRMaXN0ZW5lcihFdmVudHMuTU9VU0VMRUFWRSwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VFdmVudF8oZSwgc3VibmF2KTtcbiAgICAgICAgfSwgd3JhcHBlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlbGVnYXRlRXZlbnQoU2VsZWN0b3JzLk5BVl9JVEVNX1dSQVBQRVIsIEV2ZW50cy5LRVlVUCxcbiAgICAgICAgdGhpcy5oYW5kbGVLZXlVcF8uYmluZCh0aGlzKSwgdGhpcy5yb290Xyk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmFkZExpc3RlbmVyKEV2ZW50cy5LRVlVUCxcbiAgICAgICAgdGhpcy5oYW5kbGVUYWJiaW5nT2ZmTmF2Xy5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuYWRhcHRlcl8uYWRkTGlzdGVuZXIoRXZlbnRzLlJFU0laRSwgdGhpcy5oYW5kbGVSZXNpemVfLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBlbGVtZW50IGlzIGEgZGVza3RvcCBuYXYgaXRlbS5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWwgRE9NIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc05hdkl0ZW0oZWwpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5jb250YWluc0NsYXNzKGVsLCBDbGFzc2VzLk5BVl9JVEVNKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBhIG1vYmlsZSBuYXYgaXRlbS5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWwgRE9NIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc01vYmlsZU5hdkl0ZW0oZWwpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5jb250YWluc0NsYXNzKGVsLCBDbGFzc2VzLk1PQklMRV9OQVZfSVRFTSk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYSBkZXNrdG9wIHN1Ym5hdiBpdGVtLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbCBET00gZWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzU3ViTmF2SXRlbShlbCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmNvbnRhaW5zQ2xhc3MoZWwsIENsYXNzZXMuU1VCTkFWX0lURU0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBlbGVtZW50IGlzIGEgbW9iaWxlIHN1Ym5hdiBpdGVtLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbCBET00gZWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTW9iaWxlU3ViTmF2SXRlbShlbCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmNvbnRhaW5zQ2xhc3MoZWwsIENsYXNzZXMuTU9CSUxFX1NVQk5BVl9JVEVNKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gc3VibmF2J3MgcmlnaHQgZWRnZSBvdmVyZmxvd3Mgb3V0c2lkZSB0aGVcbiAgICogdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHN1Ym5hdiBUaGUgdmlzaWJsZSBzdWJuYXYgZWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN1Ym5hdk92ZXJmbG93c1JpZ2h0XyhzdWJuYXYpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXRCb3VuZGluZ1JlY3Qoc3VibmF2KS5yaWdodCA+XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93V2lkdGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gc3VibmF2J3MgbGVmdCBlZGdlIG92ZXJmbG93cyBvdXRzaWRlIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gc3VibmF2IFRoZSB2aXNpYmxlIHN1Ym5hdiBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3VibmF2T3ZlcmZsb3dzTGVmdF8oc3VibmF2KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0Qm91bmRpbmdSZWN0KHN1Ym5hdikubGVmdCA8IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBgb3ZlcmZsb3dgIGNsYXNzIHRvIHRoZSBnaXZlbiBzdWJuYXYgaWYgaXQgb3ZlcmZsb3dzIG91dHNpZGUgdGhlXG4gICAqIHZpZXdwb3J0IGJ5IGNoZWNraW5nIGl0cyByaWdodCBhbmQgbGVmdCBwb3NpdGlvbnMuIFRoZSBvcmRlciBvZiB3aGljaCBzaWRlXG4gICAqIHRvIGNoZWNrIGZpcnN0IGRlcGVuZHMgb24gdGhlIGRvdWNtZW50cyBgZGlyYCB2YWx1ZS5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gc3VibmF2IFRoZSB2aXNpYmxlIHN1Ym5hdiBlbGVtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U3VibmF2QWxpZ25tZW50XyhzdWJuYXYpIHtcbiAgICBjb25zdCBpc1J0bCA9IGRvY3VtZW50LmRpciA9PT0gJ3J0bCc7XG4gICAgY29uc3QgZmlyc3RPdmVyZmxvd0NoZWNrID0gaXNSdGwgP1xuICAgICAgICB0aGlzLnN1Ym5hdk92ZXJmbG93c0xlZnRfKHN1Ym5hdikgOiB0aGlzLnN1Ym5hdk92ZXJmbG93c1JpZ2h0XyhzdWJuYXYpO1xuXG4gICAgaWYgKGZpcnN0T3ZlcmZsb3dDaGVjaykge1xuICAgICAgLy8gU3VibmF2IG92ZXJmbG93cyByaWdodCAobGVmdCBmb3IgUlRMKS4gVGhpcyBjbGFzcyByaWdodC1hbGlnbnMgaXQgdG9cbiAgICAgIC8vIGl0cyBwYXJlbnQgbmF2IGl0ZW0uXG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHN1Ym5hdiwgQ2xhc3Nlcy5TVUJOQVZfT1ZFUkZMT1dJTkdfUklHSFQpO1xuICAgIH1cblxuICAgIC8vIFBlcnRhaW5zIHRvIHJlYWxseSBsb25nIHN1Ym5hdnMuXG4gICAgY29uc3Qgc2Vjb25kT3ZlcmZsb3dDaGVjayA9ICFpc1J0bCA/IHRoaXMuc3VibmF2T3ZlcmZsb3dzTGVmdF8oc3VibmF2KSA6XG4gICAgICAgIHRoaXMuc3VibmF2T3ZlcmZsb3dzUmlnaHRfKHN1Ym5hdik7XG5cbiAgICBpZiAoc2Vjb25kT3ZlcmZsb3dDaGVjaykge1xuICAgICAgLy8gU3VibmF2IG92ZXJmbG93cyBsZWZ0IChyaWdodCBmb3IgUlRMKSBhZnRlciB0aGUgZmlyc3QgYWxpZ24gYWRqdXN0bWVudFxuICAgICAgLy8gd2FzIG1hZGUuIFRoaXMgcmVtb3ZlcyB0aGUgZmlyc3QgYG92ZXJmbG93YCBjbGFzcyBhbmQgYWRkcyBhbm90aGVyIG9uZVxuICAgICAgLy8gdGhhdCBwb3NpdGlvbnMgdGhlIHN1Ym5hdiBgZml4ZWRgIGFuZCBmbHVzaCB3aXRoIHRoZSBsZWZ0IHNpZGUgKHJpZ2h0XG4gICAgICAvLyBzaWRlIGZvciBSVEwpIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3Moc3VibmF2LCBDbGFzc2VzLlNVQk5BVl9PVkVSRkxPV0lOR19SSUdIVCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHN1Ym5hdiwgQ2xhc3Nlcy5TVUJOQVZfT1ZFUkZMT1dJTkdfTEVGVCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGFwcHJvcHJpYXRlIGBhY3RpdmVgIGNsYXNzZXMgb24gYWxsIG5hdiBpdGVtcyB0byBzZXQgdGhlaXJcbiAgICogcHJvcGVyIGFjdGl2ZSBzdGF0ZXMgd2hlbiB0aGVyZSBpcyBhIGhhc2ggaW4gdGhlIFVSTC4gVGhpcyBoYXBwZW5zIG9uIGxvYWRcbiAgICogYW5kIHdoZW4gYSBoYXNoIGxpbmsgaXMgY2xpY2tlZC5cbiAgICogQHBhcmFtIHs/RWxlbWVudH0gdGFyZ2V0IENsaWNrZWQgaGFzaCBsaW5rLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSGFzaExpbmtzXyh0YXJnZXQpIHtcbiAgICAvLyBFaXRoZXIgdGhlIHRhcmdldCdzIG9yIFVSTCdzIGhhc2guXG4gICAgY29uc3QgYWN0aXZlSGFzaCA9IHRhcmdldCA/IHRoaXMuYWRhcHRlcl8uZ2V0SGFzaCh0YXJnZXQuaHJlZikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0ZXJfLmdldEhhc2god2luZG93LmxvY2F0aW9uLmhhc2gpO1xuXG4gICAgLy8gTm8gbmVlZCB0byBkbyBhbnl0aGluZyBpZiBubyBoYXNoIGlzIHByZXNlbnQgaW4gdGhlIGNsaWNrZWQgbmF2IGl0ZW0gb3JcbiAgICAvLyBpbiB0aGUgVVJMLlxuICAgIGlmICghYWN0aXZlSGFzaCkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSBgYWN0aXZlSGFzaGAgaXMgcHJlc2VudCBpbiB0aGUgbmF2LlxuICAgIGNvbnN0IGFjdGl2ZUhhc2hJbk5hdiA9IHRoaXMuYWxsTmF2SXRlbXNfLnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGxpbmsgPSBpdGVtLmhyZWY7XG5cbiAgICAgIC8vIFNvbWV0aW1lcyBuYXYgaXRlbXMgYXJlIGp1c3QgbGFiZWxzLCBub3QgbGlua3MuXG4gICAgICBpZiAobGluaykge1xuICAgICAgICBjb25zdCBoYXNoID0gbGluay5zcGxpdCgnIycpWzFdO1xuICAgICAgICByZXR1cm4gKGhhc2ggPT09IGFjdGl2ZUhhc2gpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTm8gbmVlZCB0byBkbyBhbnl0aGluZyBpZiB0aGUgYGFjdGl2ZUhhc2hgIGlzIHVucmVsYXRlZCB0byB0aGUgbmF2LlxuICAgIGlmICghYWN0aXZlSGFzaEluTmF2KSByZXR1cm47XG5cbiAgICB0aGlzLmFsbE5hdkl0ZW1zXy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0aGUgYGFjdGl2ZUhhc2hgIG1hdGNoZXMgdGhlIG5hdiBpdGVtJ3MuXG4gICAgICBjb25zdCBpc0FjdGl2ZSA9IGFjdGl2ZUhhc2ggPT09IHRoaXMuYWRhcHRlcl8uZ2V0SGFzaChpdGVtLmhyZWYpO1xuXG4gICAgICAvLyBUb2dnbGVzIHRoZSBhcHByb3ByaWF0ZSBgYWN0aXZlYCBjbGFzcyBkZXBlbmRpbmcgb24gd2hhdCB0eXBlIG9mIG5hdlxuICAgICAgLy8gaXRlbSBpdCBpcy5cbiAgICAgIHRoaXMuYWRhcHRlcl8udG9nZ2xlQ2xhc3MoQ2xhc3Nlcy5BQ1RJVkVfTkFWX0lURU0sXG4gICAgICAgICAgaXNBY3RpdmUgJiYgdGhpcy5pc05hdkl0ZW0oaXRlbSksIGl0ZW0pO1xuICAgICAgdGhpcy5hZGFwdGVyXy50b2dnbGVDbGFzcyhDbGFzc2VzLkFDVElWRV9NT0JJTEVfTkFWX0lURU0sXG4gICAgICAgICAgaXNBY3RpdmUgJiYgdGhpcy5pc01vYmlsZU5hdkl0ZW0oaXRlbSksIGl0ZW0pO1xuICAgICAgdGhpcy5hZGFwdGVyXy50b2dnbGVDbGFzcyhDbGFzc2VzLkFDVElWRV9TVUJOQVZfSVRFTSxcbiAgICAgICAgICBpc0FjdGl2ZSAmJiB0aGlzLmlzU3ViTmF2SXRlbShpdGVtKSwgaXRlbSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnRvZ2dsZUNsYXNzKENsYXNzZXMuQUNUSVZFX01PQklMRV9TVUJOQVZfSVRFTSxcbiAgICAgICAgICBpc0FjdGl2ZSAmJiB0aGlzLmlzTW9iaWxlU3ViTmF2SXRlbShpdGVtKSwgaXRlbSk7XG5cbiAgICAgIC8vIEhhbmRsZSBwYXJlbnQgbmF2IGl0ZW1zIGZvciBhY3RpdmUgc3VibmF2IGl0ZW1zLlxuICAgICAgaWYgKGlzQWN0aXZlICYmIHRoaXMuaXNTdWJOYXZJdGVtKGl0ZW0pIHx8XG4gICAgICAgICAgaXNBY3RpdmUgJiYgdGhpcy5pc01vYmlsZVN1Yk5hdkl0ZW0oaXRlbSkpIHtcbiAgICAgICAgLy8gSXRlbSBzaG91bGQgYmUgYWN0aXZlIGFuZCBpcyBhIHN1Ym5hdiBpdGVtLiBBZGQgdGhlIGFwcHJvcHJpYXRlXG4gICAgICAgIC8vIGBhY3RpdmVgIGNsYXNzIHRvIGl0cyBwYXJlbnQuXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlUGFyZW50XyhpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0ZW0gc2hvdWxkIE5PVCBiZSBhY3RpdmU7IHJlbW92ZSBgaGFzIGFjdGl2ZSBzdWJuYXZgIGNsYXNzZXMgdG9cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgcGFyZW50IG5hdiBpdGVtcyBoYXZlIHRoZSBhcHByb3ByaWF0ZSBzdHlsaW5nLlxuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGl0ZW0sIENsYXNzZXMuSEFTX0FDVElWRV9TVUJOQVYpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGl0ZW0sIENsYXNzZXMuSEFTX0FDVElWRV9NT0JJTEVfU1VCTkFWKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBhcHByb3ByaWF0ZSBgaGFzIGFjdGl2ZSBzdWJuYXZgIGNsYXNzIHRvIHRoZSBwYXJlbnQgbmF2IGl0ZW0gb2ZcbiAgICogdGhlIGdpdmVuIHN1Ym5hdiBpdGVtLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBpdGVtIFN1Ym5hdiBpdGVtLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0QWN0aXZlUGFyZW50XyhpdGVtKSB7XG4gICAgY29uc3QgcGFyZW50SXRlbSA9IHRoaXMuYWRhcHRlcl8uZ2V0UGFyZW50TmF2SXRlbShpdGVtKTtcblxuICAgIHRoaXMuYWRhcHRlcl8udG9nZ2xlQ2xhc3MoQ2xhc3Nlcy5IQVNfQUNUSVZFX1NVQk5BVixcbiAgICAgICAgdGhpcy5pc1N1Yk5hdkl0ZW0oaXRlbSksIHBhcmVudEl0ZW0pO1xuXG4gICAgdGhpcy5hZGFwdGVyXy50b2dnbGVDbGFzcyhDbGFzc2VzLkhBU19BQ1RJVkVfTU9CSUxFX1NVQk5BVixcbiAgICAgICAgdGhpcy5pc01vYmlsZVN1Yk5hdkl0ZW0oaXRlbSksIHBhcmVudEl0ZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGBhcmlhLWhpZGRlbmAgdmFsdWUgYW5kIHNldHMgdGhlIGFsaWdubWVudCBvZiB0aGUgc3VibmF2XG4gICAqIGJlbG9uZ2luZyB0byB0aGUgaW50ZXJhY3RlZCBuYXYgd3JhcHBlci5cbiAgICogQHBhcmFtIHshRXZlbnR9IGUgRXZlbnQgb2JqZWN0LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBzdWJuYXYgVGhlIHZpc2libGUgc3VibmF2IGVsZW1lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVNb3VzZUV2ZW50XyhlLCBzdWJuYXYpIHtcbiAgICBjb25zdCBpc01vdXNlRW50ZXIgPSBlLnR5cGUgPT09IEV2ZW50cy5NT1VTRUVOVEVSO1xuXG4gICAgLy8gUmVtb3ZlcyBgZm9jdXNlZGAgY2xhc3MgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIG5hdiBpdGVtIHdyYXBwZXIgd2hpbGVcbiAgICAvLyB1c2luZyB0aGUgdGFiIGtleSB0byBuYXZpZ2F0ZSBhbmQgYWxzbyByZW1vdmVzIHRoZSBmb2N1cyBmcm9tIHRoZVxuICAgIC8vIGFjdGl2ZSBlbGVtZW50LiBUaGlzIGFsbG93cyB1c2VycyB0byBzZWFtbGVzc2x5IHN3aXRjaCBmcm9tIGtleWJvYXJkIHRvXG4gICAgLy8gbW91c2UgbmF2aWdhdGlvbi5cbiAgICB0aGlzLnJlc2V0XyhzdWJuYXYpO1xuICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXG4gICAgLy8gU2V0cyB0aGUgZ2l2ZW4gc3VibmF2IGBhcmlhLWhpZGRlbmAgdG8gZmFsc2UuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEF0dHJzLkFSSUFfSElEREVOLCAhaXNNb3VzZUVudGVyLCBzdWJuYXYpO1xuXG4gICAgaWYgKGlzTW91c2VFbnRlcikge1xuICAgICAgLy8gU2V0cyB0aGUgYWxpZ25tZW50IG9mIHRoZSB2aXNpYmxlIHN1Ym5hdi5cbiAgICAgIHRoaXMuc2V0U3VibmF2QWxpZ25tZW50XyhzdWJuYXYpO1xuICAgICAgdGhpcy5zdWJuYXZJc1Zpc2libGVfID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvd3MgdGhlIHN1Ym5hdiBvZiBhIG5hdiBpdGVtIHdoZW4gaXQgaXMgZm9jdXNlZCBvbiB3aXRoIHRoZSB0YWIga2V5IHdoaWxlXG4gICAqIGF0IHRoZSBzYW1lIHRpbWUgdG9nZ2xpbmcgdGhlIHN1Ym5hdiBgYXJpYS1oaWRkZW5gIHZhbHVlLiBCZWZvcmUgYWxsIG9mXG4gICAqIHRoaXMgaGFwcGVucywgYWxsIG90aGVyIG5hdiBpdGVtcyBhbmQgdGhlaXIgc3VibmF2cyBhcmUgcmVzZXQuIEFuIGBFc2NhcGVgXG4gICAqIGtleSBwcmVzcyB3aWxsIHJlc2V0IGFsbCBuYXYgaXRlbXMgYW5kIHRoZWlyIHN1Ym5hdnMgYmVmb3JlIHJlbW92aW5nIGZvY3VzLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZSBLZXl1cCBldmVudCBvYmplY3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVLZXlVcF8odGFyZ2V0LCBlKSB7XG4gICAgY29uc3Qgc3VibmF2ID0gdGhpcy5hZGFwdGVyXy5xdWVyeUVsKFNlbGVjdG9ycy5TVUJOQVYsIHRhcmdldCk7XG5cbiAgICB0aGlzLnJlc2V0XygpO1xuXG4gICAgLy8gSXMgb24gbW9iaWxlIHZpZXcgb3IgdGhlcmUgaXMgbm8gc3VibmF2IHRvIHRvZ2dsZS5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNQYXN0QnJlYWtwb2ludCgpIHx8ICFzdWJuYXYpIHJldHVybjtcblxuICAgIGlmIChlLmtleUNvZGUgPT09IEtleXMuVEFCKSB7XG4gICAgICAvLyBUYWIga2V5IGlzIHByZXNzZWQgc28gaGFuZGxlIHN1Ym5hdiB2aXNpYmlsaXR5LlxuICAgICAgdGhpcy5zZXRTdWJuYXZBbGlnbm1lbnRfKHN1Ym5hdik7XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGFyZ2V0LCBDbGFzc2VzLk5BVl9JVEVNX1dSQVBQRVJfRk9DVVNFRCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoQXR0cnMuQVJJQV9ISURERU4sIGZhbHNlLCBzdWJuYXYpO1xuICAgICAgdGhpcy5zdWJuYXZJc1Zpc2libGVfID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS2V5cy5FU0MgJiYgdGhpcy5zdWJuYXZJc1Zpc2libGVfKSB7XG4gICAgICAvLyBFc2NhcGUga2V5IGlzIHByZXNzZWQgYW5kIGEgc3VibmF2IGlzIHZpc2libGUgc28gcmVzZXQgZXZlcnl0aGluZy5cbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIG5hdiB3aGVuIHRoZSB2aWV3cG9ydCBoYXMgYmVlbiByZWR1Y2VkIHRvIGEgc2l6ZSBiZWxvdyB0aGVcbiAgICogdGhlIGJyZWFrcG9pbnQgYnV0IG9ubHkgaWYgdGhlcmUgaXMgYSBzdWJuYXYgdmlzaWJsZS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGUgVGhlIHdpbmRvdyByZXNpemUgZXZlbnQgb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUmVzaXplXyhlKSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmlzUGFzdEJyZWFrcG9pbnQoKSAmJiB0aGlzLnN1Ym5hdklzVmlzaWJsZV8pIHtcbiAgICAgIHRoaXMucmVzZXRfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgbmF2IHdoZW4gdGhlIHVzZXIgdGFicyBvZmYgdGhlIG5hdiBhbGwgdG9nZXRoZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVUYWJiaW5nT2ZmTmF2XygpIHtcbiAgICBpZiAoIXRoaXMuaXNOYXZJdGVtKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICYmXG4gICAgICAgICF0aGlzLmlzU3ViTmF2SXRlbShkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5yZXNldF8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBgZm9jdXNlZGAgY2xhc3MgZnJvbSBhbGwgbmF2IGl0ZW0gd3JhcHBlcnMgd2hpbGUgYWxzbyBzZXR0aW5nIGFsbFxuICAgKiBzdWJuYXYgYGFyaWEtaGlkZGVuYCB2YWx1ZXMgdG8gdHJ1ZS4gSWYgYSBzcGVjaWZpYyBzdWJuYXYgaXMgZ2l2ZW4sIGFueVxuICAgKiBgb3ZlcmZsb3dgIGNsYXNzIGl0IG1heSBoYXZlIHdpbGwgYWxzbyBiZSByZW1vdmVkLlxuICAgKiBAcGFyYW0geyFFbGVtZW50PX0gc3VibmF2IE9wdGlvbmFsIHN1Ym5hdiBlbGVtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXRfKHN1Ym5hdikge1xuICAgIHRoaXMuc3VibmF2SXNWaXNpYmxlXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5uYXZJdGVtV3JhcHBlcnNfLmZvckVhY2goKHdyYXBwZXIpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3Mod3JhcHBlciwgQ2xhc3Nlcy5OQVZfSVRFTV9XUkFQUEVSX0ZPQ1VTRUQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdWJuYXZzXy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoQXR0cnMuQVJJQV9ISURERU4sIHRydWUsIHMpO1xuICAgIH0pO1xuXG4gICAgaWYgKHN1Ym5hdikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhzdWJuYXYsIENsYXNzZXMuU1VCTkFWX09WRVJGTE9XSU5HX0xFRlQpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhzdWJuYXYsIENsYXNzZXMuU1VCTkFWX09WRVJGTE9XSU5HX1JJR0hUKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvaGVhZGVyL25hdi9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IExCQ29tcG9uZW50IGZyb20gJy4uLy4uL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtMQk1vYmlsZU5hdkZvdW5kYXRpb259IGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQge0NsYXNzZXMsIFNlbGVjdG9yc30gZnJvbSAnLi4vbmF2L2NvbnN0YW50cyc7XG5pbXBvcnQge2RlbGVnYXRlfSBmcm9tICcuLi8uLi8uLi9wcm92aWRlcnMvdXRpbHMvdXRpbHMnO1xuXG5cbmV4cG9ydCBjbGFzcyBMQk1vYmlsZU5hdiBleHRlbmRzIExCQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIExCTW9iaWxlTmF2IGNsYXNzLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290IFRoZSBtb2JpbGUgbmF2IGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFMQk1vYmlsZU5hdn1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBMQk1vYmlsZU5hdihyb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTEJNb2JpbGVOYXZGb3VuZGF0aW9ufVxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBMQk1vYmlsZU5hdkZvdW5kYXRpb24oe1xuICAgICAgYWRkTGlzdGVuZXI6IChldmVudFR5cGUsIGhhbmRsZXIsIGVsID0gd2luZG93KSA9PiB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZWxlZ2F0ZUV2ZW50OiAoc2VsZWN0b3IsIGV2ZW50VHlwZSwgaGFuZGxlciwgZWwgPSBkb2N1bWVudCkgPT4ge1xuICAgICAgICBkZWxlZ2F0ZShlbCwgc2VsZWN0b3IsIGV2ZW50VHlwZSwgKCkgPT4ge1xuICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0TWVudUJ0bjogKCkgPT4ge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3RvcnMuTUVOVV9CVE4pO1xuICAgICAgfSxcbiAgICAgIGdldFJvb3RFbDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290XztcbiAgICAgIH0sXG4gICAgICBpc01vYmlsZU5hdk9wZW5lZDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3Nlcy5PUEVORURfTU9CSUxFX05BVik7XG4gICAgICB9LFxuICAgICAgaXNQYXN0QnJlYWtwb2ludDogKCkgPT4ge1xuICAgICAgICBjb25zdCBwc2V1ZG9Db250ZW50ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5yb290XyxcbiAgICAgICAgICAgICc6OmJlZm9yZScpLmdldFByb3BlcnR5VmFsdWUoJ2NvbnRlbnQnKTtcblxuICAgICAgICByZXR1cm4gcHNldWRvQ29udGVudCAhPT0gJ1wibW9iaWxlXCInO1xuICAgICAgfSxcbiAgICAgIHF1ZXJ5QWxsOiAoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlDb21wb25lbnRTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQXR0cjogKGF0dHIsIGVsID0gdGhpcy5yb290XykgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHIoYXR0ciwgZWwpO1xuICAgICAgfSxcbiAgICAgIHNldEF0dHI6IChhdHRyLCB2YWwsIGVsID0gdGhpcy5yb290XykgPT4ge1xuICAgICAgICB0aGlzLnNldEF0dHIoYXR0ciwgdmFsLCBlbCk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlQ2xhc3M6IChjbGFzc05hbWUsIGFkZENsYXNzLCBlbCkgPT4ge1xuICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzTmFtZSwgYWRkQ2xhc3MsIGVsKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvaGVhZGVyL21vYmlsZS1uYXYvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlJztcbmltcG9ydCB7QXR0cnMsIENsYXNzZXMsIEtleXMsIFNlbGVjdG9yc30gZnJvbSAnLi4vbmF2L2NvbnN0YW50cyc7XG5pbXBvcnQgRGV0ZWN0IGZyb20gJy4uLy4uLy4uL3Byb3ZpZGVycy9kZXRlY3QvZGV0ZWN0JztcblxuXG5leHBvcnQgY2xhc3MgTEJNb2JpbGVOYXZGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZExpc3RlbmVyOiAoLyogZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6ICFGdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgZWw6ICFFbGVtZW50fHdpbmRvdyAqLykgPT4ge30sXG4gICAgICBkZWxlZ2F0ZUV2ZW50OiAoLyogc2VsZWN0b3I6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiAhRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgZWw6ICFFbGVtZW50fGRvY3VtZW50ICovKSA9PiB7fSxcbiAgICAgIGdldE1lbnVCdG46ICgpID0+IC8qICFFbGVtZW50ICovIHt9LFxuICAgICAgZ2V0Um9vdEVsOiAoKSA9PiAvKiAhRWxlbWVudCAqLyB7fSxcbiAgICAgIGlzTW9iaWxlTmF2T3BlbmVkOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgaXNQYXN0QnJlYWtwb2ludDogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHF1ZXJ5QWxsOiAoLyogc2VsZWN0b3I6IHN0cmluZyAqLykgPT4gLyogIUFycmF5PCFFbGVtZW50PiAqLyBbXSxcbiAgICAgIHJlbW92ZUF0dHI6ICgvKiBhdHRyOiBzdHJpbmcsIGVsOiAhRWxlbWVudCovKSA9PiB7fSxcbiAgICAgIHNldEF0dHI6ICgvKiBhdHRyOiBzdHJpbmcsIHZhbDogc3RyaW5nLCBlbDogIUVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgdG9nZ2xlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3M6IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgIGVsOiAhRWxlbWVudCAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKExCTW9iaWxlTmF2Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqXG4gICAgICogTW9iaWxlIG5hdiBlbGVtZW50LlxuICAgICAqIEBwcml2YXRlIHshRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnJvb3RfID0gdGhpcy5hZGFwdGVyXy5nZXRSb290RWwoKTtcblxuICAgIC8qKlxuICAgICAqIEFsbCBhbmNob3IgYW5kIGJ1dHRvbiBlbGVtZW50cyB3aXRoaW4gdGhlIHJvb3QgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZSB7IUFycmF5PCFFbGVtZW50Pn1cbiAgICAgKi9cbiAgICB0aGlzLnRhYmFibGVJdGVtc18gPVxuICAgICAgICB0aGlzLmFkYXB0ZXJfLnF1ZXJ5QWxsKFNlbGVjdG9ycy5UQUJBQkxFX0VMUyk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFEZXRlY3R9ICovXG4gICAgdGhpcy5kZXRlY3RfID0gbmV3IERldGVjdCgpO1xuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50c18oKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZWdpc3RlckV2ZW50c18oKSB7XG4gICAgLy8gTW9iaWxlIG5hdiBtZW51IGJ0bi5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlbGVnYXRlRXZlbnQoU2VsZWN0b3JzLk1PQklMRV9OQVZfVE9HR0xFLCAnY2xpY2snLFxuICAgICAgICB0aGlzLnRvZ2dsZU1vYmlsZU5hdl8uYmluZCh0aGlzKSk7XG5cbiAgICAvLyBXaW5kb3cgZXZlbnRzLlxuICAgIHRoaXMuYWRhcHRlcl8uYWRkTGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplXy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlS2V5UHJlc3NfLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGBvcGVuZWRgIGNsYXNzIG9uIHRoZSBtb2JpbGUgbmF2IGVsZW1lbnQgd2hpbGUgYXQgdGhlIHNhbWUgdGltZVxuICAgKiBkaXNhYmxpbmcgc2Nyb2xsaW5nIGFuZCB0b2dnbGluZyBhcmlhIGF0dHJzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdG9nZ2xlTW9iaWxlTmF2XygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnRvZ2dsZUNsYXNzKENsYXNzZXMuT1BFTkVEX01PQklMRV9OQVYsXG4gICAgICAgICF0aGlzLmFkYXB0ZXJfLmlzTW9iaWxlTmF2T3BlbmVkKCksIHRoaXMucm9vdF8pO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEF0dHJzLkFSSUFfSElEREVOLFxuICAgICAgICAhdGhpcy5hZGFwdGVyXy5pc01vYmlsZU5hdk9wZW5lZCgpKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzTW9iaWxlTmF2T3BlbmVkKCkpIHtcbiAgICAgIHRoaXMudGFiYWJsZUl0ZW1zX1swXS5mb2N1cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmdldE1lbnVCdG4oKS5mb2N1cygpO1xuICAgIH1cblxuICAgIHRoaXMudG9nZ2xlTW9iaWxlVGFiSW5kZXhpbmdfKCk7XG4gICAgdGhpcy50b2dnbGVNb2JpbGVTY3JvbGxpbmdfKCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyBgW3RhYmluZGV4PVwiLTFcIl1gIG9uIG1vYmlsZSBuYXYgaXRlbXMgdG8gZGlzYWJsZSB0YWIgaW5kZXhpbmdcbiAgICogd2l0aGluIHRoZSBtYWJpbGUgbmF2IHdoZW4gaXQgaXMgY2xvc2VkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdG9nZ2xlTW9iaWxlVGFiSW5kZXhpbmdfKCkge1xuICAgIHRoaXMudGFiYWJsZUl0ZW1zXy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5pc01vYmlsZU5hdk9wZW5lZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cigndGFiaW5kZXgnLCBpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCAnLTEnLCBpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBgbm8tc2Nyb2xsYCBjbGFzcyBvbiB0aGUgaHRtbCBhbmQgYm9keSBlbGVtZW50cyB0byBkaXNhYmxlXG4gICAqIHBhZ2Ugc2Nyb2xsaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdG9nZ2xlTW9iaWxlU2Nyb2xsaW5nXygpIHtcbiAgICBjb25zdCBpc05hdk9wZW5lZCA9IHRoaXMuYWRhcHRlcl8uaXNNb2JpbGVOYXZPcGVuZWQoKTtcblxuICAgIHRoaXMuYWRhcHRlcl8udG9nZ2xlQ2xhc3MoQ2xhc3Nlcy5OT19TQ1JPTEwsIGlzTmF2T3BlbmVkLCBkb2N1bWVudC5ib2R5KTtcblxuICAgIC8vIGlPUyBkb2Vzbid0IHJlY29nbml6ZSBqdXN0IGBib2R5IHtvdmVyZmxvdzogaGlkZGVufWAuIFlvdSBoYXZlIHRvXG4gICAgLy8gYWRkIGl0IHRvIHRoZSBodG1sIGVsZW1lbnQgYXMgd2VsbCBhcyBzZXR0aW5nIDEwMCUgaGVpZ2h0LiBUaGUgMTAwJVxuICAgIC8vIGhlaWdodCBvbiB0aGUgaHRtbCBlbGVtZW50IGdpdmVzIHRoZSB1bndhbnRlZCBlZmZlY3Qgb2Ygc2Nyb2xsaW5nIGJhY2sgdG9cbiAgICAvLyB0aGUgdG9wLCBzbyB3ZSBsaW1pdCBpdCB0byBpT1MgZGV2aWNlcyBvbmx5LlxuICAgIGlmICh0aGlzLmRldGVjdF8uaW9zKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnRvZ2dsZUNsYXNzKENsYXNzZXMuTk9fU0NST0xMLCBpc05hdk9wZW5lZCxcbiAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIG1vYmlsZSBuYXYgZWxlbWVudCB3aGVuIGEgdXNlciByZXNpemVzIHRoZSBicm93c2VyIHdpbmRvd1xuICAgKiB0byBhIHNpemUgbGFyZ2VyIHRoZW4gb3IgZXF1YWwgdG8gdGhlIGJyZWFrcG9pbnQsIGJ1dCBvbmx5IGlmIGl0IGlzXG4gICAqIG9wZW5lZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVJlc2l6ZV8oKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNQYXN0QnJlYWtwb2ludCgpICYmXG4gICAgICAgIHRoaXMuYWRhcHRlcl8uaXNNb2JpbGVOYXZPcGVuZWQoKSkge1xuICAgICAgdGhpcy50b2dnbGVNb2JpbGVOYXZfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9iaWxlIG5hdiBhbmQgZm9jdXNlcyBvbiB0aGUgbWVudSBidXR0b24gaWYgdGhlIEVzY2FwZSBrZXlcbiAgICogaXMgcHJlc3NlZCB3aGVuIHRoZSBtb2JpbGUgbmF2IGlzIG9wZW5lZC4gSXQgYWxzbyBoYW5kbGVzLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZSBrZXl1cCBldmVudCBvYmplY3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVLZXlQcmVzc18oZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IEtleXMuRVNDICYmIHRoaXMuYWRhcHRlcl8uaXNNb2JpbGVOYXZPcGVuZWQoKSkge1xuICAgICAgdGhpcy50b2dnbGVNb2JpbGVOYXZfKCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2hlYWRlci9tb2JpbGUtbmF2L2ZvdW5kYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGNvbnN0IHtPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbj59IFRlc3RzIHRvIHJ1bi4gKi9cbmV4cG9ydCBjb25zdCB0ZXN0cyA9IHtcbiAgJ2pzJzogKHdpbiwgcGxhdGZvcm0pID0+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgJ2lvcyc6ICh3aW4sIHBsYXRmb3JtKSA9PiB7XG4gICAgcmV0dXJuIC8oaVBob25lfGlQb2R8aVBhZCkvaS50ZXN0KHBsYXRmb3JtKTtcbiAgfSxcbiAgJ21hYyc6ICh3aW4sIHBsYXRmb3JtKSA9PiB7XG4gICAgcmV0dXJuIC8oTWFjKS9pLnRlc3QocGxhdGZvcm0pO1xuICB9LFxuICAnbWFjT3JJb3MnOiAod2luLCBwbGF0Zm9ybSkgPT4ge1xuICAgIHJldHVybiB0ZXN0cy5tYWMod2luLCBwbGF0Zm9ybSkgfHwgdGVzdHMuaW9zKHdpbiwgcGxhdGZvcm0pO1xuICB9LFxuICAnYW5kcm9pZCc6ICh3aW4sIHBsYXRmb3JtKSA9PiB7XG4gICAgcmV0dXJuIC8oQW5kcm9pZCkvaS50ZXN0KHBsYXRmb3JtKTtcbiAgfSxcbiAgJ29udG91Y2hzdGFydCc6ICh3aW4sIHBsYXRmb3JtKSA9PiB7XG4gICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIHdpbjtcbiAgfSxcbiAgJ21vYmlsZSc6ICh3aW4sIHBsYXRmb3JtKSA9PiB7XG4gICAgcmV0dXJuICh0ZXN0cy5hbmRyb2lkKHdpbiwgcGxhdGZvcm0pIHx8XG4gICAgICAgICAgICB0ZXN0cy5pb3Mod2luLCBwbGF0Zm9ybSkgfHxcbiAgICAgICAgICAgIC8od2ViT1MpL2kudGVzdChwbGF0Zm9ybSkgfHxcbiAgICAgICAgICAgIC8oQmxhY2tCZXJyeSkvaS50ZXN0KHBsYXRmb3JtKSB8fFxuICAgICAgICAgICAgLyhXaW5kb3dzIFBob25lKS9pLnRlc3QocGxhdGZvcm0pKTtcbiAgfSxcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvZGV0ZWN0L3Rlc3RzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFB1YlN1YiBmcm9tICcuLi8uLi9wcm92aWRlcnMvcHViLXN1Yic7XG4vLyBQbGFjaW5nIGBQdWJTdWJgIGluIGl0J3Mgb3duIGZpbGUgYWxsb3dzIG90aGVyIHByb3ZpZGVycyBvciBjb2RlIHRvXG4vLyB1c2UgdGhlIHNoYXJlZCBpbnN0YW5jZSB3aXRob3V0IGhhdmluZyB0byBpbXBvcnQgTEJQbGFpbkNvbXBvbmVudCxcbi8vIG9yIGluamVjdCBhbiBpbnN0YW5jZSB0aGUgdXNlciBjcmVhdGVzIGludG8gZWFjaCBjb21wb25lbnQgdGhhdCBuZWVkcyBpdC5cbmV4cG9ydCBjb25zdCBwdWJTdWJTaGFyZWQgPSBuZXcgUHViU3ViKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL2Jhc2UvcHVic3ViLXNoYXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBCcmVha3BvaW50TW9uaXRvciBmcm9tICcuLi8uLi9wcm92aWRlcnMvYnJlYWtwb2ludC1tb25pdG9yL2luZGV4JztcbmltcG9ydCB7TEJBY2NvcmRpb259IGZyb20gJy4uL2FjY29yZGlvbi9pbmRleCc7XG5cblxuZXhwb3J0IGNsYXNzIExCRm9vdGVyIHtcbiAgLyoqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3QgRm9vdGVyIGVsZW1lbnQuICovXG4gIGNvbnN0cnVjdG9yKHJvb3QpIHtcbiAgICAvKiogQGNvbnN0IEBwcml2YXRlIHs/RWxlbWVudH0gKi9cbiAgICB0aGlzLmFjY29yZGlvbkVsXyA9IHJvb3QucXVlcnlTZWxlY3RvcignLmxiLWpzLWFjY29yZGlvbicpO1xuXG4gICAgLy8gTm8gYWNjb3JkaW9uIG1lYW5zIGEgbWluaW1hbCBmb290ZXIgaXMgYmVpbmcgdXNlZCDigJQgdGhlcmUgaXMgbm9cbiAgICAvLyBmdW5jdGlvbmFsaXR5IHJlcXVpcmluZyBKUy5cbiAgICBpZiAoIXRoaXMuYWNjb3JkaW9uRWxfKSByZXR1cm47XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5hY2NvcmRpb25Jbml0aWFsaXplZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFMQkFjY29yZGlvbn0gKi9cbiAgICB0aGlzLmFjY29yZGlvbl87XG5cbiAgICBuZXcgQnJlYWtwb2ludE1vbml0b3IoKGRhdGEpID0+IHRoaXMuaW5pdEFjY29yZGlvbl8oZGF0YSkpO1xuICAgIHRoaXMuaW5pdEFjY29yZGlvbl8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIGlmIHRoZSBicmVha3BvaW50IGlzIG5vdCBgZGVza3RvcGAgYW5kIG9uZSBoYXNcbiAgICogbm90IGJlZW4gY3JlYXRlZCBhbHJlYWR5LiBPdGhlcndpc2UsIGl0J3MgZGVzdHJveWVkLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+PX0gZGF0YSBCcmVha3BvaW50IG1vbml0b3IgcHJvdmlkZXIgZGF0YS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRBY2NvcmRpb25fKGRhdGE9dW5kZWZpbmVkKSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5icmVha3BvaW50ID09PSAnZGVza3RvcCcgJiYgdGhpcy5hY2NvcmRpb25Jbml0aWFsaXplZF8pIHtcbiAgICAgIHRoaXMuYWNjb3JkaW9uXy5kZXN0cm95KCk7XG4gICAgICB0aGlzLmFjY29yZGlvbkluaXRpYWxpemVkXyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWNjb3JkaW9uXyA9IExCQWNjb3JkaW9uLmF0dGFjaFRvKHRoaXMuYWNjb3JkaW9uRWxfKTtcbiAgICB0aGlzLmFjY29yZGlvbkluaXRpYWxpemVkXyA9IHRydWU7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL2NvbXBvbmVudHMvZm9vdGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgQlJFQUtQT0lOVF9DSEFOR0VfRVZFTlRfTkFNRTogJ2xiLWJyZWFrcG9pbnQtY2hhbmdlJyxcbiAgUkVTSVpFX0VWRU5UX05BTUU6ICdyZXNpemUnLFxuICBIVE1MX1NFTEVDVE9SOiAnaHRtbCcsXG4gIEJFRk9SRV9TRUxFQ1RPUjogJzpiZWZvcmUnLFxuICBDT05URU5UX1BST1BFUlRZOiAnY29udGVudCcsXG59O1xuXG4vKiogQGNvbnN0IHshUmVnRXhwfSAqL1xuZXhwb3J0IGNvbnN0IFFVT1RFX1JFXyA9IC9bJ1wiXSsvZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9icmVha3BvaW50LW1vbml0b3IvY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IExCUGxhaW5Db21wb25lbnQgZnJvbSAnLi4vYmFzZS9wbGFpbic7XG5pbXBvcnQge0F0dHIsIENsYXNzLCBFdmVudCwgU3RhdGUsIEluaXRUeXBlLCBERUZBVUxUX09QVElPTlN9XG4gICAgZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtFbGVtZW50T2JzZXJ2ZXIsIFlUSWZyYW1lQXBpSW5pdH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBZVFBsYXllciBleHRlbmRzIExCUGxhaW5Db21wb25lbnQge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFlUUGxheWVyIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdCBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgc3VwZXIocm9vdCk7XG4gICAgdGhpcy5wYXJzZU9wdGlvbnNTdHJpbmcoKTtcblxuICAgIC8qKiBAdHlwZSB7P1lvdVR1YmVQbGF5ZXJ9IEEgWW91VHViZSBlbWJlZGRlZCBwbGF5ZXIuICovXG4gICAgdGhpcy5wbGF5ZXI7XG5cbiAgICAvKiogQHByaXZhdGUge0Z1bmN0aW9ufSBSZXNvbHZlIHRoZSBwbGF5ZXIgaW50aWFsaXphdGlvbiBwcm9taXNlLiAqL1xuICAgIHRoaXMucmVzb2x2ZVBsYXllclByb21pc2VfO1xuXG4gICAgLyoqIEBwcml2YXRlIHtGdW5jdGlvbn0gUmVqZWN0IHRoZSBwbGF5ZXIgaW50aWFsaXphdGlvbiBwcm9taXNlLiAqL1xuICAgIHRoaXMucmVqZWN0UGxheWVyUHJvbWlzZV87XG5cbiAgICAvKiogQHByaXZhdGUge1Byb21pc2V9IEEgcHJvbWlzZSBmb3IgdGhlIHBsYXllciBpbnRpYWxpemF0aW9uLiAqL1xuICAgIHRoaXMucGxheWVyUHJvbWlzZV8gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmVQbGF5ZXJQcm9taXNlXyA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdFBsYXllclByb21pc2VfID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqIEBwcml2YXRlIHtzdHJpbmd9ICovXG4gICAgdGhpcy52aWRlb0lkXyA9IHRoaXMucm9vdF8uZ2V0QXR0cmlidXRlKEF0dHIuVklERU9fSUQpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtPYmplY3R9ICovXG4gICAgdGhpcy5vcHRpb25zXyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgdGhpcy5vcHRpb25zXyk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgdGhlIHBsYXllciBhY2Nlc3NpYmxlIGFzIGEgcHJvbWlzZS5cbiAgICogQHJldHVybiB7IVByb21pc2V9IEEgcHJvbWlzZSBmb3IgYSBZb3VUdWJlIHBsYXllci5cbiAgICovXG4gIGdldFBsYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJQcm9taXNlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0byBpbml0aWFsaXplIGEgWW91VHViZSBwbGF5ZXIuXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBZVElmcmFtZUFwaUluaXQubG9hZEFwaSgpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5pbml0VHlwZSA9PT0gSW5pdFR5cGUuSU1NRURJQVRFKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlUGxheWVyKHRoaXMudmlkZW9JZF8sIHRoaXMub3B0aW9uc18ucGxheWVyVmFycyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaW5pdFR5cGUgPT09IEluaXRUeXBlLkFVVE8pIHtcbiAgICAgICAgbmV3IEVsZW1lbnRPYnNlcnZlcih0aGlzLnJvb3RfLCB7XG4gICAgICAgICAgb25BY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVQbGF5ZXIodGhpcy52aWRlb0lkXywgdGhpcy5vcHRpb25zXy5wbGF5ZXJWYXJzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFjdGl2YXRlVGhyZXNob2xkOiAwLFxuICAgICAgICAgIGFjdGl2YXRlT25jZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIFlvdVR1YmUgcGxheWVyIHVzaW5nIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb0lkIFRoZSBJRCBvZiB0aGUgdmlkZW8uXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcGxheWVyVmFycyBDb25maWd1cmF0aW9uIGZvciB0aGUgcGxheWVyLlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZX0gQSBwcm9taXNlIGZvciBhIFlvdVR1YmUgcGxheWVyLlxuICAgKi9cbiAgY3JlYXRlUGxheWVyKHZpZGVvSWQgPSB0aGlzLnZpZGVvSWRfLCBwbGF5ZXJWYXJzID0gdGhpcy5vcHRpb25zXy5wbGF5ZXJWYXJzKSB7XG4gICAgdGhpcy52aWRlb0lkXyA9IHZpZGVvSWQ7XG4gICAgdGhpcy5yb290Xy5jbGFzc0xpc3QuYWRkKENsYXNzLkxPQURJTkcpO1xuICAgIGNvbnN0IHZpZGVvQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmlkZW9Db250YWluZXIuY2xhc3NMaXN0LmFkZChDbGFzcy5WSURFT19DT05UQUlORVIpO1xuICAgIHRoaXMucm9vdF8uYXBwZW5kQ2hpbGQodmlkZW9Db250YWluZXIpO1xuXG4gICAgdGhpcy5wbGF5ZXIgPSBuZXcgd2luZG93LllULlBsYXllcih2aWRlb0NvbnRhaW5lciwge1xuICAgICAgdmlkZW9JZDogcGxheWVyVmFycy5saXN0ID8gdW5kZWZpbmVkIDogdmlkZW9JZCxcbiAgICAgIC8vIExlYXJuIG1vcmUgYWJvdXQgZXZlbnRzIGhlcmU6XG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS95b3V0dWJlL2lmcmFtZV9hcGlfcmVmZXJlbmNlI0V2ZW50c1xuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIG9uRXJyb3I6IHRoaXMuaGFuZGxlUGxheWVyT25FcnJvcl8uYmluZCh0aGlzKSxcbiAgICAgICAgb25SZWFkeTogdGhpcy5oYW5kbGVQbGF5ZXJPblJlYWR5Xy5iaW5kKHRoaXMpLFxuICAgICAgICBvblN0YXRlQ2hhbmdlOiB0aGlzLmhhbmRsZVBsYXllclN0YXRlQ2hhbmdlXy5iaW5kKHRoaXMpLFxuICAgICAgfSxcbiAgICAgIC8vIFNlZSBhbGwgc3VwcG9ydGVkIHBsYXllciB2YXJzIGhlcmU6XG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS95b3V0dWJlL3BsYXllcl9wYXJhbWV0ZXJzP3BsYXllclZlcnNpb249SFRNTDUjUGFyYW1ldGVyc1xuICAgICAgcGxheWVyVmFycyxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmdldFBsYXllcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIG9uRXJyb3IgY2FsbGJhY2sgZnJvbSB0aGUgcGxheWVyLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlcnJvciBBbiBlcnJvciBtZXNzYWdlIGZyb20gdGhlIFlvdVR1YmUgUGxheWVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgIGhhbmRsZVBsYXllck9uRXJyb3JfKGVycm9yKSB7XG4gICAgIC8vIFR3byB3YXlzIG9mIG5vdGlmeWluZyB0aGF0IHRoZSBwbGF5ZXIgaW5pdGlhbGl6YXRpb24gZXJyb3JlZDpcbiAgICAgLy8gUHJvbWlzZSByZWplY3QgYW5kIHB1YnN1Yi5cbiAgICAgdGhpcy5yZWplY3RQbGF5ZXJQcm9taXNlXyhcbiAgICAgICAgICdUaGVyZSB3YXMgYW4gZXJyb3IgaW5pdGlhbGl6aW5nIHRoZSBwbGF5ZXIuJywgZXJyb3IpO1xuICAgICB0aGlzLnB1YlN1YlNoYXJlZF8uYnJvYWRjYXN0KEV2ZW50LlZJREVPX0VSUk9SLFxuICAgICAgICAge1xuICAgICAgICAgICB2aWRlb0lkOiB0aGlzLnZpZGVvSWRfLFxuICAgICAgICAgICBuYW1lOiB0aGlzLm9wdGlvbnNfLm5hbWUsXG4gICAgICAgICAgIGVycm9yLFxuICAgICAgICAgfSk7XG4gICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIG9uUmVhZHkgY2FsbGJhY2sgZnJvbSB0aGUgcGxheWVyLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEFuIGV2ZW50IGZyb20gdGhlIFlvdVR1YmUgUGxheWVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgIGhhbmRsZVBsYXllck9uUmVhZHlfKGUpIHtcbiAgICAgdGhpcy5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKENsYXNzLkxPQURJTkcpO1xuICAgICAvLyBUd28gd2F5cyBvZiBub3RpZnlpbmcgdGhhdCB0aGUgcGxheWVyIGlzIHJlYWR5IHRvIGludGVyYWN0IHdpdGg6XG4gICAgIC8vIFByb21pc2UgcmVzb2x1dGlvbiBhbmQgcHVic3ViLlxuICAgICB0aGlzLnJlc29sdmVQbGF5ZXJQcm9taXNlXyh0aGlzLnBsYXllcik7XG4gICAgIHRoaXMucHViU3ViU2hhcmVkXy5icm9hZGNhc3QoRXZlbnQuVklERU9fUkVBRFksXG4gICAgICAge1xuICAgICAgICAgdmlkZW9JZDogdGhpcy52aWRlb0lkXyxcbiAgICAgICAgIG5hbWU6IHRoaXMub3B0aW9uc18ubmFtZSxcbiAgICAgICAgIHBsYXllcjogdGhpcy5wbGF5ZXIsXG4gICAgICAgfSk7XG4gICAgIHRoaXMuc3Vic2NyaWJlRXZlbnRzXygpO1xuICAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBvblN0YXRlQ2hhbmdlIGNhbGxiYWNrIGZyb20gdGhlIHBsYXllciBieSBicm9hZGNhc3RpbmcgdGhlIGluZm8uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgQW4gZXZlbnQgZnJvbSB0aGUgWW91VHViZSBQbGF5ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQbGF5ZXJTdGF0ZUNoYW5nZV8oZSkge1xuICAgIGxldCBldmVudE5hbWU7XG4gICAgc3dpdGNoIChlLmRhdGEpIHtcbiAgICAgIGNhc2UgWVQuUGxheWVyU3RhdGUuRU5ERUQ6XG4gICAgICAgIGV2ZW50TmFtZSA9IFN0YXRlLlZJREVPX0VOREVEO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgWVQuUGxheWVyU3RhdGUuUExBWUlORzpcbiAgICAgICAgZXZlbnROYW1lID0gU3RhdGUuVklERU9fUExBWUlORztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFlULlBsYXllclN0YXRlLlBBVVNFRDpcbiAgICAgICAgZXZlbnROYW1lID0gU3RhdGUuVklERU9fUEFVU0VEO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgWVQuUGxheWVyU3RhdGUuQlVGRkVSSU5HOlxuICAgICAgICBldmVudE5hbWUgPSBTdGF0ZS5WSURFT19CVUZGRVJJTkc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBZVC5QbGF5ZXJTdGF0ZS5DVUVEOlxuICAgICAgICBldmVudE5hbWUgPSBTdGF0ZS5WSURFT19DVUVEO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5wdWJTdWJTaGFyZWRfLmJyb2FkY2FzdChldmVudE5hbWUsIHtcbiAgICAgIHZpZGVvSWQ6IHRoaXMudmlkZW9JZF8sXG4gICAgICBuYW1lOiB0aGlzLm9wdGlvbnNfLm5hbWUsXG4gICAgICBwbGF5ZXI6IHRoaXMucGxheWVyLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgdG8gZXZlbnRzIGZyb20gdGhlIFlvdVR1YmUgUGxheWVyIGFuZCB0aGUgWVRQbGF5ZXIgY29tcG9uZW50LlxuICAgKi9cbiAgc3Vic2NyaWJlRXZlbnRzXygpIHtcbiAgICB0aGlzLnB1YlN1YlNoYXJlZF8uc3Vic2NyaWJlKEV2ZW50LlZJREVPX1BMQVksXG4gICAgICAgIHRoaXMuaGFuZGxlUGxheV8sIHRoaXMpO1xuXG4gICAgdGhpcy5wdWJTdWJTaGFyZWRfLnN1YnNjcmliZShTdGF0ZS5WSURFT19QTEFZSU5HLFxuICAgICAgdGhpcy5oYW5kbGVQbGF5XywgdGhpcyk7XG5cbiAgICB0aGlzLnB1YlN1YlNoYXJlZF8uc3Vic2NyaWJlKEV2ZW50LlZJREVPX1BBVVNFLFxuICAgICAgICB0aGlzLmhhbmRsZVBhdXNlXywgdGhpcyk7XG5cbiAgICB0aGlzLnB1YlN1YlNoYXJlZF8uc3Vic2NyaWJlKEV2ZW50LlZJREVPX1NUT1AsXG4gICAgICAgIHRoaXMuaGFuZGxlU3RvcF8sIHRoaXMpO1xuXG4gICAgdGhpcy5wdWJTdWJTaGFyZWRfLnN1YnNjcmliZShFdmVudC5WSURFT19TVE9QX0FMTCxcbiAgICAgICAgdGhpcy5oYW5kbGVTdG9wQWxsXywgdGhpcyk7XG5cbiAgICB0aGlzLnB1YlN1YlNoYXJlZF8uc3Vic2NyaWJlKEV2ZW50LlZJREVPX1NFRUtfVE8sXG4gICAgICAgIHRoaXMuaGFuZGxlU2Vla1RvXywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHBsYXkgZXZlbnQuXG4gICAqIElmIHRoZSBldmVudCBpcyBmb3IgdGhpcyB2aWRlbywgcGxheSBpdC5cbiAgICogSWYgaXQncyBmb3IgYW5vdGhlciB2aWRlbyBhbmQgdGhpcyB2aWRlbyBpcyBwbGF5aW5nLCBwYXVzZSBpdC5cbiAgICogQHBhcmFtIHshRXZlbnR9IGUgVGhlIGV2ZW50IGRhdGEuXG4gICAqL1xuICBoYW5kbGVQbGF5XyhlKSB7XG4gICAgaWYgKHRoaXMudmFsaWRWaWRlb0lkTWF0Y2hfKGUudmlkZW9JZCkgfHxcbiAgICAgICAgdGhpcy52YWxpZE5hbWVNYXRjaF8oZS5uYW1lKSkge1xuICAgICAgdGhpcy5wbGF5ZXIucGxheVZpZGVvKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBsYXllci5nZXRQbGF5ZXJTdGF0ZSgpID09PSBZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HKSB7XG4gICAgICB0aGlzLnBsYXllci5wYXVzZVZpZGVvKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBwYXVzZSBldmVudC5cbiAgICogQHBhcmFtIHshRXZlbnR9IGUgVGhlIGV2ZW50IGRhdGEuXG4gICAqL1xuICBoYW5kbGVQYXVzZV8oZSkge1xuICAgIGlmICh0aGlzLnZhbGlkVmlkZW9JZE1hdGNoXyhlLnZpZGVvSWQpIHx8XG4gICAgICAgIHRoaXMudmFsaWROYW1lTWF0Y2hfKGUubmFtZSkpIHtcbiAgICAgIHRoaXMucGxheWVyLnBhdXNlVmlkZW8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHN0b3AgZXZlbnQuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBlIFRoZSBldmVudCBkYXRhLlxuICAgKi9cbiAgaGFuZGxlU3RvcF8oZSkge1xuICAgIGlmICh0aGlzLnZhbGlkVmlkZW9JZE1hdGNoXyhlLnZpZGVvSWQpIHx8XG4gICAgICAgIHRoaXMudmFsaWROYW1lTWF0Y2hfKGUubmFtZSkpIHtcbiAgICAgIHRoaXMucGxheWVyLnN0b3BWaWRlbygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgc3RvcCBhbGwgZXZlbnQuXG4gICAqL1xuICBoYW5kbGVTdG9wQWxsXygpIHtcbiAgICB0aGlzLnBsYXllci5zdG9wVmlkZW8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgc2Vla1RvIGV2ZW50LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZSBUaGUgZXZlbnQgZGF0YS5cbiAgICovXG4gIGhhbmRsZVNlZWtUb18oZSkge1xuICAgIGlmICh0aGlzLnZhbGlkVmlkZW9JZE1hdGNoXyhlLnZpZGVvSWQpIHx8XG4gICAgICAgIHRoaXMudmFsaWROYW1lTWF0Y2hfKGUubmFtZSkpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgc2Vjb25kczogZS5zZWNvbmRzIHx8IDAsXG4gICAgICAgIGFsbG93U2Vla0FoZWFkOiBlLmFsbG93U2Vla0FoZWFkIHx8IGZhbHNlLFxuICAgICAgfTtcbiAgICAgIHRoaXMucGxheWVyLnNlZWtUbyhwYXJhbXMuc2Vjb25kcywgcGFyYW1zLmFsbG93U2Vla0FoZWFkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBuYW1lIGhhcyBhIHZhbHVlIGFuZCBtYXRjaGVzIHRoZSBjb21wb25lbnQnc1xuICAgKiBuYW1lIG9wdGlvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIG5hbWUgbWF0Y2hlcy5cbiAgICovXG4gIHZhbGlkTmFtZU1hdGNoXyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc18ubmFtZSAmJiB0aGlzLm9wdGlvbnNfLm5hbWUgPT09IG5hbWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCB2aWRlb0lkIGhhcyBhIHZhbHVlIGFuZCBtYXRjaGVzIHRoZSBjb21wb25lbnQnc1xuICAgKiB2aWRlb0lkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgdmlkZW9JZCBtYXRjaGVzLlxuICAgKi9cbiAgdmFsaWRWaWRlb0lkTWF0Y2hfKHZpZGVvSWQpIHtcbiAgICByZXR1cm4gdGhpcy52aWRlb0lkXyAmJiB0aGlzLnZpZGVvSWRfID09PSB2aWRlb0lkO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBZb3VUdWJlIFBsYXllciBlbGVtZW50LCByZW1vdmVzIFB1YlN1YiBzdWJzY3JpcHRpb25zLFxuICAgKiBhbmQgaGlkZXMgdGhlIGxvYWRpbmcgaW1hZ2UuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGxheWVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMucHViU3ViU2hhcmVkXy51bnN1YnNjcmliZShFdmVudC5WSURFT19QTEFZLCB0aGlzLmhhbmRsZVBsYXlfKTtcbiAgICB0aGlzLnB1YlN1YlNoYXJlZF8udW5zdWJzY3JpYmUoU3RhdGUuVklERU9fUExBWUlORywgdGhpcy5oYW5kbGVQbGF5Xyk7XG4gICAgdGhpcy5wdWJTdWJTaGFyZWRfLnVuc3Vic2NyaWJlKEV2ZW50LlZJREVPX1BBVVNFLCB0aGlzLmhhbmRsZVBhdXNlXyk7XG4gICAgdGhpcy5wdWJTdWJTaGFyZWRfLnVuc3Vic2NyaWJlKEV2ZW50LlZJREVPX1NUT1AsIHRoaXMuaGFuZGxlUGF1c2VfKTtcbiAgICB0aGlzLnB1YlN1YlNoYXJlZF8udW5zdWJzY3JpYmUoRXZlbnQuVklERU9fU0VFS19UTywgdGhpcy5oYW5kbGVTZWVrVG9fKTtcblxuICAgIHRoaXMucm9vdF8uY2xhc3NMaXN0LmFkZChDbGFzcy5ERVNUUk9ZRUQpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL3l0LXBsYXllci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IEF0dHIgPSB7XG4gIFZJREVPX0lEOiAnbGItdmlkZW8taWQnLFxuICBQTEFZRVJfTkFNRTogJ2xiLXBsYXllci1uYW1lJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IENsYXNzID0ge1xuICBWSURFT19DT05UQUlORVI6ICdsYi15dC1wbGF5ZXJfX3ZpZGVvJyxcbiAgREVTVFJPWUVEOiAnbGIteXQtcGxheWVyLS1kZXN0cm95ZWQnLFxuICBMT0FESU5HOiAnbGIteXQtcGxheWVyLS1sb2FkaW5nJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IEV2ZW50ID0ge1xuICBWSURFT19FUlJPUjogJ2xiLXl0LXBsYXllci1lcnJvcicsXG4gIFZJREVPX1JFQURZOiAnbGIteXQtcGxheWVyLXJlYWR5JyxcbiAgVklERU9fUExBWTogJ2xiLXl0LXBsYXllci1wbGF5JyxcbiAgVklERU9fUEFVU0U6ICdsYi15dC1wbGF5ZXItcGF1c2UnLFxuICBWSURFT19TVE9QOiAnbGIteXQtcGxheWVyLXN0b3AnLFxuICBWSURFT19TVE9QX0FMTDogJ2xiLXl0LXBsYXllci1zdG9wLWFsbCcsXG4gIFZJREVPX1NFRUtfVE86ICdsYi15dC1wbGF5ZXItc2Vlay10bycsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBTdGF0ZSA9IHtcbiAgVklERU9fRU5ERUQ6ICdsYi1wbGF5ZXItc3RhdGUtZW5kZWQnLFxuICBWSURFT19QTEFZSU5HOiAnbGItcGxheWVyLXN0YXRlLXBsYXlpbmcnLFxuICBWSURFT19QQVVTRUQ6ICdsYi1wbGF5ZXItc3RhdGUtcGF1c2VkJyxcbiAgVklERU9fQlVGRkVSSU5HOiAnbGItcGxheWVyLXN0YXRlLWJ1ZmZlcmluZycsXG4gIFZJREVPX0NVRUQ6ICdsYi1wbGF5ZXItc3RhdGUtY3VlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBJbml0VHlwZSA9IHtcbiAgQVVUTzogJ2F1dG8nLFxuICBJTU1FRElBVEU6ICdpbW1lZGlhdGUnLFxuICBNQU5VQUw6ICdtYW51YWwnLFxufTtcblxuLyoqIEB0eXBlIHtPYmplY3R9ICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGF5ZXJWYXJzOiB7XG4gICAgZW5hYmxlanNhcGk6IDEsXG4gICAgbW9kZXN0YnJhbmRpbmc6IDEsXG4gICAgcmVsOiAwLFxuICB9LFxuICBpbml0VHlwZTogSW5pdFR5cGUuQVVUTyxcbiAgbmFtZTogbnVsbCxcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9jb21wb25lbnRzL3l0LXBsYXllci9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge2xiQXV0b0luaXR9IGZyb20gJy4vYXV0by1pbml0L2F1dG8taW5pdCc7XG5pbXBvcnQgKiBhcyBlYXNpbmcgZnJvbSAnLi9lYXNpbmcvJztcbmltcG9ydCBBMTF5IGZyb20gJy4vYTExeS8nO1xuaW1wb3J0IEFuYWx5dGljcyBmcm9tICcuL2FuYWx5dGljcy9hbmFseXRpY3MnO1xuaW1wb3J0IEF1dG9TY3JvbGwgZnJvbSAnLi9hdXRvLXNjcm9sbC8nO1xuaW1wb3J0IEJyZWFrcG9pbnRNb25pdG9yIGZyb20gJy4vYnJlYWtwb2ludC1tb25pdG9yLyc7XG5pbXBvcnQgRGV0ZWN0IGZyb20gJy4vZGV0ZWN0L2RldGVjdCc7XG5pbXBvcnQgRWxlbWVudE9ic2VydmVyIGZyb20gJy4vZWxlbWVudC1vYnNlcnZlci9lbGVtZW50LW9ic2VydmVyJztcbmltcG9ydCBMQlRlbXBsYXRlIGZyb20gJy4vdGVtcGxhdGUvdGVtcGxhdGUnO1xuaW1wb3J0IExvY2FsU3RvcmUgZnJvbSAnLi9sb2NhbC1zdG9yZS9sb2NhbC1zdG9yZSc7XG5pbXBvcnQgUGFyc2VyIGZyb20gJy4vdXJsLXBhcnNlci91cmwtcGFyc2VyJztcbmltcG9ydCBwb2x5ZmlsbHMgZnJvbSAnLi9wb2x5ZmlsbHMvcG9seWZpbGxzJztcbmltcG9ydCBQdWJTdWIgZnJvbSAnLi9wdWItc3ViLyc7XG5pbXBvcnQge1JhZn0gZnJvbSAnLi9yYWYvcmFmJztcbmltcG9ydCB7UmVxdWVzdG9yfSBmcm9tICcuL3JlcXVlc3QvcmVxdWVzdCc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi9zY2FsZS9zY2FsZSc7XG5pbXBvcnQgU2Nyb2xsIGZyb20gJy4vc2Nyb2xsL3Njcm9sbCc7XG5pbXBvcnQgVGltZXIgZnJvbSAnLi90aW1lci90aW1lcic7XG5pbXBvcnQgWVRBcGkgZnJvbSAnLi95dC1hcGkveXQtYXBpJztcbmltcG9ydCBZVElmcmFtZUFwaUluaXQgZnJvbSAnLi95dC1pZnJhbWUtYXBpLWluaXQveXQtaWZyYW1lLWFwaS1pbml0JztcblxuZXhwb3J0IHtcbiAgICBBMTF5LFxuICAgIEFuYWx5dGljcyxcbiAgICBBdXRvU2Nyb2xsLFxuICAgIEJyZWFrcG9pbnRNb25pdG9yLFxuICAgIERldGVjdCxcbiAgICBlYXNpbmcsXG4gICAgRWxlbWVudE9ic2VydmVyLFxuICAgIExCVGVtcGxhdGUsXG4gICAgTG9jYWxTdG9yZSxcbiAgICBQYXJzZXIsXG4gICAgcG9seWZpbGxzLFxuICAgIFB1YlN1YixcbiAgICBSYWYsXG4gICAgUmVxdWVzdG9yLFxuICAgIFNjYWxlLFxuICAgIFNjcm9sbCxcbiAgICBUaW1lcixcbiAgICBZVEFwaSxcbiAgICBZVElmcmFtZUFwaUluaXQsXG4gICAgbGJBdXRvSW5pdCxcbiAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7YXJpYSwgcm9sZSwgc3RyaW5ncywgbnVtYmVycywgdmFsaWRBcmlhUm9sZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQTExeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFNYXB9ICovXG4gICAgdGhpcy5mb2N1c1RyYXBRdWV1ZV8gPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgZ2V0dGVyIGZvciByZXRyaWV2aW5nIGNvbW1vbiBhcmlhIHByb3BlcnRpZXMuXG4gICAqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBhcmlhKCkge1xuICAgIHJldHVybiBhcmlhO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGdldHRlciBmb3IgcmV0cmlldmluZyBjb21tb24gcm9sZSB2YWx1ZXMuXG4gICAqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCByb2xlKCkge1xuICAgIHJldHVybiByb2xlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgcGVydGluZW50IGVsZW1lbnQgaW5mbyB0byB1c2UgZm9yIHRlc3RpbmcgYWdhaW5zdCBBUklBIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRFbGVtZW50SW5mb18oZWxlbWVudCkge1xuICAgIGNvbnN0IHJvbGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpO1xuICAgIGNvbnN0IHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWU7XG4gICAgcmV0dXJuIHtyb2xlLCB0eXBlLCB0YWdOYW1lfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIGFuIGVsZW1lbnQncyBzZWxlY3RlZCBzdGF0ZSBmb3Igc2NyZWVuIHJlYWRlcnMuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHRvZ2dsZVNlbGVjdGVkKGVsZW1lbnQpIHtcbiAgICBjb25zdCB7cm9sZSwgdHlwZSwgdGFnTmFtZX0gPSB0aGlzLmdldEVsZW1lbnRJbmZvXyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1JhZGlvID0gdGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiB0eXBlID09PSAncmFkaW8nO1xuXG4gICAgbGV0IGFyaWFTZWxlY3RlZFZhbHVlID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGFyaWEuU0VMRUNURUQpID09PSAndHJ1ZScpO1xuICAgIGFyaWFTZWxlY3RlZFZhbHVlID0gKCFhcmlhU2VsZWN0ZWRWYWx1ZSkudG9TdHJpbmcoKTtcblxuICAgIC8vIFdhcm4gYSBkZXZlbG9wZXIgaWYgdGhleSdyZSBub3QgdXNpbmcgXCJhcmlhLXNlbGVjdGVkXCIgdy8gYSB2YWxpZCByb2xlLlxuICAgIGlmICghdmFsaWRBcmlhUm9sZXMuU0VMRUNURUQuaW5jbHVkZXMocm9sZSkgfHwgaXNSYWRpbykge1xuICAgICAgY29uc29sZS53YXJuKHN0cmluZ3MuRVJST1JfTVNHX1ZBTElEX1NFTEVDVEVEKTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhLlNFTEVDVEVELCBhcmlhU2VsZWN0ZWRWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyBhbiBlbGVtZW50J3MgZXhwYW5kZWQgc3RhdGUgZm9yIHNjcmVlbiByZWFkZXJzLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cm9scyBEZW5vdGVzIHdoaWNoIGVsZW1lbnRzIGluIGEgcGFnZSBhbiBpbnRlcmFjdGl2ZVxuICAgKiAgICAgIGVsZW1lbnQgb3Igc2V0IG9mIGVsZW1lbnRzIGhhcyBjb250cm9sIG92ZXIuXG4gICAqL1xuICB0b2dnbGVFeHBhbmRlZChlbGVtZW50LCBjb250cm9scykge1xuICAgIGxldCBhcmlhRXhwYW5kZWRWYWx1ZSA9IChlbGVtZW50LmdldEF0dHJpYnV0ZShhcmlhLkVYUEFOREVEKSA9PT0gJ3RydWUnKTtcbiAgICBhcmlhRXhwYW5kZWRWYWx1ZSA9ICghYXJpYUV4cGFuZGVkVmFsdWUpLnRvU3RyaW5nKCk7XG5cbiAgICAvLyBXYXJuIGEgZGV2ZWxvcGVyIGlmIHRoZXkncmUgbm90IHVzaW5nIHZhbGlkIElEIHN0cmluZyBcImFyaWEtY29udHJvbHNcIi5cbiAgICBpZiAoY29udHJvbHMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY29udHJvbHMgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlLndhcm4oc3RyaW5ncy5FUlJPUl9NU0dfQ09OVFJPTFNfSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhLkNPTlRST0xTLCBjb250cm9scyk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXJpYS5FWFBBTkRFRCwgYXJpYUV4cGFuZGVkVmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgYW4gZWxlbWVudCdzIGNoZWNrZWQgc3RhdGUgZm9yIHNjcmVlbiByZWFkZXJzLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICB0b2dnbGVDaGVja2VkKGVsZW1lbnQpIHtcbiAgICBjb25zdCB7cm9sZSwgdHlwZSwgdGFnTmFtZX0gPSB0aGlzLmdldEVsZW1lbnRJbmZvXyhlbGVtZW50KTtcbiAgICBjb25zdCBpc0lucHV0Q2hlY2tib3ggPSB0YWdOYW1lICE9PSAnSU5QVVQnICYmIHR5cGUgIT09IHJvbGUuQ0hFQ0tCT1g7XG5cbiAgICBsZXQgYXJpYUNoZWNrYm94VmFsdWUgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXJpYS5DSEVDS0VEKSA9PT0gJ3RydWUnKTtcblxuICAgIGFyaWFDaGVja2JveFZhbHVlID0gKCFhcmlhQ2hlY2tib3hWYWx1ZSkudG9TdHJpbmcoKTtcblxuICAgIC8vIFdhcm4gYSBkZXZlbG9wZXIgaWYgdGhleSdyZSBub3QgdXNpbmcgXCJhcmlhLWNoZWNrZWRcIiB3LyBhXG4gICAgLy8gdmFsaWQgZWxlbWVudCBvciByb2xlLlxuICAgIGlmICghdmFsaWRBcmlhUm9sZXMuQ0hFQ0tFRC5pbmNsdWRlcyhyb2xlKSB8fCAhaXNJbnB1dENoZWNrYm94KSB7XG4gICAgICBjb25zb2xlLndhcm4oc3RyaW5ncy5FUlJPUl9NU0dfVkFMSURfQ0hFQ0tCT1gpO1xuICAgIH1cblxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGFyaWEuQ0hFQ0tFRCwgYXJpYUNoZWNrYm94VmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgYW4gZWxlbWVudCdzIHZpc2liaWxpdHkgc3RhdGUgZm9yIHNjcmVlbiByZWFkZXJzLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRpc2FibGVUYWJiaW5nXG4gICAqL1xuICB0b2dnbGVWaXNpYmlsaXR5KGVsZW1lbnQsIGRpc2FibGVUYWJiaW5nID0gZmFsc2UpIHtcbiAgICBsZXQgYXJpYUhpZGRlblZhbHVlID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGFyaWEuSElEREVOKSA9PT0gJ3RydWUnKTtcblxuICAgIGlmIChhcmlhSGlkZGVuVmFsdWUgJiYgZGlzYWJsZVRhYmJpbmcpIHtcbiAgICAgIHRoaXMuZGlzYWJsZVRhYmJpbmcoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICghYXJpYUhpZGRlblZhbHVlICYmIGRpc2FibGVUYWJiaW5nKSB7XG4gICAgICB0aGlzLmVuYWJsZVRhYmJpbmcoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgYXJpYUhpZGRlblZhbHVlID0gKCFhcmlhSGlkZGVuVmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXJpYS5ISURERU4sIGFyaWFIaWRkZW5WYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50J3MgdGFiIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBkaXNhYmxlVGFiYmluZyhlbGVtZW50KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxUYWJJbmRleFZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoc3RyaW5ncy5UQUJJTkRFWCk7XG5cbiAgICAvLyBXaGVuIHRoZXJlJ3MgYW4gZXhwbGljaXQgYHRhYmluZGV4YCB2YWx1ZSBzYXZlIGl0IGEgZGF0YSBhdHRyaWJ1dGVcbiAgICAvLyBzbyBpdCBjYW4gYmUgc3dhcHBlZCBiYWNrIGxhdGVyLlxuICAgIGlmIChvcmlnaW5hbFRhYkluZGV4VmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHN0cmluZ3MuVEFCSU5ERVhfREFUQV9QUk9QLCBvcmlnaW5hbFRhYkluZGV4VmFsdWUpO1xuICAgIH1cblxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHN0cmluZ3MuVEFCSU5ERVgsIHN0cmluZ3MuREVBQ1RJVkFURV9UQUJJTkRFWCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBkb2N1bWVudCdzIHRhYiBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgZW5hYmxlVGFiYmluZyhlbGVtZW50KSB7XG4gICAgLy8gSWYgdGhpcyBlbGVtZW50IGhhZCB0YWJiaW5nIGRpc2FibGVkIGFuZCBoYWQgYW4gb3JpZ2luYWwgYHRhYmluZGV4YFxuICAgIC8vIHZhbHVlIHRoZW4gaXQgd2FzIHNhdmVkIHRvIGEgZGF0YSBhdHRyaWJ1dGUgc28gd2UgY291bGQgcmV1c2UgaXQuXG4gICAgY29uc3Qgb3JpZ2luYWxUYWJJbmRleFZhbHVlID1cbiAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoc3RyaW5ncy5UQUJJTkRFWF9EQVRBX1BST1ApO1xuICAgIGNvbnN0IGN1cnJlbnRUYWJJbmRleFZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoc3RyaW5ncy5UQUJJTkRFWCk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIGFscmVhZHkgYSBwb3NpdGl2ZSBgdGFiaW5kZXhgIHZhbHVlIHRoZW4ganVzdCBiYWlsLlxuICAgIGlmIChwYXJzZUludChjdXJyZW50VGFiSW5kZXhWYWx1ZSk+PSAwKSByZXR1cm47XG5cbiAgICBpZiAoIW9yaWdpbmFsVGFiSW5kZXhWYWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoc3RyaW5ncy5UQUJJTkRFWCwgJzAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFiSW5kZXhWYWx1ZSA9IHBhcnNlSW50KG9yaWdpbmFsVGFiSW5kZXhWYWx1ZSkgPj0gMCA/XG4gICAgICAgICAgb3JpZ2luYWxUYWJJbmRleFZhbHVlLnRvU3RyaW5nKCkgOiAnMCc7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShzdHJpbmdzLlRBQklOREVYLCB0YWJJbmRleFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBhIHBhZ2UgcmVnaW9uJ3MgdXBkYXRlZCBjb250ZW50IHRvIGJlIGFubm91bmNlZCBieSB0aGVcbiAgICogICAgc2NyZWVuIHJlYWRlci5cbiAgICogTk9URTogU29tZSBzY3JlZW4gcmVhZGVycyByZXF1aXJlIHRoaXMgYXR0cmlidXRlIHRvIGJlIHByZXNlbnQgaW5cbiAgICogICAgdGhlIG9yaWdpbmFsIERPTS5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9saXRlbmVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGFubm91bmNlV2hvbGVTdHJpbmdcbiAgICovXG4gIGFubm91bmNlRHluYW1pY0NoYW5nZXMoZWxlbWVudCwgcG9saXRlbmVzcywgYW5ub3VuY2VXaG9sZVN0cmluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiBwb2xpdGVuZXNzICE9PSAnc3RyaW5nJykge1xuICAgICAgcG9saXRlbmVzcyA9IGFyaWEuTElWRV9QT0xJVEVfVkFMVUU7XG4gICAgfVxuXG4gICAgaWYgKHBvbGl0ZW5lc3MgIT09IGFyaWEuTElWRV9QT0xJVEVfVkFMVUUgfHxcbiAgICAgICAgcG9saXRlbmVzcyAhPT0gYXJpYS5MSVZFX0FTU0VSVElWRV9WQUxVRSkge1xuICAgICAgY29uc29sZS53YXJuKHN0cmluZ3MuRVJST1JfTVNHX1VTRV9WQUxJRF9QT0xJVEVORVNTKTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhLkxJVkUsIHBvbGl0ZW5lc3MpO1xuXG4gICAgLy8gVGhlIHNjcmVlbiByZWFkZXIgc2hvdWxkIGFsd2F5cyBwcmVzZW50IHRoZSBsaXZlIHJlZ2lvbiBhcyBhIHdob2xlLFxuICAgIC8vIGV2ZW4gaWYgb25seSBwYXJ0IG9mIHRoZSByZWdpb24gY2hhbmdlcy5cbiAgICBpZiAoYW5ub3VuY2VXaG9sZVN0cmluZykge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXJpYS5BVE9NSUMsICd0cnVlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGEgc2NyZWVuIHJlYWRlciBmcm9tIGFubm91bmNpbmcgY29udGVudCB1cGRhdGVzLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBzaWxlbmNlRHluYW1pY0NoYW5nZXMoZWxlbWVudCkge1xuICAgIGNvbnN0IGlzQXRvbWljQWN0aXZhdGVkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXJpYS5BVE9NSUMpID09PSAndHJ1ZSc7XG5cbiAgICBpZiAoaXNBdG9taWNBY3RpdmF0ZWQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGFyaWEuQVRPTUlDLCAnZmFsc2UnKTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhLkxJVkUsIGFyaWEuTElWRV9PRkZfVkFMVUUpO1xuICB9XG5cbiAvKipcbiAgKiBRdWVyaWVzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMuXG4gICogQHBhcmFtIHshRWxlbWVudH0gZW50cnlQb2ludFxuICAqIHJldHVybiB7IUFycmF5PD9FbGVtZW50Pn1cbiAgKi9cbiAgZ2F0aGVyRm9jdXNhYmxlRWxlbWVudHMoZW50cnlQb2ludCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVudHJ5UG9pbnQucXVlcnlTZWxlY3RvckFsbChzdHJpbmdzLkZPQ1VTQUJMRV9OT0RFUykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGlucXVpc2hlcyBmb2N1cyBzdGF0ZSBjb250cm9sIGJhY2sgdG8gdGhlIGRvY3VtZW50LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbnRyeVBvaW50XG4gICAqL1xuICBkaXNhYmxlRm9jdXNUcmFwKGVudHJ5UG9pbnQpIHtcbiAgICBpZiAoIXRoaXMuZm9jdXNUcmFwUXVldWVfLmhhcyhlbnRyeVBvaW50KSkgcmV0dXJuO1xuXG4gICAgY29uc3Qge2tleXVwSGFuZGxlcixcbiAgICAgICAgICAgY3VycmVudEZvY3VzRWxlbWVudH0gPSB0aGlzLmZvY3VzVHJhcFF1ZXVlXy5nZXQoZW50cnlQb2ludCk7XG5cbiAgICAvLyBSZXR1cm4gZm9jdXMgYmFjayB0byBlbGVtZW50IHRoYXQgd2FzIGFjdGl2ZSBiZWZvcmUgdHJhcHBpbmdcbiAgICAvLyB3YXMgZW5hYmxlZC5cbiAgICBjdXJyZW50Rm9jdXNFbGVtZW50ICYmIGN1cnJlbnRGb2N1c0VsZW1lbnQuZm9jdXMoKTtcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXl1cEhhbmRsZXIpO1xuICAgIHRoaXMuZm9jdXNUcmFwUXVldWVfLmRlbGV0ZShlbnRyeVBvaW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBLZWVwcyB0aGUgZm9jdXMgc3RhdGUgdHJhcHBlZCB3aXRoaW4gYW4gZWxlbWVudCdzIGJvdW5kcy5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gZW50cnlQb2ludFxuICAgKiBAcGFyYW0gez9FbGVtZW50fSBmb2N1c0luaXRpYWxFbGVtZW50XG4gICAqL1xuICBlbmFibGVGb2N1c1RyYXAoZW50cnlQb2ludCwgZm9jdXNJbml0aWFsRWxlbWVudCkge1xuICAgIGNvbnN0IHRhYmJhYmxlU2VxdWVuY2UgPSB0aGlzLmdhdGhlckZvY3VzYWJsZUVsZW1lbnRzKGVudHJ5UG9pbnQpO1xuICAgIGNvbnN0IGN1cnJlbnRGb2N1c0VsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGNvbnN0IHRhYmJhYmxlU2VxdWVuY2VTaXplID0gdGFiYmFibGVTZXF1ZW5jZS5sZW5ndGggLSAxO1xuXG4gICAgLy8gVGhlIGN1cnJlbnQgYWN0aXZlIGVsZW1lbnQgaW4gdGhlIHRhYmJhYmxlIHNlcXVlbmNlLlxuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBpZiAodGFiYmFibGVTZXF1ZW5jZS5sZW5ndGggPD0gMSkge1xuICAgICAgY29uc29sZS53YXJuKHN0cmluZ3MuRVJST1JfTVNHX05FRURfTU9SRV9FTEVNRU5UUyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RUYWJiYWJsZUVsZW1lbnQgPSB0YWJiYWJsZVNlcXVlbmNlWzBdO1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgdXNlcidzIHRhYiBkaXJlY3Rpb24uXG4gICAgbGV0IHRhYkRpcmVjdGlvbkJhY2t3YXJkID0gZmFsc2U7XG5cbiAgICAvLyBXaGVuIHRoZXJlJ3Mgbm8gaW5pdGlhbCBmb2N1c2FibGUgZWxlbWVudCwgc2V0IHRoZSBmb2N1cyBzdGF0ZVxuICAgIC8vIG9uIGZpcnN0IHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50LlxuICAgIGZvY3VzSW5pdGlhbEVsZW1lbnQgPSBmb2N1c0luaXRpYWxFbGVtZW50IHx8IGZpcnN0VGFiYmFibGVFbGVtZW50O1xuICAgIGZvY3VzSW5pdGlhbEVsZW1lbnQuZm9jdXMoKTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZSBlbGVtZW50LlxuICAgIGluZGV4ID0gdGFiYmFibGVTZXF1ZW5jZS5maW5kSW5kZXgoKGVsZW1lbnQpID0+XG4gICAgICAgIGVsZW1lbnQuaXNFcXVhbE5vZGUoZm9jdXNJbml0aWFsRWxlbWVudCkpO1xuXG4gICAgY29uc3Qga2V5dXBIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7c2hpZnRLZXksIGtleUNvZGV9ID0gZXZlbnQ7XG5cbiAgICAgIGlmIChudW1iZXJzLlRBQl9LRVkgIT09IGtleUNvZGUpIHJldHVybjtcbiAgICAgIC8vIFJlbGlucXVpc2ggbmF0aXZlIHRhYiBjb250cm9sIHRvIG91ciBoYW5kbGVyLlxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gQSB1c2VyIGhvbGRpbmcgZG93biB0aGUgc2hpZnQga2V5IGFuZCB0YWJiaW5nIGlzIG1vdmluZyBiYWNrd2FyZHMuXG4gICAgICB0YWJEaXJlY3Rpb25CYWNrd2FyZCA9IHNoaWZ0S2V5O1xuXG4gICAgICBpZiAodGFiRGlyZWN0aW9uQmFja3dhcmQpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgdXNlciBpcyB0YWJiaW5nIGJhY2t3YXJkcyBhbmQgdGhleSBoaXQgdGhlIGZpcnN0IHRhYmJhYmxlXG4gICAgICAgIC8vIGVsZW1lbnQgc2hpZnQgZm9jdXMgdG8gdGhlIGxhc3QgdGFiYmFibGUgZWxlbWVudC5cbiAgICAgICAgaW5kZXggPSBpbmRleCA9PT0gMCA/IHRhYmJhYmxlU2VxdWVuY2VTaXplIDogKGluZGV4IC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZSB1c2VyIGlzIHRhYmJpbmcgZm9yd2FyZHMgYW5kIHRoZXkgaGl0IHRoZSBsYXN0IHRhYmJhYmxlXG4gICAgICAgIC8vIGVsZW1lbnQgc2hpZnQgZm9jdXMgdG8gdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQuXG4gICAgICAgIGluZGV4ID0gaW5kZXggPT09IHRhYmJhYmxlU2VxdWVuY2VTaXplID8gMCA6IChpbmRleCArIDEpO1xuICAgICAgfVxuXG4gICAgICB0YWJiYWJsZVNlcXVlbmNlW2luZGV4XS5mb2N1cygpO1xuICAgIH07XG5cbiAgICBjb25zdCBmb2N1c1RyYXBEYXRhID0ge1xuICAgICAga2V5dXBIYW5kbGVyLFxuICAgICAgY3VycmVudEZvY3VzRWxlbWVudCxcbiAgICB9O1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleXVwSGFuZGxlcik7XG5cbiAgICAvLyBDYWNoZSB0aGUgaGFuZGxlciBzbyBpdCBjYW4gYmUgdW5ib3VuZCBsYXRlci5cbiAgICB0aGlzLmZvY3VzVHJhcFF1ZXVlXy5zZXQoZW50cnlQb2ludCwgZm9jdXNUcmFwRGF0YSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9hMTF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5leHBvcnQgY29uc3QgYXJpYSA9IHtcbiAgQVRPTUlDOiAnYXJpYS1hdG9taWMnLFxuICBCVVNZOiAnYXJpYS1idXN5JyxcbiAgQ0hFQ0tFRDogJ2FyaWEtY2hlY2tlZCcsXG4gIENPTlRST0xTOiAnYXJpYS1jb250cm9scycsXG4gIERFU0NSSUJFRF9CWTogJ2FyaWEtZGVzY3JpYmVkYnknLFxuICBFWFBBTkRFRDogJ2FyaWEtZXhwYW5kZWQnLFxuICBISURERU46ICdhcmlhLWhpZGRlbicsXG4gIExBQkVMOiAnYXJpYS1sYWJlbCcsXG4gIExBQkVMTEVEX0JZOiAnYXJpYS1sYWJlbGxlZGJ5JyxcbiAgTElWRTogJ2FyaWEtbGl2ZScsXG4gIE1PREFMOiAnYXJpYS1tb2RhbCcsXG4gIFBSRVNTRUQ6ICdhcmlhLXByZXNzZWQnLFxuICBTRUxFQ1RFRDogJ2FyaWEtc2VsZWN0ZWQnLFxuICBWQUxVRV9NQVg6ICdhcmlhLXZhbHVlbWF4JyxcbiAgVkFMVUVfTUlOOiAnYXJpYS12YWx1ZW1pbicsXG4gIFZBTFVFX05PVzogJ2FyaWEtdmFsdWVub3cnLFxuICAvLyBWYWx1ZXMgZm9yIHByb3BlcnRpZXNcblxuICAvLyBBbnkgdXBkYXRlcyBtYWRlIHRvIHRoaXMgcmVnaW9uIHNob3VsZCBvbmx5IGJlIGFubm91bmNlZCBpZiB0aGUgdXNlclxuICAvLyBpcyBub3QgY3VycmVudGx5IGRvaW5nIGFueXRoaW5nLiBsaXZlPVwicG9saXRlXCIgc2hvdWxkIGJlIHVzZWQgaW4gbW9zdFxuICAvLyBzaXR1YXRpb25zLlxuICBMSVZFX1BPTElURV9WQUxVRTogJ3BvbGl0ZScsXG5cbiAgLy8gQW55IHVwZGF0ZXMgbWFkZSB0byB0aGlzIHJlZ2lvbiBhcmUgaW1wb3J0YW50IGVub3VnaCB0byBiZSBhbm5vdW5jZWRcbiAgLy8gdG8gdGhlIHVzZXIgYXMgc29vbiBhcyBwb3NzaWJsZSwgYnV0IGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gaW1tZWRpYXRlbHlcbiAgLy8gaW50ZXJydXB0IHRoZSB1c2VyLiBsaXZlPVwiYXNzZXJ0aXZlXCIgbXVzdCBiZSB1c2VkIGlmIHRoZXJlIGlzXG4gIC8vIGluZm9ybWF0aW9uIHRoYXQgYSB1c2VyIG11c3Qga25vdyBhYm91dCByaWdodCBhd2F5LFxuICBMSVZFX0FTU0VSVElWRV9WQUxVRTogJ2Fzc2VydGl2ZScsXG5cbiAgLy8gU3RvcHMgc2NyZWVuIHJlYWRlciBmcm9tIGFubm91Y2luZyB1cGRhdGVzLlxuICBMSVZFX09GRl9WQUxVRTogJ29mZicsXG59O1xuXG4vKiogQHR5cGUgeyFPYmplYzxzdHJpbmcsICFBcnJheT59ICovXG5leHBvcnQgY29uc3QgdmFsaWRBcmlhUm9sZXMgPSB7XG4gIENIRUNLRUQ6IFtcbiAgICAnbWVudWl0ZW1yYWRpbycsXG4gICAgJ3JhZGlvJyxcbiAgICAndHJlZWl0ZW0nLFxuICBdLFxuICBTRUxFQ1RFRDogW1xuICAgICdncmlkY2VsbCcsXG4gICAgJ29wdGlvbicsXG4gICAgJ3JvdycsXG4gICAgJ3RhYicsXG4gIF0sXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUQUJJTkRFWF9EQVRBX1BST1A6ICdkYXRhLXRhYmluZGV4JyxcbiAgVEFCSU5ERVg6ICd0YWJpbmRleCcsXG4gIEFDVElWQVRFX1RBQklOREVYOiAnMCcsXG4gIERFQUNUSVZBVEVfVEFCSU5ERVg6ICctMScsXG4gIEZPQ1VTQUJMRV9OT0RFUzogJ2J1dHRvbiwgW2hyZWZdLCBpbnB1dCwgc2VsZWN0LCcgK1xuICAgICAgJ3RleHRhcmVhLCBbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICBUQUJfRk9SV0FSRDogJ2ZvcmV3YXJkJyxcbiAgVEFCX0JBQ0tXQVJEOiAnYmFja3dhcmQnLFxuICBFUlJPUl9NU0dfVkFMSURfU0VMRUNURUQ6ICdUaGUgXCJhcmlhLXNlbGVjdGVkXCIgYXR0cmlidXRlIHNob3VsZCBiZSBwYWlyZWQnICtcbiAgICAgICd3aXRoIHRoZXNlIHZhbGlkIHJvbGVzOiAnICsgdmFsaWRBcmlhUm9sZXMuU0VMRUNURUQuam9pbignLCAnKSxcbiAgRVJST1JfTVNHX1ZBTElEX0NIRUNLQk9YOiAnVGhlIFwiYXJpYS1jaGVja2VkXCIgYXR0cmlidXRlIHNob3VsZCBiZSBwYWlyZWQnICtcbiAgICAgICd3aXRoIGEgdmFsaWQgY2hlY2tib3ggZWxlbWVudCBvciB0aGVzZSB2YWxpZCByb2xlczogJyArXG4gICAgICB2YWxpZEFyaWFSb2xlcy5DSEVDS0VELmpvaW4oJywgJyksXG4gIEVSUk9SX01TR19DT05UUk9MU19JRDogJ1RoZSBcImNvbnRyb2xzXCIgcGFyYW0gc2hvdWxkIGJlIHRoZSBzdHJpbmcnICtcbiAgICAgICdpZCBvZiBhbiBlbGVtZW50LicsXG4gIEVSUk9SX01TR19VU0VfVkFMSURfUE9MSVRFTkVTUzogJ1BsZWFzZSB1c2UgYSB2YWxpZCBwb2xpdGVuZXNzIHNldHRpbmcuJyxcbiAgRVJST1JfTVNHX05FRURfTU9SRV9FTEVNRU5UUzogJ1lvdSBuZWVkIHR3byBvciBtb3JlIHRhYmJsZSBlbGVtZW50IHRvJyArXG4gICAgICAnbWFrZSB0aGUgZm9jdXMgdHJhcCB3b3JrLicsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xuICBTSElGVF9LRVk6IDE2LFxuICBUQUJfS0VZOiA5LFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5leHBvcnQgY29uc3Qgcm9sZSA9IHtcbiAgQlVUVE9OOiAnYnV0dG9uJyxcbiAgQ0hFQ0tCT1g6ICdjaGVja2JveCcsXG4gIEdSSURfQ0VMTDogJ2dyaWRjZWxsJyxcbiAgTElOSzogJ2xpbmsnLFxuICBNRU5VX0lURU06ICdtZW51aXRlbScsXG4gIE1FTlVfSVRFTV9DSEVDS0JPWDogJ21lbnVpdGVtY2hlY2tib3gnLFxuICBNRU5VX0lURU1fUkFESU86ICdtZW51aXRlbXJhZGlvJyxcbiAgT1BUSU9OOiAnb3B0aW9uJyxcbiAgUFJPR1JFU1NfQkFSOiAncHJvZ3Jlc3NiYXInLFxuICBSQURJTzogJ3JhZGlvJyxcbiAgU0NST0xMQkFSOiAnc2Nyb2xsYmFyJyxcbiAgU0VBUkNIX0JPWDogJ3NlYXJjaGJveCcsXG4gIFNMSURFUjogJ3NsaWRlcicsXG4gIFNQSU5fQlVUVE9OOiAnc3BpbmJ1dHRvbicsXG4gIFNXSVRDSDogJ3N3aXRjaCcsXG4gIFRBQjogJ3RhYicsXG4gIFRBQl9QQU5FTDogJ3RhYnBhbmVsJyxcbiAgVEVYVF9CT1g6ICd0ZXh0Ym94JyxcbiAgVFJFRV9JVEVNOiAndHJlZWl0ZW0nLFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9hMTF5L2NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAcHJpdmF0ZSBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IFBSRUZJWF9NRVRSSUMgPSAnbWV0cmljJztcblxuLyoqIEBwcml2YXRlIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgUFJFRklYX0RJTUVOU0lPTiA9ICdkaW1lbnNpb24nO1xuXG4vKiogQHByaXZhdGUgQGNvbnN0IHtudW1iZXJ9ICovXG5jb25zdCBNQVhfQ1VTVE9NX0RBVEFfUE9JTlRTID0gOTtcblxuLyoqIEBwcml2YXRlIEBjb25zdCB7IUFycmF5PHN0cmluZz59ICovXG5jb25zdCBVU0VfREFUQV9LRVkgPSBbXG4gICAgJ2hpdFR5cGUnLFxuICAgICdoaXRDYWxsYmFjaycsXG4gICAgJ2V2ZW50Q2F0ZWdvcnknLFxuICAgICdldmVudEFjdGlvbicsXG4gICAgJ2V2ZW50TGFiZWwnLFxuICAgICdldmVudFZhbHVlJyxcbiAgICAnc29jaWFsTmV0d29yaycsXG4gICAgJ3NvY2lhbEFjdGlvbicsXG4gICAgJ3NvY2lhbFRhcmdldCcsXG4gIF07XG5cbi8qKiBAcHJpdmF0ZSBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCAqPn0gKi9cbmNvbnN0IERFRkFVTFRfR0EgPSB7XG4gIGhpdFR5cGU6ICdldmVudCcsXG59O1xuXG4vLyBTZXQgYW5hbHl0aWNzIGlmIGl0J3MgYmVlbiBsb2FkZWQuXG53aW5kb3cuZ2EgPSB3aW5kb3cuZ2EgfHwgZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBDbGFzcyBmb3Igc2VuZGluZyBjdXN0b20gZGF0YSB0byBHb29nbGUgQW5hbHl0aWNzXG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5hbHl0aWNzIHtcbiAgY29uc3RydWN0b3Ioc2NydWJSZWZlcnJlcikge1xuICAgIC8qKiBAcHJpdmF0ZSB7P09iamVjdDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgdGhpcy5kaW1lbnNpb25zXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7P09iamVjdDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgdGhpcy5tZXRyaWNzXztcblxuICAgIHNjcnViUmVmZXJyZXIgJiYgdGhpcy5zY3J1YlJlZmVycmVyKCk7XG4gICAgdGhpcy5yZXNldEN1c3RvbURhdGFTdG9yZXNfKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgZXZlbnQgZGF0YSB0byBHb29nbGUgQW5hbHl0aWNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICo+fSBldmVudERhdGFcbiAgICovXG4gIHNlbmRFdmVudChldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMucGFyc2VQcm9wV2hlblN0cmluZ18oZXZlbnREYXRhLCBQUkVGSVhfRElNRU5TSU9OKTtcbiAgICBjb25zdCBtZXRyaWMgPSB0aGlzLnBhcnNlUHJvcFdoZW5TdHJpbmdfKGV2ZW50RGF0YSwgUFJFRklYX01FVFJJQyk7XG5cbiAgICBjb25zdCBkaW1lbnNpb25EYXRhID0gKGRpbWVuc2lvbiAmJlxuICAgICAgICB0aGlzLnByb2Nlc3NDdXN0b21EYXRhXyhQUkVGSVhfRElNRU5TSU9OLCB0aGlzLmRpbWVuc2lvbnNfLCBkaW1lbnNpb24pKTtcblxuICAgIGNvbnN0IG1ldHJpY0RhdGEgPSAobWV0cmljICYmXG4gICAgICAgIHRoaXMucHJvY2Vzc0N1c3RvbURhdGFfKFBSRUZJWF9NRVRSSUMsIHRoaXMubWV0cmljc18sIG1ldHJpYykpO1xuXG4gICAgY29uc3QgZXZlbnRQcm9wcyA9IE9iamVjdC5rZXlzKGV2ZW50RGF0YSk7XG5cbiAgICBjb25zdCBkYXRhUGFyY2VsID1cbiAgICAgICAgZXZlbnRQcm9wcy5maWx0ZXIoKHByb3ApID0+IH5VU0VfREFUQV9LRVkuaW5kZXhPZihwcm9wKSlcbiAgICAgICAgLnJlZHVjZSgocGFyY2VsLCBwcm9wKSA9PiB7XG4gICAgICAgICAgcGFyY2VsW3Byb3BdID0gZXZlbnREYXRhW3Byb3BdO1xuICAgICAgICAgIHJldHVybiBwYXJjZWw7XG4gICAgICAgIH0sIHt9KTtcblxuICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIGRhdGFQYXJjZWwsXG4gICAgICAgIChkaW1lbnNpb25EYXRhICYmIGRpbWVuc2lvbkRhdGEpLFxuICAgICAgICAobWV0cmljRGF0YSAmJiBtZXRyaWNEYXRhKSk7XG5cbiAgICBkZWxldGUgZGF0YVBhcmNlbC5pbmRleDtcblxuICAgIC8vIFNlbmQgdGhlIGV2ZW50LlxuICAgIHdpbmRvdy5nYShldmVudFR5cGUsIGRhdGFQYXJjZWwpO1xuXG4gICAgdGhpcy5yZXNldEN1c3RvbURhdGFTdG9yZXNfKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgR0EgdHJhbnNwb3J0IGJlYWNvbiBmZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXRDdXN0b21EYXRhU3RvcmVzXygpIHtcbiAgICB0aGlzLm1ldHJpY3NfID0gdGhpcy5kaW1lbnNpb25zXyA9IHsnaW5kZXgnOiAwfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBkb2N1bWVudC5yZWZlcnJlcmAgaW5mbyBmb3IgUElJIGNvbXBsaWFuY2UuXG4gICAqIFJlZmVyZW5jZSAoR29vZ2xlIGRvY3MgaWQpIDE1OURERFR0YzQ1cmtDb2NfNEJtdHdLT2xBR1VuVHAxOUVoem1Bek1DT3BnXG4gICAqL1xuICBzY3J1YlJlZmVycmVyKCkge1xuICAgIHdpbmRvdy5nYSgnc2V0JywgJ3JlZmVycmVyJywgZG9jdW1lbnQucmVmZXJyZXIuc3BsaXQoJz8nKVswXSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgR0EgdHJhbnNwb3J0IGJlYWNvbiBmZWF0dXJlLlxuICAgKi9cbiAgc2V0VHJhbnNwb3J0QmVhY29uKCkge1xuICAgIHdpbmRvdy5nYSgnc2V0JywgJ3RyYW5zcG9ydCcsICdiZWFjb24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcHJvcGVydHkgdmFsdWUgaXMgYSBzdHJpbmdpZmllZCBhcnJheVxuICAgKiBhbmQgcGFyc2VzIHZhbGlkIEpTT04uXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICo+fSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gcHJvcFxuICAgKiBAcmV0dXJuIHtzdHJpbmd8T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcGFyc2VQcm9wV2hlblN0cmluZ18oZGF0YSwgcHJvcCkge1xuICAgIGxldCBwcm9wVmFsdWUgPSBkYXRhW3Byb3BdO1xuXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3BWYWx1ZSA9IEpTT04ucGFyc2UocHJvcFZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvcFZhbHVlID0gJyc7XG4gICAgICAgIGNvbnNvbGUud2FybihgKExCQW5hbHl0aWNzKSBTb3JyeSwgJHtwcm9wVmFsdWV9IGlzbid0IHZhbGlkIEpTT04uYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgaW5kZXggaXMgZ3JlYXRvciBvciBlcXVhbCB0byB0aGVcbiAgICogbWF4aW11bSBudW1iZXIgb2Ygc3VwcG9ydGVkIGN1c3RvbSBkYXRhIHBvaW50cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleGNlZWRDdXN0b21EYXRhTGltaXRfKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IE1BWF9DVVNUT01fREFUQV9QT0lOVFM7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIGN1c3RvbSBgZGltZW5zaW9uYCBvciBgbWV0cmljYCB2YWx1ZXMgaW50b1xuICAgKiB0aGUgZXZlbnQgZGF0YSBwYXJjZWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZWFzdXJlbWVudFxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAqID59IGRhdGFcbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gY3VzdG9tTGlzdFxuICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb2Nlc3NDdXN0b21EYXRhXyhtZWFzdXJlbWVudCwgZGF0YSwgY3VzdG9tTGlzdCkge1xuICAgIGN1c3RvbUxpc3QuZm9yRWFjaCgodmFsdWUpID0+XG4gICAgICAgIHRoaXMuc3Bhd25DdXN0b21EYXRhRW50cnlfKG1lYXN1cmVtZW50LCBkYXRhLCB2YWx1ZSkpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGN1c3RvbSBgZGltZW5zaW9uYCBvciBgbWV0cmljYCBlbnRyeSBpbiB0aGVcbiAgICogZXZlbnQgZGF0YSBwYXJjZWwgdGhhdCBnZXRzIHNlbnQgdG8gR29vZ2xlIEFuYWx5dGljcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lYXN1cmVtZW50XG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICogPn0gZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNwYXduQ3VzdG9tRGF0YUVudHJ5XyhtZWFzdXJlbWVudCwgZGF0YSwgdmFsdWUpIHtcbiAgICBjb25zdCBub2RlID0ge307XG4gICAgY29uc3QgcHJvcCA9IChtZWFzdXJlbWVudCArIGRhdGEuaW5kZXgpO1xuXG4gICAgaWYgKHRoaXMuZXhjZWVkQ3VzdG9tRGF0YUxpbWl0XyhkYXRhLmluZGV4KSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcbiAgICAgICAgYChMQkFuYWx5dGljcykgWW91IGhhdmUgdG9vIG1hbnkgJHttZWFzdXJlbWVudH0gdmFsdWVzLmApO1xuICAgIH1cblxuICAgIGRhdGEuaW5kZXggKz0gMTtcblxuICAgIG5vZGVbcHJvcF0gPSB2YWx1ZTtcbiAgICBPYmplY3QuYXNzaWduKGRhdGEsIG5vZGUpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvYW5hbHl0aWNzL2FuYWx5dGljcy5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7bnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtnZXRUaHJlc2hvbGRBcnJheSwgdGhyb3R0bGV9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8vIENhbGxiYWNrIHRvIHJ1bi5cbiAgb25BY3RpdmF0ZTogbnVsbCxcbiAgLy8gQ2FsbGJhY2sgdG8gcnVuLlxuICBvblByb2dyZXNzOiBudWxsLFxuICAvLyBDYWxsYmFjayB0byBydW4uXG4gIG9uRGVBY3RpdmF0ZTogbnVsbCxcbiAgLy8gVGhlIGFtb3VudCBvZiB0aGUgZWxlbWVudCB0byBiZSBzaG93aW5nIHRvIHJ1biBhY3RpdmF0ZS5cbiAgYWN0aXZhdGVUaHJlc2hvbGQ6IG51bWJlcnMuREVGQVVMVF9BQ1RJVkFURV9USFJFU0hPTEQsXG4gIC8vIFRoZSBhbW91bnQgb2YgdGhlIGVsZW1lbnQgdG8gYmUgc2hvd2luZyB0byBydW4gZGVhY3RpdmF0ZS5cbiAgZGVBY3RpdmF0ZVRocmVzaG9sZDogbnVtYmVycy5ERUZBVUxUX0RFQUNUSVZBVEVfVEhSRVNIT0xELFxuICAvLyBPbmx5IHJ1biB0aGUgYWN0aXZhdGUgY2FsbGJhY2sgb25jZS5cbiAgYWN0aXZhdGVPbmNlOiBmYWxzZSxcbiAgLy8gT25seSBydW4gdGhlIGRlQWN0aXZhdGUgY2FsbGJhY2sgb25jZS5cbiAgZGVBY3RpdmF0ZU9uY2U6IGZhbHNlLFxuICAvLyBIaWdoZXIgZmlkZWxpdHkgcmVzdWx0cyBpbiBtb3JlIHByb2dyZXNzIGNhbGxiYWNrcy5cbiAgaW9GaWRlbGl0eTogMTAwMSxcbiAgLy8gU3BlY2lmeSBhIGRpZmZlcmVudCByb290IGVsZW1lbnQgdGhhbiB2aWV3cG9ydCBmb3IgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIuXG4gIGlvUm9vdDogbnVsbCxcbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIgb24gYW4gZWxlbWVudCBhbmQgcnVucyBjYWxsYmFja3Mgd2hlblxuICogdGhlIGVsZW1lbnQgY29tZXMgaW50byBhbmQgb3V0IG9mIHZpZXcsIGFjY29yZGluZyB0byBvcHRpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50T2JzZXJ2ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBFbGVtZW50T2JzZXJ2ZXIuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIG9ic2VydmVkIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG5cbiAgICAvKiogQHR5cGUgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMuZWxlbWVudF8gPSBlbGVtZW50O1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG5cbiAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICB0aGlzLm9wdGlvbnNfID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgLyoqIEB0eXBlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5hY3RpdmF0ZUNhbGxiYWNrXyA9IHRoaXMub3B0aW9uc18ub25BY3RpdmF0ZTtcblxuICAgIC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFja18gPSB0aGlzLm9wdGlvbnNfLm9uUHJvZ3Jlc3M7XG5cbiAgICAvKiogQHR5cGUge0Z1bmN0aW9uPX0gKi9cbiAgICB0aGlzLmRlQWN0aXZhdGVDYWxsYmFja18gPSB0aGlzLm9wdGlvbnNfLm9uRGVBY3RpdmF0ZTtcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmFjdGl2YXRlSGFzUnVuXyA9IGZhbHNlO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuZGVBY3RpdmF0ZUhhc1J1bl8gPSBmYWxzZTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4UG9zc2libGVSYXRpb18gPSAwO1xuXG4gICAgaWYgKHRoaXMuYWN0aXZhdGVDYWxsYmFja18gJiZcbiAgICAgICAgdGhpcy5kZUFjdGl2YXRlQ2FsbGJhY2tfICYmXG4gICAgICAgIHRoaXMub3B0aW9uc18uYWN0aXZhdGVUaHJlc2hvbGQgPD1cbiAgICAgICAgdGhpcy5vcHRpb25zXy5kZUFjdGl2YXRlVGhyZXNob2xkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnRPYnNlcnZlcjogSWYgYm90aCBhY3RpdmF0ZSBhbmQgZGVhY3RpdmF0ZVxuICAgICAgICAgIGNhbGxiYWNrcyBhcmUgcHJvdmlkZWQsIHRoZSBhY3RpdmF0ZSB0aHJlc2hvbGQgbXVzdCBiZSBsYXJnZXJcbiAgICAgICAgICB0aGFuIHRoZSBkZUFjdGl2YXRlIHRocmVzaG9sZC5gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWN0aXZhdGVDYWxsYmFja18pIHtcbiAgICAgIHRoaXMuYWN0aXZhdGVIYXNSdW5fID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZGVBY3RpdmF0ZUNhbGxiYWNrXykge1xuICAgICAgdGhpcy5kZUFjdGl2YXRlSGFzUnVuXyA9IHRydWU7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsXG4gICAgICAgIHRocm90dGxlKHRoaXMucmVzZXRNYXhQb3NzaWJsZVJhdGlvXy5iaW5kKHRoaXMpLCA1MDApKTtcblxuICAgIHRoaXMuaW5pdEludGVyc2VjdGlvbk9ic2VydmVyXyhlbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBwcm9ncmVzcyBjYWxsYmFjay5cbiAgICogQHBhcmFtIHshSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeX0gZW50cnkgVGhlIEludGVyc2VjdGlvbk9ic2VydmVyIGVudHJ5LlxuICAgKi9cbiAgcHJvZ3Jlc3MoZW50cnkpIHtcbiAgICBpZiAodGhpcy5wcm9ncmVzc0NhbGxiYWNrXykge1xuICAgICAgLy8gVGhlIGludGVyc2VjdGlvbiByYXRpbyBpZiB0aGUgZWxlbWVudCBpcyB0YWxsZXIgdGhhbiB0aGUgdmlld3BvcnRcbiAgICAgIC8vIGFuZCBjYW4ndCByZWFjaCAxIHZpYSBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5LmludGVyc2VjdGlvblJhdGlvLlxuICAgICAgLy8gUmFuZ2VzIGZyb20gMC0xLlxuICAgICAgY29uc3Qgb3ZlcmZsb3dSYXRpbyA9XG4gICAgICAgICAgdGhpcy5nZXRSYXRpb09mTWF4UG9zc2libGVfKGVudHJ5LmludGVyc2VjdGlvblJhdGlvKTtcbiAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFja18oZW50cnksIG92ZXJmbG93UmF0aW8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBhY3RpdmF0ZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHshSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeX0gZW50cnkgVGhlIEludGVyc2VjdGlvbk9ic2VydmVyIGVudHJ5LlxuICAgKi9cbiAgYWN0aXZhdGUoZW50cnkpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZhdGVDYWxsYmFja18gfHxcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWQgfHxcbiAgICAgICAgdGhpcy5hY3RpdmF0ZUhhc1J1bl8gJiYgdGhpcy5vcHRpb25zXy5hY3RpdmF0ZU9uY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmF0ZUNhbGxiYWNrXyhlbnRyeSk7XG4gICAgdGhpcy5hY3RpdmF0ZWQgPSB0cnVlO1xuICAgIHRoaXMuYWN0aXZhdGVIYXNSdW5fID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBkZWFjdGl2YXRlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0geyFJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5fSBlbnRyeSBUaGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgZW50cnkuXG4gICAqL1xuICBkZUFjdGl2YXRlKGVudHJ5KSB7XG4gICAgaWYgKCF0aGlzLmRlQWN0aXZhdGVDYWxsYmFja18gfHxcbiAgICAgICAgIXRoaXMuYWN0aXZhdGVkIHx8XG4gICAgICAgIHRoaXMuZGVBY3RpdmF0ZUhhc1J1bl8gJiYgdGhpcy5vcHRpb25zXy5kZUFjdGl2YXRlT25jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlQWN0aXZhdGVDYWxsYmFja18oZW50cnkpO1xuICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZUFjdGl2YXRlSGFzUnVuXyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVW5vYnNlcnZlcyBJbnRlcnNlY3Rpb25PYnNlcnZlciBpbnN0YW5jZSBmcm9tIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gc3RvcCBvYnNlcnZpbmcuXG4gICAqL1xuICB1bm9ic2VydmUoZWxlbWVudCA9IHRoaXMuZWxlbWVudF8pIHtcbiAgICB0aGlzLm9ic2VydmVyXy51bm9ic2VydmUoZWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgbWF4aW11bSBwb3NzaWJsZSBpbnRlcnNlY3Rpb25SYXRpbyB2YWx1ZSBhbiBlbGVtZW50IGNhblxuICAgKiBoYXZlIGJhc2VkIG9uIGl0cyBvd24gaGVpZ2h0IGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAgICogRm9yIGluc3RhbmNlIGlmIGFuIGVsZW1lbnQgaXMgdHdpY2UgYXMgdGFsbCBhcyB0aGUgdmlld3BvcnQsIGl0IGNhbiBvbmx5XG4gICAqIGV2ZXIgcmVhY2ggYW4gaW50ZXJzZWN0aW9uUmF0aW8gb2YgMC41LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByZWFsUmF0aW8gVGhlIHJlYWwgaW50ZXJzZWN0aW9uUmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heCBwb3NzaWJsZSBpbnRlcnNlY3Rpb24gcmF0aW8uXG4gICAqL1xuICBnZXRNYXhQb3NzaWJsZVJhdGlvXyhlbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLm1heFBvc3NpYmxlUmF0aW9fKSB7XG4gICAgICBjb25zdCB2aWV3cG9ydEJvdW5kcyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRCb3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgcmVhbFJhdGlvID0gdmlld3BvcnRCb3VuZHMuaGVpZ2h0IC8gZWxlbWVudEJvdW5kcy5oZWlnaHQ7XG4gICAgICB0aGlzLm1heFBvc3NpYmxlUmF0aW9fID0gTWF0aC5taW4ocmVhbFJhdGlvLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXhQb3NzaWJsZVJhdGlvXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGludGVyc2VjdGlvbiByYXRpbyB0YWtpbmcgaW50byBhY2NvdW50IGFuIGVsZW1lbnQgdGhhdCBpc1xuICAgKiB0YWxsZXIgdGhhbiB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZWFsUmF0aW8gVGhlIHJlYWwgaW50ZXJzZWN0aW9uUmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heCBwb3NzaWJsZSBpbnRlcnNlY3Rpb24gcmF0aW8uXG4gICAqL1xuICBnZXRSYXRpb09mTWF4UG9zc2libGVfKHJlYWxSYXRpbykge1xuICAgIHJldHVybiByZWFsUmF0aW8gLyB0aGlzLmdldE1heFBvc3NpYmxlUmF0aW9fKHRoaXMuZWxlbWVudF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgdmFsdWUgb2YgdGhpcy5tYXhQb3NzaWJsZVJhdGlvXy5cbiAgICovXG4gIHJlc2V0TWF4UG9zc2libGVSYXRpb18oKSB7XG4gICAgdGhpcy5tYXhQb3NzaWJsZVJhdGlvXyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlciBvbiBhbiBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIG9ic2VydmUuXG4gICAqL1xuICBpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXJfKGVsZW1lbnQpIHtcbiAgICBjb25zdCBpb09wdGlvbnMgPSB7XG4gICAgICB0aHJlc2hvbGQ6IGdldFRocmVzaG9sZEFycmF5KHRoaXMub3B0aW9uc18uaW9GaWRlbGl0eSksXG4gICAgICByb290OiB0aGlzLm9wdGlvbnNfLmlvUm9vdCxcbiAgICB9O1xuXG4gICAgdGhpcy5vYnNlcnZlcl8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2tfLmJpbmQodGhpcyksXG4gICAgICBpb09wdGlvbnMpO1xuXG4gICAgdGhpcy5vYnNlcnZlcl8ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuXG4gIGludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2tfKGVudHJpZXMsIG9ic2VydmVyKSB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbnRyeS50YXJnZXQ7XG5cbiAgICB0aGlzLnByb2dyZXNzKGVudHJ5KTtcblxuICAgIGlmIChlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IHRoaXMub3B0aW9uc18uYWN0aXZhdGVUaHJlc2hvbGQpIHtcbiAgICAgIHRoaXMuYWN0aXZhdGUoZW50cnkpO1xuICAgIH1cblxuICAgIGlmIChlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA8IHRoaXMub3B0aW9uc18uZGVBY3RpdmF0ZVRocmVzaG9sZCkge1xuICAgICAgdGhpcy5kZUFjdGl2YXRlKGVudHJ5KTtcbiAgICB9XG5cbiAgICAvLyBJbiB0aGlzIGNhc2UsIG5vIGFkZGl0aW9uYWwgY2FsbGJhY2tzIHdpbGwgcnVuLCBzbyB3ZSBjYW4gcmVtb3ZlIHRoZVxuICAgIC8vIEludGVyc2VjdGlvbk9ic2VydmVyLlxuICAgIGlmICh0aGlzLm9wdGlvbnNfLmFjdGl2YXRlT25jZSAmJlxuICAgICAgICB0aGlzLmFjdGl2YXRlSGFzUnVuXyAmJlxuICAgICAgICB0aGlzLm9wdGlvbnNfLmRlQWN0aXZhdGVPbmNlICYmXG4gICAgICAgIHRoaXMuZGVBY3RpdmF0ZUhhc1J1bl8gJiZcbiAgICAgICAgIXRoaXMucHJvZ3Jlc3NDYWxsYmFja18pIHtcbiAgICAgIHRoaXMudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvcHJvdmlkZXJzL2VsZW1lbnQtb2JzZXJ2ZXIvZWxlbWVudC1vYnNlcnZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IGEgc2VjdGlvbiBuZWVkcyB0byBiZSBpbnRlcnNlY3RpbmcgdG8gYWN0aXZhdGUgaXQuXG4gICAqL1xuICBERUZBVUxUX0FDVElWQVRFX1RIUkVTSE9MRDogLjMsXG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IGEgc2VjdGlvbiBuZWVkcyB0byBiZSBpbnRlcnNlY3RpbmcgdG8gZGVhY3RpdmF0ZSBpdC5cbiAgICovXG4gIERFRkFVTFRfREVBQ1RJVkFURV9USFJFU0hPTEQ6IC4xLFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9lbGVtZW50LW9ic2VydmVyL2NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7bGJBdXRvSW5pdH0gZnJvbSAnLi4vYXV0by1pbml0L2F1dG8taW5pdCc7XG5pbXBvcnQge2VtcHR5Q29udGFpbmVyfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5cblxuLyoqXG4gKiBDbGFzcyB0byByZW5kZXIgYSBNdXN0YWNoZSB0ZW1wbGF0ZSB3aXRoIGRhdGEgYW5kXG4gKiBzYWZlbHkgaW5zZXJ0IGl0IGludG8gdGhlIERPTS5cbiAqIEBmaW5hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMQlRlbXBsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTEJUZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlSWQgVGhlIGlkIG9mIHRoZSB0ZW1wbGF0ZSBzY3JpcHQgdGFnLlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz49fSBjdXN0b21UYWdzIEN1c3RvbSBNdXN0YWNoZSB0ZW1wbGF0ZSB0YWdzIC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRlbXBsYXRlSWQsIGN1c3RvbVRhZ3MpIHtcbiAgICB0aGlzLnRlbXBsYXRlXyA9IHRoaXMuZ2V0VGVtcGxhdGVCeUlkXyh0ZW1wbGF0ZUlkKTtcblxuICAgIGlmICghd2luZG93Lk11c3RhY2hlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBNdXN0YWNoZSBDRE4gbXVzdCBiZSBpbmNsdWRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoY3VzdG9tVGFncykge1xuICAgICAgdGhpcy5jdXN0b21pemVNdXN0YWNoZVRhZ3NfKGN1c3RvbVRhZ3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b21pemVzIHRoZSBNdXN0YWNoZSB0ZW1wbGF0ZSB0YWdzLlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBjdXN0b21UYWdzIEN1c3RvbSBNdXN0YWNoZSB0ZW1wbGF0ZSB0YWdzIHRvIHNldC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGN1c3RvbWl6ZU11c3RhY2hlVGFnc18oY3VzdG9tVGFncykge1xuICAgIGlmICh3aW5kb3cuTXVzdGFjaGUgJiYgY3VzdG9tVGFncykge1xuICAgICAgd2luZG93Lk11c3RhY2hlLnRhZ3MgPSBjdXN0b21UYWdzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgTXVzdGFjaGUgdGVtcGxhdGUgdG8gdGhlIERPTSB1c2luZyBwcm92aWRlZCBkYXRhLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGRhdGEgRGF0YSB0byBiZSByZW5kZXJlZC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gY29udGFpbmVyIFRoZSBlbGVtZW50IHRvIGluc2VydCB0aGUgcmVuZGVyZWQgdGVtcGxhdGUgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRvRW1wdHlDb250YWluZXIgV2hldGhlciB0byBlbXB0eSB0aGUgY29udGFpbmVyIGZpcnN0LlxuICAgKi9cbiAgcmVuZGVyKGRhdGEsIGNvbnRhaW5lciwgZG9FbXB0eUNvbnRhaW5lciA9IHRydWUpIHtcbiAgICAvLyBBZGQgYSBoZWxwZXIgZnVuY3Rpb24gdG8gdGhlIGRhdGEgdGhhdCBhbGxvd3MgdGhlIHRlbXBsYXRlIHRvIGtub3cgdGhlXG4gICAgLy8gaW5kZXggb2YgYW4gaXRlbSBpbiBhbiBhcnJheSBpdCdzIGl0ZXJhdGluZyBvbi5cbiAgICBkYXRhID0gdGhpcy5pbmRleEFycmF5c18oZGF0YSk7XG4gICAgZG9FbXB0eUNvbnRhaW5lciAmJiBlbXB0eUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVkID0gd2luZG93Lk11c3RhY2hlLnJlbmRlcih0aGlzLnRlbXBsYXRlXywgZGF0YSk7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChyZW5kZXJlZCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuICAgIC8vIFJ1biBsYkF1dG9Jbml0IG9uIHRoZSBjb250YWluZXIgdG8gZGlzY292ZXIgYW55IG5ldyBjb21wb25lbnRzXG4gICAgLy8gdGhhdCB3ZXJlIGFkZGVkLlxuICAgIGxiQXV0b0luaXQoY29udGFpbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGtleXMgdG8gYW4gb2JqZWN0IGluIGFuIGFycmF5IHRoYXQgcmVwcmVzZW50IHRoZSBvYmplY3QncyBpbmRleC5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIGFkZCBrZXlzIHRvLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBzYW1lIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQsIHdpdGggYW55XG4gICAqICAgb2JqZWN0cyBpbiBhbiBhcnJheSBoYXZpbmcgbmV3IGtleXMgZm9yIHRoZWlyIDAgYW5kIDEtYmFzZWQgaW5kaWNlcyBpblxuICAgKiAgIHRoZSBhcnJheS5cbiAgICovXG4gIGluZGV4QXJyYXlzXyhkYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYW4gb2JqZWN0IGRpcmVjdGx5IGluIGFuIGFycmF5LCBnaXZlIGl0IGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAvLyAwIGFuZCAxLWJhc2VkIGluZGV4IHByb3BlcnRpZXMgYXJlIGdpdmVuIHNpbmNlIE11c3RhY2hlIGNhbid0IGRvIG1hdGguXG4gICAgICBkYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpdGVtLmxiSW5kZXgwID0gaW5kZXg7XG4gICAgICAgICAgaXRlbS5sYkluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgIHRoaXMuaW5kZXhBcnJheXNfKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3QudmFsdWVzKGRhdGEpLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuaW5kZXhBcnJheXNfKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgc2NyaXB0IHRhZyB3aXRoIGEgdGVtcGxhdGUgdG8gYmUgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIHNjcmlwdCB0YWcgd2l0aCBhIHRlbXBsYXRlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZW1wbGF0ZUJ5SWRfKGlkKSB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgcmV0dXJuIHRlbXBsYXRlID8gdGVtcGxhdGUuaW5uZXJUZXh0IDogJyc7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy90ZW1wbGF0ZS90ZW1wbGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAdHlwZSB7P1BhcnNlcn0gKi9cbmxldCBpbnN0YW5jZSA9IG51bGw7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGNvbmR1Y3RpbmcgdG9rZW5pemF0aW9uIG9mIHF1ZXJ5IHN0cmluZy5cbiAqIEBmaW5hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHBhcnNlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIENvbnZlcnQgb3VyIHBhcnNlciBpbnRvIGEgc2luZ2xldG9uLlxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlID0gdGhpcztcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmVycm9yc18gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICB0aGlzLnRva2Vuc18gPSB7fTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyBrZXktdmFsdWUgb2JqZWN0IHBhaXJzIGFuZCByZXR1cm5zIGEgdmFsaWQgcXVlcnkgc3RyaW5nLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmd8bnVtYmVyfGJvb2xlYW4+fSBvYmpUb2tlbnNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgYXNzZW1ibGVTZWFyY2hTdHJpbmcob2JqVG9rZW5zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9ialRva2VucykucmVkdWNlKChzZWFyY2hTdHJpbmcsIGtleSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqVG9rZW5zW2tleV07XG4gICAgICBsZXQgc2VhcmNoUGFyYW0gPSB2YWx1ZSA/IGAke2tleX09JHt2YWx1ZX1gIDoga2V5O1xuXG4gICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgc2VhcmNoUGFyYW0gPSBgJiR7c2VhcmNoUGFyYW19YDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChzZWFyY2hTdHJpbmcgKz0gc2VhcmNoUGFyYW0pO1xuICAgIH0sICc/Jyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgcXVlcnkgc3RyaW5nIGludG8gY2h1bmtzIG9mIHNtYWxsZXIga2V5LXZhbHVlIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHF1ZXJ5IHN0cmluZyB0byB0b2tlbml6ZS5cbiAgICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXBhcmF0ZV8oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zbGljZSgxKS5zcGxpdCgnJicpLm1hcCgoY2h1bmspID0+IGNodW5rLnNwbGl0KCc9JykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBlcnJvcnMgYW5kIGluY3JlbWVudCBjb3VudGVyLlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBjaHVuayAtIEtleS12YWx1ZSBhcnJheS5cbiAgICogQHBhcmFtIHshUmVnRXhwfSB2YWxpZGF0aW9uUmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNhbml0aXplXyhjaHVuaywgdmFsaWRhdGlvblJlKSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGVfKGNodW5rLCB2YWxpZGF0aW9uUmUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yc18gKz0gMTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgZWFjaCBrZXktdmFsdWUgcGFpci5cbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gY2h1bmsgS2V5LXZhbHVlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVfKGNodW5rLCB2YWxpZGF0aW9uUmUpIHtcbiAgICByZXR1cm4gKGNodW5rWzBdICYmIGNodW5rWzFdKSAmJiB2YWxpZGF0aW9uUmUudGVzdChjaHVua1swXSkgJiZcbiAgICAgICAgdmFsaWRhdGlvblJlLnRlc3QoY2h1bmtbMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQga2V5LXZhbHVlIGNodW5rcyBpbnRvIGEgdG9rZW4gbWFwLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBidW5kbGUgVG9rZW4gbWFwLlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBjaHVuayBLZXktdmFsdWUgYXJyYXkuXG4gICAqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXNzZW1ibGVfKGJ1bmRsZSwgY2h1bmspIHtcbiAgICBidW5kbGVbY2h1bmtbMF1dID0gY2h1bmtbMV07XG4gICAgcmV0dXJuIGJ1bmRsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBvdXIgYHBhcnNlcmAgaW5zdGFuY2UuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGluc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLmVycm9yc18gPSAwO1xuICAgIHRoaXMudG9rZW5zXyA9IHt9O1xuICB9XG5cbi8qKlxuICogR2V0IHRoZSBudW1iZXIgb2YgdmFsaWQgdXJsIHF1ZXJ5IHRva2Vucy5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuICBlbnRyaWVzQ291bnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudG9rZW5zXykubGVuZ3RoO1xuICB9XG5cbi8qKlxuICogR2V0IHRva2VuIG1hcC5cbiAqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG4gIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZXJyb25lb3VzIHBhcmFtIGNvdW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBlcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdG9rZW4gZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFN0cmluZ1xuICAgKiBAcGFyYW0ge1JlZ0V4cD19IHZhbGlkYXRpb25SZVxuICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIHBhcnNlKHNlYXJjaFN0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gsIHZhbGlkYXRpb25SZSkge1xuICAgIHNlYXJjaFN0cmluZyA9IHRoaXMuc2VwYXJhdGVfKHNlYXJjaFN0cmluZyk7XG5cbiAgICBpZiAodmFsaWRhdGlvblJlICYmICh2YWxpZGF0aW9uUmUgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICBzZWFyY2hTdHJpbmcgPVxuICAgICAgICAgIHNlYXJjaFN0cmluZy5maWx0ZXIoKGNodW5rKSA9PiB0aGlzLnNhbml0aXplXyhjaHVuaywgdmFsaWRhdGlvblJlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaFN0cmluZy5yZWR1Y2UodGhpcy5hc3NlbWJsZV8sIHRoaXMudG9rZW5zXyk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy91cmwtcGFyc2VyL3VybC1wYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEEgcHJvdmlkZXIgZm9yIHBvbHlmaWxscy4gSW5pdGlhbGl6ZSBhbGwgcG9seWZpbGxzIG9yIGp1c3Qgb25lLlxuICogRGVtbzpcbiAqIGltcG9ydCBwb2x5ZmlsbHMgZnJvbSAnLi4vcHJvdmlkZXJzL3BvbHlmaWxscy9wb2x5ZmlsbHMnO1xuICogcG9seWZpbGxzLmluaXRBbGwoKTsgLy8gQWxsIHBvbHlmaWxscy5cbiAqIHBvbHlmaWxscy5pbml0KCdjbG9zZXN0Jyk7IC8vIE9uZSBwb2x5ZmlsbC5cbiAqL1xuY29uc3QgcG9seWZpbGxzID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgb25lIHBvbHlmaWxsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9seWZpbGxOYW1lIFRoZSBuYW1lIG9mIHRoZSBwb2x5ZmlsbCB0byBpbml0aWFsaXplLlxuICAgKi9cbiAgaW5pdChwb2x5ZmlsbE5hbWUpIHtcbiAgICBwb2x5ZmlsbERhdGFbcG9seWZpbGxOYW1lXSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhbGwgcG9seWZpbGxzLlxuICAgKi9cbiAgaW5pdEFsbCgpIHtcbiAgICBPYmplY3Qua2V5cyhwb2x5ZmlsbERhdGEpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5pbml0KGtleSk7XG4gICAgfSk7XG4gIH0sXG59O1xuXG5jb25zdCBwb2x5ZmlsbERhdGEgPSB7XG4gIGNsb3Nlc3Q6ICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBFbGVtZW50LmNsb3Nlc3QoKSBwb2x5ZmlsbFxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3QjUG9seWZpbGxcbiAgICAgKi9cbiAgICBpZiAoIUVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QpIHtcbiAgICAgIGlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4gICAgICB9XG4gICAgICBFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSB0aGlzO1xuICAgICAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKGFuY2VzdG9yLm1hdGNoZXMocykpIHtcbiAgICAgICAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9IHdoaWxlIChhbmNlc3RvciAhPT0gbnVsbCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwb2x5ZmlsbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvcG9seWZpbGxzL3BvbHlmaWxscy5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7cmVzcG9uc2VUeXBlcyxcbiAgICBmYWlsdXJlVHlwZXMsIHJlc3BvbnNlTW9kZWwsIGRlZmF1bHRPcHRpb25zfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogYFhNTEh0dHBSZXF1ZXN0YCB3cmFwcGVyIGNsYXNzLlxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXF1ZXN0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICo+fSAqL1xuICAgIHRoaXMub3B0aW9uc18gPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P1hNTEh0dHBSZXF1ZXN0fSAqL1xuICAgIHRoaXMuaHR0cFJlcXVlc3RfO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/UHJvbWlzZX0gKi9cbiAgICB0aGlzLnJlcXVlc3RQcm9taXNlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBsb2FkIGV2ZW50IGxpc3RlbmVyIHRvIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVMb2FkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hTdWNjZXNzTGlzdGVuZXJfKGhhbmRsZUxvYWQpIHtcbiAgICB0aGlzLmh0dHBSZXF1ZXN0Xy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgaGFuZGxlTG9hZCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXJyb3IgZXZlbnQgbGlzdGVuZXIgdG8gcmVxdWVzdC5cbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZUVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hGYWlsdXJlTGlzdGVuZXJfKGhhbmRsZUVycm9yKSB7XG4gICAgdGhpcy5odHRwUmVxdWVzdF8uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgc3RhdGUgY2hhbmdlIGV2ZW50IGxpc3RlbmVyIHRvIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVTdGF0ZUNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoU3RhdGVDaGFuZ2VMaXN0ZW5lcl8oaGFuZGxlU3RhdGVDaGFuZ2UpIHtcbiAgICB0aGlzLmh0dHBSZXF1ZXN0Xy5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgaGFuZGxlU3RhdGVDaGFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIHRpbWVvdXQgZXZlbnQgbGlzdGVuZXIgdG8gcmVxdWVzdC5cbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZVRpbWVvdXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF0dGFjaFRpbWVvdXRMaXN0ZW5lcl8oaGFuZGxlVGltZW91dCkge1xuICAgIHRoaXMuaHR0cFJlcXVlc3RfLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCBoYW5kbGVUaW1lb3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGRhdGEgZnJvbSByZXNwb25zZSB1c2luZyByZXF1ZXN0IGByZXNwb25zZVR5cGVgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRSZXNwb25zZUJ5VHlwZV8ocmVzcG9uc2VUeXBlKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gdGhpcy5odHRwUmVxdWVzdF9bcmVzcG9uc2VNb2RlbFtyZXNwb25zZVR5cGVdXTtcblxuICAgIGlmICh0aGlzLmlzSWVDb21wYXRpYmlsaXR5TW9kZV8ocmVzcG9uc2VUeXBlKSkge1xuICAgICAgcmVzcG9uc2UgPSB3aW5kb3cuSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgcmVxdWVzdCBmYWlsdXJlczogZXJyb3IsIGFib3J0IGFuZCA0MDQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWlsdXJlVHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gcmVqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmYWlsdXJlQ2FsbGJhY2tfKGZhaWx1cmVUeXBlLCByZWplY3QpIHtcbiAgICBpZiAoZmFpbHVyZVR5cGUgPT09IGZhaWx1cmVUeXBlcy5FUlJPUiB8fFxuICAgICAgICBmYWlsdXJlVHlwZSA9PT0gZmFpbHVyZVR5cGVzLlRJTUVPVVQgfHxcbiAgICAgICAgKGZhaWx1cmVUeXBlID09PSBmYWlsdXJlVHlwZXMuRk9VUl9IVU5EUkVEX0ZPVVIgJiZcbiAgICAgICAgICAgIHRoaXMuaHR0cFJlcXVlc3RfLnN0YXR1cyA9PT0gNDA0KSkge1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgZmFpbHVyZVR5cGUsXG4gICAgICAgICdzdGF0dXMnOiB0aGlzLmh0dHBSZXF1ZXN0Xy5zdGF0dXMsXG4gICAgICAgICdzdGF0dXNUZXh0JzogdGhpcy5odHRwUmVxdWVzdF8uc3RhdHVzVGV4dCxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZXF1ZXN0UHJvbWlzZV8gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHJlcXVlc3Qgc3VjY2Vzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlVHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gcmVzb2x2ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3VjY2Vzc0NhbGxiYWNrXyhyZXNwb25zZVR5cGUsIHJlc29sdmUpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuZ2V0UmVzcG9uc2VCeVR5cGVfKHJlc3BvbnNlVHlwZSk7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgdGhpcy5yZXF1ZXN0UHJvbWlzZV8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYFJlcXVlc3RvcmAgc2hvdWxkIGJlIHBsYWNlZCBpbiBJRSBjb21wYXRpYmlsaXR5IG1vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZVR5cGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSWVDb21wYXRpYmlsaXR5TW9kZV8ocmVzcG9uc2VUeXBlKSB7XG4gICAgcmV0dXJuIChyZXNwb25zZVR5cGUgPT09IHJlc3BvbnNlVHlwZXMuSlNPTiB8fFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlID09PSByZXNwb25zZVR5cGVzLlRFWFQpICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmllQ29tcGF0aWJpbGl0eU1vZGU7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgYFhNTEh0dHBSZXF1ZXN0YCBpbiBhIHByb21pc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZVR5cGVcbiAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAqL1xuICByZXF1ZXN0KHJlcXVlc3RVcmwsIHJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZXMuSlNPTikge1xuICAgIHJlc3BvbnNlVHlwZSA9IHRoaXMuaXNJZUNvbXBhdGliaWxpdHlNb2RlXyhyZXNwb25zZVR5cGUpID9cbiAgICAgICAgcmVzcG9uc2VUeXBlcy5URVhUIDogcmVzcG9uc2VUeXBlO1xuXG4gICAgaWYgKHRoaXMucmVxdWVzdFByb21pc2VfKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UHJvbWlzZV87XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0UHJvbWlzZV8gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmh0dHBSZXF1ZXN0XyA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgdGhpcy5odHRwUmVxdWVzdF8ucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgdGhpcy5odHRwUmVxdWVzdF8ub3BlbignR0VUJywgcmVxdWVzdFVybCwgdHJ1ZSk7XG4gICAgICB0aGlzLmh0dHBSZXF1ZXN0Xy5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgdGhpcy5odHRwUmVxdWVzdF8udGltZW91dCA9IHRoaXMub3B0aW9uc18udGltZW91dDtcblxuICAgICAgLy8gUmVxdWVzdCBsaXN0ZW5lcnMuXG4gICAgICB0aGlzLmF0dGFjaFN1Y2Nlc3NMaXN0ZW5lcl8oXG4gICAgICAgICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2tfLmJpbmQodGhpcywgcmVzcG9uc2VUeXBlLCByZXNvbHZlKSk7XG5cbiAgICAgIHRoaXMuYXR0YWNoU3RhdGVDaGFuZ2VMaXN0ZW5lcl8oXG4gICAgICAgICAgdGhpcy5mYWlsdXJlQ2FsbGJhY2tfLmJpbmQodGhpcyxcbiAgICAgICAgICAgICAgZmFpbHVyZVR5cGVzLkZPVVJfSFVORFJFRF9GT1VSLCByZWplY3QpKTtcblxuICAgICAgdGhpcy5hdHRhY2hGYWlsdXJlTGlzdGVuZXJfKFxuICAgICAgICAgIHRoaXMuZmFpbHVyZUNhbGxiYWNrXy5iaW5kKHRoaXMsIGZhaWx1cmVUeXBlcy5FUlJPUiwgcmVqZWN0KSk7XG5cbiAgICAgIHRoaXMuYXR0YWNoVGltZW91dExpc3RlbmVyXyhcbiAgICAgICAgICB0aGlzLmZhaWx1cmVDYWxsYmFja18uYmluZCh0aGlzLCBmYWlsdXJlVHlwZXMuVElNRU9VVCwgcmVqZWN0KSk7XG5cbiAgICAgIHRoaXMuaHR0cFJlcXVlc3RfLnNlbmQoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQcm9taXNlXztcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUveW91dHViZS9zcmMvcHJvdmlkZXJzL3JlcXVlc3QvcmVxdWVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IHJlc3BvbnNlVHlwZXMgPSB7XG4gIEFSUkFZX0JVRkZFUjogJ2FycmF5YnVmZmVyJyxcbiAgSlNPTjogJ2pzb24nLFxuICBCTE9COiAnYmxvYicsXG4gIFRFWFQ6ICd0ZXh0JyxcbiAgRE9DVU1FTlQ6ICdkb2N1bWVudCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBmYWlsdXJlVHlwZXMgPSB7XG4gIEVSUk9SOiAnZXJyb3InLFxuICBUSU1FT1VUOiAndGltZW91dCcsXG4gIEZPVVJfSFVORFJFRF9GT1VSOiAnNDA0Jyxcbn07XG5cbi8qKiBAcHJpdmF0ZSBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSAqL1xuZXhwb3J0IGNvbnN0IHJlc3BvbnNlTW9kZWwgPSB7XG4gICdhcnJheWJ1ZmZlcic6ICdyZXNwb25zZScsXG4gICdqc29uJzogJ3Jlc3BvbnNlJyxcbiAgJ2Jsb2InOiAncmVzcG9uc2UnLFxuICAndGV4dCc6ICdyZXNwb25zZVRleHQnLFxuICAnZG9jdW1lbnQnOiAncmVzcG9uc2VYTUwnLFxufTtcblxuLyoqIEBwcml2YXRlIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICo+fSAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBpZUNvbXBhdGliaWxpdHlNb2RlOiBmYWxzZSxcbiAgdGltZW91dDogNTAwMCxcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvcmVxdWVzdC9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgJ2RvbWFpbic6IEZ1bmN0aW9uLFxuICogICdyYW5nZSc6IEZ1bmN0aW9uLFxuICogICd0cmFuc2xhdGUnOiBGdW5jdGlvbixcbiAqIH19XG4gKi9cbmxldCB0cmFuc2Zvcm1lcjtcblxuLyoqXG4gKiBDbGFzcyB0byBzaW1wbGlmeSB3b3JraW5nIHdpdGggbnVtYmVyIHJhbmdlcyAtIHNwZWNpZmljYWxseSwgdHJhbnNsYXRpbmdcbiAqIHZhbHVlcyBmcm9tIG9uZSBkb21haW4gdG8gYW5vdGhlci4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gc2NhbGVcbiAqIG9yIHBvc2l0aW9uIGFuIGVsZW1lbnQgdXNpbmcgYSByYW5nZSBvZiB2YWx1ZXMgbm90IHRpZWQgdG8gdGhlXG4gKiB2aWV3cG9ydCBudW1iZXIgc3BhY2UsIG9yIGNvbnZlcnNlbHksIHVzZSB0aGUgdmlld3BvcnQgc3BhY2UgdG9cbiAqIHRyYW5zbGF0ZSBhIGRpZmZlcmVudCBzZXQgb2YgbnVtYmVyLCBsaWtlIGZvbnQgc2l6ZS5cbiAqIGUuZ1xuICogY29uc3Qgc2NhbGUgPSBuZXcgU2NhbGVQcm92aWRlcigpLmNyZWF0ZSgpO1xuICogc2NhbGUuZG9tYWluKDAsIDEwMDApLnJhbmdlKDAsIDEpO1xuICogbGV0IG5vcm1hbGl6ZWRWYWx1ZSA9IHNjYWxlLnRyYW5zbGF0ZSg0MDEpO1xuICogbm9ybWFsaXplZFZhbHVlID0gMC40MDFcbiAqIEBmaW5hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnRlcmZhY2UgZm9yIHRyYW5zbGF0aW5nIHZhbHVlcy5cbiAgICogQHJldHVybiB7IXRyYW5zZm9ybWVyfVxuICAgKi9cbiAgY3JlYXRlKCkge1xuICAgIC8qKiBAcHJpdmF0ZSB7IUFycmF5PG51bWJlcj59ICovXG4gICAgbGV0IGRvbWFpbl8gPSBbMCwgMV07XG4gICAgLyoqIEBwcml2YXRlIHshQXJyYXk8bnVtYmVyPn0gKi9cbiAgICBsZXQgb3V0cHV0XyA9IFswLCAxXTtcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIERldGVybWluZXMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgdmFsdWUgaXMgYSBudW1iZXIuXG4gICAgICAgKi9cbiAgICAgIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSAnbnVtYmVyJztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IG1pbiBhbmQgbWF4IGRvbWFpbiB2YWx1ZXMuXG4gICAgICAgKiBUaGUgYGRvbWFpbmAgaXMgYSB2YWx1ZSdzIG9yaWdpbiBudW1iZXIgc3BhY2UuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgdHJhbnNmb3JtZXI+fVxuICAgICAgICovXG4gICAgICBkb21haW46IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc051bWJlcihtaW4pIHx8ICF0aGlzLmlzTnVtYmVyKG1heCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzcGVjaWZ5IGEgbWluL21heCB2YWx1ZSBmb3IgdGhlIGRvbWFpbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5fID0gW21pbiwgbWF4XTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBtaW4gYW5kIG1heCBvdXRwdXQgdmFsdWVzLlxuICAgICAgICogVGhlIGByYW5nZWAgaXMgYSBudW1iZXIgc3BhY2UgdXNlZCB0byBpbmZvcm0gaG93IHRoZSBudW1iZXJcbiAgICAgICAqIHdpbGwgYmUgdHJhbnNsYXRlZC5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgICAqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCB0cmFuc2Zvcm1lcj59XG4gICAgICAgKi9cbiAgICAgIHJhbmdlOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNOdW1iZXIobWluKSB8fCAhdGhpcy5pc051bWJlcihtYXgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSBhIG1pbi9tYXggdmFsdWUgZm9yIHRoZSByYW5nZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRfID0gW21pbiwgbWF4XTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG5ldyB2YWx1ZSBiYXNlZCBvbiB0aGUgZG9tYWluIGFuZCByYW5nZSBzcGFjZXMuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWxEb21haW5NaW4gPSAodmFsdWUgLSBkb21haW5fWzBdKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0TWluTWF4ID0gKG91dHB1dF9bMV0gLSBvdXRwdXRfWzBdKTtcbiAgICAgICAgY29uc3QgZG9tYWluTWluTWF4ID0gKGRvbWFpbl9bMV0gLSBkb21haW5fWzBdKTtcbiAgICAgICAgcmV0dXJuIHZhbERvbWFpbk1pbiAqIG91dHB1dE1pbk1heCAvIGRvbWFpbk1pbk1heCArIG91dHB1dF9bMF07XG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9zY2FsZS9zY2FsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7UmFmfSBmcm9tICcuLi9yYWYvcmFmJztcblxuLyoqIEB0eXBlIHs/U2Nyb2xsfSAqL1xubGV0IGluc3RhbmNlID0gbnVsbDtcblxuLyoqXG4qIENsYXNzIHRoYXQgZ292ZXJucyBgd2luZG93YCBzY3JvbGwgZXZlbnRzLlxuKiBAZmluYWxcbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY3JvbGwge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UgPSB0aGlzO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFSYWZ9IC0gUmVxdWVzdCBBbmltYXRpb24gRnJhbWUgc2VydmljZS4gKi9cbiAgICB0aGlzLnJhZl8gPSBuZXcgUmFmKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQb3NpdGlvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEEgZ3JvdXAgb2YgY2FsbGJhY2tzIGV4ZWN1dGVkIGR1cmluZyBhIHNjcm9sbCBldmVudC5cbiAgICAgKiBAcHJpdmF0ZSB7IUFycmF5PCFGdW5jdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5jYWxsYmFja3NfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBGbGFnIGZvciBpbiBwcm9ncmVzcyAoUmFmKSBzY3JvbGwgZXZlbnQuXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJpbmdfID0gZmFsc2U7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhbiBSYWYgKHNjcm9sbCBldmVudCkgY2FsbGJhY2suXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW5kZXJfKCkge1xuICAgIC8vIEN1cnJlbnQgb2Zmc2V0IHBvc2l0aW9uLlxuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbigpO1xuICAgIC8vIFRoZSBzY3JvbGwgZGlyZWN0aW9uOiB1cHxkb3duLlxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5sYXN0UG9zaXRpb25fIC0gcG9zaXRpb247XG5cbiAgICBpZiAodGhpcy5jYWxsYmFja3NfLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBkZWx0YSxcbiAgICAgIH07XG5cbiAgICAgIC8vIFBhc3MgZXZlbnQgcGF5bG9hZCB0byBjYWxsYmFja3MuXG4gICAgICB0aGlzLmNhbGxiYWNrc18uZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJpbmdfID0gZmFsc2U7XG4gICAgdGhpcy5yYWZfLnN0b3AoKTtcbiAgICAvLyBTZXQgdGhlIHByZXZpb3VzIHNjcm9sbCBwb3NpdGlvbi5cbiAgICB0aGlzLmxhc3RQb3NpdGlvbl8gPSBwb3NpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgc2Nyb2xsIHBhaW50cyB1c2luZyBSYWYuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW5kZXJlcl8oKSB7XG4gICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcoKSAmJiAhdGhpcy5yZW5kZXJpbmdfKSB7XG4gICAgICB0aGlzLnJlbmRlcmluZ18gPSB0cnVlO1xuICAgICAgdGhpcy5yYWZfLnJlc3VtZSgpO1xuICAgICAgdGhpcy5yYWZfLnRpY2tlcih0aGlzLnJlbmRlcl8sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGltbWVkaWF0ZSAtIHBlcmZvcm0gcHJlLXNjcm9sbCBjYWxjdWxhdGlvbnMuXG4gICAqL1xuICBsaXN0ZW4oaW1tZWRpYXRlID0gZmFsc2UpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5yZW5kZXJlcl8uYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICB0aGlzLnJlbmRlcl8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB1c2VyIGlzIHNjcm9sbGluZy5cbiAgICovXG4gIGlzU2Nyb2xsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmxhc3RQb3NpdGlvbl8gIT09IHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGVyZSdzIHJvb20gdG8gc2Nyb2xsLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFzU3BhY2VUb1Njcm9sbF8oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZICsgd2luZG93LmlubmVySGVpZ2h0IDw9XG4gICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0IC0gdGhpcy5vcHRpb25zXy5taW5TY3JvbGxEaXN0YW5jZVB4O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzY3JvbGwgcG9zaXRpb24uXG4gICAqIFByaW1hcmlseSB1c2VkIHdpdGggYHdpbmRvdy5iZWZvcmV1bmxvYWRgLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25YXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbllcbiAgICovXG4gIHNldFBvc2l0aW9uKHBvc2l0aW9uWCwgcG9zaXRpb25ZKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uWCwgcG9zaXRpb25ZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGN1cnJlbnQgcGFnZSBZIG9mZnNldC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgc2Nyb2xsIGluc3RhbmNlLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnJhZl8uY2FuY2VsKCk7XG4gICAgdGhpcy5sYXN0UG9zaXRpb25fID0gLTE7XG4gICAgdGhpcy5jYWxsYmFja3NfID0gW107XG4gICAgaW5zdGFuY2UgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc3Vic2NyaWJlcnMgKGNhbGxiYWNrcykgdG8gbGlzdCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICogZHVyaW5nIHNjcm9sbCBldmVudC5cbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm4geyFGdW5jdGlvbn1cbiAgICovXG4gIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2tzXy5wdXNoKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2FsbGJhY2tzXy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrc18uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQGdvb2dsZS95b3V0dWJlL3NyYy9wcm92aWRlcnMvc2Nyb2xsL3Njcm9sbC5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7c3RyaW5ncywgdGF4b25vbWllc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG5sZXQgaXNDbGllbnRSZWFkeV8gPSBmYWxzZTtcblxuLyoqIEBwcml2YXRlIEBjb25zdCB7IUFycmF5PD9GdW5jdGlvbj59ICovXG5jb25zdCBsb2FkQ2FsbGJhY2tzXyA9IFtdO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgJ2xvY2F0aW9uJzogc3RyaW5nLFxuICogICdsb2NhdGlvblJhZGl1cyc6IHN0cmluZyxcbiAqICAncGFydCc6IHN0cmluZyxcbiAqICAncSc6IHN0cmluZyxcbiAqICAndHlwZSc6IHN0cmluZyxcbiAqICAnZXZlbnRUeXBlJzogc3RyaW5nLFxuICogICdyZWxhdGVkVG9WaWRlb0lkJzogc3RyaW5nLFxuICogfX1cbiAqL1xubGV0IHNlYXJjaEludGVyZmFjZTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgbWFraW5nIFlvdVR1YmUgQVBJIHJlcXVlc3RzLlxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFlUQXBpIHtcbiAgc3RhdGljIGF0dGFjaChjbGllbnRJZCkge1xuICAgIGNvbnN0IHNjcmlwdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3RyaW5ncy5TQ1JJUFRfSUQpO1xuXG4gICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQuaWQgPSBzdHJpbmdzLlNDUklQVF9JRDtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHN0cmluZ3MuQVBJU19TT1VSQ0U7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZXNvbHZlKTtcbiAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzY3JpcHRQcm9taXNlLnRoZW4oKCkgPT4gbmV3IFlUQXBpKGNsaWVudElkKSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihjbGllbnRJZCkge1xuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3Qge3N0cmluZ30gKi9cbiAgICB0aGlzLmNsaWVudElkXyA9IGNsaWVudElkO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICFBcnJheTwhRnVuY3Rpb24+Pn0gKi9cbiAgICB0aGlzLmV2ZW50c18gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/d2luZG93LmdhcGl9ICovXG4gICAgdGhpcy5nYXBpXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMud2lyZVJlc29sdmVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGV2ZW50IHNwZWNpZmljIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0gez9PYmplY3Q8c3RyaW5nLCAqPn0gZGV0YWlsc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdF8oZXZlbnROYW1lLCBkZXRhaWxzKSB7XG4gICAgKHRoaXMuZXZlbnRzX1tldmVudE5hbWVdIHx8IFtdKVxuICAgICAgICAuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGRldGFpbHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IHNwZWNpZmljIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBkZXRhaWxzXG4gICAqIEByZXR1cm4geyFGdW5jdGlvbn1cbiAgICovXG4gIGxpc3RlbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihzdHJpbmdzLkVOU1VSRV9MSVNURU5FUl9ERUZOSU5FRF9NU0cpO1xuICAgIH1cblxuICAgIGV2ZW50TmFtZSA9IGAke3N0cmluZ3MuRVZFTlRfUFJFRklYfToke2V2ZW50TmFtZX1gO1xuICAgIHRoaXMuZXZlbnRzX1tldmVudE5hbWVdID0gKHRoaXMuZXZlbnRzX1tldmVudE5hbWVdIHx8IFtdKTtcbiAgICB0aGlzLmV2ZW50c19bZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50c19bZXZlbnROYW1lXSA9XG4gICAgICAgICAgdGhpcy5ldmVudHNfW2V2ZW50TmFtZV0uZmlsdGVyKChmKSA9PiBmICE9PSBsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHZpZGVvcyBieSB2aWRlbyBpZChzKSwgY2hhcnQgbmFtZSBvciByZWdpb24gY29kZS5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20veW91dHViZS92My9kb2NzL3ZpZGVvcy9saXN0XG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59IG9wdGlvbnNcbiAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAqL1xuICB2aWRlb3Mob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVSZXF1ZXN0TWVjaGFuaXNtXyh0YXhvbm9taWVzLlZJREVPUywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBzdWJzY3JpcHRpb25zIGJ5IGNoYW5uZWwgaWQuXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3lvdXR1YmUvdjMvZG9jcy9zdWJzY3JpcHRpb25zL2xpc3RcbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICovXG4gIHN1YnMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVSZXF1ZXN0TWVjaGFuaXNtXyh0YXhvbm9taWVzLlNVQlMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdmlkZW8gY2F0ZWdvcmllcyBieSByZWdpb24gY29kZS5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20veW91dHViZS92My9kb2NzL3ZpZGVvQ2F0ZWdvcmllcy9saXN0XG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59IG9wdGlvbnNcbiAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAqL1xuICB2aWRlb0NhdGVnb3JpZXMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVSZXF1ZXN0TWVjaGFuaXNtXyh0YXhvbm9taWVzLlZJREVPX0NBVCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB2aWRlbyBjYXB0aW9ucyBieSB2aWRlbyBpZC5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20veW91dHViZS92My9kb2NzL2NhcHRpb25zL2xpc3RcbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICovXG4gIHZpZGVvQ2FwdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVSZXF1ZXN0TWVjaGFuaXNtXyh0YXhvbm9taWVzLkNBUFRJT05TLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNoYW5uZWwocykgYnkgaWQocykuXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3lvdXR1YmUvdjMvZG9jcy9jaGFubmVscy9saXN0XG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59IG9wdGlvbnNcbiAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAqL1xuICBjaGFubmVscyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVJlcXVlc3RNZWNoYW5pc21fKHRheG9ub21pZXMuQ0hBTk5FTFMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2hhbm5lbCBzZWN0aW9ucyBieSBjaGFubmVsIGlkLlxuICAgKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS95b3V0dWJlL3YzL2RvY3MvY2hhbm5lbFNlY3Rpb25zL2xpc3RcbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICovXG4gIGNoYW5uZWxTZWN0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVJlcXVlc3RNZWNoYW5pc21fKHRheG9ub21pZXMuQ0hBTk5FTF9TRUNUSU9OUywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjaGFubmVsIGFjdGl2aXRpZXMgYnkgY2hhbm5lbCBpZC5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20veW91dHViZS92My9kb2NzL2FjdGl2aXRpZXMvbGlzdFxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBvcHRpb25zXG4gICAqIEByZXR1cm4geyFQcm9taXNlfVxuICAgKi9cbiAgY2hhbm5lbEFjdGl2aXRpZXMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVSZXF1ZXN0TWVjaGFuaXNtXyh0YXhvbm9taWVzLkFDVElWSVRJRVMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgUGxheWxpc3RieSBwbGF5bGlzdCBpZC5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20veW91dHViZS92My9kb2NzL3BsYXlsaXN0cy9saXN0XG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59IG9wdGlvbnNcbiAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAqL1xuICBwbGF5bGlzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVJlcXVlc3RNZWNoYW5pc21fKHRheG9ub21pZXMuUExBWUxJU1RTLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIFBsYXlsaXN0IGl0ZW1zIGJ5IHBsYXlsaXN0IGlkLlxuICAgKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS95b3V0dWJlL3YzL2RvY3MvcGxheWxpc3RJdGVtcy9saXN0XG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59IG9wdGlvbnNcbiAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAqL1xuICBwbGF5bGlzdEl0ZW1zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlUmVxdWVzdE1lY2hhbmlzbV8odGF4b25vbWllcy5QTEFZTElTVF9JVEVNUywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoZXMgWW91VHViZSB2aWRlb3MgdXNpbmcga2V5d29yZHMsIGxvY2F0aW9ucywgZXZlbnRzLCBldGMuXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3lvdXR1YmUvdjMvZG9jcy9zZWFyY2gvbGlzdFxuICAgKiBAcGFyYW0geyFzZWFyY2hJbnRlcmZhY2V9IG9wdGlvbnNcbiAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAqL1xuICBzZWFyY2gob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVSZXF1ZXN0TWVjaGFuaXNtXyh0YXhvbm9taWVzLlNFQVJDSCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuZCBzZW5kcyBBUEkgcmVxdWVzdHMuIEVtaXRzIGEgcmVxdWVzdCBzcGVjaWZpYyBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRheG9ub215XG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59IHBhcmFtc1xuICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGV4ZWN1dGVSZXF1ZXN0TWVjaGFuaXNtXyh0YXhvbm9teSwgcGFyYW1zKSB7XG4gICAgY29uc3QgcGF0aCA9IGAveW91dHViZS8ke3N0cmluZ3MuQVBJX1ZFUlNJT059LyR7dGF4b25vbXl9YDtcbiAgICBjb25zdCBldmVudE5hbWUgPSBgJHtzdHJpbmdzLkVWRU5UX1BSRUZJWH06JHt0YXhvbm9teX1gO1xuICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgIHRoaXMuZ2FwaV8uY2xpZW50LnJlcXVlc3Qoe21ldGhvZCwgcGF0aCwgcGFyYW1zfSkuZXhlY3V0ZShyZXNvbHZlKSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKChzbmFwc2hvdCkgPT4ge1xuICAgICAgdGhpcy5lbWl0XyhldmVudE5hbWUsIHNuYXBzaG90KTtcbiAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgWVQgQVBJIGxpYiBhbmQgdXBkYXRlcyBwcm92aWRlciBzdGF0ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsb2FkQ2xpZW50XygpIHtcbiAgICB0aGlzLmdhcGlfID0gd2luZG93LmdhcGk7XG4gICAgdGhpcy5nYXBpXy5jbGllbnQuc2V0QXBpS2V5KHRoaXMuY2xpZW50SWRfKTtcbiAgICB0aGlzLmdhcGlfLmNsaWVudC5sb2FkKCd5b3V0dWJlJywgc3RyaW5ncy5BUElfVkVSU0lPTiwgdGhpcy53aXJlUmVzb2x2ZV8pO1xuICAgIHRoaXMuZW1pdF8oc3RyaW5ncy5FVkVOVF9MT0FEKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2lyZVJlc29sdmVfID0gbnVsbDtcbiAgICB9KTtcbiAgICBpc0NsaWVudFJlYWR5XyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEFQSS5cbiAgICovXG4gIGluaXQoKSB7XG4gICAgaWYgKGlzQ2xpZW50UmVhZHlfKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLmxvYWRDbGllbnRfKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy53aXJlUmVzb2x2ZV8gPSByZXNvbHZlO1xuICAgICAgbG9hZENhbGxiYWNrc18ucHVzaCh0aGlzLmxvYWRDbGllbnRfLmJpbmQodGhpcykpO1xuXG4gICAgICB3aW5kb3cub25sb2FkID0gKCkgPT5cbiAgICAgICAgICBsb2FkQ2FsbGJhY2tzXy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy95dC1hcGkveXQtYXBpLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVBJX1ZFUlNJT046ICd2MycsXG4gIEFQSVNfU09VUkNFOiAnaHR0cHM6Ly9hcGlzLmdvb2dsZS5jb20vanMvY2xpZW50LmpzJyxcbiAgQUNUSVZJVElFU19UQVg6ICdhY3Rpdml0aWVzJyxcbiAgU0NSSVBUX0lEOiAnanMteXQtYXBpJyxcbiAgLy8gRXZlbnRzXG4gIEVWRU5UX0xPQUQ6ICd5dC1hcGk6bG9hZCcsXG4gIEVWRU5UX1BSRUZJWDogJ3l0LWFwaScsXG4gIC8vIE1lc3NhZ2VzXG4gIE5PX0xJU1RFTkVSX01TRzogYFlvdSBoYXZlbid0IHJlZ2lzdGVyZWQgYW55IGxpc3RlbmVycyBmb3IgdGhpcyBldmVudC5gLFxuICBFTlNVUkVfTElTVEVORVJfREVGTklORURfTVNHOiBgUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IFwibGlzdGVuZXJcIiBpcyBmdW5jdGlvbi5gLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5leHBvcnQgY29uc3QgdGF4b25vbWllcyA9IHtcbiAgQUNUSVZJVElFUzogJ2FjdGl2aXRpZXMnLFxuICBDQVBUSU9OUzogJ2NhcHRpb25zJyxcbiAgQ0hBTk5FTFM6ICdjaGFubmVscycsXG4gIENIQU5ORUxfU0VDVElPTlM6ICdjaGFubmVsU2VjdGlvbnMnLFxuICBDT01NRU5UUzogJ2NvbW1lbnRzJyxcbiAgUExBWUxJU1RTOiAncGxheWxpc3RzJyxcbiAgUExBWUxJU1RfSVRFTVM6ICdwbGF5bGlzdEl0ZW1zJyxcbiAgU1VCUzogJ3N1YnNjcmlwdGlvbnMnLFxuICBWSURFT19DQVQ6ICd2aWRlb0NhdGVnb3JpZXMnLFxuICBWSURFT1M6ICd2aWRlb3MnLFxuICBTRUFSQ0g6ICdzZWFyY2gnLFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy95dC1hcGkvY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgSUZSQU1FX0FQSV9TUkMgPSAnaHR0cHM6Ly93d3cueW91dHViZS5jb20vaWZyYW1lX2FwaSc7XG5cbi8qKiBAY29uc3Qge251bWJlcn0gKi9cbmNvbnN0IEFQSV9SRVFVRVNUX1RJTUVPVVQgPSAxMDAwMDtcblxuXG4vKipcbiAqIENsYXNzIGZvciBsb2FkaW5nIHRoZSBZb3VUdWJlIElGcmFtZSBBUEkuXG4gKiBEb2NzOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS95b3V0dWJlL2lmcmFtZV9hcGlfcmVmZXJlbmNlXG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgWVRJZnJhbWVBcGlJbml0IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFlUSWZyYW1lQXBpSW5pdCBwcm92aWRlciwgd2hpY2ggaXMgYVxuICAgKiBzaW5nbGV0b24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGNvdW50IGJlZm9yZSB0aW1pbmcgb3V0XG4gICAqICAgdGhlIEFQSSByZXF1ZXN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IodGltZW91dCA9IEFQSV9SRVFVRVNUX1RJTUVPVVQpIHtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLnRpbWVvdXRfID0gdGltZW91dDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7UHJvbWlzZXx1bmRlZmluZWR9ICovXG4gICAgdGhpcy5hcGlQcm9taXNlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgWW91VHViZSBpRnJhbWUgQVBJIGlmIGl0J3Mgbm90IGFscmVhZHkgbG9hZGVkLlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayBvbiBZVC5yZWFkeSB0byBub3RpZnkgWVRQbGF5ZXIgY29tcG9uZW50cy5cbiAgICogQHJldHVybiB7IVByb21pc2V9IEEgcHJvbWlzZSBmb3IgdGhlIEFQSSBiZWluZyBsb2FkZWQuXG4gICAqL1xuICBsb2FkQXBpKCkge1xuICAgIGlmICghdGhpcy5hcGlQcm9taXNlXykge1xuICAgICAgdGhpcy5hcGlQcm9taXNlXyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gUnVuIHdoZW4gdGhlIEFQSSBoYXMgbG9hZGVkLlxuICAgICAgICBjb25zdCBvbkFwaVJlYWR5ID0gKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChhcGlSZXF1ZXN0VGltZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaW1lb3V0IGFuZCByZWplY3QgaWYgdGhlIEFQSSB0YWtlcyB0b28gbG9uZyB0byBsb2FkICh1bmxpa2VseSkuXG4gICAgICAgIGNvbnN0IGFwaVJlcXVlc3RUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlamVjdCgnVGhlIFlvdVR1YmUgaUZyYW1lIEFQSSByZXF1ZXN0IHRpbWVkIG91dC4nKTtcbiAgICAgICAgfSwgdGhpcy50aW1lb3V0Xyk7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5ZVCkge1xuICAgICAgICAgIG9uQXBpUmVhZHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydCBBUEkgc2NyaXB0IHdpdGggbG9hZCBjYWxsYmFjay5cbiAgICAgICAgY29uc3QgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIGNvbnN0IFtmaXJzdFNjcmlwdFRhZ10gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG5cbiAgICAgICAgdGFnLnNyYyA9IElGUkFNRV9BUElfU1JDO1xuICAgICAgICB0YWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICB3aW5kb3cuWVQucmVhZHkob25BcGlSZWFkeSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmaXJzdFNjcmlwdFRhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YWcsIGZpcnN0U2NyaXB0VGFnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwaVByb21pc2VfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBZVElmcmFtZUFwaUluaXQoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy95dC1pZnJhbWUtYXBpLWluaXQveXQtaWZyYW1lLWFwaS1pbml0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgY29uZmlnLnNldCh7XG4gICAgLy8gQmFzZSBwYXRoIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlc29sdmUgYWxsIHBhdHRlcm5zIChlZy4gZmlsZXMsIGV4Y2x1ZGUpXG4gICAgLy8gcmVsYXRpdmUgdG8gdGhlIGxvY2F0aW9uIG9mIGthcm1hLmNvbmYuanMuXG4gICAgYmFzZVBhdGg6ICcuJyxcblxuICAgIC8vIEF2YWlsYWJsZSBmcmFtZXdvcmtzOiBodHRwczovL25wbWpzLm9yZy9icm93c2Uva2V5d29yZC9rYXJtYS1hZGFwdGVyLlxuICAgIGZyYW1ld29ya3M6IFsnamFzbWluZScsICdjbG9zdXJlJ10sXG5cbiAgICAvLyBMaXN0IG9mIGZpbGVzIC8gcGF0dGVybnMgdG8gbG9hZCBpbiB0aGUgYnJvd3Nlci5cbiAgICBmaWxlczogW1xuICAgICAgLy8gQ2xvc3VyZSBzdHVmZnMuXG4gICAgICAnLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1jbG9zdXJlLWxpYnJhcnkvY2xvc3VyZS9nb29nL2Jhc2UuanMnLFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAnLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1jbG9zdXJlLWxpYnJhcnkvY2xvc3VyZS9nb29nL2RlcHMuanMnLFxuICAgICAgICBpbmNsdWRlZDogZmFsc2UsXG4gICAgICAgIHNlcnZlZDogZmFsc2UsXG4gICAgICB9LFxuICAgICAgLy8gTGlicmFyeSBkZXBlbmRlbmNpZXMgZS5nLiBBbmd1bGFyLCBMb2Rhc2ggKG5vbmUgY3VycmVudGx5KVxuICAgICAgLy8gLi4uXG4gICAgICAvLyBUaGUgdGVzdHMgdGhlbXNlbHZlcy5cbiAgICAgICcqKi8qX3Rlc3QuanMnLFxuICAgICAgLy8gSmF2YVNjcmlwdCBzb3VyY2VzLlxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAnKiovKi5qcycsXG4gICAgICAgIGluY2x1ZGVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgXSxcblxuICAgIC8vIEZpbGVzIHRvIGV4Y2x1ZGUuXG4gICAgZXhjbHVkZTogW1xuICAgICAgJ3N0YXRpYy9qcy8qLm1pbi5qcycsXG4gICAgXSxcblxuICAgIHByZXByb2Nlc3NvcnM6IHtcbiAgICAgIC8vIEV4dGVybmFsIGRlcHMuXG4gICAgICAnLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1jbG9zdXJlLWxpYnJhcnkvY2xvc3VyZS9nb29nL2RlcHMuanMnOlxuICAgICAgICAgIFsnY2xvc3VyZS1kZXBzJ10sXG4gICAgICAvLyBTb3VyY2UgZmlsZXMgYXJlIHByZXByb2Nlc3NlZCBmb3IgZGVwZW5kZW5jaWVzLlxuICAgICAgJyoqLyouanMnOiBbJ2Nsb3N1cmUnXSxcbiAgICB9LFxuXG4gICAgLy8gVGVzdCByZXN1bHRzIHJlcG9ydGVyIHRvIHVzZS5cbiAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6ICdkb3RzJywgJ3Byb2dyZXNzJ1xuICAgIC8vIEF2YWlsYWJsZSByZXBvcnRlcnM6IGh0dHBzOi8vbnBtanMub3JnL2Jyb3dzZS9rZXl3b3JkL2thcm1hLXJlcG9ydGVyXG4gICAgcmVwb3J0ZXJzOiBbJ3NwZWMnXSxcblxuICAgIC8vIExldmVsIG9mIGxvZ2dpbmcuXG4gICAgLy8gUG9zc2libGUgdmFsdWVzOiBjb25maWcuTE9HX0RJU0FCTEUgfHwgY29uZmlnLkxPR19FUlJPUiB8fCBjb25maWcuTE9HX1dBUk4gfHwgY29uZmlnLkxPR19JTkZPIHx8IGNvbmZpZy5MT0dfREVCVUcuXG4gICAgbG9nTGV2ZWw6IGNvbmZpZy5MT0dfRVJST1IsXG4gICAgLy8gV2ViIHNlcnZlciBwb3J0LlxuICAgIHBvcnQ6IDk4NzYsXG4gICAgLy8gRW5hYmxlIC8gZGlzYWJsZSBjb2xvcnMgaW4gdGhlIG91dHB1dCAocmVwb3J0ZXJzIGFuZCBsb2dzKS5cbiAgICBjb2xvcnM6IHRydWUsXG5cbiAgICAvLyBDb250aW51b3VzIEludGVncmF0aW9uIG1vZGUuIEVuYWJsZSAvIGRpc2FibGUgd2F0Y2hpbmcgZmlsZSBhbmRcbiAgICAvLyBleGVjdXRpbmcgdGVzdHMgd2hlbmV2ZXIgYW55IGZpbGUgY2hhbmdlcy5cbiAgICBzaW5nbGVSdW46IGZhbHNlLFxuICAgIGF1dG9XYXRjaDogdHJ1ZSxcblxuICAgIC8vIFN0YXJ0IHRoZXNlIGJyb3dzZXJzLlxuICAgIC8vIEF2YWlsYWJsZSBicm93c2VyIGxhdW5jaGVyczogaHR0cHM6Ly9ucG1qcy5vcmcvYnJvd3NlL2tleXdvcmQva2FybWEtbGF1bmNoZXJcbiAgICBicm93c2VyczogWydDaHJvbWUnXSxcblxuICAgIC8vIERlZmluZSBjdXN0b20gZmxhZ3MuXG4gICAgY3VzdG9tTGF1bmNoZXJzOiB7XG4gICAgICBDaHJvbWVfd2l0aG91dF9zZWN1cml0eToge1xuICAgICAgICBiYXNlOiAnQ2hyb21lJyxcbiAgICAgICAgZmxhZ3M6IFsnLS1kaXNhYmxlLXdlYi1zZWN1cml0eSddLFxuICAgICAgfSxcbiAgICB9LFxuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2thcm1hLmNvbmYuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQXV0aCBmcm9tICcuLi8uLi9wcm92aWRlcnMvYXV0aCc7XG5pbXBvcnQgWVREYXRhIGZyb20gJy4uLy4uL3Byb3ZpZGVycy95dC1kYXRhJztcbmltcG9ydCB7S2V5Q29kZXN9IGZyb20gJ0Bnb29nbGUveW91dHViZS9zcmMvY29tcG9uZW50cy9nbG9iYWwvY29uc3RhbnRzJztcbmltcG9ydCB7ZGVsZWdhdGV9IGZyb20gJ0Bnb29nbGUveW91dHViZS9zcmMvcHJvdmlkZXJzL3V0aWxzL3V0aWxzJztcbmltcG9ydCB1dGlscyBmcm9tICcuLi8uLi9nbG9iYWxzL3V0aWxzJztcblxuXG4vKiogQHByaXZhdGUgQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IFNlbGVjdG9yc18gPSB7XG4gIEFDQ09VTlRfRElBTE9HOiAnLnl0Yy1qcy1hY2NvdW50LWRpYWxvZycsXG4gIENIQU5ORUxfSU1HOiAnLnl0Yy1qcy1hdXRoLWNoYW5uZWwtaW1nJyxcbiAgQ0hBTk5FTF9OQU1FOiAnLnl0Yy1qcy1hdXRoLWNoYW5uZWwtbmFtZScsXG4gIEVNQUlMOiAnLnl0Yy1qcy1hY2NvdW50LWVtYWlsJyxcbiAgSU5GT19CQVI6ICcueXRjLWpzLWF1dGgtaW5mby1iYXIgJyxcbiAgTE9BREVSOiAnLnl0Yy1qcy1sb2FkZXInLFxuICBOQU1FOiAnLnl0Yy1qcy1hY2NvdW50LW5hbWUnLFxuICBQUk9GSUxFX0lNRzogJy55dGMtanMtYWNjb3VudC1wcm9maWxlLWltZycsXG4gIFNJR05JTl9CVE46ICcueXRjLWpzLWF1dGgtc2lnbmluLWJ0bicsXG4gIFNJR05PVVRfQlROOiAnLnl0Yy1qcy1hdXRoLXNpZ25vdXQtYnRuJyxcbiAgU1VCX0NPVU5UOiAnLnl0Yy1qcy1hdXRoLXN1Yi1jb3VudCcsXG59O1xuXG4vKiogQHByaXZhdGUgQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IENsYXNzZXNfID0ge1xuICBISURFOiAneXQtaGlkZScsXG4gIFBST0ZJTEVfSU1HOiAnYWNjb3VudF9fcHJvZmlsZS1pbWcnLFxuICBSRUFEWTogJ2FjY291bnQtcmVhZHknLFxuICBTSUdOSU5fQlROOiAneXRjLWpzLWF1dGgtc2lnbmluLWJ0bicsXG59O1xuXG5cbi8qKlxuICogUG9wdWxhdGVzIGFuZCBtYW5pcHVsYXRlcyB0aGUgRE9NIHdpdGggdXNlciBZb3VUdWJlIGFuZCBGaXJlYmFzZVxuICogYXV0aGVudGljYXRpb24gZGF0YS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWNjb3VudCBleHRlbmRzIFlURGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBBbnkgZWxlbWVudCB0aGF0IHNob3VsZCBzaG91bGQgYmVjb21lIGEgcHJvZmlsZSBpbWFnZSBvbmNlIHRoZSB1c2VyXG4gICAgICogc2lnbnMgaW4uXG4gICAgICogQHByaXZhdGUgQGNvbnN0IHshQXJyYXk8IUVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMucHJvZmlsZUltZ3NfID1cbiAgICAgICAgWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3JzXy5QUk9GSUxFX0lNRyldO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5sb2FkZXJfID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3RvcnNfLkxPQURFUik7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmFjY291bnREaWFsb2dfID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3RvcnNfLkFDQ09VTlRfRElBTE9HKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMubmFtZV8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uTkFNRSk7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmVtYWlsXyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3JzXy5FTUFJTCk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFBcnJheTwhRWxlbWVudD59ICovXG4gICAgdGhpcy5jaGFubmVsSW1nc18gPVxuICAgICAgICBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvcnNfLkNIQU5ORUxfSU1HKV07XG5cbiAgICAvKiogQHByaXZhdGUgeyFBcnJheTwhRWxlbWVudD59ICovXG4gICAgdGhpcy5jaGFubmVsTmFtZXNfID1cbiAgICAgICAgWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3JzXy5DSEFOTkVMX05BTUUpXTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFycmF5PCFFbGVtZW50Pn0gKi9cbiAgICB0aGlzLnN1YkNvdW50c18gPVxuICAgICAgICBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvcnNfLlNVQl9DT1VOVCldO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/RWxlbWVudH0gKi9cbiAgICB0aGlzLmluZm9CYXJfID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3RvcnNfLklORk9fQkFSKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzU2lnbmVkSW5fID0gZmFsc2U7XG5cbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnRzXygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlZ2lzdGVyRXZlbnRzXygpIHtcbiAgICBkZWxlZ2F0ZShkb2N1bWVudCwgU2VsZWN0b3JzXy5TSUdOSU5fQlROLCAnY2xpY2snLFxuICAgICAgICBBdXRoLnNpZ25Jbi5iaW5kKEF1dGgpKTtcbiAgICBkZWxlZ2F0ZShkb2N1bWVudCwgU2VsZWN0b3JzXy5TSUdOT1VUX0JUTiwgJ2NsaWNrJyxcbiAgICAgICAgQXV0aC5zaWduT3V0LmJpbmQoQXV0aCkpO1xuICAgIGRlbGVnYXRlKGRvY3VtZW50LCBTZWxlY3RvcnNfLlBST0ZJTEVfSU1HLCAnY2xpY2snLFxuICAgICAgICB0aGlzLnRvZ2dsZUFjY291bnREaWFsb2dfLmJpbmQodGhpcykpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oaWRlQWNjb3VudERpYWxvZ18uYmluZCh0aGlzKSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5oYW5kbGVFc2NLZXlfLmJpbmQodGhpcykpO1xuXG4gICAgLy8gU2hvd3MgdGhlIGxvYWRlci5cbiAgICB0aGlzLmxvYWRlcl8uY2xhc3NMaXN0LnJlbW92ZShDbGFzc2VzXy5ISURFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgYWNjb3VudCBkaWFsb2cgaXMgdmlzaWJsZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY291bnREaWFsb2dJc1Zpc2libGVfKCkge1xuICAgIHJldHVybiAhdGhpcy5hY2NvdW50RGlhbG9nXy5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3Nlc18uSElERSk7XG4gIH1cblxuICAvKipcbiAgICogRmlsbHMgaW4gRE9NIHdpdGggYXV0aCBhbmQgWW91VHViZSBkYXRhLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IHVzZXIgVGhlIHVzZXIgZGF0YSB0cmVlIGdpdmVuIGJ5IEZpcmViYXNlIHdoZW4gc2lnbmVkIGluLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGRhdGEgVGhlIHVzZXIncyBZb3VUdWJlIGRhdGEgdHJlZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uWVREYXRhUmVhZHkodXNlciwgZGF0YSkge1xuICAgIHRoaXMuaXNTaWduZWRJbl8gPSB0cnVlO1xuICAgIHRoaXMuZmlsbEluQXV0aERldGFpbHNfKHVzZXIpO1xuICAgIHRoaXMuZmlsbEluWVREYXRhRGV0YWlsc18oZGF0YS5pdGVtc1swXSk7XG4gICAgdGhpcy5vbkFjY291bnRSZWFkeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBpbmZvIGJhciBhbmQgYWNjb3VudCBkaWFsb2cgYW5kIHJlbW92ZXMgYWNjZXNzIHRva2VuIGZyb20gc2Vzc2lvblxuICAgKiBzdG9yYWdlLlxuICAgKi9cbiAgb25TaWduT3V0KCkge1xuICAgIHRoaXMuaXNTaWduZWRJbl8gPSBmYWxzZTtcbiAgICB0aGlzLmhpZGVBY2NvdW50RGlhbG9nXygpO1xuICAgIHRoaXMuZmlsbEluQXV0aERldGFpbHNfKCk7XG4gICAgd2luZG93LnNlc3Npb25TdG9yYWdlLmNsZWFyKCk7XG5cbiAgICBpZiAodGhpcy5pbmZvQmFyXykge1xuICAgICAgdGhpcy5pbmZvQmFyXy5jbGFzc0xpc3QuYWRkKENsYXNzZXNfLkhJREUpO1xuICAgIH1cblxuICAgIHRoaXMub25BY2NvdW50U2lnbk91dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtcHR5IG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBhY2NvdW50IGRpYWxvZyBpcyByZWFkeS5cbiAgICovXG4gIG9uQWNjb3VudFJlYWR5KCkge31cblxuICAvKipcbiAgICogRW1wdHkgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc2lnbnMgb3V0LlxuICAgKi9cbiAgb25BY2NvdW50U2lnbk91dCgpIHt9XG5cbiAgLyoqXG4gICAqIEZpbGxzIGluIHVzZXIncyBuYW1lIGFuZCBlbWFpbCBpbiB0aGUgYWNjb3VudCBkaWFsb2cgZWxlbWVudHMuIEFsc28gdG9nZ2xlc1xuICAgKiBjbGFzc2VzIGFuZCBgYmFja2dyb3VuZEltYWdlYCBvbiBhbGwgYFNpZ24gaW5gIENUQXMgdG8gc3dpdGNoIHRoZW0gdG9cbiAgICogcHJvZmlsZSBpbWFnZXMgYW5kIHZpY2UgdmVyc2EuXG4gICAqIEBwYXJhbSB7P09iamVjdH0gdXNlciBUaGUgdXNlciBkYXRhIHRyZWUgZ2l2ZW4gYnkgRmlyZWJhc2Ugd2hlbiBzaWduZWQgaW4uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmaWxsSW5BdXRoRGV0YWlsc18odXNlcj1udWxsKSB7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHRoaXMubmFtZV8udGV4dENvbnRlbnQgPSB1c2VyLmRpc3BsYXlOYW1lO1xuICAgICAgdGhpcy5lbWFpbF8udGV4dENvbnRlbnQgPSB1c2VyLmVtYWlsO1xuICAgIH1cblxuICAgIHRoaXMucHJvZmlsZUltZ3NfLmZvckVhY2goKGltZykgPT4ge1xuICAgICAgLy8gVG9nZ2xlcyBiZXR3ZWVuIGJlaW5nIGEgYFNpZ24gaW5gIENUQSBhbmQgYSBwcm9maWxlIGltYWdlLlxuICAgICAgaW1nLmNsYXNzTGlzdC50b2dnbGUoJ21kYy1idXR0b24nLCAhdXNlcik7XG4gICAgICBpbWcuY2xhc3NMaXN0LnRvZ2dsZShDbGFzc2VzXy5TSUdOSU5fQlROLCAhdXNlcik7XG4gICAgICBpbWcuY2xhc3NMaXN0LnRvZ2dsZShDbGFzc2VzXy5QUk9GSUxFX0lNRywgdXNlcik7XG5cbiAgICAgIC8vIFNob3dzIHRoZSBidXR0b24uXG4gICAgICBpbWcuY2xhc3NMaXN0LnJlbW92ZShDbGFzc2VzXy5ISURFKTtcblxuICAgICAgLy8gSGlkZXMgdGhlIGxvYWRlci5cbiAgICAgIHRoaXMubG9hZGVyXy5jbGFzc0xpc3QuYWRkKENsYXNzZXNfLkhJREUpO1xuXG4gICAgICBpZiAodXNlcikge1xuICAgICAgICAvLyBBZGRzIHByb2ZpbGUgaW1hZ2UuXG4gICAgICAgIGltZy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7dXNlci5waG90b1VSTH0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbW92ZXMgcHJvZmlsZSBpbWFnZS5cbiAgICAgICAgaW1nLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaWxscyBpbiBET00gZWxlbWVudHMgd2l0aCB1c2VyJ3MgWVQgY2hhbm5lbCBkYXRhLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGRhdGEgVXNlcidzIFlUIERhdGEgb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZmlsbEluWVREYXRhRGV0YWlsc18oZGF0YSkge1xuICAgIGNvbnN0IHN1YkNvdW50ID1cbiAgICAgICAgdXRpbHMubG9jYWxpemVOdW1iZXIocGFyc2VJbnQoZGF0YS5zdGF0aXN0aWNzLnN1YnNjcmliZXJDb3VudCwgMTApKTtcblxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChDbGFzc2VzXy5SRUFEWSk7XG5cbiAgICBpZiAodGhpcy5pbmZvQmFyXykge1xuICAgICAgdGhpcy5pbmZvQmFyXy5jbGFzc0xpc3QucmVtb3ZlKENsYXNzZXNfLkhJREUpO1xuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbEltZ3NfLmZvckVhY2goKGltZykgPT4ge1xuICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtkYXRhLnNuaXBwZXQudGh1bWJuYWlscy5kZWZhdWx0LnVybH0pYDtcbiAgICB9KTtcblxuICAgIHRoaXMuY2hhbm5lbE5hbWVzXy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBuYW1lLnRleHRDb250ZW50ID0gZGF0YS5zbmlwcGV0LnRpdGxlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdWJDb3VudHNfLmZvckVhY2goKGNvdW50KSA9PiB7XG4gICAgICBjb3VudC5xdWVyeVNlbGVjdG9yKCdzcGFuJykudGV4dENvbnRlbnQgPSBzdWJDb3VudDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBgaGlkZWAgY2xhc3Mgb24gdGhlIGFjY291bnQgZGlhbG9nIHdoZW4gdGhlIHVzZXIgaXMgc2lnbmVkIGluLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdG9nZ2xlQWNjb3VudERpYWxvZ18oKSB7XG4gICAgaWYgKCF0aGlzLmlzU2lnbmVkSW5fKSByZXR1cm47XG5cbiAgICB0aGlzLmFjY291bnREaWFsb2dfLmNsYXNzTGlzdC50b2dnbGUoXG4gICAgICAgIENsYXNzZXNfLkhJREUsIHRoaXMuYWNjb3VudERpYWxvZ0lzVmlzaWJsZV8oKSk7XG4gIH1cblxuICAvKipcbiAgICogSGlkZXMgdGhlIGFjY291bnQgZGlhbG9nIGJ5IGFkZGluZyB0aGUgYGhpZGVgIGNsYXNzIHRvIGl0LlxuICAgKiBAcGFyYW0gez9FdmVudH0gZSBFdmVudCBvYmplY3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoaWRlQWNjb3VudERpYWxvZ18oZT11bmRlZmluZWQpIHtcbiAgICBpZiAoIWUpIHtcbiAgICAgIC8vIE5vIGV2ZW50LCBqdXN0IGhpZGUgdGhlIGFjY291bnQgZGlhbG9nLlxuICAgICAgdGhpcy5hY2NvdW50RGlhbG9nXy5jbGFzc0xpc3QuYWRkKENsYXNzZXNfLkhJREUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hY2NvdW50RGlhbG9nXy5jb250YWlucyhlLnRhcmdldCkgJiZcbiAgICAgICAgIWUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc2VzXy5QUk9GSUxFX0lNRykpIHtcbiAgICAgIC8vIFVzZXIgY2xpY2tlZCBvdXRzaWRlIHRoZSBhY2NvdW50IGRpYWxvZyBhbmQgbm90IG9uIGEgdGhlIHByb2ZpbGUgaW1hZ2UuXG4gICAgICB0aGlzLmFjY291bnREaWFsb2dfLmNsYXNzTGlzdC5hZGQoQ2xhc3Nlc18uSElERSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBhY2NvdW50IGRpYWxvZyBvbiBFc2NhcGUga2V5dXAgaWYgaXQncyB2aXNpYmxlLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZSBFdmVudCBvYmplY3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVFc2NLZXlfKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSBLZXlDb2Rlcy5FU0MgJiYgdGhpcy5hY2NvdW50RGlhbG9nSXNWaXNpYmxlXygpKSB7XG4gICAgICB0aGlzLmhpZGVBY2NvdW50RGlhbG9nXygpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2FjY291bnQvYWNjb3VudC5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB1dGlscyBmcm9tICcuLi8uLi9nbG9iYWxzL3V0aWxzJztcblxuXG4vKiogQHByaXZhdGUgQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IEF0dHJzXyA9IHtcbiAgQU5TV0VSOiAnZGF0YS1uZXh0dXAtZWxpZ2liaWx0eS1hbnN3ZXInLFxuICBOT1RfRUxJR0lCTEVfTVNHOiAnZGF0YS1uZXh0dXAtbm90LWVsaWdpYmxlLW1lc3NhZ2UnLFxuICBSRVNVTFQ6ICdkYXRhLW5leHR1cC1yZXN1bHQtbWVzc2FnZScsXG4gIFNVQl9DT1VOVF9BTlNXRVI6ICdkYXRhLW5leHR1cC1lbGlnaWJpbHR5LXN1Yi1jb3VudC1hbnN3ZXInLFxufTtcblxuLyoqIEBwcml2YXRlIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBTZWxlY3RvcnNfID0ge1xuICBBTlNXRVI6IGBbJHtBdHRyc18uQU5TV0VSfV1gLFxuICBRVUVTVElPTjogJy55dC1qcy1uZXh0dXAtZWxpZ2liaWx0eS1xdWVzdGlvbicsXG4gIFFVRVNUSU9OU19XUkFQUEVSOiAnLnl0LWpzLW5leHR1cC1lbGlnaWJpbHR5LXF1ZXN0aW9ucycsXG4gIE1JU1NJTkdfUkVRVUlSRU1FTlRTOiAnLnl0LWpzLW5leHR1cC1taXNzaW5nLXJlcXVpcmVtZW50cycsXG4gIE5PVF9FTElHSUJMRV9NU0c6IGBbJHtBdHRyc18uTk9UX0VMSUdJQkxFX01TR31dYCxcbiAgTk9UX0VMSUdJQkxFX01TR1NfV1JBUFBFUjogJy55dC1qcy1uZXh0dXAtbm90LWVsaWdpYmxlLW1lc3NhZ2VzJyxcbiAgUkVTRVQ6ICcueXQtanMtbmV4dHVwLWVsaWdpYmlsdHktcmVzZXQnLFxuICBSRVNVTFQ6IGBbJHtBdHRyc18uUkVTVUxUfV1gLFxuICBSRVNVTFRTX1dSQVBQRVI6ICcueXQtanMtbmV4dHVwLXJlc3VsdHMnLFxuICBTVUJfQ09VTlRfQU5TV0VSOiBgWyR7QXR0cnNfLlNVQl9DT1VOVF9BTlNXRVJ9XWAsXG59O1xuXG4vKiogQHByaXZhdGUgQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IENsYXNzZXNfID0ge1xuICBISURFOiAneXQtaGlkZScsXG59O1xuXG4vKiogQHByaXZhdGUgQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IE1lc3NhZ2VzXyA9IHtcbiAgRUxJR0lCTEU6ICdlbGlnaWJsZScsXG4gIE5PVF9FTElHSUJMRTogJ25vdC1lbGlnaWJsZScsXG4gIE5PVF9FTk9VR0hfU1VCUzogJ25vdC1lbm91Z2gtc3VicycsXG4gIFRPT19NQU5ZX1NVQlM6ICd0b28tbWFueS1zdWJzJyxcbn07XG5cblxuLyoqXG4gKiBBc3Nlc3NlcyB3aGV0aGVyIGEgdXNlciBpcyBlbGlnaWJsZSB0byBwYXJ0aWNpcGF0ZSBpbiBOZXh0VXAgYnkgcmVjb3JkaW5nXG4gKiB0aGVpciBhbnN3ZXJzIHRvIGEgcXVpei4gVGhleSBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZlxuICogc3Vic2NyaWJlcnMsIG5vdCB0b28gZmV3IG9yIHRvbyBtYW55LCBhbmQgYW5zd2VyIGBZZXNgIHRvIGFsbCBxdWVzdGlvbnMuIElmXG4gKiB0aGV5IGFyZSBub3QgZWxpZ2libGUsIHRoZW4gYSBtZXNzYWdlIHdpdGggbWlzc2luZyByZXF1aXJlbWVudHMgaXMgZGlzcGxheWVkLlxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5leHRVcEVsaWdpYmlsaXR5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5xdWVzdGlvbnNXcmFwcGVyXyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIFNlbGVjdG9yc18uUVVFU1RJT05TX1dSQVBQRVIpO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUFycmF5PCFFbGVtZW50Pn0gKi9cbiAgICB0aGlzLnF1ZXN0aW9uc18gPSBbLi4udGhpcy5xdWVzdGlvbnNXcmFwcGVyXy5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBTZWxlY3RvcnNfLlFVRVNUSU9OKV07XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLm5vdEVsaWdpYmxlTXNnc1dyYXBwZXJfID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgU2VsZWN0b3JzXy5OT1RfRUxJR0lCTEVfTVNHU19XUkFQUEVSKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFBcnJheTwhRWxlbWVudD59ICovXG4gICAgdGhpcy5ub3RFbGlnaWJsZU1zZ3NfID0gWy4uLnRoaXMubm90RWxpZ2libGVNc2dzV3JhcHBlcl8ucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgU2VsZWN0b3JzXy5OT1RfRUxJR0lCTEVfTVNHKV07XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLnJlc3VsdHNXcmFwcGVyXyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIFNlbGVjdG9yc18uUkVTVUxUU19XUkFQUEVSKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFBcnJheTwhRWxlbWVudD59ICovXG4gICAgdGhpcy5yZXN1bHRzXyA9IFsuLi50aGlzLnJlc3VsdHNXcmFwcGVyXy5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBTZWxlY3RvcnNfLlJFU1VMVCldO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5taXNzaW5nUmVxdWlyZW1lbnRzV3JhcHBlcl8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBTZWxlY3RvcnNfLk1JU1NJTkdfUkVRVUlSRU1FTlRTKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFBcnJheTwhRWxlbWVudD59ICovXG4gICAgdGhpcy5taXNzaW5nUmVxdWlyZW1lbnRzXyA9IFsuLi50aGlzLm1pc3NpbmdSZXF1aXJlbWVudHNXcmFwcGVyXy5jaGlsZHJlbl07XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmN1cnJlbnRRdWVzdGlvbkluZGV4XyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHtudW1iZXJ9ICovXG4gICAgdGhpcy5lbGlnaWJsZVNjb3JlXyA9IHRoaXMucXVlc3Rpb25zXy5sZW5ndGg7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgICB0aGlzLnVzZXJBbnN3ZXJzXyA9IFtdO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zY29yZV8gPSAwO1xuXG4gICAgdGhpcy5yZW1vdmVNaXNzaW5nUmVxdWlyZW1lbnRzXygpO1xuICAgIHRoaXMucmVnaXN0ZXJFdmVudHNfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIGBtaXNzaW5nIHJlcXVpcmVtZW50c2Agd3JhcHBlciBzbyB0aGF0XG4gICAqIGl0IGNhbiBiZSBmaWxsZWQgaW4gbGF0ZXIgd2l0aCBvbmx5IHRoZSBvbmVzIHRoYXQgYXJlIGFwcHJvcHJpYXRlIGZvciB0aGVcbiAgICogY2hvc2VuIGFuc3dlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW1vdmVNaXNzaW5nUmVxdWlyZW1lbnRzXygpIHtcbiAgICB3aGlsZSAodGhpcy5taXNzaW5nUmVxdWlyZW1lbnRzV3JhcHBlcl8uZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5taXNzaW5nUmVxdWlyZW1lbnRzV3JhcHBlcl8ucmVtb3ZlQ2hpbGQoXG4gICAgICAgICAgdGhpcy5taXNzaW5nUmVxdWlyZW1lbnRzV3JhcHBlcl8uZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlZ2lzdGVyRXZlbnRzXygpIHtcbiAgICB1dGlscy55dGMuZGVsZWdhdGUoZG9jdW1lbnQsIFNlbGVjdG9yc18uU1VCX0NPVU5UX0FOU1dFUiwgJ2NsaWNrJyxcbiAgICAgICAgdGhpcy5jaGVja1N1YkNvdW50QW5zd2VyXy5iaW5kKHRoaXMpKTtcblxuICAgIHV0aWxzLnl0Yy5kZWxlZ2F0ZShkb2N1bWVudCwgU2VsZWN0b3JzXy5BTlNXRVIsICdjbGljaycsXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NfLmJpbmQodGhpcykpO1xuXG4gICAgdXRpbHMueXRjLmRlbGVnYXRlKGRvY3VtZW50LCBTZWxlY3RvcnNfLlJFU0VULCAnY2xpY2snLFxuICAgICAgICB0aGlzLnJlc2V0Xy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93cyBhIHNwZWNpZmljIGBub3QgZWxpZ2libGVgIG1lc3NhZ2Ugb3IgY29udGludWVzIG9uIHRoZSBuZXh0IHF1ZXN0aW9uXG4gICAqIHdoaWxlIGFkZGluZyAxIHRvIHRoZSB1c2VyJ3MgYHNjb3JlYC4gV2hhdCBoYXBwZW5zIGRlcGVuZHMgb24gdGhlXG4gICAqIGBzdWJzY3JpYmVyIGNvdW50YCBkYXRhIGF0dHIgdmFsdWUgb2YgdGhlIGdpdmVuIHRhcmdldC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjaGVja1N1YkNvdW50QW5zd2VyXyh0YXJnZXQpIHtcbiAgICBjb25zdCBhbnN3ZXIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKEF0dHJzXy5TVUJfQ09VTlRfQU5TV0VSKTtcblxuICAgIHN3aXRjaCAoYW5zd2VyKSB7XG4gICAgICBjYXNlICcxJzpcbiAgICAgICAgLy8gTm90IGVub3VnaCBzdWJzY3JpYmVycy5cbiAgICAgICAgdGhpcy5zaG93Tm90RWxpZ2libGVNc2dfKE1lc3NhZ2VzXy5OT1RfRU5PVUdIX1NVQlMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzMnOlxuICAgICAgICAvLyBUb28gbWFueSBzdWJzY3JpYmVycy5cbiAgICAgICAgdGhpcy5zaG93Tm90RWxpZ2libGVNc2dfKE1lc3NhZ2VzXy5UT09fTUFOWV9TVUJTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBUaGUgcmlnaHQgYW1vdW50IG9mIHN1YnNjcmliZXJzLlxuICAgICAgICB0aGlzLm5leHRRdWVzdGlvbl8oKTtcbiAgICAgICAgdGhpcy5zY29yZV8rKztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGlkZXMgdGhlIHF1ZXN0aW9ucyBhbmQgc2hvd3MgdGhlIGBub3QgZWxpZ2libGVgIG1lc3NhZ2Ugd2l0aCB0aGUgZ2l2ZW5cbiAgICogdmFsdWUgaW4gaXRzIGRhdGEgYXR0ci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZ05hbWUgVmFsdWUgb2YgdGhlIGBub3QgZWxpZ2libGVgIG1lc3NhZ2UgZGF0YSBhdHRyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2hvd05vdEVsaWdpYmxlTXNnXyhtc2dOYW1lKSB7XG4gICAgY29uc3QgbXNnID1cbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgWyR7QXR0cnNfLk5PVF9FTElHSUJMRV9NU0d9PSR7bXNnTmFtZX1dYCk7XG5cbiAgICBtc2cuY2xhc3NMaXN0LnJlbW92ZShDbGFzc2VzXy5ISURFKTtcbiAgICB0aGlzLnF1ZXN0aW9uc1dyYXBwZXJfLmNsYXNzTGlzdC5hZGQoQ2xhc3Nlc18uSElERSk7XG4gICAgdGhpcy5ub3RFbGlnaWJsZU1zZ3NXcmFwcGVyXy5jbGFzc0xpc3QucmVtb3ZlKENsYXNzZXNfLkhJREUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgdXNlcidzIGFuc3dlciwgYWRkcyAxIHRvIHRoZWlyIGBzY29yZWAgaWYgdGhleSBjaG9zZSBhbiBlbGlnaWJsZVxuICAgKiBhbnN3ZXIgdGhlbiBzaG93cyB0aGUgbmV4dCBxdWVzdGlvbi5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm9ncmVzc18odGFyZ2V0KSB7XG4gICAgY29uc3QgYW5zd2VyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShBdHRyc18uQU5TV0VSKTtcbiAgICBjb25zdCBpc0VsaWdpYmxlID0gYW5zd2VyID09PSAnMSc7XG5cbiAgICB0aGlzLnVzZXJBbnN3ZXJzXy5wdXNoKGFuc3dlcik7XG5cbiAgICBpZiAoaXNFbGlnaWJsZSkgdGhpcy5zY29yZV8rKztcblxuICAgIHRoaXMubmV4dFF1ZXN0aW9uXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBjdXJyZW50IHF1ZXN0aW9uIHRoZW4gZWl0aGVyIHNob3dzIHRoZSByZXN1bHRzLCBpZiB0aGUgdXNlclxuICAgKiBhbnN3ZXJlZCB0aGUgbGFzdCBvbmUsIG9yIHNob3dzIHRoZSBuZXh0IG9uZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5leHRRdWVzdGlvbl8oKSB7XG4gICAgdGhpcy5xdWVzdGlvbnNfW3RoaXMuY3VycmVudFF1ZXN0aW9uSW5kZXhfXS5jbGFzc0xpc3QuYWRkKENsYXNzZXNfLkhJREUpO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudFF1ZXN0aW9uSW5kZXhfICsgMSA9PT0gdGhpcy5lbGlnaWJsZVNjb3JlXykge1xuICAgICAgdGhpcy5zaG93UmVzdWx0c18oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRRdWVzdGlvbkluZGV4XysrO1xuICAgIHRoaXMucXVlc3Rpb25zX1t0aGlzLmN1cnJlbnRRdWVzdGlvbkluZGV4X10uY2xhc3NMaXN0LnJlbW92ZShDbGFzc2VzXy5ISURFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgcXVlc3Rpb25zIGFuZCBzaG93cyB0aGUgcmVzdWx0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNob3dSZXN1bHRzXygpIHtcbiAgICBsZXQgbXNnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgYFske0F0dHJzXy5SRVNVTFR9PSR7TWVzc2FnZXNfLkVMSUdJQkxFfV1gKTtcblxuICAgIHRoaXMucXVlc3Rpb25zV3JhcHBlcl8uY2xhc3NMaXN0LmFkZChDbGFzc2VzXy5ISURFKTtcbiAgICB0aGlzLnJlc3VsdHNXcmFwcGVyXy5jbGFzc0xpc3QucmVtb3ZlKENsYXNzZXNfLkhJREUpO1xuXG4gICAgaWYgKHRoaXMuc2NvcmVfICE9PSB0aGlzLmVsaWdpYmxlU2NvcmVfKSB7XG4gICAgICAvLyBVc2VyIGlzIE5PVCBlbGlnaWJsZS5cbiAgICAgIG1zZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYFske0F0dHJzXy5SRVNVTFR9PSR7TWVzc2FnZXNfLk5PVF9FTElHSUJMRX1dYCk7XG5cbiAgICAgIC8vIFBvcHVsYXRlIHRoZSBgbWlzc2luZyByZXF1aXJlbWVudHNgIHdyYXBwZXIgd2l0aCB0aGUgYXBwcm9wcmlhdGUsXG4gICAgICAvLyBwcmV2aW91c2x5IHN0b3JlZCByZXF1aXJlbWVudHMgYmFzZWQgb24gdGhlIHVzZXIncyBhbnN3ZXJzLlxuICAgICAgdGhpcy51c2VyQW5zd2Vyc18uZm9yRWFjaCgoYW5zd2VyLCBpKSA9PiB7XG4gICAgICAgIGlmIChhbnN3ZXIgPT09ICcwJykge1xuICAgICAgICAgIHRoaXMubWlzc2luZ1JlcXVpcmVtZW50c1dyYXBwZXJfLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGhpcy5taXNzaW5nUmVxdWlyZW1lbnRzX1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1zZy5jbGFzc0xpc3QucmVtb3ZlKENsYXNzZXNfLkhJREUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgcXVpei5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlc2V0XygpIHtcbiAgICAvLyBIaWRlIHJlc3VsdCBtZXNzYWdlcy5cbiAgICB0aGlzLnJlc3VsdHNXcmFwcGVyXy5jbGFzc0xpc3QuYWRkKENsYXNzZXNfLkhJREUpO1xuICAgIHRoaXMucmVzdWx0c18uZm9yRWFjaCgocmVzdWx0KSA9PiByZXN1bHQuY2xhc3NMaXN0LmFkZChDbGFzc2VzXy5ISURFKSk7XG4gICAgdGhpcy5yZW1vdmVNaXNzaW5nUmVxdWlyZW1lbnRzXygpO1xuXG4gICAgLy8gSGlkZSBgTm90IGVsaWdpYmxlYCBtZXNzYWdlcy5cbiAgICB0aGlzLm5vdEVsaWdpYmxlTXNnc1dyYXBwZXJfLmNsYXNzTGlzdC5hZGQoQ2xhc3Nlc18uSElERSk7XG4gICAgdGhpcy5ub3RFbGlnaWJsZU1zZ3NfLmZvckVhY2goKG1zZykgPT4gbXNnLmNsYXNzTGlzdC5hZGQoQ2xhc3Nlc18uSElERSkpO1xuXG4gICAgLy8gU2hvdyBmaXJzdCBxdWVzdGlvbiB3aGlsZSBoaWRpbmcgdGhlIHJlc3QuXG4gICAgdGhpcy5xdWVzdGlvbnNXcmFwcGVyXy5jbGFzc0xpc3QucmVtb3ZlKENsYXNzZXNfLkhJREUpO1xuICAgIHRoaXMucXVlc3Rpb25zXy5mb3JFYWNoKChxKSA9PiBxLmNsYXNzTGlzdC5hZGQoQ2xhc3Nlc18uSElERSkpO1xuICAgIHRoaXMucXVlc3Rpb25zX1swXS5jbGFzc0xpc3QucmVtb3ZlKENsYXNzZXNfLkhJREUpO1xuXG4gICAgLy8gUmVzZXQgdGhlIHVzZXIncyBhbnN3ZXJzLlxuICAgIHRoaXMuY3VycmVudFF1ZXN0aW9uSW5kZXhfID0gMDtcbiAgICB0aGlzLnVzZXJBbnN3ZXJzXyA9IFtdO1xuICAgIHRoaXMuc2NvcmVfID0gMDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWdlcy9uZXh0dXAvZWxpZ2liaWxpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBpbXBvcnQgUGFnZSBmcm9tICdAZ29vZ2xlL3lvdXR1YmUvc3JjL3Byb3ZpZGVycy9wYWdlL3BhZ2UnO1xuLy8gaW1wb3J0IE5leHRVcEVsaWdpYmlsaXR5IGZyb20gJy4vZWxpZ2liaWxpdHknO1xuLy8gaW1wb3J0IE5leHRVcFJlZ2lzdHJhdGlvbiBmcm9tICcuL3JlZ2lzdHJhdGlvbic7XG4vLyBpbXBvcnQgdXRpbHMgZnJvbSAnLi4vLi4vZ2xvYmFscy91dGlscyc7XG4vLyAvKiogQHByaXZhdGUgQGVudW0ge3N0cmluZ30gKi9cbi8vIGNvbnN0IFNlbGVjdG9yc18gPSB7XG4vLyAgIEFDQ09SRElPTjogJy55dGMtanMtYWNjb3JkaW9uJyxcbi8vICAgQ0FNUF9EQVRFOiAnLnl0LWpzLWNhbXAtZGF0ZScsXG4vLyAgIE5FWFRfUk9VTkRfREFURTogJy55dC1uZXh0LXJvdW5kLWRhdGUnLFxuLy8gICBSRUdJU1RSQVRJT05fTU9EQUw6ICcueXQtanMtbmV4dHVwLXJlZ2lzdHJhdGlvbi1tb2RhbCcsXG4vLyB9O1xuLy8gZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV4dFVwIGV4dGVuZHMgUGFnZSB7XG4vLyAgIHJlbmRlcl8oWVRDQWNjb3JkaW9uLCBNb2RhbCwgU2xpZGVzaG93LCBZVENJZnJhbWVBcGkpIHtcbi8vICAgICBuZXcgTW9kYWw7XG4vLyAgICAgbmV3IFNsaWRlc2hvdztcbi8vICAgICBuZXcgWVRDSWZyYW1lQXBpO1xuLy8gICAgIG5ldyBOZXh0VXBFbGlnaWJpbGl0eTtcbi8vICAgICAvLyBOZXh0VXAgUmVnaXN0cmF0aW9uIG1vZGFscy5cbi8vICAgICBjb25zdCByZWdpc3RyYXRpb25Nb2RhbHMgPVxuLy8gICAgICAgICBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvcnNfLlJFR0lTVFJBVElPTl9NT0RBTCldO1xuLy8gICAgIHJlZ2lzdHJhdGlvbk1vZGFscy5mb3JFYWNoKChtb2RhbCkgPT4gbmV3IE5leHRVcFJlZ2lzdHJhdGlvbihtb2RhbCkpO1xuLy8gICAgIC8vIFlUQyBBY2NvcmRpb24uXG4vLyAgICAgY29uc3QgYWNjb3JkaW9uRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uQUNDT1JESU9OKTtcbi8vICAgICBpZiAoYWNjb3JkaW9uRWwpIG5ldyBZVENBY2NvcmRpb24oYWNjb3JkaW9uRWwpO1xuLy8gICAgIC8vIExvY2FsaXplIGNhbXAgZGF0ZXMuXG4vLyAgICAgY29uc3QgZGF0ZXMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvcnNfLkNBTVBfREFURSldO1xuLy8gICAgIGRhdGVzLmZvckVhY2goKGRhdGUpID0+IHtcbi8vICAgICAgIGRhdGUuaW5uZXJUZXh0ID0gdXRpbHMubG9jYWxpemVEYXRlKGRhdGUuaW5uZXJUZXh0LCAnc2hvcnQnLCAnVVRDJyk7XG4vLyAgICAgfSk7XG4vLyAgICAgLy8gTG9jYWxpemUgbmV4dCByb3VuZCBkYXRlLlxuLy8gICAgIGNvbnN0IG5leHRSb3VuZERhdGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uTkVYVF9ST1VORF9EQVRFKTtcbi8vICAgICBpZiAobmV4dFJvdW5kRGF0ZSkge1xuLy8gICAgICAgY29uc3QgZGF0ZSA9IG5leHRSb3VuZERhdGUucXVlcnlTZWxlY3Rvcignc3Ryb25nJyk7XG4vLyAgICAgICBpZiAoZGF0ZSkge1xuLy8gICAgICAgICBkYXRlLmlubmVyVGV4dCA9IHV0aWxzLmxvY2FsaXplRGF0ZShkYXRlLmlubmVyVGV4dCwgJ3Nob3J0JywgJ1VUQycpO1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFnZXMvbmV4dHVwL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtNRENDaGVja2JveH0gZnJvbSAnQG1hdGVyaWFsL2NoZWNrYm94JztcbmltcG9ydCB7TURDRm9ybUZpZWxkfSBmcm9tICdAbWF0ZXJpYWwvZm9ybS1maWVsZCc7XG5cblxuLyoqIEBwcml2YXRlIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBTZWxlY3RvcnNfID0ge1xuICBDSEVDS0JPWDogJy55dC1qcy1uZXh0dXAtcmVnaXN0cmF0aW9uLWNoZWNrYm94JyxcbiAgRVJST1JfV1JBUFBFUjogJy55dC1qcy1uZXh0dXAtcmVnaXN0cmF0aW9uLWVycm9yLW1zZycsXG4gIFBERl9CVE46ICcueXQtanMtbmV4dHVwLXJlZ2lzdHJhdGlvbi1wZGYnLFxuICBSRUdJU1RSQVRJT05fTElOSzogJy55dC1qcy1uZXh0dXAtcmVnaXN0cmF0aW9uLWxpbmsnLFxufTtcblxuLyoqIEBwcml2YXRlIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBDbGFzc2VzXyA9IHtcbiAgSElERTogJ3l0LWhpZGUnLFxufTtcblxuXG4vKipcbiAqIFRvZ2dsZXMgZXJyb3IgbWVzc2FnZXMgYW5kIGVuYWJsZXMgdGhlIHJlZ2lzdHJhdGlvbiBsaW5rIGlmIHRoZSB1c2VyIHBlcmZvcm1zXG4gKiBhbGwgcmVxdWlyZWQgYWN0aW9ucy5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAqIEBmaW5hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZXh0VXBSZWdpc3RyYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCAqL1xuICAgIHRoaXMucm9vdF8gPSByb290O1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5lcnJvcnNXcmFwcGVyXyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihTZWxlY3RvcnNfLkVSUk9SX1dSQVBQRVIpO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5lcnJvcnNMaXN0XyA9IHRoaXMuZXJyb3JzV3JhcHBlcl8ucXVlcnlTZWxlY3RvcigndWwnKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFBcnJheTwhRWxlbWVudD59ICovXG4gICAgdGhpcy5lcnJvcnNfID0gWy4uLnRoaXMuZXJyb3JzTGlzdF8uY2hpbGRyZW5dO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5wZGZFcnJvcl8gPSB0aGlzLmVycm9yc19bMF07XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmNoZWNrYm94RXJyb3JfID0gdGhpcy5lcnJvcnNfWzFdO1xuXG4gICAgLyoqIEBwcml2YXRlIEBjb25zdCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5wZGZCdG5fID0gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yc18uUERGX0JUTik7XG5cbiAgICAvKiogQHByaXZhdGUgQGNvbnN0IHshRWxlbWVudH0gKi9cbiAgICB0aGlzLmNoZWNrYm94XyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihTZWxlY3RvcnNfLkNIRUNLQk9YKTtcblxuICAgIC8qKiBAcHJpdmF0ZSBAY29uc3QgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMucmVnaXN0cmF0aW9uTGlua18gPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIFNlbGVjdG9yc18uUkVHSVNUUkFUSU9OX0xJTkspO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMucGRmVmlld2VkXyA9IGZhbHNlO1xuXG4gICAgLy8gUmVtb3ZlcyB0aGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIGBlcnJvcnMgbGlzdGAgc28gdGhhdCBpdCBjYW4gYmUgZmlsbGVkXG4gICAgLy8gaW4gbGF0ZXIgd2l0aCBvbmx5IHRoZSBvbmVzIHRoYXQgYXJlIGFwcHJvcHJpYXRlIGZvciB0aGUgdXNlcidzIGFjdGlvbnMuXG4gICAgd2hpbGUgKHRoaXMuZXJyb3JzTGlzdF8uZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5lcnJvcnNMaXN0Xy5yZW1vdmVDaGlsZCh0aGlzLmVycm9yc0xpc3RfLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGV2ZW50cy5cbiAgICB0aGlzLnBkZkJ0bl8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZVBERkNsaWNrXy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmNoZWNrYm94Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLFxuICAgICAgICB0aGlzLmhhbmRsZUNoZWNrYm94Q2hhbmdlXy5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuaW5pdE1EQ0NoZWNrYm94XygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgUERGIGVycm9yIGFuZCBhcHBlbmRzIHRoZSBjaGVja2JveCBvbmUgaWYgaXQgaXMgbm90IGNoZWNrZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQREZDbGlja18oKSB7XG4gICAgdGhpcy5lcnJvcnNXcmFwcGVyXy5jbGFzc0xpc3QucmVtb3ZlKENsYXNzZXNfLkhJREUpO1xuXG4gICAgdGhpcy5wZGZWaWV3ZWRfID0gdHJ1ZTtcbiAgICB0aGlzLnBkZkVycm9yXy5yZW1vdmUoKTtcblxuICAgIGlmICh0aGlzLmNoZWNrYm94Xy5jaGVja2VkKSB7XG4gICAgICAvLyBDaGVja2JveCBjaGVja2VkLlxuICAgICAgdGhpcy5lcnJvcnNXcmFwcGVyXy5jbGFzc0xpc3QuYWRkKENsYXNzZXNfLkhJREUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaGVja2JveCBOT1QgY2hlY2tlZC5cbiAgICAgIHRoaXMuZXJyb3JzTGlzdF8uYXBwZW5kQ2hpbGQodGhpcy5jaGVja2JveEVycm9yXyk7XG4gICAgfVxuXG4gICAgdGhpcy50b2dnbGVSZWdpc3RyYWlvbkxpbmtfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBjaGVja2JveCBlcnJvciBhbmQgYXBwZW5kcyB0aGUgUERGIG9uZSBpZiBpdCBoYXMgbm90IGJlZW4gY2xpY2tlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUNoZWNrYm94Q2hhbmdlXygpIHtcbiAgICB0aGlzLmVycm9yc1dyYXBwZXJfLmNsYXNzTGlzdC5yZW1vdmUoQ2xhc3Nlc18uSElERSk7XG5cbiAgICBpZiAodGhpcy5jaGVja2JveF8uY2hlY2tlZCkge1xuICAgICAgLy8gQ2hlY2tib3ggY2hlY2tlZC5cbiAgICAgIHRoaXMuY2hlY2tib3hFcnJvcl8ucmVtb3ZlKCk7XG5cbiAgICAgIGlmICh0aGlzLnBkZlZpZXdlZF8pIHtcbiAgICAgICAgLy8gUERGIGJ0biBjbGlja2VkLlxuICAgICAgICB0aGlzLmVycm9yc1dyYXBwZXJfLmNsYXNzTGlzdC5hZGQoQ2xhc3Nlc18uSElERSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQREYgYnRuIE5PVCBjbGlja2VkLlxuICAgICAgICB0aGlzLmVycm9yc0xpc3RfLmFwcGVuZENoaWxkKHRoaXMucGRmRXJyb3JfKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hlY2tib3ggTk9UIGNoZWNrZWQuXG4gICAgICB0aGlzLmVycm9yc0xpc3RfLmFwcGVuZENoaWxkKHRoaXMuY2hlY2tib3hFcnJvcl8pO1xuICAgIH1cblxuICAgIHRoaXMudG9nZ2xlUmVnaXN0cmFpb25MaW5rXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGRpc2FibGVkYCBhdHRyaWJ1dGUgZnJvbSByZWdpc3RyYXRpb24gbGluayBpZiB0aGUgY2hlY2tib3ggaXNcbiAgICogY2hlY2tlZCBhbmQgdGhlIFBERiBidXR0b24gaGFzIGJlZW4gY2xpY2tlZC4gSXQgaXMgYWRkZWQsIG90aGVyd2lzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRvZ2dsZVJlZ2lzdHJhaW9uTGlua18oKSB7XG4gICAgaWYgKHRoaXMucGRmVmlld2VkXyAmJiB0aGlzLmNoZWNrYm94Xy5jaGVja2VkKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbkxpbmtfLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25MaW5rXy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlcyBvZiBNRENGb3JtRmllbGQgYW5kIE1EQ0NoZWNrYm94IHRvIGFkZCB0aGUgTWF0ZXJpYWxcbiAgICogcmlwcGxlIGVmZmVjdCB0byB0aGUgYE9mZmljaWFsIFJ1bGVzYCBjaGVja2JveC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRNRENDaGVja2JveF8oKSB7XG4gICAgY29uc3QgZm9ybUZpZWxkRWwgPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoJy5tZGMtZm9ybS1maWVsZCcpO1xuICAgIGNvbnN0IGNoZWNrYm94RWwgPSBmb3JtRmllbGRFbC5xdWVyeVNlbGVjdG9yKCcubWRjLWNoZWNrYm94Jyk7XG4gICAgY29uc3QgZm9ybUZpZWxkID0gbmV3IE1EQ0Zvcm1GaWVsZChmb3JtRmllbGRFbCk7XG4gICAgY29uc3QgY2hlY2tib3ggPSBuZXcgTURDQ2hlY2tib3goY2hlY2tib3hFbCk7XG5cbiAgICBmb3JtRmllbGQuaW5wdXQgPSBjaGVja2JveDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWdlcy9uZXh0dXAvcmVnaXN0cmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCB7Z2V0Q29ycmVjdEV2ZW50TmFtZX0gZnJvbSAnQG1hdGVyaWFsL2FuaW1hdGlvbi9pbmRleCc7XG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGUsIE1EQ1NlbGVjdGlvbkNvbnRyb2x9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgTURDQ2hlY2tib3hGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQge01EQ1JpcHBsZSwgTURDUmlwcGxlRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS9pbmRleCc7XG5pbXBvcnQge2dldE1hdGNoZXNQcm9wZXJ0eX0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS91dGlsJztcblxuLyoqXG4gKiBAZXh0ZW5kcyBNRENDb21wb25lbnQ8IU1EQ0NoZWNrYm94Rm91bmRhdGlvbj5cbiAqIEBpbXBsZW1lbnRzIHtNRENTZWxlY3Rpb25Db250cm9sfVxuICovXG5jbGFzcyBNRENDaGVja2JveCBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBNRENDaGVja2JveChyb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBvZiB0aGUgbmF0aXZlIGNvbnRyb2wgZWxlbWVudCwgb3IgbnVsbCBpZiB0aGUgbmF0aXZlIGNvbnRyb2wgZWxlbWVudCBpcyBub3QgcHJlc2VudC5cbiAgICogQHJldHVybiB7P01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBuYXRpdmVDYl8oKSB7XG4gICAgY29uc3Qge05BVElWRV9DT05UUk9MX1NFTEVDVE9SfSA9IE1EQ0NoZWNrYm94Rm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIGNvbnN0IGNiRWwgPSAvKiogQHR5cGUgez9NRENTZWxlY3Rpb25Db250cm9sU3RhdGV9ICovIChcbiAgICAgIHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihOQVRJVkVfQ09OVFJPTF9TRUxFQ1RPUikpO1xuICAgIHJldHVybiBjYkVsO1xuICB9XG5cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshTURDUmlwcGxlfSAqL1xuICAgIHRoaXMucmlwcGxlXyA9IHRoaXMuaW5pdFJpcHBsZV8oKTtcbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLmhhbmRsZUNoYW5nZV87XG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5oYW5kbGVBbmltYXRpb25FbmRfO1xuICB9XG5cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIHRoaXMuaGFuZGxlQ2hhbmdlXyA9ICgpID0+IHRoaXMuZm91bmRhdGlvbl8uaGFuZGxlQ2hhbmdlKCk7XG4gICAgdGhpcy5oYW5kbGVBbmltYXRpb25FbmRfPSAoKSA9PiB0aGlzLmZvdW5kYXRpb25fLmhhbmRsZUFuaW1hdGlvbkVuZCgpO1xuICAgIHRoaXMubmF0aXZlQ2JfLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuaGFuZGxlQ2hhbmdlXyk7XG4gICAgdGhpcy5saXN0ZW4oZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3csICdhbmltYXRpb25lbmQnKSwgdGhpcy5oYW5kbGVBbmltYXRpb25FbmRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDUmlwcGxlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdFJpcHBsZV8oKSB7XG4gICAgY29uc3QgTUFUQ0hFUyA9IGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBPYmplY3QuYXNzaWduKE1EQ1JpcHBsZS5jcmVhdGVBZGFwdGVyKHRoaXMpLCB7XG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gdHJ1ZSxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gdGhpcy5uYXRpdmVDYl9bTUFUQ0hFU10oJzphY3RpdmUnKSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4gdGhpcy5uYXRpdmVDYl8uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB0aGlzLm5hdGl2ZUNiXy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgIH0pO1xuICAgIGNvbnN0IGZvdW5kYXRpb24gPSBuZXcgTURDUmlwcGxlRm91bmRhdGlvbihhZGFwdGVyKTtcbiAgICByZXR1cm4gbmV3IE1EQ1JpcHBsZSh0aGlzLnJvb3RfLCBmb3VuZGF0aW9uKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDQ2hlY2tib3hGb3VuZGF0aW9ufSAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE1EQ0NoZWNrYm94Rm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBzZXROYXRpdmVDb250cm9sQXR0cjogKGF0dHIsIHZhbHVlKSA9PiB0aGlzLm5hdGl2ZUNiXy5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxuICAgICAgcmVtb3ZlTmF0aXZlQ29udHJvbEF0dHI6IChhdHRyKSA9PiB0aGlzLm5hdGl2ZUNiXy5yZW1vdmVBdHRyaWJ1dGUoYXR0ciksXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiB0aGlzLm5hdGl2ZUNiXyxcbiAgICAgIGZvcmNlTGF5b3V0OiAoKSA9PiB0aGlzLnJvb3RfLm9mZnNldFdpZHRoLFxuICAgICAgaXNBdHRhY2hlZFRvRE9NOiAoKSA9PiBCb29sZWFuKHRoaXMucm9vdF8ucGFyZW50Tm9kZSksXG4gICAgfSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ1JpcHBsZX0gKi9cbiAgZ2V0IHJpcHBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yaXBwbGVfO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCBjaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fLmlzQ2hlY2tlZCgpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZCAqL1xuICBzZXQgY2hlY2tlZChjaGVja2VkKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRDaGVja2VkKGNoZWNrZWQpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCBpbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fLmlzSW5kZXRlcm1pbmF0ZSgpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaW5kZXRlcm1pbmF0ZSAqL1xuICBzZXQgaW5kZXRlcm1pbmF0ZShpbmRldGVybWluYXRlKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRJbmRldGVybWluYXRlKGluZGV0ZXJtaW5hdGUpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uXy5pc0Rpc2FibGVkKCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXQgZGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLnNldERpc2FibGVkKGRpc2FibGVkKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbl8uZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlICovXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0VmFsdWUodmFsdWUpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJpcHBsZV8uZGVzdHJveSgpO1xuICAgIHRoaXMubmF0aXZlQ2JfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuaGFuZGxlQ2hhbmdlXyk7XG4gICAgdGhpcy51bmxpc3RlbihnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ2FuaW1hdGlvbmVuZCcpLCB0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZF8pO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ0NoZWNrYm94Rm91bmRhdGlvbiwgTURDQ2hlY2tib3h9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGVja2JveC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIG5vUHJlZml4OiBzdHJpbmcsXG4gKiAgIHdlYmtpdFByZWZpeDogc3RyaW5nLFxuICogICBzdHlsZVByb3BlcnR5OiBzdHJpbmdcbiAqIH19XG4gKi9cbmxldCBWZW5kb3JQcm9wZXJ0eU1hcFR5cGU7XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgZXZlbnRUeXBlTWFwID0ge1xuICAnYW5pbWF0aW9uc3RhcnQnOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25zdGFydCcsXG4gICAgd2Via2l0UHJlZml4OiAnd2Via2l0QW5pbWF0aW9uU3RhcnQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uZW5kJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uZW5kJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uaXRlcmF0aW9uJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25JdGVyYXRpb24nLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAndHJhbnNpdGlvbmVuZCc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb25lbmQnLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICd0cmFuc2l0aW9uJyxcbiAgfSxcbn07XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgY3NzUHJvcGVydHlNYXAgPSB7XG4gICdhbmltYXRpb24nOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtYW5pbWF0aW9uJyxcbiAgfSxcbiAgJ3RyYW5zZm9ybSc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zZm9ybScsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICB9LFxuICAndHJhbnNpdGlvbic6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtdHJhbnNpdGlvbicsXG4gIH0sXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJTaGFwZSh3aW5kb3dPYmopIHtcbiAgcmV0dXJuICh3aW5kb3dPYmpbJ2RvY3VtZW50J10gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGV2ZW50Rm91bmRJbk1hcHMoZXZlbnRUeXBlKSB7XG4gIHJldHVybiAoZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCB8fCBldmVudFR5cGUgaW4gY3NzUHJvcGVydHlNYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSBtYXBcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEphdmFTY3JpcHRFdmVudE5hbWUoZXZlbnRUeXBlLCBtYXAsIGVsKSB7XG4gIHJldHVybiBtYXBbZXZlbnRUeXBlXS5zdHlsZVByb3BlcnR5IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBicm93c2VyIHByZWZpeCBmb3IgQ1NTMyBhbmltYXRpb24gZXZlbnRzXG4gKiBhbmQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcGFyYW0geyFPYmplY3R9IHdpbmRvd09ialxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRBbmltYXRpb25OYW1lKHdpbmRvd09iaiwgZXZlbnRUeXBlKSB7XG4gIGlmICghaGFzUHJvcGVyU2hhcGUod2luZG93T2JqKSB8fCAhZXZlbnRGb3VuZEluTWFwcyhldmVudFR5cGUpKSB7XG4gICAgcmV0dXJuIGV2ZW50VHlwZTtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqLyAoXG4gICAgZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCA/IGV2ZW50VHlwZU1hcCA6IGNzc1Byb3BlcnR5TWFwXG4gICk7XG4gIGNvbnN0IGVsID0gd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10oJ2RpdicpO1xuICBsZXQgZXZlbnROYW1lID0gJyc7XG5cbiAgaWYgKG1hcCA9PT0gZXZlbnRUeXBlTWFwKSB7XG4gICAgZXZlbnROYW1lID0gZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZShldmVudFR5cGUsIG1hcCwgZWwpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50TmFtZSA9IG1hcFtldmVudFR5cGVdLm5vUHJlZml4IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBQdWJsaWMgZnVuY3Rpb25zIHRvIGFjY2VzcyBnZXRBbmltYXRpb25OYW1lKCkgZm9yIEphdmFTY3JpcHQgZXZlbnRzIG9yIENTU1xuLy8gcHJvcGVydHkgbmFtZXMuXG5cbmNvbnN0IHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyA9IFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNU1RyYW5zZm9ybSddO1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RFdmVudE5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG5leHBvcnQge3RyYW5zZm9ybVN0eWxlUHJvcGVydGllcywgZ2V0Q29ycmVjdEV2ZW50TmFtZSwgZ2V0Q29ycmVjdFByb3BlcnR5TmFtZX07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2FuaW1hdGlvbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcbmltcG9ydCBNRENDaGVja2JveEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKiogQGNvbnN0IHshQXJyYXk8c3RyaW5nPn0gKi9cbmNvbnN0IENCX1BST1RPX1BST1BTID0gWydjaGVja2VkJywgJ2luZGV0ZXJtaW5hdGUnXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDQ2hlY2tib3hBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDQ2hlY2tib3hGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDQ2hlY2tib3hBZGFwdGVyfSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENDaGVja2JveEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0TmF0aXZlQ29udHJvbEF0dHI6ICgvKiBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlTmF0aXZlQ29udHJvbEF0dHI6ICgvKiBhdHRyOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gLyogIU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZSAqLyB7fSxcbiAgICAgIGZvcmNlTGF5b3V0OiAoKSA9PiB7fSxcbiAgICAgIGlzQXR0YWNoZWRUb0RPTTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoZWNrYm94Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV8gPSBzdHJpbmdzLlRSQU5TSVRJT05fU1RBVEVfSU5JVDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyA9ICcnO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuZW5hYmxlQW5pbWF0aW9uRW5kSGFuZGxlcl8gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXyA9IHRoaXMuZGV0ZXJtaW5lQ2hlY2tTdGF0ZV8odGhpcy5nZXROYXRpdmVDb250cm9sXygpKTtcbiAgICB0aGlzLnVwZGF0ZUFyaWFDaGVja2VkXygpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgdGhpcy5pbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNDaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWQgKi9cbiAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzSW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmluZGV0ZXJtaW5hdGU7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpbmRldGVybWluYXRlICovXG4gIHNldEluZGV0ZXJtaW5hdGUoaW5kZXRlcm1pbmF0ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgYW5pbWF0aW9uZW5kIGV2ZW50IGZvciB0aGUgY2hlY2tib3hcbiAgICovXG4gIGhhbmRsZUFuaW1hdGlvbkVuZCgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlQW5pbWF0aW9uRW5kSGFuZGxlcl8pIHJldHVybjtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyk7XG5cbiAgICB0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18pO1xuICAgICAgdGhpcy5lbmFibGVBbmltYXRpb25FbmRIYW5kbGVyXyA9IGZhbHNlO1xuICAgIH0sIG51bWJlcnMuQU5JTV9FTkRfTEFUQ0hfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNoYW5nZSBldmVudCBmb3IgdGhlIGNoZWNrYm94XG4gICAqL1xuICBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uQ2hlY2tTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBpbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKSB7XG4gICAgY29uc3QgbmF0aXZlQ2IgPSB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCk7XG4gICAgY29uc3QgY2JQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihuYXRpdmVDYik7XG5cbiAgICBDQl9QUk9UT19QUk9QUy5mb3JFYWNoKChjb250cm9sU3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNiUHJvdG8sIGNvbnRyb2xTdGF0ZSk7XG4gICAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGZvciB0aGlzIGRlc2NyaXB0b3IsIHNpbmNlIHNvbWUgYnJvd3NlcnMgKFNhZmFyaSkgZG9uJ3Qgc3VwcG9ydCBpdHMgcmV0dXJuLlxuICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDk3MzlcbiAgICAgIGlmICh2YWxpZERlc2NyaXB0b3IoZGVzYykpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlQ2JEZXNjID0gLyoqIEB0eXBlIHshT2JqZWN0UHJvcGVydHlEZXNjcmlwdG9yfSAqLyAoe1xuICAgICAgICAgIGdldDogZGVzYy5nZXQsXG4gICAgICAgICAgc2V0OiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGRlc2Muc2V0LmNhbGwobmF0aXZlQ2IsIHN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbkNoZWNrU3RhdGVfKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGRlc2MuY29uZmlndXJhYmxlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVDYiwgY29udHJvbFN0YXRlLCBuYXRpdmVDYkRlc2MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNiID0gdGhpcy5nZXROYXRpdmVDb250cm9sXygpO1xuICAgIGNvbnN0IGNiUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmF0aXZlQ2IpO1xuXG4gICAgQ0JfUFJPVE9fUFJPUFMuZm9yRWFjaCgoY29udHJvbFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkZXNjID0gLyoqIEB0eXBlIHshT2JqZWN0UHJvcGVydHlEZXNjcmlwdG9yfSAqLyAoXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2JQcm90bywgY29udHJvbFN0YXRlKSk7XG4gICAgICBpZiAodmFsaWREZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVDYiwgY29udHJvbFN0YXRlLCBkZXNjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB0cmFuc2l0aW9uQ2hlY2tTdGF0ZV8oKSB7XG4gICAgY29uc3QgbmF0aXZlQ2IgPSB0aGlzLmFkYXB0ZXJfLmdldE5hdGl2ZUNvbnRyb2woKTtcbiAgICBpZiAoIW5hdGl2ZUNiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV87XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLmRldGVybWluZUNoZWNrU3RhdGVfKG5hdGl2ZUNiKTtcbiAgICBpZiAob2xkU3RhdGUgPT09IG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVBcmlhQ2hlY2tlZF8oKTtcblxuICAgIC8vIENoZWNrIHRvIGVuc3VyZSB0aGF0IHRoZXJlIGlzbid0IGEgcHJldmlvdXNseSBleGlzdGluZyBhbmltYXRpb24gY2xhc3MsIGluIGNhc2UgZm9yIGV4YW1wbGVcbiAgICAvLyB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIGNoZWNrYm94IGJlZm9yZSB0aGUgYW5pbWF0aW9uIHdhcyBmaW5pc2hlZC5cbiAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfLmxlbmd0aCA+IDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvcmNlTGF5b3V0KCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfID0gdGhpcy5nZXRUcmFuc2l0aW9uQW5pbWF0aW9uQ2xhc3NfKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV8gPSBuZXdTdGF0ZTtcblxuICAgIC8vIENoZWNrIGZvciBwYXJlbnROb2RlIHNvIHRoYXQgYW5pbWF0aW9ucyBhcmUgb25seSBydW4gd2hlbiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZFxuICAgIC8vIHRvIHRoZSBET00uXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNBdHRhY2hlZFRvRE9NKCkgJiYgdGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfKTtcbiAgICAgIHRoaXMuZW5hYmxlQW5pbWF0aW9uRW5kSGFuZGxlcl8gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IG5hdGl2ZUNiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGVybWluZUNoZWNrU3RhdGVfKG5hdGl2ZUNiKSB7XG4gICAgY29uc3Qge1xuICAgICAgVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFLFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VELFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQsXG4gICAgfSA9IHN0cmluZ3M7XG5cbiAgICBpZiAobmF0aXZlQ2IuaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgcmV0dXJuIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZUNiLmNoZWNrZWQgPyBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgOiBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkU3RhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXRlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18ob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgVFJBTlNJVElPTl9TVEFURV9JTklULFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VELFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQsXG4gICAgfSA9IHN0cmluZ3M7XG5cbiAgICBjb25zdCB7XG4gICAgICBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VELFxuICAgICAgQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURSxcbiAgICAgIEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQsXG4gICAgICBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURSxcbiAgICAgIEFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VELFxuICAgICAgQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRCxcbiAgICB9ID0gTURDQ2hlY2tib3hGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG5cbiAgICBzd2l0Y2ggKG9sZFN0YXRlKSB7XG4gICAgY2FzZSBUUkFOU0lUSU9OX1NUQVRFX0lOSVQ6XG4gICAgICBpZiAobmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQ6XG4gICAgICByZXR1cm4gbmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCA/IEFOSU1fVU5DSEVDS0VEX0NIRUNLRUQgOiBBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFO1xuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEOlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCA/IEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQgOiBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURTtcbiAgICAvLyBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgP1xuICAgICAgICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCA6IEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQ7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQXJpYUNoZWNrZWRfKCkge1xuICAgIC8vIEVuc3VyZSBhcmlhLWNoZWNrZWQgaXMgc2V0IHRvIG1peGVkIGlmIGNoZWNrYm94IGlzIGluIGluZGV0ZXJtaW5hdGUgc3RhdGUuXG4gICAgaWYgKHRoaXMuaXNJbmRldGVybWluYXRlKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0TmF0aXZlQ29udHJvbEF0dHIoXG4gICAgICAgIHN0cmluZ3MuQVJJQV9DSEVDS0VEX0FUVFIsIHN0cmluZ3MuQVJJQV9DSEVDS0VEX0lOREVURVJNSU5BVEVfVkFMVUUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgb24vb2ZmIHN0YXRlIGRvZXMgbm90IG5lZWQgdG8ga2VlcCB0cmFjayBvZiBhcmlhLWNoZWNrZWQsIHNpbmNlXG4gICAgICAvLyB0aGUgc2NyZWVucmVhZGVyIHVzZXMgdGhlIGNoZWNrZWQgcHJvcGVydHkgb24gdGhlIGNoZWNrYm94IGVsZW1lbnQuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZU5hdGl2ZUNvbnRyb2xBdHRyKHN0cmluZ3MuQVJJQV9DSEVDS0VEX0FUVFIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmF0aXZlQ29udHJvbF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlQ29udHJvbCgpIHx8IHtcbiAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3J8dW5kZWZpbmVkfSBpbnB1dFByb3BEZXNjXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2YWxpZERlc2NyaXB0b3IoaW5wdXRQcm9wRGVzYykge1xuICByZXR1cm4gISFpbnB1dFByb3BEZXNjICYmIHR5cGVvZiBpbnB1dFByb3BEZXNjLnNldCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hlY2tib3hGb3VuZGF0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGVja2JveC9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIENoZWNrYm94LiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENDaGVja2JveEFkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4gdmFsdWUgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0TmF0aXZlQ29udHJvbEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICByZW1vdmVOYXRpdmVDb250cm9sQXR0cihhdHRyKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSAqL1xuICBnZXROYXRpdmVDb250cm9sKCkge31cblxuICBmb3JjZUxheW91dCgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzQXR0YWNoZWRUb0RPTSgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoZWNrYm94QWRhcHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvYWRhcHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBST09UID0gJ21kYy1jaGVja2JveCc7XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgVVBHUkFERUQ6ICdtZGMtY2hlY2tib3gtLXVwZ3JhZGVkJyxcbiAgQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tY2hlY2tlZCcsXG4gIElOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWluZGV0ZXJtaW5hdGUnLFxuICBESVNBQkxFRDogJ21kYy1jaGVja2JveC0tZGlzYWJsZWQnLFxuICBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLXVuY2hlY2tlZC1jaGVja2VkJyxcbiAgQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZScsXG4gIEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0tY2hlY2tlZC11bmNoZWNrZWQnLFxuICBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUnLFxuICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1pbmRldGVybWluYXRlLWNoZWNrZWQnLFxuICBBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTkFUSVZFX0NPTlRST0xfU0VMRUNUT1I6IGAuJHtST09UfV9fbmF0aXZlLWNvbnRyb2xgLFxuICBUUkFOU0lUSU9OX1NUQVRFX0lOSVQ6ICdpbml0JyxcbiAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEOiAnY2hlY2tlZCcsXG4gIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEOiAndW5jaGVja2VkJyxcbiAgVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFOiAnaW5kZXRlcm1pbmF0ZScsXG4gIEFSSUFfQ0hFQ0tFRF9BVFRSOiAnYXJpYS1jaGVja2VkJyxcbiAgQVJJQV9DSEVDS0VEX0lOREVURVJNSU5BVEVfVkFMVUU6ICdtaXhlZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIEFOSU1fRU5EX0xBVENIX01TOiAyNTAsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGVja2JveC9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2x9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQGV4dGVuZHMgTURDQ29tcG9uZW50PCFNRENGb3JtRmllbGRGb3VuZGF0aW9uPlxuICovXG5jbGFzcyBNRENGb3JtRmllbGQgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDRm9ybUZpZWxkKHJvb3QpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7P01EQ1NlbGVjdGlvbkNvbnRyb2x9IGlucHV0ICovXG4gIHNldCBpbnB1dChpbnB1dCkge1xuICAgIHRoaXMuaW5wdXRfID0gaW5wdXQ7XG4gIH1cblxuICAvKiogQHJldHVybiB7P01EQ1NlbGVjdGlvbkNvbnRyb2x9ICovXG4gIGdldCBpbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dF87XG4gIH1cblxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAvKiogQHByaXZhdGUgez9NRENTZWxlY3Rpb25Db250cm9sfSAqL1xuICAgIHRoaXMuaW5wdXRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGxhYmVsXygpIHtcbiAgICBjb25zdCB7TEFCRUxfU0VMRUNUT1J9ID0gTURDRm9ybUZpZWxkRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFFbGVtZW50fSAqLyAodGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yKExBQkVMX1NFTEVDVE9SKSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ0Zvcm1GaWVsZEZvdW5kYXRpb259ICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTURDRm9ybUZpZWxkRm91bmRhdGlvbih7XG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHRoaXMubGFiZWxfLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4gdGhpcy5sYWJlbF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcbiAgICAgIGFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRfICYmIHRoaXMuaW5wdXRfLnJpcHBsZSkge1xuICAgICAgICAgIHRoaXMuaW5wdXRfLnJpcHBsZS5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0XyAmJiB0aGlzLmlucHV0Xy5yaXBwbGUpIHtcbiAgICAgICAgICB0aGlzLmlucHV0Xy5yaXBwbGUuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7TURDRm9ybUZpZWxkLCBNRENGb3JtRmllbGRGb3VuZGF0aW9ufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENGb3JtRmllbGRBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDRm9ybUZpZWxkQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENGb3JtRmllbGRBZGFwdGVyfSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHt9LFxuICAgICAgZGVhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDRm9ybUZpZWxkRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi9cbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAvKiogQHR5cGUgeyFFdmVudExpc3RlbmVyfSAqLyAoXG4gICAgICAoKSA9PiB0aGlzLmhhbmRsZUNsaWNrXygpKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBoYW5kbGVDbGlja18oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hY3RpdmF0ZUlucHV0UmlwcGxlKCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRhcHRlcl8uZGVhY3RpdmF0ZUlucHV0UmlwcGxlKCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zvcm0tZmllbGQvZm91bmRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgRm9ybSBGaWVsZC4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBldmVudCBoYW5kbGVyc1xuICogLSByaXBwbGUgYWN0aXZhdGlvblxuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDRm9ybUZpZWxkQWRhcHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgYWN0aXZhdGVJbnB1dFJpcHBsZSgpIHt9XG5cbiAgZGVhY3RpdmF0ZUlucHV0UmlwcGxlKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm9ybUZpZWxkQWRhcHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9hZGFwdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1mb3JtLWZpZWxkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLWZvcm0tZmllbGQgPiBsYWJlbCcsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxY0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuWEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzNCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2RUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDNUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOUpBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDM0lBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDckJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0SUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNXZCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNySEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDakVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdkpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ3JDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ3BEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQy9CQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3SEE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNYQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUM1Q0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDcEVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUM5SUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzlJQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUM3S0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzdKQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ2xPQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeFBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDblFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTs7Ozs7Ozs7QUN6ZkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9CQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ2pCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ2pCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ2pCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDVkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ1pBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNWQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzdDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDbkRBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDN0xBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUN0YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDakJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUM1Q0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDbkNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQy9EQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RtQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDNUZBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUM3SkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0NBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEhBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ2xCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDN0tBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzFIQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ2hEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNaQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcktBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6TkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5RUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JJQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25GQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2R0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL1JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25GQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25FQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4UUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3REQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVGQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5WUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25DQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4SUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVJQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNURBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ3ZRQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzlEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUM1Q0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNqQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDdk5BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNwWUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUMxREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzNCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ0pBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ1ZBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ2pEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXNCQTs7Ozs7Ozs7QUMxQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUN0TEE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNWQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDekZBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDcEpBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4RUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUN4UEE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdENBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNoSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pKQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pVQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4REE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=